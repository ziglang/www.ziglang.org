<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>Documentation - The Zig Programming Language</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      :root{
         --nav-width: 26em;
         --nav-margin-l: 1em;
      }
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }
      header {
        padding: 0 1em;
      }
      #contents {
        max-width: 60em;
        margin: auto;
        padding: 0 1em;
      }
      #navigation {
        padding: 0 1em;
      }
      table ul {
        list-style-type: none;
        padding: 0em;
      }
      table li {
        padding-bottom: 1em;
        line-height:1.2em;
      }
      table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
      }
      th, td {
        padding: 0.5em;
      }
      th[scope=row] {
          text-align: left;
          font-weight: normal;
      }

      @media screen and (min-width: 1025px) {
        header {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
        header h1 {
          margin: auto;
          max-width: 30em;
        }
        #navigation {
          overflow: auto;
          width: var(--nav-width);
          height: 100vh;
          position: fixed;
          top:0;
          left:0;
          bottom:0;
          padding: unset;
          margin-left: var(--nav-margin-l);
        }
        #navigation nav ul {
          padding-left: 1em;
        }
        #contents-wrapper {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
      }

      a:hover,a:focus {
        background: #fff2a8;
      }
      dt {
        font-weight: bold;
      }
      .sgr-1m {
        font-weight: bold;
      }
      .sgr-2m {
        color: #575757;
      }
      .sgr-31_1m {
        color: #b40000;
      }
      .sgr-32_1m {
        color: green;
      }
      .sgr-36_1m {
        color: #005C7A;
      }
      .file {
        font-weight: bold;
        border: unset;
      }
      code {
        background: #f8f8f8;
        border: 1px dotted silver;
        padding-left: 0.3em;
        padding-right: 0.3em;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        border: 1px solid #eee;
        line-height: normal;
      }
      samp {
        background: #fafafa;
      }
      pre > samp {
        display: block;
        overflow: auto;
        padding: 0.5em;
        border: 1px solid #eee;
        line-height: normal;
      }
      kbd {
        font-weight: normal;
      }
      .table-wrapper {
        width: 100%;
        overflow-x: auto;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      figure {
        margin: auto 0;
      }
      figure pre {
        margin-top: 0;
      }

      figcaption {
        padding-left: 0.5em;
        font-size: small;
        border-top-left-radius: 5px;
        border-top-right-radius: 5px;
      }
      figcaption.zig-cap {
        background: #fcdba5;
      }
      figcaption.c-cap {
        background: #a8b9cc;
        color: #000;
      }
      figcaption.peg-cap {
        background: #fcdba5;
      }
      figcaption.javascript-cap {
        background: #365d95;
        color: #fff;
      }
      figcaption.shell-cap {
        background: #ccc;
        color: #000;
      }

      aside {
        border-left: 0.25em solid #f7a41d;
        padding: 0 1em 0 1em;
      }

      h1 a, h2 a, h3 a, h4 a, h5 a {
        text-decoration: none;
        color: #333;
      }

      a.hdr {
        visibility: hidden;
      }
      h1:hover > a.hdr, h2:hover > a.hdr, h3:hover > a.hdr, h4:hover > a.hdr, h5:hover > a.hdr {
        visibility: visible;
      }

      th pre code {
          background: none;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#121212;
            color: #ccc;
        }
        a {
            color: #88f;
        }
        a:hover,a:focus {
            color: #000;
        }
        table, th, td {
            border-color: grey;
        }
        .sgr-2m {
            color: grey;
        }
        .sgr-31_1m {
            color: red;
        }
        .sgr-32_1m {
            color: #00B800;
        }
        .sgr-36_1m {
            color: #0086b3;
        }
        code {
          background: #222;
          border-color: #444;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        samp {
          background: #000;
          color: #ccc;
        }
        pre > samp {
          border: unset;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
        h1 a, h2 a, h3 a, h4 a, h5 a {
            color: #aaa;
        }
        figcaption.zig-cap {
            background-color: #b27306;
            color: #000;
        }
        figcaption.peg-cap {
            background-color: #b27306;
            color: #000;
        }
        figcaption.shell-cap {
          background: #2a2a2a;
          color: #fff;
        }
      }
    </style>
</head>
<body>
  <header><h1>Zig Language Reference</h1></header>
  <div id="main-wrapper">
      <div id="navigation">
        <nav aria-labelledby="zig-version">
          <h2 id="zig-version">Zig Version</h2>
          {#embed|vernav#}
        </nav>
        <nav aria-labelledby="table-of-contents">
          <h2 id="table-of-contents">Table of Contents</h2>
          

    <ul>
        <li><a id="toc-Introduction" href="#Introduction">Introduction</a></li>
        <li><a id="toc-Zig-Standard-Library" href="#Zig-Standard-Library">Zig Standard Library</a></li>
        <li><a id="toc-Hello-World" href="#Hello-World">Hello World</a></li>
        <li><a id="toc-Comments" href="#Comments">Comments</a>
        <ul>
            <li><a id="toc-Doc-Comments" href="#Doc-Comments">Doc Comments</a></li>
            <li><a id="toc-Top-Level-Doc-Comments" href="#Top-Level-Doc-Comments">Top-Level Doc Comments</a></li>
        </ul></li>
        <li><a id="toc-Values" href="#Values">Values</a>
        <ul>
            <li><a id="toc-Primitive-Types" href="#Primitive-Types">Primitive Types</a></li>
            <li><a id="toc-Primitive-Values" href="#Primitive-Values">Primitive Values</a></li>
            <li><a id="toc-String-Literals-and-Unicode-Code-Point-Literals" href="#String-Literals-and-Unicode-Code-Point-Literals">String Literals and Unicode Code Point Literals</a>
            <ul>
                <li><a id="toc-Escape-Sequences" href="#Escape-Sequences">Escape Sequences</a></li>
                <li><a id="toc-Multiline-String-Literals" href="#Multiline-String-Literals">Multiline String Literals</a></li>
            </ul></li>
            <li><a id="toc-Assignment" href="#Assignment">Assignment</a>
            <ul>
                <li><a id="toc-undefined" href="#undefined">undefined</a></li>
                <li><a id="toc-Destructuring" href="#Destructuring">Destructuring</a></li>
            </ul></li>
        </ul></li>
        <li><a id="toc-Zig-Test" href="#Zig-Test">Zig Test</a>
        <ul>
            <li><a id="toc-Test-Declarations" href="#Test-Declarations">Test Declarations</a>
            <ul>
                <li><a id="toc-Doctests" href="#Doctests">Doctests</a></li>
            </ul></li>
            <li><a id="toc-Test-Failure" href="#Test-Failure">Test Failure</a></li>
            <li><a id="toc-Skip-Tests" href="#Skip-Tests">Skip Tests</a></li>
            <li><a id="toc-Report-Memory-Leaks" href="#Report-Memory-Leaks">Report Memory Leaks</a></li>
            <li><a id="toc-Detecting-Test-Build" href="#Detecting-Test-Build">Detecting Test Build</a></li>
            <li><a id="toc-Test-Output-and-Logging" href="#Test-Output-and-Logging">Test Output and Logging</a></li>
            <li><a id="toc-The-Testing-Namespace" href="#The-Testing-Namespace">The Testing Namespace</a></li>
            <li><a id="toc-Test-Tool-Documentation" href="#Test-Tool-Documentation">Test Tool Documentation</a></li>
        </ul></li>
        <li><a id="toc-Variables" href="#Variables">Variables</a>
        <ul>
            <li><a id="toc-Identifiers" href="#Identifiers">Identifiers</a></li>
            <li><a id="toc-Container-Level-Variables" href="#Container-Level-Variables">Container Level Variables</a></li>
            <li><a id="toc-Static-Local-Variables" href="#Static-Local-Variables">Static Local Variables</a></li>
            <li><a id="toc-Thread-Local-Variables" href="#Thread-Local-Variables">Thread Local Variables</a></li>
            <li><a id="toc-Local-Variables" href="#Local-Variables">Local Variables</a></li>
        </ul></li>
        <li><a id="toc-Integers" href="#Integers">Integers</a>
        <ul>
            <li><a id="toc-Integer-Literals" href="#Integer-Literals">Integer Literals</a></li>
            <li><a id="toc-Runtime-Integer-Values" href="#Runtime-Integer-Values">Runtime Integer Values</a></li>
        </ul></li>
        <li><a id="toc-Floats" href="#Floats">Floats</a>
        <ul>
            <li><a id="toc-Float-Literals" href="#Float-Literals">Float Literals</a></li>
            <li><a id="toc-Floating-Point-Operations" href="#Floating-Point-Operations">Floating Point Operations</a></li>
        </ul></li>
        <li><a id="toc-Operators" href="#Operators">Operators</a>
        <ul>
            <li><a id="toc-Table-of-Operators" href="#Table-of-Operators">Table of Operators</a></li>
            <li><a id="toc-Precedence" href="#Precedence">Precedence</a></li>
        </ul></li>
        <li><a id="toc-Arrays" href="#Arrays">Arrays</a>
        <ul>
            <li><a id="toc-Multidimensional-Arrays" href="#Multidimensional-Arrays">Multidimensional Arrays</a></li>
            <li><a id="toc-Sentinel-Terminated-Arrays" href="#Sentinel-Terminated-Arrays">Sentinel-Terminated Arrays</a></li>
            <li><a id="toc-Destructuring-Arrays" href="#Destructuring-Arrays">Destructuring Arrays</a></li>
        </ul></li>
        <li><a id="toc-Vectors" href="#Vectors">Vectors</a>
        <ul>
            <li><a id="toc-Destructuring-Vectors" href="#Destructuring-Vectors">Destructuring Vectors</a></li>
        </ul></li>
        <li><a id="toc-Pointers" href="#Pointers">Pointers</a>
        <ul>
            <li><a id="toc-volatile" href="#volatile">volatile</a></li>
            <li><a id="toc-Alignment" href="#Alignment">Alignment</a></li>
            <li><a id="toc-allowzero" href="#allowzero">allowzero</a></li>
            <li><a id="toc-Sentinel-Terminated-Pointers" href="#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a></li>
        </ul></li>
        <li><a id="toc-Slices" href="#Slices">Slices</a>
        <ul>
            <li><a id="toc-Sentinel-Terminated-Slices" href="#Sentinel-Terminated-Slices">Sentinel-Terminated Slices</a></li>
        </ul></li>
        <li><a id="toc-struct" href="#struct">struct</a>
        <ul>
            <li><a id="toc-Default-Field-Values" href="#Default-Field-Values">Default Field Values</a>
            <ul>
                <li><a id="toc-Faulty-Default-Field-Values" href="#Faulty-Default-Field-Values">Faulty Default Field Values</a></li>
            </ul></li>
            <li><a id="toc-extern-struct" href="#extern-struct">extern struct</a></li>
            <li><a id="toc-packed-struct" href="#packed-struct">packed struct</a></li>
            <li><a id="toc-Struct-Naming" href="#Struct-Naming">Struct Naming</a></li>
            <li><a id="toc-Anonymous-Struct-Literals" href="#Anonymous-Struct-Literals">Anonymous Struct Literals</a></li>
            <li><a id="toc-Tuples" href="#Tuples">Tuples</a>
            <ul>
                <li><a id="toc-Destructuring-Tuples" href="#Destructuring-Tuples">Destructuring Tuples</a></li>
            </ul></li>
        </ul></li>
        <li><a id="toc-enum" href="#enum">enum</a>
        <ul>
            <li><a id="toc-extern-enum" href="#extern-enum">extern enum</a></li>
            <li><a id="toc-Enum-Literals" href="#Enum-Literals">Enum Literals</a></li>
            <li><a id="toc-Non-exhaustive-enum" href="#Non-exhaustive-enum">Non-exhaustive enum</a></li>
        </ul></li>
        <li><a id="toc-union" href="#union">union</a>
        <ul>
            <li><a id="toc-Tagged-union" href="#Tagged-union">Tagged union</a></li>
            <li><a id="toc-extern-union" href="#extern-union">extern union</a></li>
            <li><a id="toc-packed-union" href="#packed-union">packed union</a></li>
            <li><a id="toc-Anonymous-Union-Literals" href="#Anonymous-Union-Literals">Anonymous Union Literals</a></li>
        </ul></li>
        <li><a id="toc-opaque" href="#opaque">opaque</a></li>
        <li><a id="toc-Blocks" href="#Blocks">Blocks</a>
        <ul>
            <li><a id="toc-Shadowing" href="#Shadowing">Shadowing</a></li>
            <li><a id="toc-Empty-Blocks" href="#Empty-Blocks">Empty Blocks</a></li>
        </ul></li>
        <li><a id="toc-switch" href="#switch">switch</a>
        <ul>
            <li><a id="toc-Exhaustive-Switching" href="#Exhaustive-Switching">Exhaustive Switching</a></li>
            <li><a id="toc-Switching-with-Enum-Literals" href="#Switching-with-Enum-Literals">Switching with Enum Literals</a></li>
            <li><a id="toc-Labeled-switch" href="#Labeled-switch">Labeled switch</a></li>
            <li><a id="toc-Inline-Switch-Prongs" href="#Inline-Switch-Prongs">Inline Switch Prongs</a></li>
        </ul></li>
        <li><a id="toc-while" href="#while">while</a>
        <ul>
            <li><a id="toc-Labeled-while" href="#Labeled-while">Labeled while</a></li>
            <li><a id="toc-while-with-Optionals" href="#while-with-Optionals">while with Optionals</a></li>
            <li><a id="toc-while-with-Error-Unions" href="#while-with-Error-Unions">while with Error Unions</a></li>
            <li><a id="toc-inline-while" href="#inline-while">inline while</a></li>
        </ul></li>
        <li><a id="toc-for" href="#for">for</a>
        <ul>
            <li><a id="toc-Labeled-for" href="#Labeled-for">Labeled for</a></li>
            <li><a id="toc-inline-for" href="#inline-for">inline for</a></li>
        </ul></li>
        <li><a id="toc-if" href="#if">if</a>
        <ul>
            <li><a id="toc-if-with-Optionals" href="#if-with-Optionals">if with Optionals</a></li>
        </ul></li>
        <li><a id="toc-defer" href="#defer">defer</a></li>
        <li><a id="toc-unreachable" href="#unreachable">unreachable</a>
        <ul>
            <li><a id="toc-Basics" href="#Basics">Basics</a></li>
            <li><a id="toc-At-Compile-Time" href="#At-Compile-Time">At Compile-Time</a></li>
        </ul></li>
        <li><a id="toc-noreturn" href="#noreturn">noreturn</a></li>
        <li><a id="toc-Functions" href="#Functions">Functions</a>
        <ul>
            <li><a id="toc-Pass-by-value-Parameters" href="#Pass-by-value-Parameters">Pass-by-value Parameters</a></li>
            <li><a id="toc-Function-Parameter-Type-Inference" href="#Function-Parameter-Type-Inference">Function Parameter Type Inference</a></li>
            <li><a id="toc-inline-fn" href="#inline-fn">inline fn</a></li>
            <li><a id="toc-Function-Reflection" href="#Function-Reflection">Function Reflection</a></li>
        </ul></li>
        <li><a id="toc-Errors" href="#Errors">Errors</a>
        <ul>
            <li><a id="toc-Error-Set-Type" href="#Error-Set-Type">Error Set Type</a>
            <ul>
                <li><a id="toc-The-Global-Error-Set" href="#The-Global-Error-Set">The Global Error Set</a></li>
            </ul></li>
            <li><a id="toc-Error-Union-Type" href="#Error-Union-Type">Error Union Type</a>
            <ul>
                <li><a id="toc-catch" href="#catch">catch</a></li>
                <li><a id="toc-try" href="#try">try</a></li>
                <li><a id="toc-errdefer" href="#errdefer">errdefer</a></li>
                <li><a id="toc-Merging-Error-Sets" href="#Merging-Error-Sets">Merging Error Sets</a></li>
                <li><a id="toc-Inferred-Error-Sets" href="#Inferred-Error-Sets">Inferred Error Sets</a></li>
            </ul></li>
            <li><a id="toc-Error-Return-Traces" href="#Error-Return-Traces">Error Return Traces</a>
            <ul>
                <li><a id="toc-Implementation-Details" href="#Implementation-Details">Implementation Details</a></li>
            </ul></li>
        </ul></li>
        <li><a id="toc-Optionals" href="#Optionals">Optionals</a>
        <ul>
            <li><a id="toc-Optional-Type" href="#Optional-Type">Optional Type</a></li>
            <li><a id="toc-null" href="#null">null</a></li>
            <li><a id="toc-Optional-Pointers" href="#Optional-Pointers">Optional Pointers</a></li>
        </ul></li>
        <li><a id="toc-Casting" href="#Casting">Casting</a>
        <ul>
            <li><a id="toc-Type-Coercion" href="#Type-Coercion">Type Coercion</a>
            <ul>
                <li><a id="toc-Type-Coercion-Stricter-Qualification" href="#Type-Coercion-Stricter-Qualification">Type Coercion: Stricter Qualification</a></li>
                <li><a id="toc-Type-Coercion-Integer-and-Float-Widening" href="#Type-Coercion-Integer-and-Float-Widening">Type Coercion: Integer and Float Widening</a></li>
                <li><a id="toc-Type-Coercion-Float-to-Int" href="#Type-Coercion-Float-to-Int">Type Coercion: Float to Int</a></li>
                <li><a id="toc-Type-Coercion-Slices-Arrays-and-Pointers" href="#Type-Coercion-Slices-Arrays-and-Pointers">Type Coercion: Slices, Arrays and Pointers</a></li>
                <li><a id="toc-Type-Coercion-Optionals" href="#Type-Coercion-Optionals">Type Coercion: Optionals</a></li>
                <li><a id="toc-Type-Coercion-Error-Unions" href="#Type-Coercion-Error-Unions">Type Coercion: Error Unions</a></li>
                <li><a id="toc-Type-Coercion-Compile-Time-Known-Numbers" href="#Type-Coercion-Compile-Time-Known-Numbers">Type Coercion: Compile-Time Known Numbers</a></li>
                <li><a id="toc-Type-Coercion-Unions-and-Enums" href="#Type-Coercion-Unions-and-Enums">Type Coercion: Unions and Enums</a></li>
                <li><a id="toc-Type-Coercion-undefined" href="#Type-Coercion-undefined">Type Coercion: undefined</a></li>
                <li><a id="toc-Type-Coercion-Tuples-to-Arrays" href="#Type-Coercion-Tuples-to-Arrays">Type Coercion: Tuples to Arrays</a></li>
            </ul></li>
            <li><a id="toc-Explicit-Casts" href="#Explicit-Casts">Explicit Casts</a></li>
            <li><a id="toc-Peer-Type-Resolution" href="#Peer-Type-Resolution">Peer Type Resolution</a></li>
        </ul></li>
        <li><a id="toc-Zero-Bit-Types" href="#Zero-Bit-Types">Zero Bit Types</a>
        <ul>
            <li><a id="toc-void" href="#void">void</a></li>
        </ul></li>
        <li><a id="toc-Result-Location-Semantics" href="#Result-Location-Semantics">Result Location Semantics</a>
        <ul>
            <li><a id="toc-Result-Types" href="#Result-Types">Result Types</a></li>
            <li><a id="toc-Result-Locations" href="#Result-Locations">Result Locations</a></li>
        </ul></li>
        <li><a id="toc-usingnamespace" href="#usingnamespace">usingnamespace</a></li>
        <li><a id="toc-comptime" href="#comptime">comptime</a>
        <ul>
            <li><a id="toc-Introducing-the-Compile-Time-Concept" href="#Introducing-the-Compile-Time-Concept">Introducing the Compile-Time Concept</a>
            <ul>
                <li><a id="toc-Compile-Time-Parameters" href="#Compile-Time-Parameters">Compile-Time Parameters</a></li>
                <li><a id="toc-Compile-Time-Variables" href="#Compile-Time-Variables">Compile-Time Variables</a></li>
                <li><a id="toc-Compile-Time-Expressions" href="#Compile-Time-Expressions">Compile-Time Expressions</a></li>
            </ul></li>
            <li><a id="toc-Generic-Data-Structures" href="#Generic-Data-Structures">Generic Data Structures</a></li>
            <li><a id="toc-Case-Study-print-in-Zig" href="#Case-Study-print-in-Zig">Case Study: print in Zig</a></li>
        </ul></li>
        <li><a id="toc-Assembly" href="#Assembly">Assembly</a>
        <ul>
            <li><a id="toc-Output-Constraints" href="#Output-Constraints">Output Constraints</a></li>
            <li><a id="toc-Input-Constraints" href="#Input-Constraints">Input Constraints</a></li>
            <li><a id="toc-Clobbers" href="#Clobbers">Clobbers</a></li>
            <li><a id="toc-Global-Assembly" href="#Global-Assembly">Global Assembly</a></li>
        </ul></li>
        <li><a id="toc-Atomics" href="#Atomics">Atomics</a></li>
        <li><a id="toc-Async-Functions" href="#Async-Functions">Async Functions</a></li>
        <li><a id="toc-Builtin-Functions" href="#Builtin-Functions">Builtin Functions</a>
        <ul style="columns: 2">
            <li><a id="toc-addrSpaceCast" href="#addrSpaceCast">@addrSpaceCast</a></li>
            <li><a id="toc-addWithOverflow" href="#addWithOverflow">@addWithOverflow</a></li>
            <li><a id="toc-alignCast" href="#alignCast">@alignCast</a></li>
            <li><a id="toc-alignOf" href="#alignOf">@alignOf</a></li>
            <li><a id="toc-as" href="#as">@as</a></li>
            <li><a id="toc-atomicLoad" href="#atomicLoad">@atomicLoad</a></li>
            <li><a id="toc-atomicRmw" href="#atomicRmw">@atomicRmw</a></li>
            <li><a id="toc-atomicStore" href="#atomicStore">@atomicStore</a></li>
            <li><a id="toc-bitCast" href="#bitCast">@bitCast</a></li>
            <li><a id="toc-bitOffsetOf" href="#bitOffsetOf">@bitOffsetOf</a></li>
            <li><a id="toc-bitSizeOf" href="#bitSizeOf">@bitSizeOf</a></li>
            <li><a id="toc-branchHint" href="#branchHint">@branchHint</a></li>
            <li><a id="toc-breakpoint" href="#breakpoint">@breakpoint</a></li>
            <li><a id="toc-mulAdd" href="#mulAdd">@mulAdd</a></li>
            <li><a id="toc-byteSwap" href="#byteSwap">@byteSwap</a></li>
            <li><a id="toc-bitReverse" href="#bitReverse">@bitReverse</a></li>
            <li><a id="toc-offsetOf" href="#offsetOf">@offsetOf</a></li>
            <li><a id="toc-call" href="#call">@call</a></li>
            <li><a id="toc-cDefine" href="#cDefine">@cDefine</a></li>
            <li><a id="toc-cImport" href="#cImport">@cImport</a></li>
            <li><a id="toc-cInclude" href="#cInclude">@cInclude</a></li>
            <li><a id="toc-clz" href="#clz">@clz</a></li>
            <li><a id="toc-cmpxchgStrong" href="#cmpxchgStrong">@cmpxchgStrong</a></li>
            <li><a id="toc-cmpxchgWeak" href="#cmpxchgWeak">@cmpxchgWeak</a></li>
            <li><a id="toc-compileError" href="#compileError">@compileError</a></li>
            <li><a id="toc-compileLog" href="#compileLog">@compileLog</a></li>
            <li><a id="toc-constCast" href="#constCast">@constCast</a></li>
            <li><a id="toc-ctz" href="#ctz">@ctz</a></li>
            <li><a id="toc-cUndef" href="#cUndef">@cUndef</a></li>
            <li><a id="toc-cVaArg" href="#cVaArg">@cVaArg</a></li>
            <li><a id="toc-cVaCopy" href="#cVaCopy">@cVaCopy</a></li>
            <li><a id="toc-cVaEnd" href="#cVaEnd">@cVaEnd</a></li>
            <li><a id="toc-cVaStart" href="#cVaStart">@cVaStart</a></li>
            <li><a id="toc-divExact" href="#divExact">@divExact</a></li>
            <li><a id="toc-divFloor" href="#divFloor">@divFloor</a></li>
            <li><a id="toc-divTrunc" href="#divTrunc">@divTrunc</a></li>
            <li><a id="toc-embedFile" href="#embedFile">@embedFile</a></li>
            <li><a id="toc-enumFromInt" href="#enumFromInt">@enumFromInt</a></li>
            <li><a id="toc-errorFromInt" href="#errorFromInt">@errorFromInt</a></li>
            <li><a id="toc-errorName" href="#errorName">@errorName</a></li>
            <li><a id="toc-errorReturnTrace" href="#errorReturnTrace">@errorReturnTrace</a></li>
            <li><a id="toc-errorCast" href="#errorCast">@errorCast</a></li>
            <li><a id="toc-export" href="#export">@export</a></li>
            <li><a id="toc-extern" href="#extern">@extern</a></li>
            <li><a id="toc-field" href="#field">@field</a></li>
            <li><a id="toc-fieldParentPtr" href="#fieldParentPtr">@fieldParentPtr</a></li>
            <li><a id="toc-FieldType" href="#FieldType">@FieldType</a></li>
            <li><a id="toc-floatCast" href="#floatCast">@floatCast</a></li>
            <li><a id="toc-floatFromInt" href="#floatFromInt">@floatFromInt</a></li>
            <li><a id="toc-frameAddress" href="#frameAddress">@frameAddress</a></li>
            <li><a id="toc-hasDecl" href="#hasDecl">@hasDecl</a></li>
            <li><a id="toc-hasField" href="#hasField">@hasField</a></li>
            <li><a id="toc-import" href="#import">@import</a></li>
            <li><a id="toc-inComptime" href="#inComptime">@inComptime</a></li>
            <li><a id="toc-intCast" href="#intCast">@intCast</a></li>
            <li><a id="toc-intFromBool" href="#intFromBool">@intFromBool</a></li>
            <li><a id="toc-intFromEnum" href="#intFromEnum">@intFromEnum</a></li>
            <li><a id="toc-intFromError" href="#intFromError">@intFromError</a></li>
            <li><a id="toc-intFromFloat" href="#intFromFloat">@intFromFloat</a></li>
            <li><a id="toc-intFromPtr" href="#intFromPtr">@intFromPtr</a></li>
            <li><a id="toc-max" href="#max">@max</a></li>
            <li><a id="toc-memcpy" href="#memcpy">@memcpy</a></li>
            <li><a id="toc-memset" href="#memset">@memset</a></li>
            <li><a id="toc-min" href="#min">@min</a></li>
            <li><a id="toc-wasmMemorySize" href="#wasmMemorySize">@wasmMemorySize</a></li>
            <li><a id="toc-wasmMemoryGrow" href="#wasmMemoryGrow">@wasmMemoryGrow</a></li>
            <li><a id="toc-mod" href="#mod">@mod</a></li>
            <li><a id="toc-mulWithOverflow" href="#mulWithOverflow">@mulWithOverflow</a></li>
            <li><a id="toc-panic" href="#panic">@panic</a></li>
            <li><a id="toc-popCount" href="#popCount">@popCount</a></li>
            <li><a id="toc-prefetch" href="#prefetch">@prefetch</a></li>
            <li><a id="toc-ptrCast" href="#ptrCast">@ptrCast</a></li>
            <li><a id="toc-ptrFromInt" href="#ptrFromInt">@ptrFromInt</a></li>
            <li><a id="toc-rem" href="#rem">@rem</a></li>
            <li><a id="toc-returnAddress" href="#returnAddress">@returnAddress</a></li>
            <li><a id="toc-select" href="#select">@select</a></li>
            <li><a id="toc-setEvalBranchQuota" href="#setEvalBranchQuota">@setEvalBranchQuota</a></li>
            <li><a id="toc-setFloatMode" href="#setFloatMode">@setFloatMode</a></li>
            <li><a id="toc-setRuntimeSafety" href="#setRuntimeSafety">@setRuntimeSafety</a></li>
            <li><a id="toc-shlExact" href="#shlExact">@shlExact</a></li>
            <li><a id="toc-shlWithOverflow" href="#shlWithOverflow">@shlWithOverflow</a></li>
            <li><a id="toc-shrExact" href="#shrExact">@shrExact</a></li>
            <li><a id="toc-shuffle" href="#shuffle">@shuffle</a></li>
            <li><a id="toc-sizeOf" href="#sizeOf">@sizeOf</a></li>
            <li><a id="toc-splat" href="#splat">@splat</a></li>
            <li><a id="toc-reduce" href="#reduce">@reduce</a></li>
            <li><a id="toc-src" href="#src">@src</a></li>
            <li><a id="toc-sqrt" href="#sqrt">@sqrt</a></li>
            <li><a id="toc-sin" href="#sin">@sin</a></li>
            <li><a id="toc-cos" href="#cos">@cos</a></li>
            <li><a id="toc-tan" href="#tan">@tan</a></li>
            <li><a id="toc-exp" href="#exp">@exp</a></li>
            <li><a id="toc-exp2" href="#exp2">@exp2</a></li>
            <li><a id="toc-log" href="#log">@log</a></li>
            <li><a id="toc-log2" href="#log2">@log2</a></li>
            <li><a id="toc-log10" href="#log10">@log10</a></li>
            <li><a id="toc-abs" href="#abs">@abs</a></li>
            <li><a id="toc-floor" href="#floor">@floor</a></li>
            <li><a id="toc-ceil" href="#ceil">@ceil</a></li>
            <li><a id="toc-trunc" href="#trunc">@trunc</a></li>
            <li><a id="toc-round" href="#round">@round</a></li>
            <li><a id="toc-subWithOverflow" href="#subWithOverflow">@subWithOverflow</a></li>
            <li><a id="toc-tagName" href="#tagName">@tagName</a></li>
            <li><a id="toc-This" href="#This">@This</a></li>
            <li><a id="toc-trap" href="#trap">@trap</a></li>
            <li><a id="toc-truncate" href="#truncate">@truncate</a></li>
            <li><a id="toc-Type" href="#Type">@Type</a></li>
            <li><a id="toc-typeInfo" href="#typeInfo">@typeInfo</a></li>
            <li><a id="toc-typeName" href="#typeName">@typeName</a></li>
            <li><a id="toc-TypeOf" href="#TypeOf">@TypeOf</a></li>
            <li><a id="toc-unionInit" href="#unionInit">@unionInit</a></li>
            <li><a id="toc-Vector" href="#Vector">@Vector</a></li>
            <li><a id="toc-volatileCast" href="#volatileCast">@volatileCast</a></li>
            <li><a id="toc-workGroupId" href="#workGroupId">@workGroupId</a></li>
            <li><a id="toc-workGroupSize" href="#workGroupSize">@workGroupSize</a></li>
            <li><a id="toc-workItemId" href="#workItemId">@workItemId</a></li>
        </ul></li>
        <li><a id="toc-Build-Mode" href="#Build-Mode">Build Mode</a>
        <ul>
            <li><a id="toc-Debug" href="#Debug">Debug</a></li>
            <li><a id="toc-ReleaseFast" href="#ReleaseFast">ReleaseFast</a></li>
            <li><a id="toc-ReleaseSafe" href="#ReleaseSafe">ReleaseSafe</a></li>
            <li><a id="toc-ReleaseSmall" href="#ReleaseSmall">ReleaseSmall</a></li>
        </ul></li>
        <li><a id="toc-Single-Threaded-Builds" href="#Single-Threaded-Builds">Single Threaded Builds</a></li>
        <li><a id="toc-Illegal-Behavior" href="#Illegal-Behavior">Illegal Behavior</a>
        <ul>
            <li><a id="toc-Reaching-Unreachable-Code" href="#Reaching-Unreachable-Code">Reaching Unreachable Code</a></li>
            <li><a id="toc-Index-out-of-Bounds" href="#Index-out-of-Bounds">Index out of Bounds</a></li>
            <li><a id="toc-Cast-Negative-Number-to-Unsigned-Integer" href="#Cast-Negative-Number-to-Unsigned-Integer">Cast Negative Number to Unsigned Integer</a></li>
            <li><a id="toc-Cast-Truncates-Data" href="#Cast-Truncates-Data">Cast Truncates Data</a></li>
            <li><a id="toc-Integer-Overflow" href="#Integer-Overflow">Integer Overflow</a>
            <ul>
                <li><a id="toc-Default-Operations" href="#Default-Operations">Default Operations</a></li>
                <li><a id="toc-Standard-Library-Math-Functions" href="#Standard-Library-Math-Functions">Standard Library Math Functions</a></li>
                <li><a id="toc-Builtin-Overflow-Functions" href="#Builtin-Overflow-Functions">Builtin Overflow Functions</a></li>
                <li><a id="toc-Wrapping-Operations" href="#Wrapping-Operations">Wrapping Operations</a></li>
            </ul></li>
            <li><a id="toc-Exact-Left-Shift-Overflow" href="#Exact-Left-Shift-Overflow">Exact Left Shift Overflow</a></li>
            <li><a id="toc-Exact-Right-Shift-Overflow" href="#Exact-Right-Shift-Overflow">Exact Right Shift Overflow</a></li>
            <li><a id="toc-Division-by-Zero" href="#Division-by-Zero">Division by Zero</a></li>
            <li><a id="toc-Remainder-Division-by-Zero" href="#Remainder-Division-by-Zero">Remainder Division by Zero</a></li>
            <li><a id="toc-Exact-Division-Remainder" href="#Exact-Division-Remainder">Exact Division Remainder</a></li>
            <li><a id="toc-Attempt-to-Unwrap-Null" href="#Attempt-to-Unwrap-Null">Attempt to Unwrap Null</a></li>
            <li><a id="toc-Attempt-to-Unwrap-Error" href="#Attempt-to-Unwrap-Error">Attempt to Unwrap Error</a></li>
            <li><a id="toc-Invalid-Error-Code" href="#Invalid-Error-Code">Invalid Error Code</a></li>
            <li><a id="toc-Invalid-Enum-Cast" href="#Invalid-Enum-Cast">Invalid Enum Cast</a></li>
            <li><a id="toc-Invalid-Error-Set-Cast" href="#Invalid-Error-Set-Cast">Invalid Error Set Cast</a></li>
            <li><a id="toc-Incorrect-Pointer-Alignment" href="#Incorrect-Pointer-Alignment">Incorrect Pointer Alignment</a></li>
            <li><a id="toc-Wrong-Union-Field-Access" href="#Wrong-Union-Field-Access">Wrong Union Field Access</a></li>
            <li><a id="toc-Out-of-Bounds-Float-to-Integer-Cast" href="#Out-of-Bounds-Float-to-Integer-Cast">Out of Bounds Float to Integer Cast</a></li>
            <li><a id="toc-Pointer-Cast-Invalid-Null" href="#Pointer-Cast-Invalid-Null">Pointer Cast Invalid Null</a></li>
        </ul></li>
        <li><a id="toc-Memory" href="#Memory">Memory</a>
        <ul>
            <li><a id="toc-Choosing-an-Allocator" href="#Choosing-an-Allocator">Choosing an Allocator</a></li>
            <li><a id="toc-Where-are-the-bytes" href="#Where-are-the-bytes">Where are the bytes?</a></li>
            <li><a id="toc-Implementing-an-Allocator" href="#Implementing-an-Allocator">Implementing an Allocator</a></li>
            <li><a id="toc-Heap-Allocation-Failure" href="#Heap-Allocation-Failure">Heap Allocation Failure</a></li>
            <li><a id="toc-Recursion" href="#Recursion">Recursion</a></li>
            <li><a id="toc-Lifetime-and-Ownership" href="#Lifetime-and-Ownership">Lifetime and Ownership</a></li>
        </ul></li>
        <li><a id="toc-Compile-Variables" href="#Compile-Variables">Compile Variables</a></li>
        <li><a id="toc-Compilation-Model" href="#Compilation-Model">Compilation Model</a>
        <ul>
            <li><a id="toc-Source-File-Structs" href="#Source-File-Structs">Source File Structs</a></li>
            <li><a id="toc-File-and-Declaration-Discovery" href="#File-and-Declaration-Discovery">File and Declaration Discovery</a></li>
            <li><a id="toc-Special-Root-Declarations" href="#Special-Root-Declarations">Special Root Declarations</a>
            <ul>
                <li><a id="toc-Entry-Point" href="#Entry-Point">Entry Point</a></li>
                <li><a id="toc-Standard-Library-Options" href="#Standard-Library-Options">Standard Library Options</a></li>
                <li><a id="toc-Panic-Handler" href="#Panic-Handler">Panic Handler</a></li>
            </ul></li>
        </ul></li>
        <li><a id="toc-Zig-Build-System" href="#Zig-Build-System">Zig Build System</a></li>
        <li><a id="toc-C" href="#C">C</a>
        <ul>
            <li><a id="toc-C-Type-Primitives" href="#C-Type-Primitives">C Type Primitives</a></li>
            <li><a id="toc-Import-from-C-Header-File" href="#Import-from-C-Header-File">Import from C Header File</a></li>
            <li><a id="toc-C-Translation-CLI" href="#C-Translation-CLI">C Translation CLI</a>
            <ul>
                <li><a id="toc-Command-line-flags" href="#Command-line-flags">Command line flags</a></li>
                <li><a id="toc-Using--target-and--cflags" href="#Using--target-and--cflags">Using -target and -cflags</a></li>
                <li><a id="toc-cImport-vs-translate-c" href="#cImport-vs-translate-c">@cImport vs translate-c</a></li>
            </ul></li>
            <li><a id="toc-C-Translation-Caching" href="#C-Translation-Caching">C Translation Caching</a></li>
            <li><a id="toc-Translation-failures" href="#Translation-failures">Translation failures</a></li>
            <li><a id="toc-C-Macros" href="#C-Macros">C Macros</a></li>
            <li><a id="toc-C-Pointers" href="#C-Pointers">C Pointers</a></li>
            <li><a id="toc-C-Variadic-Functions" href="#C-Variadic-Functions">C Variadic Functions</a></li>
            <li><a id="toc-Exporting-a-C-Library" href="#Exporting-a-C-Library">Exporting a C Library</a></li>
            <li><a id="toc-Mixing-Object-Files" href="#Mixing-Object-Files">Mixing Object Files</a></li>
        </ul></li>
        <li><a id="toc-WebAssembly" href="#WebAssembly">WebAssembly</a>
        <ul>
            <li><a id="toc-Freestanding" href="#Freestanding">Freestanding</a></li>
            <li><a id="toc-WASI" href="#WASI">WASI</a></li>
        </ul></li>
        <li><a id="toc-Targets" href="#Targets">Targets</a></li>
        <li><a id="toc-Style-Guide" href="#Style-Guide">Style Guide</a>
        <ul>
            <li><a id="toc-Avoid-Redundancy-in-Names" href="#Avoid-Redundancy-in-Names">Avoid Redundancy in Names</a></li>
            <li><a id="toc-Avoid-Redundant-Names-in-Fully-Qualified-Namespaces" href="#Avoid-Redundant-Names-in-Fully-Qualified-Namespaces">Avoid Redundant Names in Fully-Qualified Namespaces</a></li>
            <li><a id="toc-Whitespace" href="#Whitespace">Whitespace</a></li>
            <li><a id="toc-Names" href="#Names">Names</a></li>
            <li><a id="toc-Examples" href="#Examples">Examples</a></li>
            <li><a id="toc-Doc-Comment-Guidance" href="#Doc-Comment-Guidance">Doc Comment Guidance</a></li>
        </ul></li>
        <li><a id="toc-Source-Encoding" href="#Source-Encoding">Source Encoding</a></li>
        <li><a id="toc-Keyword-Reference" href="#Keyword-Reference">Keyword Reference</a></li>
        <li><a id="toc-Appendix" href="#Appendix">Appendix</a>
        <ul>
            <li><a id="toc-Containers" href="#Containers">Containers</a></li>
            <li><a id="toc-Grammar" href="#Grammar">Grammar</a></li>
            <li><a id="toc-Zen" href="#Zen">Zen</a></li>
        </ul></li>
    </ul>

        </nav>
      </div>
      <div id="contents-wrapper"><main id="contents">
      <h2 id="Introduction"><a href="#toc-Introduction">Introduction</a> <a class="hdr" href="#Introduction">§</a></h2>

      <p>
      <a href="https://ziglang.org">Zig</a> is a general-purpose programming language and toolchain for maintaining
      <strong>robust</strong>, <strong>optimal</strong>, and <strong>reusable</strong> software.
      </p>
      <dl>
        <dt>Robust</dt><dd>Behavior is correct even for edge cases such as out of memory.</dd>
        <dt>Optimal</dt><dd>Write programs the best way they can behave and perform.</dd>
        <dt>Reusable</dt><dd>The same code works in many environments which have different
          constraints.</dd>
        <dt>Maintainable</dt><dd>Precisely communicate intent to the compiler and
          other programmers. The language imposes a low overhead to reading code and is
          resilient to changing requirements and environments.</dd>
      </dl>
      <p>
      Often the most efficient way to learn something new is to see examples, so
      this documentation shows how to use each of Zig's features. It is
      all on one page so you can search with your browser's search tool.
      </p>
      <p>
      The code samples in this document are compiled and tested as part of the main test suite of Zig.
      </p>
      <p>
      This HTML document depends on no external files, so you can use it offline.
      </p>
      

      <h2 id="Zig-Standard-Library"><a href="#toc-Zig-Standard-Library">Zig Standard Library</a> <a class="hdr" href="#Zig-Standard-Library">§</a></h2>

      <p>
        The <a href="https://ziglang.org/documentation/0.14.0/std/">Zig Standard Library</a> has its own documentation.
      </p>
      <p>
        Zig's Standard Library contains commonly used algorithms, data structures, and definitions to help you build programs or libraries.
        You will see many examples of Zig's Standard Library used in this documentation. To learn more about the Zig Standard Library,
        visit the link above.
      </p>
      <p>
        Alternatively, the Zig Standard Library documentation is provided with each Zig distribution. It can be rendered via a local webserver with:
      </p>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>zig std
</samp></pre></figure>
      

      <h2 id="Hello-World"><a href="#toc-Hello-World">Hello World</a> <a class="hdr" href="#Hello-World">§</a></h2>


      <figure><figcaption class="zig-cap"><cite class="file">hello.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> stdout = std.io.getStdOut().writer();
    <span class="tok-kw">try</span> stdout.print(<span class="tok-str">&quot;Hello, {s}!\n&quot;</span>, .{<span class="tok-str">&quot;world&quot;</span>});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe hello.zig</kbd>
$ <kbd>./hello</kbd>
Hello, world!
</samp></pre></figure>

      <p>
      Most of the time, it is more appropriate to write to stderr rather than stdout, and
      whether or not the message is successfully written to the stream is irrelevant.
      For this common case, there is a simpler API:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">hello_again.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    std.debug.print(<span class="tok-str">&quot;Hello, world!\n&quot;</span>, .{});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe hello_again.zig</kbd>
$ <kbd>./hello_again</kbd>
Hello, world!
</samp></pre></figure>

      <p>
      In this case, the <code>!</code> may be omitted from the return
      type of <code>main</code> because no errors are returned from the function.
      </p>
      <p>See also:</p><ul>
<li><a href="#Values">Values</a></li>
<li><a href="#Tuples">Tuples</a></li>
<li><a href="#import">@import</a></li>
<li><a href="#Errors">Errors</a></li>
<li><a href="#Entry-Point">Entry Point</a></li>
<li><a href="#Source-Encoding">Source Encoding</a></li>
<li><a href="#try">try</a></li>
</ul>

      
      <h2 id="Comments"><a href="#toc-Comments">Comments</a> <a class="hdr" href="#Comments">§</a></h2>

      <p>
      Zig supports 3 types of comments. Normal comments are ignored, but doc comments
      and top-level doc comments are used by the compiler to generate the package documentation.
      </p>
      <p>
      The generated documentation is still experimental, and can be produced with:
      </p>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>zig test -femit-docs main.zig
</samp></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">comments.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-comment">// Comments in Zig start with &quot;//&quot; and end at the next LF byte (end of line).</span>
    <span class="tok-comment">// The line below is a comment and won't be executed.</span>

    <span class="tok-comment">//print(&quot;Hello?&quot;, .{});</span>

    print(<span class="tok-str">&quot;Hello, world!\n&quot;</span>, .{}); <span class="tok-comment">// another comment</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe comments.zig</kbd>
$ <kbd>./comments</kbd>
Hello, world!
</samp></pre></figure>

      <p>
      There are no multiline comments in Zig (e.g. like <code class="c">/* */</code>
      comments in C).  This allows Zig to have the property that each line
      of code can be tokenized out of context.
      </p>
      <h3 id="Doc-Comments"><a href="#toc-Doc-Comments">Doc Comments</a> <a class="hdr" href="#Doc-Comments">§</a></h3>

      <p>
      A doc comment is one that begins with exactly three slashes (i.e.
      <code><span class="tok-comment">///</span></code> but not <code><span class="tok-comment">////</span></code>);
      multiple doc comments in a row are merged together to form a multiline
      doc comment.  The doc comment documents whatever immediately follows it.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">doc_comments.zig</cite></figcaption><pre><code><span class="tok-comment">/// A structure for storing a timestamp, with nanosecond precision (this is a</span>
<span class="tok-comment">/// multiline doc comment).</span>
<span class="tok-kw">const</span> Timestamp = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// The number of seconds since the epoch (this is also a doc comment).</span>
    seconds: <span class="tok-type">i64</span>, <span class="tok-comment">// signed so we can represent pre-1970 (not a doc comment)</span>
    <span class="tok-comment">/// The number of nanoseconds past the second (doc comment again).</span>
    nanos: <span class="tok-type">u32</span>,

    <span class="tok-comment">/// Returns a `Timestamp` struct representing the Unix epoch; that is, the</span>
    <span class="tok-comment">/// moment of 1970 Jan 1 00:00:00 UTC (this is a doc comment too).</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unixEpoch</span>() Timestamp {
        <span class="tok-kw">return</span> Timestamp{
            .seconds = <span class="tok-number">0</span>,
            .nanos = <span class="tok-number">0</span>,
        };
    }
};</code></pre></figure>

      <p>
      Doc comments are only allowed in certain places; it is a compile error to
      have a doc comment in an unexpected place, such as in the middle of an expression,
      or just before a non-doc comment.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">invalid_doc-comment.zig</cite></figcaption><pre><code><span class="tok-comment">/// doc-comment</span>
<span class="tok-comment">//! top-level doc-comment</span>
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj invalid_doc-comment.zig</kbd>
<span class="sgr-1m">doc/langref/invalid_doc-comment.zig:1:16: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type expression, found 'a document comment'
</span>/// doc-comment
               <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <figure><figcaption class="zig-cap"><cite class="file">unattached_doc-comment.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {}

<span class="tok-comment">/// End of file</span></code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj unattached_doc-comment.zig</kbd>
<span class="sgr-1m">doc/langref/unattached_doc-comment.zig:3:1: </span><span class="sgr-31m">error: </span><span class="sgr-1m">unattached documentation comment
</span>/// End of file
<span class="sgr-32m">^~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>
      Doc comments can be interleaved with normal comments. Currently, when producing
      the package documentation, normal comments are merged with doc comments.
      </p>
      
      <h3 id="Top-Level-Doc-Comments"><a href="#toc-Top-Level-Doc-Comments">Top-Level Doc Comments</a> <a class="hdr" href="#Top-Level-Doc-Comments">§</a></h3>

      <p>
      A top-level doc comment is one that begins with two slashes and an exclamation
      point: <code><span class="tok-comment">//!</span></code>; it documents the current module.
      </p>
      <p>
      It is a compile error if a top-level doc comment is not placed at the start
      of a <a href="#Containers">container</a>, before any expressions.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">tldoc_comments.zig</cite></figcaption><pre><code><span class="tok-comment">//! This module provides functions for retrieving the current date and</span>
<span class="tok-comment">//! time with varying degrees of precision and accuracy. It does not</span>
<span class="tok-comment">//! depend on libc, but will use functions from it if available.</span>

<span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
    <span class="tok-comment">//! Top level comments are allowed inside a container other than a module,</span>
    <span class="tok-comment">//! but it is not very useful.  Currently, when producing the package</span>
    <span class="tok-comment">//! documentation, these comments are ignored.</span>
};</code></pre></figure>

      
      
      <h2 id="Values"><a href="#toc-Values">Values</a> <a class="hdr" href="#Values">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">values.zig</cite></figcaption><pre><code><span class="tok-comment">// Top-level declarations are order-independent:</span>
<span class="tok-kw">const</span> print = std.debug.print;
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> os = std.os;
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-comment">// integers</span>
    <span class="tok-kw">const</span> one_plus_one: <span class="tok-type">i32</span> = <span class="tok-number">1</span> + <span class="tok-number">1</span>;
    print(<span class="tok-str">&quot;1 + 1 = {}\n&quot;</span>, .{one_plus_one});

    <span class="tok-comment">// floats</span>
    <span class="tok-kw">const</span> seven_div_three: <span class="tok-type">f32</span> = <span class="tok-number">7.0</span> / <span class="tok-number">3.0</span>;
    print(<span class="tok-str">&quot;7.0 / 3.0 = {}\n&quot;</span>, .{seven_div_three});

    <span class="tok-comment">// boolean</span>
    print(<span class="tok-str">&quot;{}\n{}\n{}\n&quot;</span>, .{
        <span class="tok-null">true</span> <span class="tok-kw">and</span> <span class="tok-null">false</span>,
        <span class="tok-null">true</span> <span class="tok-kw">or</span> <span class="tok-null">false</span>,
        !<span class="tok-null">true</span>,
    });

    <span class="tok-comment">// optional</span>
    <span class="tok-kw">var</span> optional_value: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;
    assert(optional_value == <span class="tok-null">null</span>);

    print(<span class="tok-str">&quot;\noptional 1\ntype: {}\nvalue: {?s}\n&quot;</span>, .{
        <span class="tok-builtin">@TypeOf</span>(optional_value), optional_value,
    });

    optional_value = <span class="tok-str">&quot;hi&quot;</span>;
    assert(optional_value != <span class="tok-null">null</span>);

    print(<span class="tok-str">&quot;\noptional 2\ntype: {}\nvalue: {?s}\n&quot;</span>, .{
        <span class="tok-builtin">@TypeOf</span>(optional_value), optional_value,
    });

    <span class="tok-comment">// error union</span>
    <span class="tok-kw">var</span> number_or_error: <span class="tok-type">anyerror</span>!<span class="tok-type">i32</span> = <span class="tok-kw">error</span>.ArgNotFound;

    print(<span class="tok-str">&quot;\nerror union 1\ntype: {}\nvalue: {!}\n&quot;</span>, .{
        <span class="tok-builtin">@TypeOf</span>(number_or_error),
        number_or_error,
    });

    number_or_error = <span class="tok-number">1234</span>;

    print(<span class="tok-str">&quot;\nerror union 2\ntype: {}\nvalue: {!}\n&quot;</span>, .{
        <span class="tok-builtin">@TypeOf</span>(number_or_error), number_or_error,
    });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe values.zig</kbd>
$ <kbd>./values</kbd>
1 + 1 = 2
7.0 / 3.0 = 2.3333333e0
false
true
false

optional 1
type: ?[]const u8
value: null

optional 2
type: ?[]const u8
value: hi

error union 1
type: anyerror!i32
value: error.ArgNotFound

error union 2
type: anyerror!i32
value: 1234
</samp></pre></figure>

      <h3 id="Primitive-Types"><a href="#toc-Primitive-Types">Primitive Types</a> <a class="hdr" href="#Primitive-Types">§</a></h3>

      <div class="table-wrapper">
      <table>
        <caption>Primitive Types</caption>
        <thead>
            <tr>
            <th scope="col">Type</th>
            <th scope="col">C Equivalent</th>
            <th scope="col">Description</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th scope="row"><code><span class="tok-type">i8</span></code></th>
          <td><code class="c">int8_t</code></td>
          <td>signed 8-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">u8</span></code></th>
          <td><code class="c">uint8_t</code></td>
          <td>unsigned 8-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">i16</span></code></th>
          <td><code class="c">int16_t</code></td>
          <td>signed 16-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">u16</span></code></th>
          <td><code class="c">uint16_t</code></td>
          <td>unsigned 16-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">i32</span></code></th>
          <td><code class="c">int32_t</code></td>
          <td>signed 32-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">u32</span></code></th>
          <td><code class="c">uint32_t</code></td>
          <td>unsigned 32-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">i64</span></code></th>
          <td><code class="c">int64_t</code></td>
          <td>signed 64-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">u64</span></code></th>
          <td><code class="c">uint64_t</code></td>
          <td>unsigned 64-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">i128</span></code></th>
          <td><code class="c">__int128</code></td>
          <td>signed 128-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">u128</span></code></th>
          <td><code class="c">unsigned __int128</code></td>
          <td>unsigned 128-bit integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">isize</span></code></th>
          <td><code class="c">intptr_t</code></td>
          <td>signed pointer sized integer</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">usize</span></code></th>
          <td><code class="c">uintptr_t</code>, <code class="c">size_t</code></td>
          <td>unsigned pointer sized integer. Also see <a href="https://github.com/ziglang/zig/issues/5185">#5185</a></td>
        </tr>

        <tr>
            <th scope="row"><code><span class="tok-type">c_char</span></code></th>
          <td><code class="c">char</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_short</span></code></th>
          <td><code class="c">short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_ushort</span></code></th>
          <td><code class="c">unsigned short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_int</span></code></th>
          <td><code class="c">int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_uint</span></code></th>
          <td><code class="c">unsigned int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_long</span></code></th>
          <td><code class="c">long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_ulong</span></code></th>
          <td><code class="c">unsigned long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_longlong</span></code></th>
          <td><code class="c">long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_ulonglong</span></code></th>
          <td><code class="c">unsigned long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">c_longdouble</span></code></th>
          <td><code class="c">long double</code></td>
          <td>for ABI compatibility with C</td>
        </tr>

        <tr>
            <th scope="row"><code><span class="tok-type">f16</span></code></th>
          <td><code class="c">_Float16</code></td>
          <td>16-bit floating point (10-bit mantissa) IEEE-754-2008 binary16</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">f32</span></code></th>
          <td><code class="c">float</code></td>
          <td>32-bit floating point (23-bit mantissa) IEEE-754-2008 binary32</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">f64</span></code></th>
          <td><code class="c">double</code></td>
          <td>64-bit floating point (52-bit mantissa) IEEE-754-2008 binary64</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">f80</span></code></th>
          <td><code class="c">long double</code></td>
          <td>80-bit floating point (64-bit mantissa) IEEE-754-2008 80-bit extended precision</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">f128</span></code></th>
            <td><code class="c">_Float128</code></td>
          <td>128-bit floating point (112-bit mantissa) IEEE-754-2008 binary128</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">bool</span></code></th>
          <td><code class="c">bool</code></td>
          <td><code><span class="tok-null">true</span></code> or <code><span class="tok-null">false</span></code></td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">anyopaque</span></code></th>
          <td><code class="c">void</code></td>
          <td>Used for type-erased pointers.</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">void</span></code></th>
          <td>(none)</td>
          <td>Always the value <code><span class="tok-type">void</span>{}</code></td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">noreturn</span></code></th>
          <td>(none)</td>
          <td>the type of <code><span class="tok-kw">break</span></code>, <code><span class="tok-kw">continue</span></code>, <code><span class="tok-kw">return</span></code>, <code><span class="tok-kw">unreachable</span></code>, and <code><span class="tok-kw">while</span> (<span class="tok-null">true</span>) {}</code></td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">type</span></code></th>
          <td>(none)</td>
          <td>the type of types</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">anyerror</span></code></th>
          <td>(none)</td>
          <td>an error code</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">comptime_int</span></code></th>
          <td>(none)</td>
          <td>Only allowed for <a href="#comptime">comptime</a>-known values. The type of integer literals.</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-type">comptime_float</span></code></th>
          <td>(none)</td>
          <td>Only allowed for <a href="#comptime">comptime</a>-known values. The type of float literals.</td>
        </tr>
        </tbody>
      </table>
      </div>
      <p>
      In addition to the integer types above, arbitrary bit-width integers can be referenced by using
      an identifier of <code>i</code> or <code>u</code> followed by digits. For example, the identifier
      <code><span class="tok-type">i7</span></code> refers to a signed 7-bit integer. The maximum allowed bit-width of an
      integer type is <code><span class="tok-number">65535</span></code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Integers">Integers</a></li>
<li><a href="#Floats">Floats</a></li>
<li><a href="#void">void</a></li>
<li><a href="#Errors">Errors</a></li>
<li><a href="#Type">@Type</a></li>
</ul>

      
      <h3 id="Primitive-Values"><a href="#toc-Primitive-Values">Primitive Values</a> <a class="hdr" href="#Primitive-Values">§</a></h3>

      <div class="table-wrapper">
      <table>
        <caption>Primitive Values</caption>
        <thead>
        <tr>
          <th scope="col">Name</th>
          <th scope="col">Description</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th scope="row"><code><span class="tok-null">true</span></code> and <code><span class="tok-null">false</span></code></th>
            <td><code><span class="tok-type">bool</span></code> values</td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-null">null</span></code></th>
            <td>used to set an optional type to <code><span class="tok-null">null</span></code></td>
        </tr>
        <tr>
            <th scope="row"><code><span class="tok-null">undefined</span></code></th>
          <td>used to leave a value unspecified</td>
        </tr>
        </tbody>
      </table>
      </div>
      <p>See also:</p><ul>
<li><a href="#Optionals">Optionals</a></li>
<li><a href="#undefined">undefined</a></li>
</ul>

      
      <h3 id="String-Literals-and-Unicode-Code-Point-Literals"><a href="#toc-String-Literals-and-Unicode-Code-Point-Literals">String Literals and Unicode Code Point Literals</a> <a class="hdr" href="#String-Literals-and-Unicode-Code-Point-Literals">§</a></h3>

      <p>
      String literals are constant single-item <a href="#Pointers">Pointers</a> to null-terminated byte arrays.
      The type of string literals encodes both the length, and the fact that they are null-terminated,
      and thus they can be <a href="#Type-Coercion">coerced</a> to both <a href="#Slices">Slices</a> and
      <a href="#Sentinel-Terminated-Pointers">Null-Terminated Pointers</a>.
      Dereferencing string literals converts them to <a href="#Arrays">Arrays</a>.
      </p>
      <p>
      Because Zig source code is <a href="#Source-Encoding">UTF-8 encoded</a>, any
      non-ASCII bytes appearing within a string literal in source code carry
      their UTF-8 meaning into the content of the string in the Zig program;
      the bytes are not modified by the compiler. It is possible to embed
      non-UTF-8 bytes into a string literal using <code>\xNN</code> notation.
      </p>
      <p>Indexing into a string containing non-ASCII bytes returns individual
      bytes, whether valid UTF-8 or not.</p>
      <p>
      Unicode code point literals have type <code><span class="tok-type">comptime_int</span></code>, the same as
      <a href="#Integer-Literals">Integer Literals</a>. All <a href="#Escape-Sequences">Escape Sequences</a> are valid in both string literals
      and Unicode code point literals.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">string_literals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem; <span class="tok-comment">// will be used to compare bytes</span>

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> bytes = <span class="tok-str">&quot;hello&quot;</span>;
    print(<span class="tok-str">&quot;{}\n&quot;</span>, .{<span class="tok-builtin">@TypeOf</span>(bytes)}); <span class="tok-comment">// *const [5:0]u8</span>
    print(<span class="tok-str">&quot;{d}\n&quot;</span>, .{bytes.len}); <span class="tok-comment">// 5</span>
    print(<span class="tok-str">&quot;{c}\n&quot;</span>, .{bytes[<span class="tok-number">1</span>]}); <span class="tok-comment">// 'e'</span>
    print(<span class="tok-str">&quot;{d}\n&quot;</span>, .{bytes[<span class="tok-number">5</span>]}); <span class="tok-comment">// 0</span>
    print(<span class="tok-str">&quot;{}\n&quot;</span>, .{<span class="tok-str">'e'</span> == <span class="tok-str">'\x65'</span>}); <span class="tok-comment">// true</span>
    print(<span class="tok-str">&quot;{d}\n&quot;</span>, .{<span class="tok-str">'\u{1f4a9}'</span>}); <span class="tok-comment">// 128169</span>
    print(<span class="tok-str">&quot;{d}\n&quot;</span>, .{<span class="tok-str">'💯'</span>}); <span class="tok-comment">// 128175</span>
    print(<span class="tok-str">&quot;{u}\n&quot;</span>, .{<span class="tok-str">'⚡'</span>});
    print(<span class="tok-str">&quot;{}\n&quot;</span>, .{mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">&quot;h\x65llo&quot;</span>)}); <span class="tok-comment">// true</span>
    print(<span class="tok-str">&quot;{}\n&quot;</span>, .{mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;💯&quot;</span>, <span class="tok-str">&quot;\xf0\x9f\x92\xaf&quot;</span>)}); <span class="tok-comment">// also true</span>
    <span class="tok-kw">const</span> invalid_utf8 = <span class="tok-str">&quot;\xff\xfe&quot;</span>; <span class="tok-comment">// non-UTF-8 strings are possible with \xNN notation.</span>
    print(<span class="tok-str">&quot;0x{x}\n&quot;</span>, .{invalid_utf8[<span class="tok-number">1</span>]}); <span class="tok-comment">// indexing them returns individual bytes...</span>
    print(<span class="tok-str">&quot;0x{x}\n&quot;</span>, .{<span class="tok-str">&quot;💯&quot;</span>[<span class="tok-number">1</span>]}); <span class="tok-comment">// ...as does indexing part-way through non-ASCII characters</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe string_literals.zig</kbd>
$ <kbd>./string_literals</kbd>
*const [5:0]u8
5
e
0
true
128169
128175
⚡
true
true
0xfe
0x9f
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#Arrays">Arrays</a></li>
<li><a href="#Source-Encoding">Source Encoding</a></li>
</ul>

      <h4 id="Escape-Sequences"><a href="#toc-Escape-Sequences">Escape Sequences</a> <a class="hdr" href="#Escape-Sequences">§</a></h4>

      <div class="table-wrapper">
      <table>
        <caption>Escape Sequences</caption>
        <thead>
        <tr>
          <th scope="col">Escape Sequence</th>
          <th scope="col">Name</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th scope="row"><code>\n</code></th>
          <td>Newline</td>
        </tr>
        <tr>
            <th scope="row"><code>\r</code></th>
          <td>Carriage Return</td>
        </tr>
        <tr>
            <th scope="row"><code>\t</code></th>
          <td>Tab</td>
        </tr>
        <tr>
            <th scope="row"><code>\\</code></th>
          <td>Backslash</td>
        </tr>
        <tr>
            <th scope="row"><code>\'</code></th>
          <td>Single Quote</td>
        </tr>
        <tr>
            <th scope="row"><code>\"</code></th>
          <td>Double Quote</td>
        </tr>
        <tr>
            <th scope="row"><code>\xNN</code></th>
          <td>hexadecimal 8-bit byte value (2 digits)</td>
        </tr>
        <tr>
            <th scope="row"><code>\u{NNNNNN}</code></th>
          <td>hexadecimal Unicode scalar value UTF-8 encoded (1 or more digits)</td>
        </tr>
        </tbody>
      </table>
      </div>
      <p>Note that the maximum valid Unicode scalar value is <code><span class="tok-number">0x10ffff</span></code>.</p>
      
      <h4 id="Multiline-String-Literals"><a href="#toc-Multiline-String-Literals">Multiline String Literals</a> <a class="hdr" href="#Multiline-String-Literals">§</a></h4>

      <p>
      Multiline string literals have no escapes and can span across multiple lines.
      To start a multiline string literal, use the <code><span class="tok-str">\\</span></code> token. Just like a comment,
      the string literal goes until the end of the line. The end of the line is
      not included in the string literal.
      However, if the next line begins with <code><span class="tok-str">\\</span></code> then a newline is appended and
      the string literal continues.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">multiline_string_literals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> hello_world_in_c =
    <span class="tok-str">\\#include &lt;stdio.h&gt;</span>
    <span class="tok-str">\\</span>
    <span class="tok-str">\\int main(int argc, char **argv) {</span>
    <span class="tok-str">\\    printf(&quot;hello world\n&quot;);</span>
    <span class="tok-str">\\    return 0;</span>
    <span class="tok-str">\\}</span>
;</code></pre></figure>

      <p>See also:</p><ul>
<li><a href="#embedFile">@embedFile</a></li>
</ul>

      
      
      <h3 id="Assignment"><a href="#toc-Assignment">Assignment</a> <a class="hdr" href="#Assignment">§</a></h3>

      <p>Use the <code><span class="tok-kw">const</span></code> keyword to assign a value to an identifier:</p>
      <figure><figcaption class="zig-cap"><cite class="file">constant_identifier_cannot_change.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> x = <span class="tok-number">1234</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {
    <span class="tok-comment">// It works at file scope as well as inside functions.</span>
    <span class="tok-kw">const</span> y = <span class="tok-number">5678</span>;

    <span class="tok-comment">// Once assigned, an identifier cannot be changed.</span>
    y += <span class="tok-number">1</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    foo();
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe constant_identifier_cannot_change.zig</kbd>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/constant_identifier_cannot_change.zig:8:7: </span><span class="sgr-31m">error: </span><span class="sgr-1m">cannot assign to constant
</span>    y += 1;
    <span class="sgr-32m">~~^~~~
</span><span class="sgr-2m">referenced by:
    main: /home/andy/src/zig/doc/langref/constant_identifier_cannot_change.zig:12:8
    posixCallMainAndExit: /home/andy/src/zig/lib/std/start.zig:647:22
    4 reference(s) hidden; use '-freference-trace=6' to see all references
</span>
</samp></pre></figure>

      <p><code><span class="tok-kw">const</span></code> applies to all of the bytes that the identifier immediately addresses. <a href="#Pointers">Pointers</a> have their own const-ness.</p>
      <p>If you need a variable that you can modify, use the <code><span class="tok-kw">var</span></code> keyword:</p>
      <figure><figcaption class="zig-cap"><cite class="file">mutable_var.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">5678</span>;

    y += <span class="tok-number">1</span>;

    print(<span class="tok-str">&quot;{d}&quot;</span>, .{y});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe mutable_var.zig</kbd>
$ <kbd>./mutable_var</kbd>
5679
</samp></pre></figure>

      <p>Variables must be initialized:</p>
      <figure><figcaption class="zig-cap"><cite class="file">var_must_be_initialized.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span>;

    x = <span class="tok-number">1</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe var_must_be_initialized.zig</kbd>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/var_must_be_initialized.zig:2:15: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected '=', found ';'
</span>    var x: i32;
              <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <h4 id="undefined"><a href="#toc-undefined">undefined</a> <a class="hdr" href="#undefined">§</a></h4>

      <p>Use <code><span class="tok-null">undefined</span></code> to leave variables uninitialized:</p>
      <figure><figcaption class="zig-cap"><cite class="file">assign_undefined.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
    x = <span class="tok-number">1</span>;
    print(<span class="tok-str">&quot;{d}&quot;</span>, .{x});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe assign_undefined.zig</kbd>
$ <kbd>./assign_undefined</kbd>
1
</samp></pre></figure>

      <p>
      <code><span class="tok-null">undefined</span></code> can be <a href="#Type-Coercion">coerced</a> to any type.
          Once this happens, it is no longer possible to detect that the value is <code><span class="tok-null">undefined</span></code>.
              <code><span class="tok-null">undefined</span></code> means the value could be anything, even something that is nonsense
                  according to the type. Translated into English, <code><span class="tok-null">undefined</span></code> means "Not a meaningful
      value. Using this value would be a bug. The value will be unused, or overwritten before being used."
      </p>
      <p>
      In <a href="#Debug">Debug</a> mode, Zig writes <code><span class="tok-number">0xaa</span></code> bytes to undefined memory. This is to catch
      bugs early, and to help detect use of undefined memory in a debugger. However, this behavior is only an
      implementation feature, not a language semantic, so it is not guaranteed to be observable to code.
      </p>
      

      <h4 id="Destructuring"><a href="#toc-Destructuring">Destructuring</a> <a class="hdr" href="#Destructuring">§</a></h4>

      <p>
        A destructuring assignment can separate elements of indexable aggregate types
        (<a href="#Tuples">Tuples</a>, <a href="#Arrays">Arrays</a>, <a href="#Vectors">Vectors</a>):
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_to_existing.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> y: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> z: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> tuple = .{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> };

    x, y, z = tuple;

    print(<span class="tok-str">&quot;tuple: x = {}, y = {}, z = {}\n&quot;</span>, .{x, y, z});

    <span class="tok-kw">const</span> array = [_]<span class="tok-type">u32</span>{ <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span> };

    x, y, z = array;

    print(<span class="tok-str">&quot;array: x = {}, y = {}, z = {}\n&quot;</span>, .{x, y, z});

    <span class="tok-kw">const</span> vector: <span class="tok-builtin">@Vector</span>(<span class="tok-number">3</span>, <span class="tok-type">u32</span>) = .{ <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span> };

    x, y, z = vector;

    print(<span class="tok-str">&quot;vector: x = {}, y = {}, z = {}\n&quot;</span>, .{x, y, z});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_to_existing.zig</kbd>
$ <kbd>./destructuring_to_existing</kbd>
tuple: x = 1, y = 2, z = 3
array: x = 4, y = 5, z = 6
vector: x = 7, y = 8, z = 9
</samp></pre></figure>

      <p>
        A destructuring expression may only appear within a block (i.e. not at container scope).
        The left hand side of the assignment must consist of a comma separated list,
        each element of which may be either an lvalue (for instance, an existing `var`) or a variable declaration:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_mixed.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;

    <span class="tok-kw">const</span> tuple = .{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> };

    x, <span class="tok-kw">var</span> y : <span class="tok-type">u32</span>, <span class="tok-kw">const</span> z = tuple;

    print(<span class="tok-str">&quot;x = {}, y = {}, z = {}\n&quot;</span>, .{x, y, z});

    <span class="tok-comment">// y is mutable</span>
    y = <span class="tok-number">100</span>;

    <span class="tok-comment">// You can use _ to throw away unwanted values.</span>
    _, x, _ = tuple;

    print(<span class="tok-str">&quot;x = {}&quot;</span>, .{x});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_mixed.zig</kbd>
$ <kbd>./destructuring_mixed</kbd>
x = 1, y = 2, z = 3
x = 2
</samp></pre></figure>

      <p>
        A destructure may be prefixed with the <code><span class="tok-kw">comptime</span></code> keyword, in which case the entire
        destructure expression is evaluated at <a href="#comptime">comptime</a>. All <code><span class="tok-kw">var</span></code>s declared would
        be <code><span class="tok-kw">comptime</span> <span class="tok-kw">var</span></code>s and all expressions (both result locations and the assignee
        expression) are evaluated at <a href="#comptime">comptime</a>.
      </p>

      <p>See also:</p><ul>
<li><a href="#Destructuring-Tuples">Destructuring Tuples</a></li>
<li><a href="#Destructuring-Arrays">Destructuring Arrays</a></li>
<li><a href="#Destructuring-Vectors">Destructuring Vectors</a></li>
</ul>

      
      
      
      <h2 id="Zig-Test"><a href="#toc-Zig-Test">Zig Test</a> <a class="hdr" href="#Zig-Test">§</a></h2>

      <p>
        Code written within one or more <code><span class="tok-kw">test</span></code> declarations can be used to ensure behavior meets expectations:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_introduction.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;expect addOne adds one to 41&quot;</span> {

    <span class="tok-comment">// The Standard Library contains useful functions to help create tests.</span>
    <span class="tok-comment">// `expect` is a function that verifies its argument is true.</span>
    <span class="tok-comment">// It will return an error if its argument is false to indicate a failure.</span>
    <span class="tok-comment">// `try` is used to return an error to the test runner to notify it that the test failed.</span>
    <span class="tok-kw">try</span> std.testing.expect(addOne(<span class="tok-number">41</span>) == <span class="tok-number">42</span>);
}

<span class="tok-kw">test</span> addOne {
    <span class="tok-comment">// A test name can also be written using an identifier.</span>
    <span class="tok-comment">// This is a doctest, and serves as documentation for `addOne`.</span>
    <span class="tok-kw">try</span> std.testing.expect(addOne(<span class="tok-number">41</span>) == <span class="tok-number">42</span>);
}

<span class="tok-comment">/// The function `addOne` adds one to the number given as its argument.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">addOne</span>(number: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> number + <span class="tok-number">1</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_introduction.zig</kbd>
1/2 testing_introduction.test.expect addOne adds one to 41...OK
2/2 testing_introduction.decltest.addOne...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
        The <code class="file">testing_introduction.zig</code> code sample tests the <a href="#Functions">function</a>
        <code>addOne</code> to ensure that it returns <code><span class="tok-number">42</span></code> given the input
        <code><span class="tok-number">41</span></code>. From this test's perspective, the <code>addOne</code> function is
        said to be <em>code under test</em>.
      </p>
      <p>
        <kbd>zig test</kbd> is a tool that creates and runs a test build. By default, it builds and runs an
        executable program using the <em>default test runner</em> provided by the <a href="#Zig-Standard-Library">Zig Standard Library</a>
        as its main entry point. During the build, <code><span class="tok-kw">test</span></code> declarations found while
        <a href="#File-and-Declaration-Discovery">resolving</a> the given Zig source file are included for the default test runner
        to run and report on.
      </p>
      <aside>
        This documentation discusses the features of the default test runner as provided by the Zig Standard Library.
        Its source code is located in <code class="file">lib/compiler/test_runner.zig</code>.
      </aside>
      <p>
        The shell output shown above displays two lines after the <kbd>zig test</kbd> command. These lines are
        printed to standard error by the default test runner:
      </p>
      <dl>
        <dt><samp>1/2 testing_introduction.test.expect addOne adds one to 41...</samp></dt>
        <dd>Lines like this indicate which test, out of the total number of tests, is being run.
          In this case, <samp>1/2</samp> indicates that the first test, out of a total of two tests,
          is being run. Note that, when the test runner program's standard error is output
          to the terminal, these lines are cleared when a test succeeds.
        </dd>
        <dt><samp>2/2 testing_introduction.decltest.addOne...</samp></dt>
        <dd>When the test name is an identifier, the default test runner uses the text
          decltest instead of test.
        </dd>
        <dt><samp>All 2 tests passed.</samp></dt>
        <dd>This line indicates the total number of tests that have passed.</dd>
      </dl>
      <h3 id="Test-Declarations"><a href="#toc-Test-Declarations">Test Declarations</a> <a class="hdr" href="#Test-Declarations">§</a></h3>

      <p>
        Test declarations contain the <a href="#Keyword-Reference">keyword</a> <code><span class="tok-kw">test</span></code>, followed by an
        optional name written as a <a href="#String-Literals-and-Unicode-Code-Point-Literals">string literal</a> or an
        <a href="#Identifiers">identifier</a>, followed by a <a href="#Blocks">block</a> containing any valid Zig code that
        is allowed in a <a href="#Functions">function</a>.
      </p>
      <p>Non-named test blocks always run during test builds and are exempt from
        <a href="#Skip-Tests">Skip Tests</a>.</p>
      <p>
        Test declarations are similar to <a href="#Functions">Functions</a>: they have a return type and a block of code. The implicit
        return type of <code><span class="tok-kw">test</span></code> is the <a href="#Error-Union-Type">Error Union Type</a> <code><span class="tok-type">anyerror</span>!<span class="tok-type">void</span></code>,
        and it cannot be changed. When a Zig source file is not built using the <kbd>zig test</kbd> tool, the test
        declarations are omitted from the build.
      </p>
      <p>
        Test declarations can be written in the same file, where code under test is written, or in a separate Zig source file.
        Since test declarations are top-level declarations, they are order-independent and can
        be written before or after the code under test.
      </p>
      <p>See also:</p><ul>
<li><a href="#The-Global-Error-Set">The Global Error Set</a></li>
<li><a href="#Grammar">Grammar</a></li>
</ul>

      <h4 id="Doctests"><a href="#toc-Doctests">Doctests</a> <a class="hdr" href="#Doctests">§</a></h4>

      <p>
        Test declarations named using an identifier are <em>doctests</em>. The identifier must refer to another declaration in
        scope. A doctest, like a <a href="#Doc-Comments">doc comment</a>, serves as documentation for the associated declaration, and
        will appear in the generated documentation for the declaration.
      </p>
      <p>
        An effective doctest should be self-contained and focused on the declaration being tested, answering questions a new
        user might have about its interface or intended usage, while avoiding unnecessary or confusing details. A doctest is not
        a substitute for a doc comment, but rather a supplement and companion providing a testable, code-driven example, verified
        by <kbd>zig test</kbd>.
      </p>
      
      
      <h3 id="Test-Failure"><a href="#toc-Test-Failure">Test Failure</a> <a class="hdr" href="#Test-Failure">§</a></h3>

      <p>
        The default test runner checks for an <a href="#Errors">error</a> returned from a test.
        When a test returns an error, the test is considered a failure and its <a href="#Error-Return-Traces">error return trace</a>
        is output to standard error. The total number of failures will be reported after all tests have run.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_failure.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;expect this to fail&quot;</span> {
    <span class="tok-kw">try</span> std.testing.expect(<span class="tok-null">false</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;expect this to succeed&quot;</span> {
    <span class="tok-kw">try</span> std.testing.expect(<span class="tok-null">true</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_failure.zig</kbd>
1/2 testing_failure.test.expect this to fail...FAIL (TestUnexpectedResult)
<span class="sgr-1m">/home/andy/src/zig/lib/std/testing.zig:580:14</span>: <span class="sgr-2m">0x104899f in expect (test)</span>
    if (!ok) return error.TestUnexpectedResult;
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/testing_failure.zig:4:5</span>: <span class="sgr-2m">0x1048a35 in test.expect this to fail (test)</span>
    try std.testing.expect(false);
    <span class="sgr-32m">^</span>
2/2 testing_failure.test.expect this to succeed...OK
1 passed; 0 skipped; 1 failed.
error: the following test command failed with exit code 1:
/home/andy/src/zig/.zig-cache/o/4b55be885f04d4406910bf905e0a160c/test --seed=0x5dd97878
</samp></pre></figure>

      
      <h3 id="Skip-Tests"><a href="#toc-Skip-Tests">Skip Tests</a> <a class="hdr" href="#Skip-Tests">§</a></h3>

      <p>
        One way to skip tests is to filter them out by using the <kbd>zig test</kbd> command line parameter
        <kbd>--test-filter [text]</kbd>. This makes the test build only include tests whose name contains the
        supplied filter text. Note that non-named tests are run even when using the <kbd>--test-filter [text]</kbd>
        command line parameter.
      </p>
      <p>
        To programmatically skip a test, make a <code><span class="tok-kw">test</span></code> return the error
        <code><span class="tok-kw">error</span>.SkipZigTest</code> and the default test runner will consider the test as being skipped.
        The total number of skipped tests will be reported after all tests have run.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_skip.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;this will be skipped&quot;</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_skip.zig</kbd>
1/1 testing_skip.test.this will be skipped...SKIP
0 passed; 1 skipped; 0 failed.
</samp></pre></figure>

      

      <h3 id="Report-Memory-Leaks"><a href="#toc-Report-Memory-Leaks">Report Memory Leaks</a> <a class="hdr" href="#Report-Memory-Leaks">§</a></h3>

      <p>
        When code allocates <a href="#Memory">Memory</a> using the <a href="#Zig-Standard-Library">Zig Standard Library</a>'s testing allocator,
        <code>std.testing.allocator</code>, the default test runner will report any leaks that are
        found from using the testing allocator:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_detect_leak.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;detect leak&quot;</span> {
    <span class="tok-kw">var</span> list = std.ArrayList(<span class="tok-type">u21</span>).init(std.testing.allocator);
    <span class="tok-comment">// missing `defer list.deinit();`</span>
    <span class="tok-kw">try</span> list.append(<span class="tok-str">'☔'</span>);

    <span class="tok-kw">try</span> std.testing.expect(list.items.len == <span class="tok-number">1</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_detect_leak.zig</kbd>
1/1 testing_detect_leak.test.detect leak...OK
[gpa] (err): memory address 0x7f7537720000 leaked:
<span class="sgr-1m">/home/andy/src/zig/lib/std/array_list.zig:474:67</span>: <span class="sgr-2m">0x10695a2 in ensureTotalCapacityPrecise (test)</span>
                const new_memory = try self.allocator.alignedAlloc(T, alignment, new_capacity);
                                                                  <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/array_list.zig:450:51</span>: <span class="sgr-2m">0x104ea80 in ensureTotalCapacity (test)</span>
            return self.ensureTotalCapacityPrecise(better_capacity);
                                                  <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/array_list.zig:500:41</span>: <span class="sgr-2m">0x104cdaf in addOne (test)</span>
            try self.ensureTotalCapacity(newlen);
                                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/array_list.zig:261:49</span>: <span class="sgr-2m">0x104a8cd in append (test)</span>
            const new_item_ptr = try self.addOne();
                                                <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/testing_detect_leak.zig:6:20</span>: <span class="sgr-2m">0x1048d05 in test.detect leak (test)</span>
    try list.append('☔');
                   <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:214:25</span>: <span class="sgr-2m">0x10f7c35 in mainTerminal (test)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:62:28</span>: <span class="sgr-2m">0x10f1c8d in main (test)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10f1212 in posixCallMainAndExit (test)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10f0ded in _start (test)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>

All 1 tests passed.
1 errors were logged.
1 tests leaked memory.
error: the following test command failed with exit code 1:
/home/andy/src/zig/.zig-cache/o/9073e84ae632f507d6f6e265f9c82f56/test --seed=0xe9497de3
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#defer">defer</a></li>
<li><a href="#Memory">Memory</a></li>
</ul>

      
      <h3 id="Detecting-Test-Build"><a href="#toc-Detecting-Test-Build">Detecting Test Build</a> <a class="hdr" href="#Detecting-Test-Build">§</a></h3>

      <p>
        Use the <a href="#Compile-Variables">compile variable</a> <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).is_test</code>
        to detect a test build:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_detect_test.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;builtin.is_test&quot;</span> {
    <span class="tok-kw">try</span> expect(isATest());
}

<span class="tok-kw">fn</span> <span class="tok-fn">isATest</span>() <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> builtin.is_test;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_detect_test.zig</kbd>
1/1 testing_detect_test.test.builtin.is_test...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h3 id="Test-Output-and-Logging"><a href="#toc-Test-Output-and-Logging">Test Output and Logging</a> <a class="hdr" href="#Test-Output-and-Logging">§</a></h3>

      <p>
        The default test runner and the Zig Standard Library's testing namespace output messages to standard error.
      </p>
      
      <h3 id="The-Testing-Namespace"><a href="#toc-The-Testing-Namespace">The Testing Namespace</a> <a class="hdr" href="#The-Testing-Namespace">§</a></h3>

      <p>
        The Zig Standard Library's <code>testing</code> namespace contains useful functions to help
        you create tests. In addition to the <code>expect</code> function, this document uses a couple of more functions
        as exemplified here:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_namespace.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;expectEqual demo&quot;</span> {
    <span class="tok-kw">const</span> expected: <span class="tok-type">i32</span> = <span class="tok-number">42</span>;
    <span class="tok-kw">const</span> actual = <span class="tok-number">42</span>;

    <span class="tok-comment">// The first argument to `expectEqual` is the known, expected, result.</span>
    <span class="tok-comment">// The second argument is the result of some expression.</span>
    <span class="tok-comment">// The actual's type is casted to the type of expected.</span>
    <span class="tok-kw">try</span> std.testing.expectEqual(expected, actual);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;expectError demo&quot;</span> {
    <span class="tok-kw">const</span> expected_error = <span class="tok-kw">error</span>.DemoError;
    <span class="tok-kw">const</span> actual_error_union: <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> = <span class="tok-kw">error</span>.DemoError;

    <span class="tok-comment">// `expectError` will fail when the actual error is different than</span>
    <span class="tok-comment">// the expected error.</span>
    <span class="tok-kw">try</span> std.testing.expectError(expected_error, actual_error_union);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test testing_namespace.zig</kbd>
1/2 testing_namespace.test.expectEqual demo...OK
2/2 testing_namespace.test.expectError demo...OK
All 2 tests passed.
</samp></pre></figure>

      <p>The Zig Standard Library also contains functions to compare <a href="#Slices">Slices</a>, strings, and more. See the rest of the
        <code>std.testing</code> namespace in the <a href="#Zig-Standard-Library">Zig Standard Library</a> for more available functions.</p>
      
      <h3 id="Test-Tool-Documentation"><a href="#toc-Test-Tool-Documentation">Test Tool Documentation</a> <a class="hdr" href="#Test-Tool-Documentation">§</a></h3>

      <p>
        <kbd>zig test</kbd> has a few command line parameters which affect the compilation.
        See <kbd>zig test --help</kbd> for a full list.
      </p>
      
      

      <h2 id="Variables"><a href="#toc-Variables">Variables</a> <a class="hdr" href="#Variables">§</a></h2>

      <p>
      A variable is a unit of <a href="#Memory">Memory</a> storage.
      </p>
      <p>
      It is generally preferable to use <code><span class="tok-kw">const</span></code> rather than
      <code><span class="tok-kw">var</span></code> when declaring a variable. This causes less work for both
      humans and computers to do when reading code, and creates more optimization opportunities.
      </p>
      <p>
      The <code><span class="tok-kw">extern</span></code> keyword or <a href="#extern">@extern</a> builtin function can be used to link against a variable that is exported
      from another object. The <code><span class="tok-kw">export</span></code> keyword or <a href="#export">@export</a> builtin function
      can be used to make a variable available to other objects at link time. In both cases,
      the type of the variable must be C ABI compatible.
      </p>
      <p>See also:</p><ul>
<li><a href="#Exporting-a-C-Library">Exporting a C Library</a></li>
</ul>


      <h3 id="Identifiers"><a href="#toc-Identifiers">Identifiers</a> <a class="hdr" href="#Identifiers">§</a></h3>

      <p>
      Variable identifiers are never allowed to shadow identifiers from an outer scope.
      </p>
      <p>
      Identifiers must start with an alphabetic character or underscore and may be followed
      by any number of alphanumeric characters or underscores.
      They must not overlap with any keywords. See <a href="#Keyword-Reference">Keyword Reference</a>.
      </p>
      <p>
      If a name that does not fit these requirements is needed, such as for linking with external libraries, the <code>@&quot;&quot;</code> syntax may be used.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">identifiers.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> @&quot;identifier with spaces in it&quot; = <span class="tok-number">0xff</span>;
<span class="tok-kw">const</span> @&quot;1SmallStep4Man&quot; = <span class="tok-number">112358</span>;

<span class="tok-kw">const</span> c = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).c;
<span class="tok-kw">pub</span> <span class="tok-kw">extern</span> <span class="tok-str">&quot;c&quot;</span> <span class="tok-kw">fn</span> <span class="tok-fn">@&quot;error&quot;</span>() <span class="tok-type">void</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">extern</span> <span class="tok-str">&quot;c&quot;</span> <span class="tok-kw">fn</span> <span class="tok-fn">@&quot;fstat$INODE64&quot;</span>(fd: c.fd_t, buf: *c.Stat) <span class="tok-type">c_int</span>;

<span class="tok-kw">const</span> Color = <span class="tok-kw">enum</span> {
    red,
    @&quot;really red&quot;,
};
<span class="tok-kw">const</span> color: Color = .@&quot;really red&quot;;</code></pre></figure>

      

      <h3 id="Container-Level-Variables"><a href="#toc-Container-Level-Variables">Container Level Variables</a> <a class="hdr" href="#Container-Level-Variables">§</a></h3>

      <p>
      <a href="#Containers">Container</a> level variables have static lifetime and are order-independent and lazily analyzed.
      The initialization value of container level variables is implicitly
      <a href="#comptime">comptime</a>. If a container level variable is <code><span class="tok-kw">const</span></code> then its value is
      <code><span class="tok-kw">comptime</span></code>-known, otherwise it is runtime-known.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_container_level_variables.zig</cite></figcaption><pre><code><span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = add(<span class="tok-number">10</span>, x);
<span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = add(<span class="tok-number">12</span>, <span class="tok-number">34</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;container level variables&quot;</span> {
    <span class="tok-kw">try</span> expect(x == <span class="tok-number">46</span>);
    <span class="tok-kw">try</span> expect(y == <span class="tok-number">56</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a + b;
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_container_level_variables.zig</kbd>
1/1 test_container_level_variables.test.container level variables...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Container level variables may be declared inside a <a href="#struct">struct</a>, <a href="#union">union</a>, <a href="#enum">enum</a>, or <a href="#opaque">opaque</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_namespaced_container_level_variable.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;namespaced container level variable&quot;</span> {
    <span class="tok-kw">try</span> expect(foo() == <span class="tok-number">1235</span>);
    <span class="tok-kw">try</span> expect(foo() == <span class="tok-number">1236</span>);
}

<span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
};

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    S.x += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> S.x;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_namespaced_container_level_variable.zig</kbd>
1/1 test_namespaced_container_level_variable.test.namespaced container level variable...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Static-Local-Variables"><a href="#toc-Static-Local-Variables">Static Local Variables</a> <a class="hdr" href="#Static-Local-Variables">§</a></h3>

      <p>
        It is also possible to have local variables with static lifetime by using containers inside functions.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_static_local_variable.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;static local variable&quot;</span> {
    <span class="tok-kw">try</span> expect(foo() == <span class="tok-number">1235</span>);
    <span class="tok-kw">try</span> expect(foo() == <span class="tok-number">1236</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    };
    S.x += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> S.x;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_static_local_variable.zig</kbd>
1/1 test_static_local_variable.test.static local variable...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Thread-Local-Variables"><a href="#toc-Thread-Local-Variables">Thread Local Variables</a> <a class="hdr" href="#Thread-Local-Variables">§</a></h3>

      <p>A variable may be specified to be a thread-local variable using the
      <code><span class="tok-kw">threadlocal</span></code> keyword,
      which makes each thread work with a separate instance of the variable:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_thread_local_variables.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">threadlocal</span> <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;thread local storage&quot;</span> {
    <span class="tok-kw">const</span> thread1 = <span class="tok-kw">try</span> std.Thread.spawn(.{}, testTls, .{});
    <span class="tok-kw">const</span> thread2 = <span class="tok-kw">try</span> std.Thread.spawn(.{}, testTls, .{});
    testTls();
    thread1.join();
    thread2.join();
}

<span class="tok-kw">fn</span> <span class="tok-fn">testTls</span>() <span class="tok-type">void</span> {
    assert(x == <span class="tok-number">1234</span>);
    x += <span class="tok-number">1</span>;
    assert(x == <span class="tok-number">1235</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_thread_local_variables.zig</kbd>
1/1 test_thread_local_variables.test.thread local storage...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      For <a href="#Single-Threaded-Builds">Single Threaded Builds</a>, all thread local variables are treated as regular <a href="#Container-Level-Variables">Container Level Variables</a>.
      </p>
      <p>
      Thread local variables may not be <code><span class="tok-kw">const</span></code>.
      </p>
      

      <h3 id="Local-Variables"><a href="#toc-Local-Variables">Local Variables</a> <a class="hdr" href="#Local-Variables">§</a></h3>

      <p>
      Local variables occur inside <a href="#Functions">Functions</a>, <a href="#comptime">comptime</a> blocks, and <a href="#cImport">@cImport</a> blocks.
      </p>
      <p>
      When a local variable is <code><span class="tok-kw">const</span></code>, it means that after initialization, the variable's
      value will not change. If the initialization value of a <code><span class="tok-kw">const</span></code> variable is
      <a href="#comptime">comptime</a>-known, then the variable is also <code><span class="tok-kw">comptime</span></code>-known.
      </p>
      <p>
      A local variable may be qualified with the <code><span class="tok-kw">comptime</span></code> keyword. This causes
      the variable's value to be <code><span class="tok-kw">comptime</span></code>-known, and all loads and stores of the
      variable to happen during semantic analysis of the program, rather than at runtime.
      All variables declared in a <code><span class="tok-kw">comptime</span></code> expression are implicitly
      <code><span class="tok-kw">comptime</span></code> variables.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_variables.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;comptime vars&quot;</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;

    x += <span class="tok-number">1</span>;
    y += <span class="tok-number">1</span>;

    <span class="tok-kw">try</span> expect(x == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(y == <span class="tok-number">2</span>);

    <span class="tok-kw">if</span> (y != <span class="tok-number">2</span>) {
        <span class="tok-comment">// This compile error never triggers because y is a comptime variable,</span>
        <span class="tok-comment">// and so `y != 2` is a comptime value, and this if is statically evaluated.</span>
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;wrong y value&quot;</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_variables.zig</kbd>
1/1 test_comptime_variables.test.comptime vars...OK
All 1 tests passed.
</samp></pre></figure>

      
      

      <h2 id="Integers"><a href="#toc-Integers">Integers</a> <a class="hdr" href="#Integers">§</a></h2>

      <h3 id="Integer-Literals"><a href="#toc-Integer-Literals">Integer Literals</a> <a class="hdr" href="#Integer-Literals">§</a></h3>

      <figure><figcaption class="zig-cap"><cite class="file">integer_literals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> decimal_int = <span class="tok-number">98222</span>;
<span class="tok-kw">const</span> hex_int = <span class="tok-number">0xff</span>;
<span class="tok-kw">const</span> another_hex_int = <span class="tok-number">0xFF</span>;
<span class="tok-kw">const</span> octal_int = <span class="tok-number">0o755</span>;
<span class="tok-kw">const</span> binary_int = <span class="tok-number">0b11110000</span>;

<span class="tok-comment">// underscores may be placed between two digits as a visual separator</span>
<span class="tok-kw">const</span> one_billion = <span class="tok-number">1_000_000_000</span>;
<span class="tok-kw">const</span> binary_mask = <span class="tok-number">0b1_1111_1111</span>;
<span class="tok-kw">const</span> permissions = <span class="tok-number">0o7_5_5</span>;
<span class="tok-kw">const</span> big_address = <span class="tok-number">0xFF80_0000_0000_0000</span>;</code></pre></figure>

      
      <h3 id="Runtime-Integer-Values"><a href="#toc-Runtime-Integer-Values">Runtime Integer Values</a> <a class="hdr" href="#Runtime-Integer-Values">§</a></h3>

      <p>
      Integer literals have no size limitation, and if any Illegal Behavior occurs,
      the compiler catches it.
      </p>
      <p>
      However, once an integer value is no longer known at compile-time, it must have a
      known size, and is vulnerable to safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_vs_comptime.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">divide</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a / b;
}</code></pre></figure>

      <p>
      In this function, values <code>a</code> and <code>b</code> are known only at runtime,
      and thus this division operation is vulnerable to both <a href="#Integer-Overflow">Integer Overflow</a> and
      <a href="#Division-by-Zero">Division by Zero</a>.
      </p>
      <p>
      Operators such as <code>+</code> and <code>-</code> cause <a href="#Illegal-Behavior">Illegal Behavior</a> on
      integer overflow. Alternative operators are provided for wrapping and saturating arithmetic on all targets.
      <code>+%</code> and <code>-%</code> perform wrapping arithmetic
      while <code>+|</code> and <code>-|</code> perform saturating arithmetic.
      </p>
      <p>
      Zig supports arbitrary bit-width integers, referenced by using
      an identifier of <code>i</code> or <code>u</code> followed by digits. For example, the identifier
      <code><span class="tok-type">i7</span></code> refers to a signed 7-bit integer. The maximum allowed bit-width of an
      integer type is <code><span class="tok-number">65535</span></code>. For signed integer types, Zig uses a
      <a href="https://en.wikipedia.org/wiki/Two's_complement">two's complement</a> representation.
      </p>
      <p>See also:</p><ul>
<li><a href="#Wrapping-Operations">Wrapping Operations</a></li>
</ul>

      
      
      <h2 id="Floats"><a href="#toc-Floats">Floats</a> <a class="hdr" href="#Floats">§</a></h2>

      <p>Zig has the following floating point types:</p>
      <ul>
          <li><code><span class="tok-type">f16</span></code> - IEEE-754-2008 binary16</li>
          <li><code><span class="tok-type">f32</span></code> - IEEE-754-2008 binary32</li>
          <li><code><span class="tok-type">f64</span></code> - IEEE-754-2008 binary64</li>
          <li><code><span class="tok-type">f80</span></code> - IEEE-754-2008 80-bit extended precision</li>
          <li><code><span class="tok-type">f128</span></code> - IEEE-754-2008 binary128</li>
          <li><code><span class="tok-type">c_longdouble</span></code> - matches <code class="c">long double</code> for the target C ABI</li>
      </ul>
      <h3 id="Float-Literals"><a href="#toc-Float-Literals">Float Literals</a> <a class="hdr" href="#Float-Literals">§</a></h3>

      <p>
      Float literals have type <code><span class="tok-type">comptime_float</span></code> which is guaranteed to have
      the same precision and operations of the largest other floating point type, which is
      <code><span class="tok-type">f128</span></code>.
      </p>
      <p>
      Float literals <a href="#Type-Coercion">coerce</a> to any floating point type,
      and to any <a href="#Integers">integer</a> type when there is no fractional component.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">float_literals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> floating_point = <span class="tok-number">123.0E+77</span>;
<span class="tok-kw">const</span> another_float = <span class="tok-number">123.0</span>;
<span class="tok-kw">const</span> yet_another = <span class="tok-number">123.0e+77</span>;

<span class="tok-kw">const</span> hex_floating_point = <span class="tok-number">0x103.70p-5</span>;
<span class="tok-kw">const</span> another_hex_float = <span class="tok-number">0x103.70</span>;
<span class="tok-kw">const</span> yet_another_hex_float = <span class="tok-number">0x103.70P-5</span>;

<span class="tok-comment">// underscores may be placed between two digits as a visual separator</span>
<span class="tok-kw">const</span> lightspeed = <span class="tok-number">299_792_458.000_000</span>;
<span class="tok-kw">const</span> nanosecond = <span class="tok-number">0.000_000_001</span>;
<span class="tok-kw">const</span> more_hex = <span class="tok-number">0x1234_5678.9ABC_CDEFp-10</span>;</code></pre></figure>

      <p>
      There is no syntax for NaN, infinity, or negative infinity. For these special values,
      one must use the standard library:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">float_special_values.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> inf = std.math.inf(<span class="tok-type">f32</span>);
<span class="tok-kw">const</span> negative_inf = -std.math.inf(<span class="tok-type">f64</span>);
<span class="tok-kw">const</span> nan = std.math.nan(<span class="tok-type">f128</span>);</code></pre></figure>

      
      <h3 id="Floating-Point-Operations"><a href="#toc-Floating-Point-Operations">Floating Point Operations</a> <a class="hdr" href="#Floating-Point-Operations">§</a></h3>

      <p>By default floating point operations use <code>Strict</code> mode,
          but you can switch to <code>Optimized</code> mode on a per-block basis:</p>
      <figure><figcaption class="zig-cap"><cite class="file">float_mode_obj.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> big = <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">1</span> &lt;&lt; <span class="tok-number">40</span>);

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_strict</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span> {
    <span class="tok-kw">return</span> x + big - big;
}

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_optimized</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span> {
    <span class="tok-builtin">@setFloatMode</span>(.optimized);
    <span class="tok-kw">return</span> x + big - big;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj float_mode_obj.zig -O ReleaseFast</kbd>
</samp></pre></figure>

      <p>For this test we have to separate code into two object files -
      otherwise the optimizer figures out all the values at compile-time,
      which operates in strict mode.</p>
      <figure><figcaption class="zig-cap"><cite class="file">float_mode_exe.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_strict</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span>;
<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_optimized</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x = <span class="tok-number">0.001</span>;
    print(<span class="tok-str">&quot;optimized = {}\n&quot;</span>, .{foo_optimized(x)});
    print(<span class="tok-str">&quot;strict = {}\n&quot;</span>, .{foo_strict(x)});
}</code></pre></figure>

      <p>See also:</p><ul>
<li><a href="#setFloatMode">@setFloatMode</a></li>
<li><a href="#Division-by-Zero">Division by Zero</a></li>
</ul>

      
      
      <h2 id="Operators"><a href="#toc-Operators">Operators</a> <a class="hdr" href="#Operators">§</a></h2>

      <p>
      There is no operator overloading. When you see an operator in Zig, you know that
      it is doing something from this table, and nothing else.
      </p>
      <h3 id="Table-of-Operators"><a href="#toc-Table-of-Operators">Table of Operators</a> <a class="hdr" href="#Table-of-Operators">§</a></h3>

      <div class="table-wrapper">
      <table>
        <thead>
        <tr>
          <th scope="col">Name</th>
          <th scope="col">Syntax</th>
          <th scope="col">Types</th>
          <th scope="col">Remarks</th>
          <th scope="col">Example</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td>Addition</td>
          <td><pre><code>a + b
a += b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#addWithOverflow">@addWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">2</span> + <span class="tok-number">5</span> == <span class="tok-number">7</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Wrapping Addition</td>
          <td><pre><code>a +% b
a +%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Twos-complement wrapping behavior.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#addWithOverflow">@addWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0xffffffff</span>) +% <span class="tok-number">1</span> == <span class="tok-number">0</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Saturating Addition</td>
          <td><pre><code>a +| b
a +|= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>) +| <span class="tok-number">1</span> == <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>)</code></pre>
          </td>
        </tr>
        <tr>
          <td>Subtraction</td>
          <td><pre><code>a - b
a -= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#subWithOverflow">@subWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">2</span> - <span class="tok-number">5</span> == -<span class="tok-number">3</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Wrapping Subtraction</td>
          <td><pre><code>a -% b
a -%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Twos-complement wrapping behavior.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#subWithOverflow">@subWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0</span>) -% <span class="tok-number">1</span> == <span class="tok-number">255</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Saturating Subtraction</td>
          <td><pre><code>a -| b
a -|= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>) -| <span class="tok-number">1</span> == <span class="tok-number">0</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Negation</td>
          <td><pre><code>-a</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
            </ul>
          </td>
          <td>
            <pre><code>-<span class="tok-number">1</span> == <span class="tok-number">0</span> - <span class="tok-number">1</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Wrapping Negation</td>
          <td><pre><code>-%a</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Twos-complement wrapping behavior.</li>
            </ul>
          </td>
          <td>
            <pre><code>-%<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">128</span>) == -<span class="tok-number">128</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Multiplication</td>
          <td><pre><code>a * b
a *= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#mulWithOverflow">@mulWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">2</span> * <span class="tok-number">5</span> == <span class="tok-number">10</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Wrapping Multiplication</td>
          <td><pre><code>a *% b
a *%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Twos-complement wrapping behavior.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#mulWithOverflow">@mulWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">200</span>) *% <span class="tok-number">2</span> == <span class="tok-number">144</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Saturating Multiplication</td>
          <td><pre><code>a *| b
a *|= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">200</span>) *| <span class="tok-number">2</span> == <span class="tok-number">255</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Division</td>
          <td><pre><code>a / b
a /= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for integers.</li>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for floats in <a href="#Floating-Point-Operations">FloatMode.Optimized Mode</a>.</li>
              <li>Signed integer operands must be comptime-known and positive. In other cases, use
                <a href="#divTrunc">@divTrunc</a>,
                <a href="#divFloor">@divFloor</a>, or
                <a href="#divExact">@divExact</a> instead.
              </li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">10</span> / <span class="tok-number">5</span> == <span class="tok-number">2</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Remainder Division</td>
          <td><pre><code>a % b
a %= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for integers.</li>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for floats in <a href="#Floating-Point-Operations">FloatMode.Optimized Mode</a>.</li>
              <li>Signed or floating-point operands must be comptime-known and positive. In other cases, use
                <a href="#rem">@rem</a> or
                <a href="#mod">@mod</a> instead.
              </li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">10</span> % <span class="tok-number">3</span> == <span class="tok-number">1</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Bit Shift Left</td>
          <td><pre><code>a &lt;&lt; b
a &lt;&lt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Moves all bits to the left, inserting new zeroes at the
              least-significant bit.</li>
              <li><code>b</code> must be
              <a href="#comptime">comptime-known</a> or have a type with log2 number
              of bits as <code>a</code>.</li>
              <li>See also <a href="#shlExact">@shlExact</a>.</li>
              <li>See also <a href="#shlWithOverflow">@shlWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">0b1</span> &lt;&lt; <span class="tok-number">8</span> == <span class="tok-number">0b100000000</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Saturating Bit Shift Left</td>
          <td><pre><code>a &lt;&lt;| b
a &lt;&lt;|= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>See also <a href="#shlExact">@shlExact</a>.</li>
              <li>See also <a href="#shlWithOverflow">@shlWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>) &lt;&lt;| <span class="tok-number">8</span> == <span class="tok-number">255</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Bit Shift Right</td>
          <td><pre><code>a &gt;&gt; b
a &gt;&gt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Moves all bits to the right, inserting zeroes at the most-significant bit.</li>
              <li><code>b</code> must be
                <a href="#comptime">comptime-known</a> or have a type with log2 number
                of bits as <code>a</code>.</li>
              <li>See also <a href="#shrExact">@shrExact</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">0b1010</span> &gt;&gt; <span class="tok-number">1</span> == <span class="tok-number">0b101</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Bitwise And</td>
          <td><pre><code>a &amp; b
a &amp;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">0b011</span> &amp; <span class="tok-number">0b101</span> == <span class="tok-number">0b001</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Bitwise Or</td>
          <td><pre><code>a | b
a |= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">0b010</span> | <span class="tok-number">0b100</span> == <span class="tok-number">0b110</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Bitwise Xor</td>
          <td><pre><code>a ^ b
a ^= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-number">0b011</span> ^ <span class="tok-number">0b101</span> == <span class="tok-number">0b110</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Bitwise Not</td>
          <td><pre><code>~a</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td></td>
          <td>
            <pre><code>~<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0b10101111</span>) == <span class="tok-number">0b01010000</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Defaulting Optional Unwrap</td>
          <td><pre><code>a <span class="tok-kw">orelse</span> b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Optionals">Optionals</a></li>
            </ul>
          </td>
          <td>If <code>a</code> is <code><span class="tok-null">null</span></code>,
          returns <code>b</code> ("default value"),
          otherwise returns the unwrapped value of <code>a</code>.
          Note that <code>b</code> may be a value of type <a href="#noreturn">noreturn</a>.
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
<span class="tok-kw">const</span> unwrapped = value <span class="tok-kw">orelse</span> <span class="tok-number">1234</span>;
unwrapped == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Optional Unwrap</td>
          <td><pre><code>a.?</code></pre></td>
          <td>
            <ul>
              <li><a href="#Optionals">Optionals</a></li>
            </ul>
          </td>
          <td>
            Equivalent to:
            <pre><code>a <span class="tok-kw">orelse</span> <span class="tok-kw">unreachable</span></code></pre>
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-number">5678</span>;
value.? == <span class="tok-number">5678</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Defaulting Error Unwrap</td>
          <td><pre><code>a <span class="tok-kw">catch</span> b
a <span class="tok-kw">catch</span> |err| b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Errors">Error Unions</a></li>
            </ul>
          </td>
          <td>If <code>a</code> is an <code><span class="tok-kw">error</span></code>,
          returns <code>b</code> ("default value"),
          otherwise returns the unwrapped value of <code>a</code>.
          Note that <code>b</code> may be a value of type <a href="#noreturn">noreturn</a>.
<code>err</code> is the <code><span class="tok-kw">error</span></code> and is in scope of the expression <code>b</code>.
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> value: <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> = <span class="tok-kw">error</span>.Broken;
<span class="tok-kw">const</span> unwrapped = value <span class="tok-kw">catch</span> <span class="tok-number">1234</span>;
unwrapped == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Logical And</td>
          <td><pre><code>a <span class="tok-kw">and</span> b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td>
          If <code>a</code> is <code><span class="tok-null">false</span></code>, returns <code><span class="tok-null">false</span></code>
          without evaluating <code>b</code>. Otherwise, returns <code>b</code>.
          </td>
          <td>
            <pre><code>(<span class="tok-null">false</span> <span class="tok-kw">and</span> <span class="tok-null">true</span>) == <span class="tok-null">false</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Logical Or</td>
          <td><pre><code>a <span class="tok-kw">or</span> b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td>
              If <code>a</code> is <code><span class="tok-null">true</span></code>,
              returns <code><span class="tok-null">true</span></code> without evaluating
              <code>b</code>. Otherwise, returns
              <code>b</code>.
          </td>
          <td>
            <pre><code>(<span class="tok-null">false</span> <span class="tok-kw">or</span> <span class="tok-null">true</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Boolean Not</td>
          <td><pre><code>!a</code></pre></td>
          <td>
            <ul>
              <li><a href="#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td></td>
          <td>
            <pre><code>!<span class="tok-null">false</span> == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Equality</td>
          <td><pre><code>a == b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
              <li><a href="#Primitive-Types">bool</a></li>
              <li><a href="#Primitive-Types">type</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">true</span></code> if a and b are equal, otherwise returns <code><span class="tok-null">false</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code>(<span class="tok-number">1</span> == <span class="tok-number">1</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Null Check</td>
          <td><pre><code>a == <span class="tok-null">null</span></code></pre></td>
          <td>
            <ul>
              <li><a href="#Optionals">Optionals</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">true</span></code> if a is <code><span class="tok-null">null</span></code>, otherwise returns <code><span class="tok-null">false</span></code>.
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
(value == <span class="tok-null">null</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Inequality</td>
          <td><pre><code>a != b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
              <li><a href="#Primitive-Types">bool</a></li>
              <li><a href="#Primitive-Types">type</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">false</span></code> if a and b are equal, otherwise returns <code><span class="tok-null">true</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code>(<span class="tok-number">1</span> != <span class="tok-number">1</span>) == <span class="tok-null">false</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Non-Null Check</td>
          <td><pre><code>a != <span class="tok-null">null</span></code></pre></td>
          <td>
            <ul>
              <li><a href="#Optionals">Optionals</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">false</span></code> if a is <code><span class="tok-null">null</span></code>, otherwise returns <code><span class="tok-null">true</span></code>.
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
(value != <span class="tok-null">null</span>) == <span class="tok-null">false</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Greater Than</td>
          <td><pre><code>a &gt; b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">true</span></code> if a is greater than b, otherwise returns <code><span class="tok-null">false</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code>(<span class="tok-number">2</span> &gt; <span class="tok-number">1</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Greater or Equal</td>
          <td><pre><code>a &gt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">true</span></code> if a is greater than or equal to b, otherwise returns <code><span class="tok-null">false</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code>(<span class="tok-number">2</span> &gt;= <span class="tok-number">1</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Less Than</td>
          <td><pre><code>a &lt; b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">true</span></code> if a is less than b, otherwise returns <code><span class="tok-null">false</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code>(<span class="tok-number">1</span> &lt; <span class="tok-number">2</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Lesser or Equal</td>
          <td><pre><code>a &lt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code><span class="tok-null">true</span></code> if a is less than or equal to b, otherwise returns <code><span class="tok-null">false</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code>(<span class="tok-number">1</span> &lt;= <span class="tok-number">2</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Array Concatenation</td>
          <td><pre><code>a ++ b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Arrays">Arrays</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Only available when the lengths of both <code>a</code> and <code>b</code> are <a href="#comptime">compile-time known</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;
<span class="tok-kw">const</span> array1 = [_]<span class="tok-type">u32</span>{<span class="tok-number">1</span>,<span class="tok-number">2</span>};
<span class="tok-kw">const</span> array2 = [_]<span class="tok-type">u32</span>{<span class="tok-number">3</span>,<span class="tok-number">4</span>};
<span class="tok-kw">const</span> together = array1 ++ array2;
mem.eql(<span class="tok-type">u32</span>, &amp;together, &amp;[_]<span class="tok-type">u32</span>{<span class="tok-number">1</span>,<span class="tok-number">2</span>,<span class="tok-number">3</span>,<span class="tok-number">4</span>})</code></pre>
          </td>
        </tr>
        <tr>
          <td>Array Multiplication</td>
          <td><pre><code>a ** b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Arrays">Arrays</a></li>
            </ul>
          </td>
          <td>
            <ul>
              <li>Only available when the length of <code>a</code> and <code>b</code> are <a href="#comptime">compile-time known</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;
<span class="tok-kw">const</span> pattern = <span class="tok-str">&quot;ab&quot;</span> ** <span class="tok-number">3</span>;
mem.eql(<span class="tok-type">u8</span>, pattern, <span class="tok-str">&quot;ababab&quot;</span>)</code></pre>
          </td>
        </tr>
        <tr>
          <td>Pointer Dereference</td>
          <td><pre><code>a.*</code></pre></td>
          <td>
            <ul>
              <li><a href="#Pointers">Pointers</a></li>
            </ul>
          </td>
          <td>
            Pointer dereference.
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> x: <span class="tok-type">u32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> ptr = &amp;x;
ptr.* == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Address Of</td>
          <td><pre><code>&amp;a</code></pre></td>
          <td>
            All types
          </td>
          <td>
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> x: <span class="tok-type">u32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> ptr = &amp;x;
ptr.* == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td>Error Set Merge</td>
          <td><pre><code>a || b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Error-Set-Type">Error Set Type</a></li>
            </ul>
          </td>
          <td>
              <a href="#Merging-Error-Sets">Merging Error Sets</a>
          </td>
          <td>
            <pre><code><span class="tok-kw">const</span> A = <span class="tok-kw">error</span>{One};
<span class="tok-kw">const</span> B = <span class="tok-kw">error</span>{Two};
(A || B) == <span class="tok-kw">error</span>{One, Two}</code></pre>
          </td>
        </tr>
        </tbody>
      </table>
      </div>
      
      <h3 id="Precedence"><a href="#toc-Precedence">Precedence</a> <a class="hdr" href="#Precedence">§</a></h3>

      <pre><code>x() x[] x.y x.* x.?
a!b
x{}
!x -x -%x ~x &amp;x ?x
* / % ** *% *| ||
+ - ++ +% -% +| -|
&lt;&lt; &gt;&gt; &lt;&lt;|
&amp; ^ | <span class="tok-kw">orelse</span> <span class="tok-kw">catch</span>
== != &lt; &gt; &lt;= &gt;=
<span class="tok-kw">and</span>
<span class="tok-kw">or</span>
= *= *%= *|= /= %= += +%= +|= -= -%= -|= &lt;&lt;= &lt;&lt;|= &gt;&gt;= &amp;= ^= |=</code></pre>
      
      
      <h2 id="Arrays"><a href="#toc-Arrays">Arrays</a> <a class="hdr" href="#Arrays">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_arrays.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;
<span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;

<span class="tok-comment">// array literal</span>
<span class="tok-kw">const</span> message = [_]<span class="tok-type">u8</span>{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'o'</span> };

<span class="tok-comment">// alternative initialization using result location</span>
<span class="tok-kw">const</span> alt_message: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = .{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'o'</span> };

<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, &amp;message, &amp;alt_message));
}

<span class="tok-comment">// get the size of an array</span>
<span class="tok-kw">comptime</span> {
    assert(message.len == <span class="tok-number">5</span>);
}

<span class="tok-comment">// A string literal is a single-item pointer to an array.</span>
<span class="tok-kw">const</span> same_message = <span class="tok-str">&quot;hello&quot;</span>;

<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, &amp;message, same_message));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;iterate over an array&quot;</span> {
    <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (message) |byte| {
        sum += byte;
    }
    <span class="tok-kw">try</span> expect(sum == <span class="tok-str">'h'</span> + <span class="tok-str">'e'</span> + <span class="tok-str">'l'</span> * <span class="tok-number">2</span> + <span class="tok-str">'o'</span>);
}

<span class="tok-comment">// modifiable array</span>
<span class="tok-kw">var</span> some_integers: [<span class="tok-number">100</span>]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;modify an array&quot;</span> {
    <span class="tok-kw">for</span> (&amp;some_integers, <span class="tok-number">0</span>..) |*item, i| {
        item.* = <span class="tok-builtin">@intCast</span>(i);
    }
    <span class="tok-kw">try</span> expect(some_integers[<span class="tok-number">10</span>] == <span class="tok-number">10</span>);
    <span class="tok-kw">try</span> expect(some_integers[<span class="tok-number">99</span>] == <span class="tok-number">99</span>);
}

<span class="tok-comment">// array concatenation works if the values are known</span>
<span class="tok-comment">// at compile time</span>
<span class="tok-kw">const</span> part_one = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
<span class="tok-kw">const</span> part_two = [_]<span class="tok-type">i32</span>{ <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> };
<span class="tok-kw">const</span> all_of_it = part_one ++ part_two;
<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">i32</span>, &amp;all_of_it, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> }));
}

<span class="tok-comment">// remember that string literals are arrays</span>
<span class="tok-kw">const</span> hello = <span class="tok-str">&quot;hello&quot;</span>;
<span class="tok-kw">const</span> world = <span class="tok-str">&quot;world&quot;</span>;
<span class="tok-kw">const</span> hello_world = hello ++ <span class="tok-str">&quot; &quot;</span> ++ world;
<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, hello_world, <span class="tok-str">&quot;hello world&quot;</span>));
}

<span class="tok-comment">// ** does repeating patterns</span>
<span class="tok-kw">const</span> pattern = <span class="tok-str">&quot;ab&quot;</span> ** <span class="tok-number">3</span>;
<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, pattern, <span class="tok-str">&quot;ababab&quot;</span>));
}

<span class="tok-comment">// initialize an array to zero</span>
<span class="tok-kw">const</span> all_zero = [_]<span class="tok-type">u16</span>{<span class="tok-number">0</span>} ** <span class="tok-number">10</span>;

<span class="tok-kw">comptime</span> {
    assert(all_zero.len == <span class="tok-number">10</span>);
    assert(all_zero[<span class="tok-number">5</span>] == <span class="tok-number">0</span>);
}

<span class="tok-comment">// use compile-time code to initialize an array</span>
<span class="tok-kw">var</span> fancy_array = init: {
    <span class="tok-kw">var</span> initial_value: [<span class="tok-number">10</span>]Point = <span class="tok-null">undefined</span>;
    <span class="tok-kw">for</span> (&amp;initial_value, <span class="tok-number">0</span>..) |*pt, i| {
        pt.* = Point{
            .x = <span class="tok-builtin">@intCast</span>(i),
            .y = <span class="tok-builtin">@intCast</span>(i * <span class="tok-number">2</span>),
        };
    }
    <span class="tok-kw">break</span> :init initial_value;
};
<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">i32</span>,
    y: <span class="tok-type">i32</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;compile-time array initialization&quot;</span> {
    <span class="tok-kw">try</span> expect(fancy_array[<span class="tok-number">4</span>].x == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(fancy_array[<span class="tok-number">4</span>].y == <span class="tok-number">8</span>);
}

<span class="tok-comment">// call a function to initialize an array</span>
<span class="tok-kw">var</span> more_points = [_]Point{makePoint(<span class="tok-number">3</span>)} ** <span class="tok-number">10</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">makePoint</span>(x: <span class="tok-type">i32</span>) Point {
    <span class="tok-kw">return</span> Point{
        .x = x,
        .y = x * <span class="tok-number">2</span>,
    };
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;array initialization with function calls&quot;</span> {
    <span class="tok-kw">try</span> expect(more_points[<span class="tok-number">4</span>].x == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> expect(more_points[<span class="tok-number">4</span>].y == <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> expect(more_points.len == <span class="tok-number">10</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_arrays.zig</kbd>
1/4 test_arrays.test.iterate over an array...OK
2/4 test_arrays.test.modify an array...OK
3/4 test_arrays.test.compile-time array initialization...OK
4/4 test_arrays.test.array initialization with function calls...OK
All 4 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#for">for</a></li>
<li><a href="#Slices">Slices</a></li>
</ul>


      <h3 id="Multidimensional-Arrays"><a href="#toc-Multidimensional-Arrays">Multidimensional Arrays</a> <a class="hdr" href="#Multidimensional-Arrays">§</a></h3>

      <p>
      Multidimensional arrays can be created by nesting arrays:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_multidimensional_arrays.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> mat4x4 = [<span class="tok-number">4</span>][<span class="tok-number">4</span>]<span class="tok-type">f32</span>{
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span> },
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span> },
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span> },
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span> },
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;multidimensional arrays&quot;</span> {
    <span class="tok-comment">// Access the 2D array by indexing the outer array, and then the inner array.</span>
    <span class="tok-kw">try</span> expect(mat4x4[<span class="tok-number">1</span>][<span class="tok-number">1</span>] == <span class="tok-number">1.0</span>);

    <span class="tok-comment">// Here we iterate with for loops.</span>
    <span class="tok-kw">for</span> (mat4x4, <span class="tok-number">0</span>..) |row, row_index| {
        <span class="tok-kw">for</span> (row, <span class="tok-number">0</span>..) |cell, column_index| {
            <span class="tok-kw">if</span> (row_index == column_index) {
                <span class="tok-kw">try</span> expect(cell == <span class="tok-number">1.0</span>);
            }
        }
    }

    <span class="tok-comment">// initialize a multidimensional array to zeros</span>
    <span class="tok-kw">const</span> all_zero: [<span class="tok-number">4</span>][<span class="tok-number">4</span>]<span class="tok-type">f32</span> = .{.{<span class="tok-number">0</span>} ** <span class="tok-number">4</span>} ** <span class="tok-number">4</span>;
    <span class="tok-kw">try</span> expect(all_zero[<span class="tok-number">0</span>][<span class="tok-number">0</span>] == <span class="tok-number">0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_multidimensional_arrays.zig</kbd>
1/1 test_multidimensional_arrays.test.multidimensional arrays...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Sentinel-Terminated-Arrays"><a href="#toc-Sentinel-Terminated-Arrays">Sentinel-Terminated Arrays</a> <a class="hdr" href="#Sentinel-Terminated-Arrays">§</a></h3>

      <p>
      The syntax <code>[N:x]T</code> describes an array which has a sentinel element of value <code>x</code> at the
      index corresponding to the length <code>N</code>.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_null_terminated_array.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;0-terminated sentinel array&quot;</span> {
    <span class="tok-kw">const</span> array = [_:<span class="tok-number">0</span>]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(array) == [<span class="tok-number">4</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> expect(array.len == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">4</span>] == <span class="tok-number">0</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;extra 0s in 0-terminated sentinel array&quot;</span> {
    <span class="tok-comment">// The sentinel value may appear earlier, but does not influence the compile-time 'len'.</span>
    <span class="tok-kw">const</span> array = [_:<span class="tok-number">0</span>]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">4</span> };

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(array) == [<span class="tok-number">4</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> expect(array.len == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">4</span>] == <span class="tok-number">0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_null_terminated_array.zig</kbd>
1/2 test_null_terminated_array.test.0-terminated sentinel array...OK
2/2 test_null_terminated_array.test.extra 0s in 0-terminated sentinel array...OK
All 2 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a></li>
<li><a href="#Sentinel-Terminated-Slices">Sentinel-Terminated Slices</a></li>
</ul>

      

      <h3 id="Destructuring-Arrays"><a href="#toc-Destructuring-Arrays">Destructuring Arrays</a> <a class="hdr" href="#Destructuring-Arrays">§</a></h3>

      <p>
        Arrays can be destructured:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_arrays.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">fn</span> <span class="tok-fn">swizzleRgbaToBgra</span>(rgba: [<span class="tok-number">4</span>]<span class="tok-type">u8</span>) [<span class="tok-number">4</span>]<span class="tok-type">u8</span> {
    <span class="tok-comment">// readable swizzling by destructuring</span>
    <span class="tok-kw">const</span> r, <span class="tok-kw">const</span> g, <span class="tok-kw">const</span> b, <span class="tok-kw">const</span> a = rgba;
    <span class="tok-kw">return</span> .{ b, g, r, a };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> pos = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span> };
    <span class="tok-kw">const</span> x, <span class="tok-kw">const</span> y = pos;
    print(<span class="tok-str">&quot;x = {}, y = {}\n&quot;</span>, .{x, y});

    <span class="tok-kw">const</span> orange: [<span class="tok-number">4</span>]<span class="tok-type">u8</span> = .{ <span class="tok-number">255</span>, <span class="tok-number">165</span>, <span class="tok-number">0</span>, <span class="tok-number">255</span> };
    print(<span class="tok-str">&quot;{any}\n&quot;</span>, .{swizzleRgbaToBgra(orange)});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_arrays.zig</kbd>
$ <kbd>./destructuring_arrays</kbd>
x = 1, y = 2
{ 0, 165, 255, 255 }
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#Destructuring">Destructuring</a></li>
<li><a href="#Destructuring-Tuples">Destructuring Tuples</a></li>
<li><a href="#Destructuring-Vectors">Destructuring Vectors</a></li>
</ul>

      
      

      <h2 id="Vectors"><a href="#toc-Vectors">Vectors</a> <a class="hdr" href="#Vectors">§</a></h2>

      <p>
      A vector is a group of booleans, <a href="#Integers">Integers</a>, <a href="#Floats">Floats</a>, or
      <a href="#Pointers">Pointers</a> which are operated on in parallel, using SIMD instructions if possible.
      Vector types are created with the builtin function <a href="#Vector">@Vector</a>.
      </p>
      <p>
      Vectors support the same builtin operators as their underlying base types.
      These operations are performed element-wise, and return a vector of the same length
      as the input vectors. This includes:
      </p>
      <ul>
          <li>Arithmetic (<code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>,
                         <code><span class="tok-builtin">@divFloor</span></code>, <code><span class="tok-builtin">@sqrt</span></code>, <code><span class="tok-builtin">@ceil</span></code>,
                         <code><span class="tok-builtin">@log</span></code>, etc.)</li>
          <li>Bitwise operators (<code>&gt;&gt;</code>, <code>&lt;&lt;</code>, <code>&amp;</code>,
                                 <code>|</code>, <code>~</code>, etc.)</li>
          <li>Comparison operators (<code>&lt;</code>, <code>&gt;</code>, <code>==</code>, etc.)</li>
      </ul>
      <p>
      It is prohibited to use a math operator on a mixture of scalars (individual numbers)
      and vectors. Zig provides the <a href="#splat">@splat</a> builtin to easily convert from scalars
      to vectors, and it supports <a href="#reduce">@reduce</a> and array indexing syntax to convert
      from vectors to scalars. Vectors also support assignment to and from fixed-length
      arrays with comptime-known length.
      </p>
      <p>
      For rearranging elements within and between vectors, Zig provides the <a href="#shuffle">@shuffle</a> and <a href="#select">@select</a> functions.
      </p>
      <p>
      Operations on vectors shorter than the target machine's native SIMD size will typically compile to single SIMD
      instructions, while vectors longer than the target machine's native SIMD size will compile to multiple SIMD
      instructions. If a given operation doesn't have SIMD support on the target architecture, the compiler will default
      to operating on each vector element one at a time. Zig supports any comptime-known vector length up to 2^32-1,
      although small powers of two (2-64) are most typical. Note that excessively long vector lengths (e.g. 2^20) may
      result in compiler crashes on current versions of Zig.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_vector.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expectEqual = std.testing.expectEqual;

<span class="tok-kw">test</span> <span class="tok-str">&quot;Basic vector usage&quot;</span> {
    <span class="tok-comment">// Vectors have a compile-time known length and base type.</span>
    <span class="tok-kw">const</span> a = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> b = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>){ <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> };

    <span class="tok-comment">// Math operations take place element-wise.</span>
    <span class="tok-kw">const</span> c = a + b;

    <span class="tok-comment">// Individual vector elements can be accessed using array indexing syntax.</span>
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">6</span>, c[<span class="tok-number">0</span>]);
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">8</span>, c[<span class="tok-number">1</span>]);
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">10</span>, c[<span class="tok-number">2</span>]);
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">12</span>, c[<span class="tok-number">3</span>]);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;Conversion between vectors, arrays, and slices&quot;</span> {
    <span class="tok-comment">// Vectors and fixed-length arrays can be automatically assigned back and forth</span>
    <span class="tok-kw">const</span> arr1: [<span class="tok-number">4</span>]<span class="tok-type">f32</span> = [_]<span class="tok-type">f32</span>{ <span class="tok-number">1.1</span>, <span class="tok-number">3.2</span>, <span class="tok-number">4.5</span>, <span class="tok-number">5.6</span> };
    <span class="tok-kw">const</span> vec: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) = arr1;
    <span class="tok-kw">const</span> arr2: [<span class="tok-number">4</span>]<span class="tok-type">f32</span> = vec;
    <span class="tok-kw">try</span> expectEqual(arr1, arr2);

    <span class="tok-comment">// You can also assign from a slice with comptime-known length to a vector using .*</span>
    <span class="tok-kw">const</span> vec2: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">f32</span>) = arr1[<span class="tok-number">1</span>..<span class="tok-number">3</span>].*;

    <span class="tok-kw">const</span> slice: []<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;arr1;
    <span class="tok-kw">var</span> offset: <span class="tok-type">u32</span> = <span class="tok-number">1</span>; <span class="tok-comment">// var to make it runtime-known</span>
    _ = &amp;offset; <span class="tok-comment">// suppress 'var is never mutated' error</span>
    <span class="tok-comment">// To extract a comptime-known length from a runtime-known offset,</span>
    <span class="tok-comment">// first extract a new slice from the starting offset, then an array of</span>
    <span class="tok-comment">// comptime-known length</span>
    <span class="tok-kw">const</span> vec3: <span class="tok-builtin">@Vector</span>(<span class="tok-number">2</span>, <span class="tok-type">f32</span>) = slice[offset..][<span class="tok-number">0</span>..<span class="tok-number">2</span>].*;
    <span class="tok-kw">try</span> expectEqual(slice[offset], vec2[<span class="tok-number">0</span>]);
    <span class="tok-kw">try</span> expectEqual(slice[offset + <span class="tok-number">1</span>], vec2[<span class="tok-number">1</span>]);
    <span class="tok-kw">try</span> expectEqual(vec2, vec3);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_vector.zig</kbd>
1/2 test_vector.test.Basic vector usage...OK
2/2 test_vector.test.Conversion between vectors, arrays, and slices...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
      TODO talk about C ABI interop<br>
      TODO consider suggesting std.MultiArrayList
      </p>
      <p>See also:</p><ul>
<li><a href="#splat">@splat</a></li>
<li><a href="#shuffle">@shuffle</a></li>
<li><a href="#select">@select</a></li>
<li><a href="#reduce">@reduce</a></li>
</ul>


      <h3 id="Destructuring-Vectors"><a href="#toc-Destructuring-Vectors">Destructuring Vectors</a> <a class="hdr" href="#Destructuring-Vectors">§</a></h3>

      <p>
        Vectors can be destructured:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_vectors.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-comment">// emulate punpckldq</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unpack</span>(x: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>), y: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>)) <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) {
    <span class="tok-kw">const</span> a, <span class="tok-kw">const</span> c, _, _ = x;
    <span class="tok-kw">const</span> b, <span class="tok-kw">const</span> d, _, _ = y;
    <span class="tok-kw">return</span> .{ a, b, c, d };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) = .{ <span class="tok-number">1.0</span>, <span class="tok-number">2.0</span>, <span class="tok-number">3.0</span>, <span class="tok-number">4.0</span> };
    <span class="tok-kw">const</span> y: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">f32</span>) = .{ <span class="tok-number">5.0</span>, <span class="tok-number">6.0</span>, <span class="tok-number">7.0</span>, <span class="tok-number">8.0</span> };
    print(<span class="tok-str">&quot;{}&quot;</span>, .{unpack(x, y)});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_vectors.zig</kbd>
$ <kbd>./destructuring_vectors</kbd>
{ 1e0, 5e0, 2e0, 6e0 }
</samp></pre></figure>
      <p>See also:</p><ul>
<li><a href="#Destructuring">Destructuring</a></li>
<li><a href="#Destructuring-Tuples">Destructuring Tuples</a></li>
<li><a href="#Destructuring-Arrays">Destructuring Arrays</a></li>
</ul>

      

      

      <h2 id="Pointers"><a href="#toc-Pointers">Pointers</a> <a class="hdr" href="#Pointers">§</a></h2>

      <p>
      Zig has two kinds of pointers: single-item and many-item.
      </p>
      <ul>
          <li><code>*T</code> - single-item pointer to exactly one item.
            <ul>
              <li>Supports deref syntax: <code>ptr.*</code></li>
              <li>Supports slice syntax: <code>ptr[<span class="tok-number">0</span>..<span class="tok-number">1</span>]</code></li>
              <li>Supports pointer subtraction: <code>ptr - ptr</code></li>
            </ul>
          </li>
          <li><code>[*]T</code> - many-item pointer to unknown number of items.
            <ul>
              <li>Supports index syntax: <code>ptr[i]</code></li>
              <li>Supports slice syntax: <code>ptr[start..end]</code> and <code>ptr[start..]</code></li>
              <li>Supports pointer-integer arithmetic: <code>ptr + int</code>, <code>ptr - int</code></li>
              <li>Supports pointer subtraction: <code>ptr - ptr</code></li>
            </ul>
            <code>T</code> must have a known size, which means that it cannot be
            <code><span class="tok-type">anyopaque</span></code> or any other <a href="#opaque">opaque type</a>.
          </li>
      </ul>
      <p>These types are closely related to <a href="#Arrays">Arrays</a> and <a href="#Slices">Slices</a>:</p>
        <ul>
            <li><code>*[N]T</code> - pointer to N items, same as single-item pointer to an array.
            <ul>
                <li>Supports index syntax: <code>array_ptr[i]</code></li>
                <li>Supports slice syntax: <code>array_ptr[start..end]</code></li>
                <li>Supports len property: <code>array_ptr.len</code></li>
                <li>Supports pointer subtraction: <code>array_ptr - array_ptr</code></li>
            </ul>
            </li>
        </ul>
        <ul>
            <li><code>[]T</code> - is a slice (a fat pointer, which contains a pointer of type <code>[*]T</code> and a length).
            <ul>
                <li>Supports index syntax: <code>slice[i]</code></li>
                <li>Supports slice syntax: <code>slice[start..end]</code></li>
                <li>Supports len property: <code>slice.len</code></li>
            </ul>
            </li>
        </ul>
        <p>Use <code>&amp;x</code> to obtain a single-item pointer:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_single_item_pointer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;address of syntax&quot;</span> {
    <span class="tok-comment">// Get the address of a variable:</span>
    <span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> x_ptr = &amp;x;

    <span class="tok-comment">// Dereference a pointer:</span>
    <span class="tok-kw">try</span> expect(x_ptr.* == <span class="tok-number">1234</span>);

    <span class="tok-comment">// When you get the address of a const variable, you get a const single-item pointer.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(x_ptr) == *<span class="tok-kw">const</span> <span class="tok-type">i32</span>);

    <span class="tok-comment">// If you want to mutate the value, you'd need an address of a mutable variable:</span>
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">5678</span>;
    <span class="tok-kw">const</span> y_ptr = &amp;y;
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(y_ptr) == *<span class="tok-type">i32</span>);
    y_ptr.* += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(y_ptr.* == <span class="tok-number">5679</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer array access&quot;</span> {
    <span class="tok-comment">// Taking an address of an individual element gives a</span>
    <span class="tok-comment">// single-item pointer. This kind of pointer</span>
    <span class="tok-comment">// does not support pointer arithmetic.</span>
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span> };
    <span class="tok-kw">const</span> ptr = &amp;array[<span class="tok-number">2</span>];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(ptr) == *<span class="tok-type">u8</span>);

    <span class="tok-kw">try</span> expect(array[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);
    ptr.* += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">2</span>] == <span class="tok-number">4</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;slice syntax&quot;</span> {
    <span class="tok-comment">// Get a pointer to a variable:</span>
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> x_ptr = &amp;x;

    <span class="tok-comment">// Convert to array pointer using slice syntax:</span>
    <span class="tok-kw">const</span> x_array_ptr = x_ptr[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(x_array_ptr) == *[<span class="tok-number">1</span>]<span class="tok-type">i32</span>);

    <span class="tok-comment">// Coerce to many-item pointer:</span>
    <span class="tok-kw">const</span> x_many_ptr: [*]<span class="tok-type">i32</span> = x_array_ptr;
    <span class="tok-kw">try</span> expect(x_many_ptr[<span class="tok-number">0</span>] == <span class="tok-number">1234</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_single_item_pointer.zig</kbd>
1/3 test_single_item_pointer.test.address of syntax...OK
2/3 test_single_item_pointer.test.pointer array access...OK
3/3 test_single_item_pointer.test.slice syntax...OK
All 3 tests passed.
</samp></pre></figure>

      <p>
       Zig supports pointer arithmetic. It's better to assign the pointer to <code>[*]T</code> and increment that variable. For example, directly incrementing the pointer from a slice will corrupt it.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_pointer_arithmetic.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer arithmetic with many-item pointer&quot;</span> {
    <span class="tok-kw">const</span> array = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">var</span> ptr: [*]<span class="tok-kw">const</span> <span class="tok-type">i32</span> = &amp;array;

    <span class="tok-kw">try</span> expect(ptr[<span class="tok-number">0</span>] == <span class="tok-number">1</span>);
    ptr += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(ptr[<span class="tok-number">0</span>] == <span class="tok-number">2</span>);

    <span class="tok-comment">// slicing a many-item pointer without an end is equivalent to</span>
    <span class="tok-comment">// pointer arithmetic: `ptr[start..] == ptr + start`</span>
    <span class="tok-kw">try</span> expect(ptr[<span class="tok-number">1</span>..] == ptr + <span class="tok-number">1</span>);

    <span class="tok-comment">// subtraction between any two pointers except slices based on element size is supported</span>
    <span class="tok-kw">try</span> expect(&amp;ptr[<span class="tok-number">1</span>] - &amp;ptr[<span class="tok-number">0</span>] == <span class="tok-number">1</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer arithmetic with slices&quot;</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">var</span> length: <span class="tok-type">usize</span> = <span class="tok-number">0</span>; <span class="tok-comment">// var to make it runtime-known</span>
    _ = &amp;length; <span class="tok-comment">// suppress 'var is never mutated' error</span>
    <span class="tok-kw">var</span> slice = array[length..array.len];

    <span class="tok-kw">try</span> expect(slice[<span class="tok-number">0</span>] == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">4</span>);

    slice.ptr += <span class="tok-number">1</span>;
    <span class="tok-comment">// now the slice is in an bad state since len has not been updated</span>

    <span class="tok-kw">try</span> expect(slice[<span class="tok-number">0</span>] == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">4</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pointer_arithmetic.zig</kbd>
1/2 test_pointer_arithmetic.test.pointer arithmetic with many-item pointer...OK
2/2 test_pointer_arithmetic.test.pointer arithmetic with slices...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
        In Zig, we generally prefer <a href="#Slices">Slices</a> rather than <a href="#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a>.
        You can turn an array or pointer into a slice using slice syntax.
      </p>
      <p>
        Slices have bounds checking and are therefore protected
        against this kind of Illegal Behavior. This is one reason
        we prefer slices to pointers.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_slice_bounds.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer slicing&quot;</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span> };
    <span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">2</span>; <span class="tok-comment">// var to make it runtime-known</span>
    _ = &amp;start; <span class="tok-comment">// suppress 'var is never mutated' error</span>
    <span class="tok-kw">const</span> slice = array[start..<span class="tok-number">4</span>];
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">2</span>);

    <span class="tok-kw">try</span> expect(array[<span class="tok-number">3</span>] == <span class="tok-number">4</span>);
    slice[<span class="tok-number">1</span>] += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">3</span>] == <span class="tok-number">5</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_slice_bounds.zig</kbd>
1/1 test_slice_bounds.test.pointer slicing...OK
All 1 tests passed.
</samp></pre></figure>

      <p>Pointers work at compile-time too, as long as the code does not depend on
      an undefined memory layout:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_pointers.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;comptime pointers&quot;</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> ptr = &amp;x;
        ptr.* += <span class="tok-number">1</span>;
        x += <span class="tok-number">1</span>;
        <span class="tok-kw">try</span> expect(ptr.* == <span class="tok-number">3</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_pointers.zig</kbd>
1/1 test_comptime_pointers.test.comptime pointers...OK
All 1 tests passed.
</samp></pre></figure>

      <p>To convert an integer address into a pointer, use <code><span class="tok-builtin">@ptrFromInt</span></code>.
      To convert a pointer to an integer, use <code><span class="tok-builtin">@intFromPtr</span></code>:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_integer_pointer_conversion.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;@intFromPtr and @ptrFromInt&quot;</span> {
    <span class="tok-kw">const</span> ptr: *<span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0xdeadbee0</span>);
    <span class="tok-kw">const</span> addr = <span class="tok-builtin">@intFromPtr</span>(ptr);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(addr) == <span class="tok-type">usize</span>);
    <span class="tok-kw">try</span> expect(addr == <span class="tok-number">0xdeadbee0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_integer_pointer_conversion.zig</kbd>
1/1 test_integer_pointer_conversion.test.@intFromPtr and @ptrFromInt...OK
All 1 tests passed.
</samp></pre></figure>

      <p>Zig is able to preserve memory addresses in comptime code, as long as
      the pointer is never dereferenced:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_pointer_conversion.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;comptime @ptrFromInt&quot;</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-comment">// Zig is able to do this at compile-time, as long as</span>
        <span class="tok-comment">// ptr is never dereferenced.</span>
        <span class="tok-kw">const</span> ptr: *<span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0xdeadbee0</span>);
        <span class="tok-kw">const</span> addr = <span class="tok-builtin">@intFromPtr</span>(ptr);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(addr) == <span class="tok-type">usize</span>);
        <span class="tok-kw">try</span> expect(addr == <span class="tok-number">0xdeadbee0</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_pointer_conversion.zig</kbd>
1/1 test_comptime_pointer_conversion.test.comptime @ptrFromInt...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      <a href="#ptrCast">@ptrCast</a> converts a pointer's element type to another. This
      creates a new pointer that can cause undetectable Illegal Behavior
      depending on the loads and stores that pass through it. Generally, other
      kinds of type conversions are preferable to
      <code><span class="tok-builtin">@ptrCast</span></code> if possible.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_pointer_casting.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer casting&quot;</span> {
    <span class="tok-kw">const</span> bytes <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">u32</span>)) = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span> };
    <span class="tok-kw">const</span> u32_ptr: *<span class="tok-kw">const</span> <span class="tok-type">u32</span> = <span class="tok-builtin">@ptrCast</span>(&amp;bytes);
    <span class="tok-kw">try</span> expect(u32_ptr.* == <span class="tok-number">0x12121212</span>);

    <span class="tok-comment">// Even this example is contrived - there are better ways to do the above than</span>
    <span class="tok-comment">// pointer casting. For example, using a slice narrowing cast:</span>
    <span class="tok-kw">const</span> u32_value = std.mem.bytesAsSlice(<span class="tok-type">u32</span>, bytes[<span class="tok-number">0</span>..])[<span class="tok-number">0</span>];
    <span class="tok-kw">try</span> expect(u32_value == <span class="tok-number">0x12121212</span>);

    <span class="tok-comment">// And even another way, the most straightforward way to do it:</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@bitCast</span>(bytes)) == <span class="tok-number">0x12121212</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer child type&quot;</span> {
    <span class="tok-comment">// pointer types have a `child` field which tells you the type they point to.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(*<span class="tok-type">u32</span>).pointer.child == <span class="tok-type">u32</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pointer_casting.zig</kbd>
1/2 test_pointer_casting.test.pointer casting...OK
2/2 test_pointer_casting.test.pointer child type...OK
All 2 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#Optional-Pointers">Optional Pointers</a></li>
<li><a href="#ptrFromInt">@ptrFromInt</a></li>
<li><a href="#intFromPtr">@intFromPtr</a></li>
<li><a href="#C-Pointers">C Pointers</a></li>
</ul>

      <h3 id="volatile"><a href="#toc-volatile">volatile</a> <a class="hdr" href="#volatile">§</a></h3>

      <p>Loads and stores are assumed to not have side effects. If a given load or store
      should have side effects, such as Memory Mapped Input/Output (MMIO), use <code><span class="tok-kw">volatile</span></code>.
      In the following code, loads and stores with <code>mmio_ptr</code> are guaranteed to all happen
      and in the same order as in source code:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_volatile.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;volatile&quot;</span> {
    <span class="tok-kw">const</span> mmio_ptr: *<span class="tok-kw">volatile</span> <span class="tok-type">u8</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0x12345678</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(mmio_ptr) == *<span class="tok-kw">volatile</span> <span class="tok-type">u8</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_volatile.zig</kbd>
1/1 test_volatile.test.volatile...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Note that <code><span class="tok-kw">volatile</span></code> is unrelated to concurrency and <a href="#Atomics">Atomics</a>.
      If you see code that is using <code><span class="tok-kw">volatile</span></code> for something other than Memory Mapped
      Input/Output, it is probably a bug.
      </p>
      

      <h3 id="Alignment"><a href="#toc-Alignment">Alignment</a> <a class="hdr" href="#Alignment">§</a></h3>

      <p>
      Each type has an <strong>alignment</strong> - a number of bytes such that,
      when a value of the type is loaded from or stored to memory,
      the memory address must be evenly divisible by this number. You can use
      <a href="#alignOf">@alignOf</a> to find out this value for any type.
      </p>
      <p>
      Alignment depends on the CPU architecture, but is always a power of two, and
      less than <code><span class="tok-number">1</span> &lt;&lt; <span class="tok-number">29</span></code>.
      </p>
      <p>
      In Zig, a pointer type has an alignment value. If the value is equal to the
      alignment of the underlying type, it can be omitted from the type:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_variable_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;variable alignment&quot;</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> align_of_i32 = <span class="tok-builtin">@alignOf</span>(<span class="tok-builtin">@TypeOf</span>(x));
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;x) == *<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(*<span class="tok-type">i32</span> == *<span class="tok-kw">align</span>(align_of_i32) <span class="tok-type">i32</span>);
    <span class="tok-kw">if</span> (builtin.target.cpu.arch == .x86_64) {
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(*<span class="tok-type">i32</span>).pointer.alignment == <span class="tok-number">4</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_variable_alignment.zig</kbd>
1/1 test_variable_alignment.test.variable alignment...OK
All 1 tests passed.
</samp></pre></figure>

      <p>In the same way that a <code>*<span class="tok-type">i32</span></code> can be <a href="#Type-Coercion">coerced</a> to a
          <code>*<span class="tok-kw">const</span> <span class="tok-type">i32</span></code>, a pointer with a larger alignment can be implicitly
      cast to a pointer with a smaller alignment, but not vice versa.
      </p>
      <p>
      You can specify alignment on variables and functions. If you do this, then
      pointers to them get the specified alignment:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_variable_func_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">var</span> foo: <span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = <span class="tok-number">100</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;global variable alignment&quot;</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(&amp;foo)).pointer.alignment == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;foo) == *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>);
    <span class="tok-kw">const</span> as_pointer_to_array: *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) [<span class="tok-number">1</span>]<span class="tok-type">u8</span> = &amp;foo;
    <span class="tok-kw">const</span> as_slice: []<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span> = as_pointer_to_array;
    <span class="tok-kw">const</span> as_unaligned_slice: []<span class="tok-type">u8</span> = as_slice;
    <span class="tok-kw">try</span> expect(as_unaligned_slice[<span class="tok-number">0</span>] == <span class="tok-number">100</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">derp</span>() <span class="tok-kw">align</span>(<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-number">2</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}
<span class="tok-kw">fn</span> <span class="tok-fn">noop1</span>() <span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">void</span> {}
<span class="tok-kw">fn</span> <span class="tok-fn">noop4</span>() <span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">void</span> {}

<span class="tok-kw">test</span> <span class="tok-str">&quot;function alignment&quot;</span> {
    <span class="tok-kw">try</span> expect(derp() == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(derp) == <span class="tok-kw">fn</span> () <span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;derp) == *<span class="tok-kw">align</span>(<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-number">2</span>) <span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">i32</span>);

    noop1();
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(noop1) == <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;noop1) == *<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);

    noop4();
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(noop4) == <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;noop4) == *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-kw">const</span> <span class="tok-kw">fn</span> () <span class="tok-type">void</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_variable_func_alignment.zig</kbd>
1/2 test_variable_func_alignment.test.global variable alignment...OK
2/2 test_variable_func_alignment.test.function alignment...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
      If you have a pointer or a slice that has a small alignment, but you know that it actually
      has a bigger alignment, use <a href="#alignCast">@alignCast</a> to change the
      pointer into a more aligned pointer. This is a no-op at runtime, but inserts a
      <a href="#Incorrect-Pointer-Alignment">safety check</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_incorrect_pointer_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer alignment safety&quot;</span> {
    <span class="tok-kw">var</span> array <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = [_]<span class="tok-type">u32</span>{ <span class="tok-number">0x11111111</span>, <span class="tok-number">0x11111111</span> };
    <span class="tok-kw">const</span> bytes = std.mem.sliceAsBytes(array[<span class="tok-number">0</span>..]);
    <span class="tok-kw">try</span> std.testing.expect(foo(bytes) == <span class="tok-number">0x11111111</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(bytes: []<span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> slice4 = bytes[<span class="tok-number">1</span>..<span class="tok-number">5</span>];
    <span class="tok-kw">const</span> int_slice = std.mem.bytesAsSlice(<span class="tok-type">u32</span>, <span class="tok-builtin">@as</span>([]<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>, <span class="tok-builtin">@alignCast</span>(slice4)));
    <span class="tok-kw">return</span> int_slice[<span class="tok-number">0</span>];
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_incorrect_pointer_alignment.zig</kbd>
1/1 test_incorrect_pointer_alignment.test.pointer alignment safety...thread 211638 panic: incorrect alignment
<span class="sgr-1m">/home/andy/src/zig/doc/langref/test_incorrect_pointer_alignment.zig:10:68</span>: <span class="sgr-2m">0x1048c12 in foo (test)</span>
    const int_slice = std.mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));
                                                                   <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/test_incorrect_pointer_alignment.zig:6:31</span>: <span class="sgr-2m">0x1048abf in test.pointer alignment safety (test)</span>
    try std.testing.expect(foo(bytes) == 0x11111111);
                              <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:214:25</span>: <span class="sgr-2m">0x10ef185 in mainTerminal (test)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:62:28</span>: <span class="sgr-2m">0x10e771d in main (test)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10e6ca2 in posixCallMainAndExit (test)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10e687d in _start (test)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/src/zig/.zig-cache/o/08ad046baf4e682f3eb12b3ecaa07a72/test --seed=0xaf095082
</samp></pre></figure>

      

      <h3 id="allowzero"><a href="#toc-allowzero">allowzero</a> <a class="hdr" href="#allowzero">§</a></h3>

      <p>
      This pointer attribute allows a pointer to have address zero. This is only ever needed on the
      freestanding OS target, where the address zero is mappable. If you want to represent null pointers, use
      <a href="#Optional-Pointers">Optional Pointers</a> instead. <a href="#Optional-Pointers">Optional Pointers</a> with <code><span class="tok-kw">allowzero</span></code>
      are not the same size as pointers. In this code example, if the pointer
      did not have the <code><span class="tok-kw">allowzero</span></code> attribute, this would be a
      <a href="#Pointer-Cast-Invalid-Null">Pointer Cast Invalid Null</a> panic:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_allowzero.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;allowzero&quot;</span> {
    <span class="tok-kw">var</span> zero: <span class="tok-type">usize</span> = <span class="tok-number">0</span>; <span class="tok-comment">// var to make to runtime-known</span>
    _ = &amp;zero; <span class="tok-comment">// suppress 'var is never mutated' error</span>
    <span class="tok-kw">const</span> ptr: *<span class="tok-kw">allowzero</span> <span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(zero);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(ptr) == <span class="tok-number">0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_allowzero.zig</kbd>
1/1 test_allowzero.test.allowzero...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Sentinel-Terminated-Pointers"><a href="#toc-Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a> <a class="hdr" href="#Sentinel-Terminated-Pointers">§</a></h3>

      <p>
      The syntax <code>[*:x]T</code> describes a pointer that
      has a length determined by a sentinel value. This provides protection
      against buffer overflow and overreads.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">sentinel-terminated_pointer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-comment">// This is also available as `std.c.printf`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">extern</span> <span class="tok-str">&quot;c&quot;</span> <span class="tok-kw">fn</span> <span class="tok-fn">printf</span>(format: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ...) <span class="tok-type">c_int</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    _ = printf(<span class="tok-str">&quot;Hello, world!\n&quot;</span>); <span class="tok-comment">// OK</span>

    <span class="tok-kw">const</span> msg = <span class="tok-str">&quot;Hello, world!\n&quot;</span>;
    <span class="tok-kw">const</span> non_null_terminated_msg: [msg.len]<span class="tok-type">u8</span> = msg.*;
    _ = printf(&amp;non_null_terminated_msg);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe sentinel-terminated_pointer.zig -lc</kbd>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type '[*:0]const u8', found '*const [14]u8'
</span>    _ = printf(&amp;non_null_terminated_msg);
               <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-1m">/home/andy/src/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: </span><span class="sgr-36m">note: </span><span class="sgr-1m">destination pointer requires '0' sentinel
</span><span class="sgr-1m">/home/andy/src/zig/doc/langref/sentinel-terminated_pointer.zig:4:34: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter type declared here
</span>pub extern &quot;c&quot; fn printf(format: [*:0]const u8, ...) c_int;
                                 <span class="sgr-32m">^~~~~~~~~~~~~
</span><span class="sgr-2m">referenced by:
    main: /home/andy/src/zig/lib/std/start.zig:656:37
    comptime: /home/andy/src/zig/lib/std/start.zig:58:30
    2 reference(s) hidden; use '-freference-trace=4' to see all references
</span>
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#Sentinel-Terminated-Slices">Sentinel-Terminated Slices</a></li>
<li><a href="#Sentinel-Terminated-Arrays">Sentinel-Terminated Arrays</a></li>
</ul>

      
      

      <h2 id="Slices"><a href="#toc-Slices">Slices</a> <a class="hdr" href="#Slices">§</a></h2>

      <p>
      A slice is a pointer and a length. The difference between an array and
      a slice is that the array's length is part of the type and known at
      compile-time, whereas the slice's length is known at runtime.
      Both can be accessed with the <code>len</code> field.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_basic_slices.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;
<span class="tok-kw">const</span> expectEqualSlices = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expectEqualSlices;

<span class="tok-kw">test</span> <span class="tok-str">&quot;basic slices&quot;</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">var</span> known_at_runtime_zero: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    _ = &amp;known_at_runtime_zero;
    <span class="tok-kw">const</span> slice = array[known_at_runtime_zero..array.len];

    <span class="tok-comment">// alternative initialization using result location</span>
    <span class="tok-kw">const</span> alt_slice: []<span class="tok-kw">const</span> <span class="tok-type">i32</span> = &amp;.{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };

    <span class="tok-kw">try</span> expectEqualSlices(<span class="tok-type">i32</span>, slice, alt_slice);

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice) == []<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(&amp;slice[<span class="tok-number">0</span>] == &amp;array[<span class="tok-number">0</span>]);
    <span class="tok-kw">try</span> expect(slice.len == array.len);

    <span class="tok-comment">// If you slice with comptime-known start and end positions, the result is</span>
    <span class="tok-comment">// a pointer to an array, rather than a slice.</span>
    <span class="tok-kw">const</span> array_ptr = array[<span class="tok-number">0</span>..array.len];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(array_ptr) == *[array.len]<span class="tok-type">i32</span>);

    <span class="tok-comment">// You can perform a slice-by-length by slicing twice. This allows the compiler</span>
    <span class="tok-comment">// to perform some optimisations like recognising a comptime-known length when</span>
    <span class="tok-comment">// the start position is only known at runtime.</span>
    <span class="tok-kw">var</span> runtime_start: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    _ = &amp;runtime_start;
    <span class="tok-kw">const</span> length = <span class="tok-number">2</span>;
    <span class="tok-kw">const</span> array_ptr_len = array[runtime_start..][<span class="tok-number">0</span>..length];
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(array_ptr_len) == *[length]<span class="tok-type">i32</span>);

    <span class="tok-comment">// Using the address-of operator on a slice gives a single-item pointer.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(&amp;slice[<span class="tok-number">0</span>]) == *<span class="tok-type">i32</span>);
    <span class="tok-comment">// Using the `ptr` field gives a many-item pointer.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice.ptr) == [*]<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(slice.ptr) == <span class="tok-builtin">@intFromPtr</span>(&amp;slice[<span class="tok-number">0</span>]));

    <span class="tok-comment">// Slices have array bounds checking. If you try to access something out</span>
    <span class="tok-comment">// of bounds, you'll get a safety check failure:</span>
    slice[<span class="tok-number">10</span>] += <span class="tok-number">1</span>;

    <span class="tok-comment">// Note that `slice.ptr` does not invoke safety checking, while `&amp;slice[0]`</span>
    <span class="tok-comment">// asserts that the slice has len &gt; 0.</span>

    <span class="tok-comment">// Empty slices can be created like this:</span>
    <span class="tok-kw">const</span> empty1 = &amp;[<span class="tok-number">0</span>]<span class="tok-type">u8</span>{};
    <span class="tok-comment">// If the type is known you can use this short hand:</span>
    <span class="tok-kw">const</span> empty2: []<span class="tok-type">u8</span> = &amp;.{};
    <span class="tok-kw">try</span> expect(empty1.len == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(empty2.len == <span class="tok-number">0</span>);

    <span class="tok-comment">// A zero-length initialization can always be used to create an empty slice, even if the slice is mutable.</span>
    <span class="tok-comment">// This is because the pointed-to data is zero bits long, so its immutability is irrelevant.</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_basic_slices.zig</kbd>
1/1 test_basic_slices.test.basic slices...thread 222617 panic: index out of bounds: index 10, len 4
<span class="sgr-1m">/home/andy/src/zig/doc/langref/test_basic_slices.zig:41:10</span>: <span class="sgr-2m">0x104b5a1 in test.basic slices (test)</span>
    slice[10] += 1;
         <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:214:25</span>: <span class="sgr-2m">0x10f2645 in mainTerminal (test)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:62:28</span>: <span class="sgr-2m">0x10eabdd in main (test)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10ea162 in posixCallMainAndExit (test)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10e9d3d in _start (test)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/src/zig/.zig-cache/o/d7a037b9b130e4363980ed7df085d9dc/test --seed=0x830cf24c
</samp></pre></figure>

      <p>This is one reason we prefer slices to pointers.</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_slices.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> mem = std.mem;
<span class="tok-kw">const</span> fmt = std.fmt;

<span class="tok-kw">test</span> <span class="tok-str">&quot;using slices for strings&quot;</span> {
    <span class="tok-comment">// Zig has no concept of strings. String literals are const pointers</span>
    <span class="tok-comment">// to null-terminated arrays of u8, and by convention parameters</span>
    <span class="tok-comment">// that are &quot;strings&quot; are expected to be UTF-8 encoded slices of u8.</span>
    <span class="tok-comment">// Here we coerce *const [5:0]u8 and *const [6:0]u8 to []const u8</span>
    <span class="tok-kw">const</span> hello: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>;
    <span class="tok-kw">const</span> world: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;世界&quot;</span>;

    <span class="tok-kw">var</span> all_together: [<span class="tok-number">100</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-comment">// You can use slice syntax with at least one runtime-known index on an</span>
    <span class="tok-comment">// array to convert an array into a slice.</span>
    <span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    _ = &amp;start;
    <span class="tok-kw">const</span> all_together_slice = all_together[start..];
    <span class="tok-comment">// String concatenation example.</span>
    <span class="tok-kw">const</span> hello_world = <span class="tok-kw">try</span> fmt.bufPrint(all_together_slice, <span class="tok-str">&quot;{s} {s}&quot;</span>, .{ hello, world });

    <span class="tok-comment">// Generally, you can use UTF-8 and not worry about whether something is a</span>
    <span class="tok-comment">// string. If you don't need to deal with individual characters, no need</span>
    <span class="tok-comment">// to decode.</span>
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, hello_world, <span class="tok-str">&quot;hello 世界&quot;</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;slice pointer&quot;</span> {
    <span class="tok-kw">var</span> array: [<span class="tok-number">10</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> ptr = &amp;array;
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(ptr) == *[<span class="tok-number">10</span>]<span class="tok-type">u8</span>);

    <span class="tok-comment">// A pointer to an array can be sliced just like an array:</span>
    <span class="tok-kw">var</span> start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> end: <span class="tok-type">usize</span> = <span class="tok-number">5</span>;
    _ = .{ &amp;start, &amp;end };
    <span class="tok-kw">const</span> slice = ptr[start..end];
    <span class="tok-comment">// The slice is mutable because we sliced a mutable pointer.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice) == []<span class="tok-type">u8</span>);
    slice[<span class="tok-number">2</span>] = <span class="tok-number">3</span>;
    <span class="tok-kw">try</span> expect(array[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);

    <span class="tok-comment">// Again, slicing with comptime-known indexes will produce another pointer</span>
    <span class="tok-comment">// to an array:</span>
    <span class="tok-kw">const</span> ptr2 = slice[<span class="tok-number">2</span>..<span class="tok-number">3</span>];
    <span class="tok-kw">try</span> expect(ptr2.len == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(ptr2[<span class="tok-number">0</span>] == <span class="tok-number">3</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(ptr2) == *[<span class="tok-number">1</span>]<span class="tok-type">u8</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_slices.zig</kbd>
1/2 test_slices.test.using slices for strings...OK
2/2 test_slices.test.slice pointer...OK
All 2 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#Pointers">Pointers</a></li>
<li><a href="#for">for</a></li>
<li><a href="#Arrays">Arrays</a></li>
</ul>


      <h3 id="Sentinel-Terminated-Slices"><a href="#toc-Sentinel-Terminated-Slices">Sentinel-Terminated Slices</a> <a class="hdr" href="#Sentinel-Terminated-Slices">§</a></h3>

      <p>
      The syntax <code>[:x]T</code> is a slice which has a runtime-known length
      and also guarantees a sentinel value at the element indexed by the length. The type does not
      guarantee that there are no sentinel elements before that. Sentinel-terminated slices allow element
      access to the <code>len</code> index.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_null_terminated_slice.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;0-terminated slice&quot;</span> {
    <span class="tok-kw">const</span> slice: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>;

    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> expect(slice[<span class="tok-number">5</span>] == <span class="tok-number">0</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_null_terminated_slice.zig</kbd>
1/1 test_null_terminated_slice.test.0-terminated slice...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Sentinel-terminated slices can also be created using a variation of the slice syntax
      <code>data[start..end :x]</code>, where <code>data</code> is a many-item pointer,
      array or slice and <code>x</code> is the sentinel value.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_null_terminated_slicing.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;0-terminated slicing&quot;</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> };
    <span class="tok-kw">var</span> runtime_length: <span class="tok-type">usize</span> = <span class="tok-number">3</span>;
    _ = &amp;runtime_length;
    <span class="tok-kw">const</span> slice = array[<span class="tok-number">0</span>..runtime_length :<span class="tok-number">0</span>];

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(slice) == [:<span class="tok-number">0</span>]<span class="tok-type">u8</span>);
    <span class="tok-kw">try</span> expect(slice.len == <span class="tok-number">3</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_null_terminated_slicing.zig</kbd>
1/1 test_null_terminated_slicing.test.0-terminated slicing...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Sentinel-terminated slicing asserts that the element in the sentinel position of the backing data is
      actually the sentinel value. If this is not the case, safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a> results.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_sentinel_mismatch.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;sentinel mismatch&quot;</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> };

    <span class="tok-comment">// Creating a sentinel-terminated slice from the array with a length of 2</span>
    <span class="tok-comment">// will result in the value `1` occupying the sentinel element position.</span>
    <span class="tok-comment">// This does not match the indicated sentinel value of `0` and will lead</span>
    <span class="tok-comment">// to a runtime panic.</span>
    <span class="tok-kw">var</span> runtime_length: <span class="tok-type">usize</span> = <span class="tok-number">2</span>;
    _ = &amp;runtime_length;
    <span class="tok-kw">const</span> slice = array[<span class="tok-number">0</span>..runtime_length :<span class="tok-number">0</span>];

    _ = slice;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_sentinel_mismatch.zig</kbd>
1/1 test_sentinel_mismatch.test.sentinel mismatch...thread 212416 panic: sentinel mismatch: expected 0, found 1
<span class="sgr-1m">/home/andy/src/zig/doc/langref/test_sentinel_mismatch.zig:13:24</span>: <span class="sgr-2m">0x1048af1 in test.sentinel mismatch (test)</span>
    const slice = array[0..runtime_length :0];
                       <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:214:25</span>: <span class="sgr-2m">0x10eeee5 in mainTerminal (test)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:62:28</span>: <span class="sgr-2m">0x10e747d in main (test)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10e6a02 in posixCallMainAndExit (test)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10e65dd in _start (test)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/src/zig/.zig-cache/o/9dfcdd59e16f1035ebfa67da73c4ad20/test --seed=0xb1e7629e
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a></li>
<li><a href="#Sentinel-Terminated-Arrays">Sentinel-Terminated Arrays</a></li>
</ul>

      
      

      <h2 id="struct"><a href="#toc-struct">struct</a> <a class="hdr" href="#struct">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_structs.zig</cite></figcaption><pre><code><span class="tok-comment">// Declare a struct.</span>
<span class="tok-comment">// Zig gives no guarantees about the order of fields and the size of</span>
<span class="tok-comment">// the struct but the fields are guaranteed to be ABI-aligned.</span>
<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">f32</span>,
    y: <span class="tok-type">f32</span>,
};

<span class="tok-comment">// Declare an instance of a struct.</span>
<span class="tok-kw">const</span> p: Point = .{
    .x = <span class="tok-number">0.12</span>,
    .y = <span class="tok-number">0.34</span>,
};

<span class="tok-comment">// Functions in the struct's namespace can be called with dot syntax.</span>
<span class="tok-kw">const</span> Vec3 = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">f32</span>,
    y: <span class="tok-type">f32</span>,
    z: <span class="tok-type">f32</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span>, z: <span class="tok-type">f32</span>) Vec3 {
        <span class="tok-kw">return</span> Vec3{
            .x = x,
            .y = y,
            .z = z,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dot</span>(self: Vec3, other: Vec3) <span class="tok-type">f32</span> {
        <span class="tok-kw">return</span> self.x * other.x + self.y * other.y + self.z * other.z;
    }
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;dot product&quot;</span> {
    <span class="tok-kw">const</span> v1 = Vec3.init(<span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>);
    <span class="tok-kw">const</span> v2 = Vec3.init(<span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>);
    <span class="tok-kw">try</span> expect(v1.dot(v2) == <span class="tok-number">0.0</span>);

    <span class="tok-comment">// Other than being available to call with dot syntax, struct methods are</span>
    <span class="tok-comment">// not special. You can reference them as any other declaration inside</span>
    <span class="tok-comment">// the struct:</span>
    <span class="tok-kw">try</span> expect(Vec3.dot(v1, v2) == <span class="tok-number">0.0</span>);
}

<span class="tok-comment">// Structs can have declarations.</span>
<span class="tok-comment">// Structs can have 0 fields.</span>
<span class="tok-kw">const</span> Empty = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PI = <span class="tok-number">3.14</span>;
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;struct namespaced variable&quot;</span> {
    <span class="tok-kw">try</span> expect(Empty.PI == <span class="tok-number">3.14</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@sizeOf</span>(Empty) == <span class="tok-number">0</span>);

    <span class="tok-comment">// Empty structs can be instantiated the same as usual.</span>
    <span class="tok-kw">const</span> does_nothing: Empty = .{};

    _ = does_nothing;
}

<span class="tok-comment">// Struct field order is determined by the compiler, however, a base pointer</span>
<span class="tok-comment">// can be computed from a field pointer:</span>
<span class="tok-kw">fn</span> <span class="tok-fn">setYBasedOnX</span>(x: *<span class="tok-type">f32</span>, y: <span class="tok-type">f32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> point: *Point = <span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-str">&quot;x&quot;</span>, x);
    point.y = y;
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;field parent pointer&quot;</span> {
    <span class="tok-kw">var</span> point = Point{
        .x = <span class="tok-number">0.1234</span>,
        .y = <span class="tok-number">0.5678</span>,
    };
    setYBasedOnX(&amp;point.x, <span class="tok-number">0.9</span>);
    <span class="tok-kw">try</span> expect(point.y == <span class="tok-number">0.9</span>);
}

<span class="tok-comment">// Structs can be returned from functions.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">LinkedList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
            prev: ?*Node,
            next: ?*Node,
            data: T,
        };

        first: ?*Node,
        last: ?*Node,
        len: <span class="tok-type">usize</span>,
    };
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;linked list&quot;</span> {
    <span class="tok-comment">// Functions called at compile-time are memoized.</span>
    <span class="tok-kw">try</span> expect(LinkedList(<span class="tok-type">i32</span>) == LinkedList(<span class="tok-type">i32</span>));

    <span class="tok-kw">const</span> list = LinkedList(<span class="tok-type">i32</span>){
        .first = <span class="tok-null">null</span>,
        .last = <span class="tok-null">null</span>,
        .len = <span class="tok-number">0</span>,
    };
    <span class="tok-kw">try</span> expect(list.len == <span class="tok-number">0</span>);

    <span class="tok-comment">// Since types are first class values you can instantiate the type</span>
    <span class="tok-comment">// by assigning it to a variable:</span>
    <span class="tok-kw">const</span> ListOfInts = LinkedList(<span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(ListOfInts == LinkedList(<span class="tok-type">i32</span>));

    <span class="tok-kw">var</span> node = ListOfInts.Node{
        .prev = <span class="tok-null">null</span>,
        .next = <span class="tok-null">null</span>,
        .data = <span class="tok-number">1234</span>,
    };
    <span class="tok-kw">const</span> list2 = LinkedList(<span class="tok-type">i32</span>){
        .first = &amp;node,
        .last = &amp;node,
        .len = <span class="tok-number">1</span>,
    };

    <span class="tok-comment">// When using a pointer to a struct, fields can be accessed directly,</span>
    <span class="tok-comment">// without explicitly dereferencing the pointer.</span>
    <span class="tok-comment">// So you can do</span>
    <span class="tok-kw">try</span> expect(list2.first.?.data == <span class="tok-number">1234</span>);
    <span class="tok-comment">// instead of try expect(list2.first.?.*.data == 1234);</span>
}

<span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_structs.zig</kbd>
1/4 test_structs.test.dot product...OK
2/4 test_structs.test.struct namespaced variable...OK
3/4 test_structs.test.field parent pointer...OK
4/4 test_structs.test.linked list...OK
All 4 tests passed.
</samp></pre></figure>


      <h3 id="Default-Field-Values"><a href="#toc-Default-Field-Values">Default Field Values</a> <a class="hdr" href="#Default-Field-Values">§</a></h3>

      <p>
      Each struct field may have an expression indicating the default field
      value. Such expressions are executed at <a href="#comptime">comptime</a>, and allow the
      field to be omitted in a struct literal expression:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">struct_default_field_values.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
    a: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>,
    b: <span class="tok-type">i32</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;default struct initialization fields&quot;</span> {
    <span class="tok-kw">const</span> x: Foo = .{
        .b = <span class="tok-number">5</span>,
    };
    <span class="tok-kw">if</span> (x.a + x.b != <span class="tok-number">1239</span>) {
        <span class="tok-kw">comptime</span> <span class="tok-kw">unreachable</span>;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test struct_default_field_values.zig</kbd>
1/1 struct_default_field_values.test.default struct initialization fields...OK
All 1 tests passed.
</samp></pre></figure>

      <h4 id="Faulty-Default-Field-Values"><a href="#toc-Faulty-Default-Field-Values">Faulty Default Field Values</a> <a class="hdr" href="#Faulty-Default-Field-Values">§</a></h4>

      <p>
      Default field values are only appropriate when the data invariants of a struct
      cannot be violated by omitting that field from an initialization.
      </p>
      <p>
      For example, here is an inappropriate use of default struct field initialization:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">bad_default_value.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Threshold = <span class="tok-kw">struct</span> {
    minimum: <span class="tok-type">f32</span> = <span class="tok-number">0.25</span>,
    maximum: <span class="tok-type">f32</span> = <span class="tok-number">0.75</span>,

    <span class="tok-kw">const</span> Category = <span class="tok-kw">enum</span> { low, medium, high };

    <span class="tok-kw">fn</span> <span class="tok-fn">categorize</span>(t: Threshold, value: <span class="tok-type">f32</span>) Category {
        assert(t.maximum &gt;= t.minimum);
        <span class="tok-kw">if</span> (value &lt; t.minimum) <span class="tok-kw">return</span> .low;
        <span class="tok-kw">if</span> (value &gt; t.maximum) <span class="tok-kw">return</span> .high;
        <span class="tok-kw">return</span> .medium;
    }
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> threshold: Threshold = .{
        .maximum = <span class="tok-number">0.20</span>,
    };
    <span class="tok-kw">const</span> category = threshold.categorize(<span class="tok-number">0.90</span>);
    <span class="tok-kw">try</span> std.io.getStdOut().writeAll(<span class="tok-builtin">@tagName</span>(category));
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe bad_default_value.zig</kbd>
$ <kbd>./bad_default_value</kbd>
thread 216489 panic: reached unreachable code
<span class="sgr-1m">/home/andy/src/zig/lib/std/debug.zig:522:14</span>: <span class="sgr-2m">0x1048e4d in assert (bad_default_value)</span>
    if (!ok) unreachable; // assertion failure
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/bad_default_value.zig:8:15</span>: <span class="sgr-2m">0x10de7b9 in categorize (bad_default_value)</span>
        assert(t.maximum &gt;= t.minimum);
              <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/bad_default_value.zig:19:42</span>: <span class="sgr-2m">0x10de6fa in main (bad_default_value)</span>
    const category = threshold.categorize(0.90);
                                         <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:656:37</span>: <span class="sgr-2m">0x10de60a in posixCallMainAndExit (bad_default_value)</span>
            const result = root.main() catch |err| {
                                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10de1bd in _start (bad_default_value)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>
      Above you can see the danger of ignoring this principle. The default
      field values caused the data invariant to be violated, causing illegal
      behavior.
      </p>
      <p>
      To fix this, remove the default values from all the struct fields, and provide
      a named default value:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">struct_default_value.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Threshold = <span class="tok-kw">struct</span> {
    minimum: <span class="tok-type">f32</span>,
    maximum: <span class="tok-type">f32</span>,

    <span class="tok-kw">const</span> default: Threshold = .{
        .minimum = <span class="tok-number">0.25</span>,
        .maximum = <span class="tok-number">0.75</span>,
    };
};</code></pre></figure>

      <p>If a struct value requires a runtime-known value in order to be initialized
      without violating data invariants, then use an initialization method that accepts
      those runtime values, and populates the remaining fields.</p>
      
      

      <h3 id="extern-struct"><a href="#toc-extern-struct">extern struct</a> <a class="hdr" href="#extern-struct">§</a></h3>

      <p>An <code><span class="tok-kw">extern</span> <span class="tok-kw">struct</span></code> has in-memory layout matching
      the C ABI for the target.</p>
      <p>If well-defined in-memory layout is not required, <a href="#struct">struct</a> is a better choice
      because it places fewer restrictions on the compiler.</p>
      <p>See <a href="#packed-struct">packed struct</a> for a struct that has the ABI of its backing integer,
      which can be useful for modeling flags.</p>
      <p>See also:</p><ul>
<li><a href="#extern-union">extern union</a></li>
<li><a href="#extern-enum">extern enum</a></li>
</ul>

      

      <h3 id="packed-struct"><a href="#toc-packed-struct">packed struct</a> <a class="hdr" href="#packed-struct">§</a></h3>

      <p>
      Unlike normal structs, <code><span class="tok-kw">packed</span></code> structs have guaranteed in-memory layout:
      </p>
      <ul>
        <li>Fields remain in the order declared, least to most significant.</li>
        <li>There is no padding between fields.</li>
        <li>Zig supports arbitrary width <a href="#Integers">Integers</a> and although normally, integers with fewer
        than 8 bits will still use 1 byte of memory, in packed structs, they use
        exactly their bit width.
        </li>
        <li><code><span class="tok-type">bool</span></code> fields use exactly 1 bit.</li>
        <li>An <a href="#enum">enum</a> field uses exactly the bit width of its integer tag type.</li>
        <li>A <a href="#packed-union">packed union</a> field uses exactly the bit width of the union field with
        the largest bit width.</li>
        <li>Packed structs support equality operators.</li>
      </ul>
      <p>
      This means that a <code><span class="tok-kw">packed</span> <span class="tok-kw">struct</span></code> can participate
      in a <a href="#bitCast">@bitCast</a> or a <a href="#ptrCast">@ptrCast</a> to reinterpret memory.
      This even works at <a href="#comptime">comptime</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_packed_structs.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> native_endian = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).target.cpu.arch.endian();
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Full = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    number: <span class="tok-type">u16</span>,
};
<span class="tok-kw">const</span> Divided = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    half1: <span class="tok-type">u8</span>,
    quarter3: <span class="tok-type">u4</span>,
    quarter4: <span class="tok-type">u4</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;@bitCast between packed structs&quot;</span> {
    <span class="tok-kw">try</span> doTheTest();
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> doTheTest();
}

<span class="tok-kw">fn</span> <span class="tok-fn">doTheTest</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@sizeOf</span>(Full) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@sizeOf</span>(Divided) == <span class="tok-number">2</span>);
    <span class="tok-kw">const</span> full = Full{ .number = <span class="tok-number">0x1234</span> };
    <span class="tok-kw">const</span> divided: Divided = <span class="tok-builtin">@bitCast</span>(full);
    <span class="tok-kw">try</span> expect(divided.half1 == <span class="tok-number">0x34</span>);
    <span class="tok-kw">try</span> expect(divided.quarter3 == <span class="tok-number">0x2</span>);
    <span class="tok-kw">try</span> expect(divided.quarter4 == <span class="tok-number">0x1</span>);

    <span class="tok-kw">const</span> ordered: [<span class="tok-number">2</span>]<span class="tok-type">u8</span> = <span class="tok-builtin">@bitCast</span>(full);
    <span class="tok-kw">switch</span> (native_endian) {
        .big =&gt; {
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">0</span>] == <span class="tok-number">0x12</span>);
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">1</span>] == <span class="tok-number">0x34</span>);
        },
        .little =&gt; {
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">0</span>] == <span class="tok-number">0x34</span>);
            <span class="tok-kw">try</span> expect(ordered[<span class="tok-number">1</span>] == <span class="tok-number">0x12</span>);
        },
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_packed_structs.zig</kbd>
1/1 test_packed_structs.test.@bitCast between packed structs...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      The backing integer is inferred from the fields' total bit width.
      Optionally, it can be explicitly provided and enforced at compile time:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_missized_packed_struct.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;missized packed struct&quot;</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span>(<span class="tok-type">u32</span>) { a: <span class="tok-type">u16</span>, b: <span class="tok-type">u8</span> };
    _ = S{ .a = <span class="tok-number">4</span>, .b = <span class="tok-number">2</span> };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_missized_packed_struct.zig</kbd>
<span class="sgr-1m">doc/langref/test_missized_packed_struct.zig:2:29: </span><span class="sgr-31m">error: </span><span class="sgr-1m">backing integer type 'u32' has bit size 32 but the struct fields have a total bit size of 24
</span>    const S = packed struct(u32) { a: u16, b: u8 };
                            <span class="sgr-32m">^~~
</span>
</samp></pre></figure>

      <p>
      Zig allows the address to be taken of a non-byte-aligned field:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_pointer_to_non-byte_aligned_field.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">var</span> foo = BitField{
    .a = <span class="tok-number">1</span>,
    .b = <span class="tok-number">2</span>,
    .c = <span class="tok-number">3</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer to non-byte-aligned field&quot;</span> {
    <span class="tok-kw">const</span> ptr = &amp;foo.b;
    <span class="tok-kw">try</span> expect(ptr.* == <span class="tok-number">2</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pointer_to_non-byte_aligned_field.zig</kbd>
1/1 test_pointer_to_non-byte_aligned_field.test.pointer to non-byte-aligned field...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      However, the pointer to a non-byte-aligned field has special properties and cannot
      be passed when a normal pointer is expected:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_misaligned_pointer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">var</span> bit_field = BitField{
    .a = <span class="tok-number">1</span>,
    .b = <span class="tok-number">2</span>,
    .c = <span class="tok-number">3</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer to non-byte-aligned field&quot;</span> {
    <span class="tok-kw">try</span> expect(bar(&amp;bit_field.b) == <span class="tok-number">2</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(x: *<span class="tok-kw">const</span> <span class="tok-type">u3</span>) <span class="tok-type">u3</span> {
    <span class="tok-kw">return</span> x.*;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_misaligned_pointer.zig</kbd>
<span class="sgr-1m">doc/langref/test_misaligned_pointer.zig:17:20: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type '*const u3', found '*align(1:3:1) u3'
</span>    try expect(bar(&amp;bit_field.b) == 2);
                   <span class="sgr-32m">^~~~~~~~~~~~
</span><span class="sgr-1m">doc/langref/test_misaligned_pointer.zig:17:20: </span><span class="sgr-36m">note: </span><span class="sgr-1m">pointer host size '1' cannot cast into pointer host size '0'
</span><span class="sgr-1m">doc/langref/test_misaligned_pointer.zig:17:20: </span><span class="sgr-36m">note: </span><span class="sgr-1m">pointer bit offset '3' cannot cast into pointer bit offset '0'
</span><span class="sgr-1m">doc/langref/test_misaligned_pointer.zig:20:11: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter type declared here
</span>fn bar(x: *const u3) u3 {
          <span class="sgr-32m">^~~~~~~~~
</span>
</samp></pre></figure>

      <p>
      In this case, the function <code>bar</code> cannot be called because the pointer
      to the non-ABI-aligned field mentions the bit offset, but the function expects an ABI-aligned pointer.
      </p>
      <p>
      Pointers to non-ABI-aligned fields share the same address as the other fields within their host integer:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_packed_struct_field_address.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">var</span> bit_field = BitField{
    .a = <span class="tok-number">1</span>,
    .b = <span class="tok-number">2</span>,
    .c = <span class="tok-number">3</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointers of sub-byte-aligned fields share addresses&quot;</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.a) == <span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.b));
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.a) == <span class="tok-builtin">@intFromPtr</span>(&amp;bit_field.c));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_packed_struct_field_address.zig</kbd>
1/1 test_packed_struct_field_address.test.pointers of sub-byte-aligned fields share addresses...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      This can be observed with <a href="#bitOffsetOf">@bitOffsetOf</a> and <a href="#offsetOf">offsetOf</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_bitOffsetOf_offsetOf.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;offsets of non-byte-aligned fields&quot;</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@bitOffsetOf</span>(BitField, <span class="tok-str">&quot;a&quot;</span>) == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@bitOffsetOf</span>(BitField, <span class="tok-str">&quot;b&quot;</span>) == <span class="tok-number">3</span>);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@bitOffsetOf</span>(BitField, <span class="tok-str">&quot;c&quot;</span>) == <span class="tok-number">6</span>);

        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@offsetOf</span>(BitField, <span class="tok-str">&quot;a&quot;</span>) == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@offsetOf</span>(BitField, <span class="tok-str">&quot;b&quot;</span>) == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@offsetOf</span>(BitField, <span class="tok-str">&quot;c&quot;</span>) == <span class="tok-number">0</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_bitOffsetOf_offsetOf.zig</kbd>
1/1 test_bitOffsetOf_offsetOf.test.offsets of non-byte-aligned fields...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Packed structs have the same alignment as their backing integer, however, overaligned
      pointers to packed structs can override this:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_overaligned_packed_struct.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> S = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u32</span>,
    b: <span class="tok-type">u32</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;overaligned pointer to packed struct&quot;</span> {
    <span class="tok-kw">var</span> foo: S <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = .{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span> };
    <span class="tok-kw">const</span> ptr: *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) S = &amp;foo;
    <span class="tok-kw">const</span> ptr_to_b: *<span class="tok-type">u32</span> = &amp;ptr.b;
    <span class="tok-kw">try</span> expect(ptr_to_b.* == <span class="tok-number">2</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_overaligned_packed_struct.zig</kbd>
1/1 test_overaligned_packed_struct.test.overaligned pointer to packed struct...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      It's also possible to set alignment of struct fields:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_aligned_struct_fields.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expectEqual = std.testing.expectEqual;

<span class="tok-kw">test</span> <span class="tok-str">&quot;aligned struct fields&quot;</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u32</span> <span class="tok-kw">align</span>(<span class="tok-number">2</span>),
        b: <span class="tok-type">u32</span> <span class="tok-kw">align</span>(<span class="tok-number">64</span>),
    };
    <span class="tok-kw">var</span> foo = S{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span> };

    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">64</span>, <span class="tok-builtin">@alignOf</span>(S));
    <span class="tok-kw">try</span> expectEqual(*<span class="tok-kw">align</span>(<span class="tok-number">2</span>) <span class="tok-type">u32</span>, <span class="tok-builtin">@TypeOf</span>(&amp;foo.a));
    <span class="tok-kw">try</span> expectEqual(*<span class="tok-kw">align</span>(<span class="tok-number">64</span>) <span class="tok-type">u32</span>, <span class="tok-builtin">@TypeOf</span>(&amp;foo.b));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_aligned_struct_fields.zig</kbd>
1/1 test_aligned_struct_fields.test.aligned struct fields...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Equating packed structs results in a comparison of the backing integer, 
      and only works for the `==` and `!=` operators.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_packed_struct_equality.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;packed struct equality&quot;</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u4</span>,
        b: <span class="tok-type">u4</span>,
    };
    <span class="tok-kw">const</span> x: S = .{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span> };
    <span class="tok-kw">const</span> y: S = .{ .b = <span class="tok-number">2</span>, .a = <span class="tok-number">1</span> };
    <span class="tok-kw">try</span> expect(x == y);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_packed_struct_equality.zig</kbd>
1/1 test_packed_struct_equality.test.packed struct equality...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Using packed structs with <a href="#volatile">volatile</a> is problematic, and may be a compile error in the future.
      For details on this subscribe to
      <a href="https://github.com/ziglang/zig/issues/1761">this issue</a>.
      TODO update these docs with a recommendation on how to use packed structs with MMIO
      (the use case for volatile packed structs) once this issue is resolved.
      Don't worry, there will be a good solution for this use case in zig.
      </p>
      

      <h3 id="Struct-Naming"><a href="#toc-Struct-Naming">Struct Naming</a> <a class="hdr" href="#Struct-Naming">§</a></h3>

      <p>Since all structs are anonymous, Zig infers the type name based on a few rules.</p>
      <ul>
          <li>If the struct is in the initialization expression of a variable, it gets named after
          that variable.</li>
          <li>If the struct is in the <code><span class="tok-kw">return</span></code> expression, it gets named after
          the function it is returning from, with the parameter values serialized.</li>
          <li>Otherwise, the struct gets a name such as <code>(filename.funcname__struct_ID)</code>.</li>
          <li>If the struct is declared inside another struct, it gets named after both the parent
          struct and the name inferred by the previous rules, separated by a dot.</li>
      </ul>
      <figure><figcaption class="zig-cap"><cite class="file">struct_name.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {};
    std.debug.print(<span class="tok-str">&quot;variable: {s}\n&quot;</span>, .{<span class="tok-builtin">@typeName</span>(Foo)});
    std.debug.print(<span class="tok-str">&quot;anonymous: {s}\n&quot;</span>, .{<span class="tok-builtin">@typeName</span>(<span class="tok-kw">struct</span> {})});
    std.debug.print(<span class="tok-str">&quot;function: {s}\n&quot;</span>, .{<span class="tok-builtin">@typeName</span>(List(<span class="tok-type">i32</span>))});
}

<span class="tok-kw">fn</span> <span class="tok-fn">List</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        x: T,
    };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe struct_name.zig</kbd>
$ <kbd>./struct_name</kbd>
variable: struct_name.main.Foo
anonymous: struct_name.main__struct_24143
function: struct_name.List(i32)
</samp></pre></figure>

      

      <h3 id="Anonymous-Struct-Literals"><a href="#toc-Anonymous-Struct-Literals">Anonymous Struct Literals</a> <a class="hdr" href="#Anonymous-Struct-Literals">§</a></h3>

      <p>
      Zig allows omitting the struct type of a literal. When the result is <a href="#Type-Coercion">coerced</a>,
      the struct literal will directly instantiate the <a href="#Result-Location-Semantics">result location</a>,
      with no copy:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_struct_result.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> { x: <span class="tok-type">i32</span>, y: <span class="tok-type">i32</span> };

<span class="tok-kw">test</span> <span class="tok-str">&quot;anonymous struct literal&quot;</span> {
    <span class="tok-kw">const</span> pt: Point = .{
        .x = <span class="tok-number">13</span>,
        .y = <span class="tok-number">67</span>,
    };
    <span class="tok-kw">try</span> expect(pt.x == <span class="tok-number">13</span>);
    <span class="tok-kw">try</span> expect(pt.y == <span class="tok-number">67</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_struct_result.zig</kbd>
1/1 test_struct_result.test.anonymous struct literal...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      The struct type can be inferred. Here the <a href="#Result-Location-Semantics">result location</a>
      does not include a type, and so Zig infers the type:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_anonymous_struct.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;fully anonymous struct&quot;</span> {
    <span class="tok-kw">try</span> check(.{
        .int = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1234</span>),
        .float = <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">12.34</span>),
        .b = <span class="tok-null">true</span>,
        .s = <span class="tok-str">&quot;hi&quot;</span>,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">check</span>(args: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> expect(args.int == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> expect(args.float == <span class="tok-number">12.34</span>);
    <span class="tok-kw">try</span> expect(args.b);
    <span class="tok-kw">try</span> expect(args.s[<span class="tok-number">0</span>] == <span class="tok-str">'h'</span>);
    <span class="tok-kw">try</span> expect(args.s[<span class="tok-number">1</span>] == <span class="tok-str">'i'</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_anonymous_struct.zig</kbd>
1/1 test_anonymous_struct.test.fully anonymous struct...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Tuples"><a href="#toc-Tuples">Tuples</a> <a class="hdr" href="#Tuples">§</a></h3>

      <p>
      Anonymous structs can be created without specifying field names, and are referred to as "tuples". An empty tuple looks like <code>.{}</code> and can be seen in one of the <a href="#Hello-World">Hello World examples</a>.
      </p>
      <p>
      The fields are implicitly named using numbers starting from 0. Because their names are integers,
      they cannot be accessed with <code>.</code> syntax without also wrapping them in
      <code>@&quot;&quot;</code>. Names inside <code>@&quot;&quot;</code> are always recognised as
      <a href="#Identifiers">identifiers</a>.
      </p>
      <p>
      Like arrays, tuples have a .len field, can be indexed (provided the index is comptime-known)
      and work with the ++ and ** operators. They can also be iterated over with <a href="#inline-for">inline for</a>.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_tuples.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;tuple&quot;</span> {
    <span class="tok-kw">const</span> values = .{
        <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1234</span>),
        <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">12.34</span>),
        <span class="tok-null">true</span>,
        <span class="tok-str">&quot;hi&quot;</span>,
    } ++ .{<span class="tok-null">false</span>} ** <span class="tok-number">2</span>;
    <span class="tok-kw">try</span> expect(values[<span class="tok-number">0</span>] == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> expect(values[<span class="tok-number">4</span>] == <span class="tok-null">false</span>);
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (values, <span class="tok-number">0</span>..) |v, i| {
        <span class="tok-kw">if</span> (i != <span class="tok-number">2</span>) <span class="tok-kw">continue</span>;
        <span class="tok-kw">try</span> expect(v);
    }
    <span class="tok-kw">try</span> expect(values.len == <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> expect(values.@&quot;3&quot;[<span class="tok-number">0</span>] == <span class="tok-str">'h'</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_tuples.zig</kbd>
1/1 test_tuples.test.tuple...OK
All 1 tests passed.
</samp></pre></figure>

      <h4 id="Destructuring-Tuples"><a href="#toc-Destructuring-Tuples">Destructuring Tuples</a> <a class="hdr" href="#Destructuring-Tuples">§</a></h4>

      <p>
        Tuples can be <a href="#Destructuring">destructured</a>.
      </p>
      <p>
        Tuple destructuring is helpful for returning multiple values from a block:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_block.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> digits = [_]<span class="tok-type">i8</span> { <span class="tok-number">3</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">0</span>, <span class="tok-number">7</span>, <span class="tok-number">4</span>, <span class="tok-number">1</span> };

    <span class="tok-kw">const</span> min, <span class="tok-kw">const</span> max = blk: {
        <span class="tok-kw">var</span> min: <span class="tok-type">i8</span> = <span class="tok-number">127</span>;
        <span class="tok-kw">var</span> max: <span class="tok-type">i8</span> = -<span class="tok-number">128</span>;

        <span class="tok-kw">for</span> (digits) |digit| {
            <span class="tok-kw">if</span> (digit &lt; min) min = digit;
            <span class="tok-kw">if</span> (digit &gt; max) max = digit;
        }

        <span class="tok-kw">break</span> :blk .{ min, max };
    };

    print(<span class="tok-str">&quot;min = {}&quot;</span>, .{ min });
    print(<span class="tok-str">&quot;max = {}&quot;</span>, .{ max });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_block.zig</kbd>
$ <kbd>./destructuring_block</kbd>
min = 0max = 9
</samp></pre></figure>

      <p>
        Tuple destructuring is helpful for dealing with functions and built-ins that return multiple values
        as a tuple:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">destructuring_return_value.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">fn</span> <span class="tok-fn">divmod</span>(numerator: <span class="tok-type">u32</span>, denominator: <span class="tok-type">u32</span>) <span class="tok-kw">struct</span> { <span class="tok-type">u32</span>, <span class="tok-type">u32</span> } {
    <span class="tok-kw">return</span> .{ numerator / denominator, numerator % denominator };
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> div, <span class="tok-kw">const</span> mod = divmod(<span class="tok-number">10</span>, <span class="tok-number">3</span>);

    print(<span class="tok-str">&quot;10 / 3 = {}\n&quot;</span>, .{div});
    print(<span class="tok-str">&quot;10 % 3 = {}\n&quot;</span>, .{mod});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe destructuring_return_value.zig</kbd>
$ <kbd>./destructuring_return_value</kbd>
10 / 3 = 3
10 % 3 = 1
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#Destructuring">Destructuring</a></li>
<li><a href="#Destructuring-Arrays">Destructuring Arrays</a></li>
<li><a href="#Destructuring-Vectors">Destructuring Vectors</a></li>
</ul>

      
      
      <p>See also:</p><ul>
<li><a href="#comptime">comptime</a></li>
<li><a href="#fieldParentPtr">@fieldParentPtr</a></li>
</ul>

      
      <h2 id="enum"><a href="#toc-enum">enum</a> <a class="hdr" href="#enum">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_enums.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;

<span class="tok-comment">// Declare an enum.</span>
<span class="tok-kw">const</span> Type = <span class="tok-kw">enum</span> {
    ok,
    not_ok,
};

<span class="tok-comment">// Declare a specific enum field.</span>
<span class="tok-kw">const</span> c = Type.ok;

<span class="tok-comment">// If you want access to the ordinal value of an enum, you</span>
<span class="tok-comment">// can specify the tag type.</span>
<span class="tok-kw">const</span> Value = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {
    zero,
    one,
    two,
};
<span class="tok-comment">// Now you can cast between u2 and Value.</span>
<span class="tok-comment">// The ordinal value starts from 0, counting up by 1 from the previous member.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;enum ordinal value&quot;</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value.zero) == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value.one) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value.two) == <span class="tok-number">2</span>);
}

<span class="tok-comment">// You can override the ordinal value for an enum.</span>
<span class="tok-kw">const</span> Value2 = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    hundred = <span class="tok-number">100</span>,
    thousand = <span class="tok-number">1000</span>,
    million = <span class="tok-number">1000000</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;set enum ordinal value&quot;</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value2.hundred) == <span class="tok-number">100</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value2.thousand) == <span class="tok-number">1000</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value2.million) == <span class="tok-number">1000000</span>);
}

<span class="tok-comment">// You can also override only some values.</span>
<span class="tok-kw">const</span> Value3 = <span class="tok-kw">enum</span>(<span class="tok-type">u4</span>) {
    a,
    b = <span class="tok-number">8</span>,
    c,
    d = <span class="tok-number">4</span>,
    e,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;enum implicit ordinal values and overridden values&quot;</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value3.a) == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value3.b) == <span class="tok-number">8</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value3.c) == <span class="tok-number">9</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value3.d) == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@intFromEnum</span>(Value3.e) == <span class="tok-number">5</span>);
}

<span class="tok-comment">// Enums can have methods, the same as structs and unions.</span>
<span class="tok-comment">// Enum methods are not special, they are only namespaced</span>
<span class="tok-comment">// functions that you can call with dot syntax.</span>
<span class="tok-kw">const</span> Suit = <span class="tok-kw">enum</span> {
    clubs,
    spades,
    diamonds,
    hearts,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isClubs</span>(self: Suit) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self == Suit.clubs;
    }
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;enum method&quot;</span> {
    <span class="tok-kw">const</span> p = Suit.spades;
    <span class="tok-kw">try</span> expect(!p.isClubs());
}

<span class="tok-comment">// An enum can be switched upon.</span>
<span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    string,
    number,
    none,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;enum switch&quot;</span> {
    <span class="tok-kw">const</span> p = Foo.number;
    <span class="tok-kw">const</span> what_is_it = <span class="tok-kw">switch</span> (p) {
        Foo.string =&gt; <span class="tok-str">&quot;this is a string&quot;</span>,
        Foo.number =&gt; <span class="tok-str">&quot;this is a number&quot;</span>,
        Foo.none =&gt; <span class="tok-str">&quot;this is a none&quot;</span>,
    };
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, what_is_it, <span class="tok-str">&quot;this is a number&quot;</span>));
}

<span class="tok-comment">// @typeInfo can be used to access the integer tag type of an enum.</span>
<span class="tok-kw">const</span> Small = <span class="tok-kw">enum</span> {
    one,
    two,
    three,
    four,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;std.meta.Tag&quot;</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(Small).@&quot;enum&quot;.tag_type == <span class="tok-type">u2</span>);
}

<span class="tok-comment">// @typeInfo tells us the field count and the fields names:</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;@typeInfo&quot;</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@typeInfo</span>(Small).@&quot;enum&quot;.fields.len == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@typeInfo</span>(Small).@&quot;enum&quot;.fields[<span class="tok-number">1</span>].name, <span class="tok-str">&quot;two&quot;</span>));
}

<span class="tok-comment">// @tagName gives a [:0]const u8 representation of an enum value:</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;@tagName&quot;</span> {
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@tagName</span>(Small.three), <span class="tok-str">&quot;three&quot;</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_enums.zig</kbd>
1/8 test_enums.test.enum ordinal value...OK
2/8 test_enums.test.set enum ordinal value...OK
3/8 test_enums.test.enum implicit ordinal values and overridden values...OK
4/8 test_enums.test.enum method...OK
5/8 test_enums.test.enum switch...OK
6/8 test_enums.test.std.meta.Tag...OK
7/8 test_enums.test.@typeInfo...OK
8/8 test_enums.test.@tagName...OK
All 8 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#typeInfo">@typeInfo</a></li>
<li><a href="#tagName">@tagName</a></li>
<li><a href="#sizeOf">@sizeOf</a></li>
</ul>


      <h3 id="extern-enum"><a href="#toc-extern-enum">extern enum</a> <a class="hdr" href="#extern-enum">§</a></h3>

      <p>
      By default, enums are not guaranteed to be compatible with the C ABI:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">enum_export_error.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> { a, b, c };
<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">entry</span>(foo: Foo) <span class="tok-type">void</span> {
    _ = foo;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj enum_export_error.zig -target x86_64-linux</kbd>
<span class="sgr-1m">doc/langref/enum_export_error.zig:2:17: </span><span class="sgr-31m">error: </span><span class="sgr-1m">parameter of type 'enum_export_error.Foo' not allowed in function with calling convention 'x86_64_sysv'
</span>export fn entry(foo: Foo) void {
                <span class="sgr-32m">^~~~~~~~
</span><span class="sgr-1m">doc/langref/enum_export_error.zig:2:17: </span><span class="sgr-36m">note: </span><span class="sgr-1m">enum tag type 'u2' is not extern compatible
</span><span class="sgr-1m">doc/langref/enum_export_error.zig:2:17: </span><span class="sgr-36m">note: </span><span class="sgr-1m">only integers with 0, 8, 16, 32, 64 and 128 bits are extern compatible
</span><span class="sgr-1m">doc/langref/enum_export_error.zig:1:13: </span><span class="sgr-36m">note: </span><span class="sgr-1m">enum declared here
</span>const Foo = enum { a, b, c };
            <span class="sgr-32m">^~~~~~~~~~~~~~~~
</span><span class="sgr-2m">referenced by:
    root: lib/std/start.zig:3:22
    comptime: lib/std/start.zig:27:9
    2 reference(s) hidden; use '-freference-trace=4' to see all references
</span>
</samp></pre></figure>

      <p>
      For a C-ABI-compatible enum, provide an explicit tag type to
      the enum:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">enum_export.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span>(<span class="tok-type">c_int</span>) { a, b, c };
<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">entry</span>(foo: Foo) <span class="tok-type">void</span> {
    _ = foo;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj enum_export.zig</kbd>
</samp></pre></figure>

      

      <h3 id="Enum-Literals"><a href="#toc-Enum-Literals">Enum Literals</a> <a class="hdr" href="#Enum-Literals">§</a></h3>

      <p>
      Enum literals allow specifying the name of an enum field without specifying the enum type:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_enum_literals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Color = <span class="tok-kw">enum</span> {
    auto,
    off,
    on,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;enum literals&quot;</span> {
    <span class="tok-kw">const</span> color1: Color = .auto;
    <span class="tok-kw">const</span> color2 = Color.auto;
    <span class="tok-kw">try</span> expect(color1 == color2);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;switch using enum literals&quot;</span> {
    <span class="tok-kw">const</span> color = Color.on;
    <span class="tok-kw">const</span> result = <span class="tok-kw">switch</span> (color) {
        .auto =&gt; <span class="tok-null">false</span>,
        .on =&gt; <span class="tok-null">true</span>,
        .off =&gt; <span class="tok-null">false</span>,
    };
    <span class="tok-kw">try</span> expect(result);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_enum_literals.zig</kbd>
1/2 test_enum_literals.test.enum literals...OK
2/2 test_enum_literals.test.switch using enum literals...OK
All 2 tests passed.
</samp></pre></figure>

      

      <h3 id="Non-exhaustive-enum"><a href="#toc-Non-exhaustive-enum">Non-exhaustive enum</a> <a class="hdr" href="#Non-exhaustive-enum">§</a></h3>

      <p>
      A non-exhaustive enum can be created by adding a trailing <code>_</code> field.
      The enum must specify a tag type and cannot consume every enumeration value.
      </p>
      <p>
      <a href="#enumFromInt">@enumFromInt</a> on a non-exhaustive enum involves the safety semantics
      of <a href="#intCast">@intCast</a> to the integer tag type, but beyond that always results in
      a well-defined enum value.
      </p>
      <p>
      A switch on a non-exhaustive enum can include a <code>_</code> prong as an alternative to an <code><span class="tok-kw">else</span></code> prong.
      With a <code>_</code> prong the compiler errors if all the known tag names are not handled by the switch.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_switch_non-exhaustive.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Number = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {
    one,
    two,
    three,
    _,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;switch on non-exhaustive enum&quot;</span> {
    <span class="tok-kw">const</span> number = Number.one;
    <span class="tok-kw">const</span> result = <span class="tok-kw">switch</span> (number) {
        .one =&gt; <span class="tok-null">true</span>,
        .two, .three =&gt; <span class="tok-null">false</span>,
        _ =&gt; <span class="tok-null">false</span>,
    };
    <span class="tok-kw">try</span> expect(result);
    <span class="tok-kw">const</span> is_one = <span class="tok-kw">switch</span> (number) {
        .one =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };
    <span class="tok-kw">try</span> expect(is_one);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch_non-exhaustive.zig</kbd>
1/1 test_switch_non-exhaustive.test.switch on non-exhaustive enum...OK
All 1 tests passed.
</samp></pre></figure>

      
      

      <h2 id="union"><a href="#toc-union">union</a> <a class="hdr" href="#union">§</a></h2>

      <p>
      A bare <code><span class="tok-kw">union</span></code> defines a set of possible types that a value
      can be as a list of fields. Only one field can be active at a time.
      The in-memory representation of bare unions is not guaranteed.
      Bare unions cannot be used to reinterpret memory. For that, use <a href="#ptrCast">@ptrCast</a>,
      or use an <a href="#extern-union">extern union</a> or a <a href="#packed-union">packed union</a> which have
      guaranteed in-memory layout.
      <a href="#Wrong-Union-Field-Access">Accessing the non-active field</a> is
      safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_wrong_union_access.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Payload = <span class="tok-kw">union</span> {
    int: <span class="tok-type">i64</span>,
    float: <span class="tok-type">f64</span>,
    boolean: <span class="tok-type">bool</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;simple union&quot;</span> {
    <span class="tok-kw">var</span> payload = Payload{ .int = <span class="tok-number">1234</span> };
    payload.float = <span class="tok-number">12.34</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_wrong_union_access.zig</kbd>
1/1 test_wrong_union_access.test.simple union...thread 221884 panic: access of union field 'float' while field 'int' is active
<span class="sgr-1m">/home/andy/src/zig/doc/langref/test_wrong_union_access.zig:8:12</span>: <span class="sgr-2m">0x1048aef in test.simple union (test)</span>
    payload.float = 12.34;
           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:214:25</span>: <span class="sgr-2m">0x10ef005 in mainTerminal (test)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:62:28</span>: <span class="sgr-2m">0x10e759d in main (test)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10e6b22 in posixCallMainAndExit (test)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10e66fd in _start (test)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/src/zig/.zig-cache/o/cc43f9aad019d16b70a651087b598133/test --seed=0x94ba4c6a
</samp></pre></figure>

      <p>You can activate another field by assigning the entire union:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_simple_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Payload = <span class="tok-kw">union</span> {
    int: <span class="tok-type">i64</span>,
    float: <span class="tok-type">f64</span>,
    boolean: <span class="tok-type">bool</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;simple union&quot;</span> {
    <span class="tok-kw">var</span> payload = Payload{ .int = <span class="tok-number">1234</span> };
    <span class="tok-kw">try</span> expect(payload.int == <span class="tok-number">1234</span>);
    payload = Payload{ .float = <span class="tok-number">12.34</span> };
    <span class="tok-kw">try</span> expect(payload.float == <span class="tok-number">12.34</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_simple_union.zig</kbd>
1/1 test_simple_union.test.simple union...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      In order to use <a href="#switch">switch</a> with a union, it must be a <a href="#Tagged-union">Tagged union</a>.
      </p>
      <p>
      To initialize a union when the tag is a <a href="#comptime">comptime</a>-known name, see <a href="#unionInit">@unionInit</a>.
      </p>

      <h3 id="Tagged-union"><a href="#toc-Tagged-union">Tagged union</a> <a class="hdr" href="#Tagged-union">§</a></h3>

      <p>Unions can be declared with an enum tag type.
      This turns the union into a <em>tagged</em> union, which makes it eligible
      to use with <a href="#switch">switch</a> expressions.
      Tagged unions coerce to their tag type: <a href="#Type-Coercion-Unions-and-Enums">Type Coercion: Unions and Enums</a>.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_tagged_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> ComplexTypeTag = <span class="tok-kw">enum</span> {
    ok,
    not_ok,
};
<span class="tok-kw">const</span> ComplexType = <span class="tok-kw">union</span>(ComplexTypeTag) {
    ok: <span class="tok-type">u8</span>,
    not_ok: <span class="tok-type">void</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;switch on tagged union&quot;</span> {
    <span class="tok-kw">const</span> c = ComplexType{ .ok = <span class="tok-number">42</span> };
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@as</span>(ComplexTypeTag, c) == ComplexTypeTag.ok);

    <span class="tok-kw">switch</span> (c) {
        .ok =&gt; |value| <span class="tok-kw">try</span> expect(value == <span class="tok-number">42</span>),
        .not_ok =&gt; <span class="tok-kw">unreachable</span>,
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;get tag type&quot;</span> {
    <span class="tok-kw">try</span> expect(std.meta.Tag(ComplexType) == ComplexTypeTag);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_tagged_union.zig</kbd>
1/2 test_tagged_union.test.switch on tagged union...OK
2/2 test_tagged_union.test.get tag type...OK
All 2 tests passed.
</samp></pre></figure>

      <p>In order to modify the payload of a tagged union in a switch expression,
      place a <code>*</code> before the variable name to make it a pointer:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_switch_modify_tagged_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> ComplexTypeTag = <span class="tok-kw">enum</span> {
    ok,
    not_ok,
};
<span class="tok-kw">const</span> ComplexType = <span class="tok-kw">union</span>(ComplexTypeTag) {
    ok: <span class="tok-type">u8</span>,
    not_ok: <span class="tok-type">void</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;modify tagged union in switch&quot;</span> {
    <span class="tok-kw">var</span> c = ComplexType{ .ok = <span class="tok-number">42</span> };

    <span class="tok-kw">switch</span> (c) {
        ComplexTypeTag.ok =&gt; |*value| value.* += <span class="tok-number">1</span>,
        ComplexTypeTag.not_ok =&gt; <span class="tok-kw">unreachable</span>,
    }

    <span class="tok-kw">try</span> expect(c.ok == <span class="tok-number">43</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch_modify_tagged_union.zig</kbd>
1/1 test_switch_modify_tagged_union.test.modify tagged union in switch...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Unions can be made to infer the enum tag type.
      Further, unions can have methods just like structs and enums.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_union_method.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Variant = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    int: <span class="tok-type">i32</span>,
    boolean: <span class="tok-type">bool</span>,

    <span class="tok-comment">// void can be omitted when inferring enum tag type.</span>
    none,

    <span class="tok-kw">fn</span> <span class="tok-fn">truthy</span>(self: Variant) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
            Variant.int =&gt; |x_int| x_int != <span class="tok-number">0</span>,
            Variant.boolean =&gt; |x_bool| x_bool,
            Variant.none =&gt; <span class="tok-null">false</span>,
        };
    }
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;union method&quot;</span> {
    <span class="tok-kw">var</span> v1: Variant = .{ .int = <span class="tok-number">1</span> };
    <span class="tok-kw">var</span> v2: Variant = .{ .boolean = <span class="tok-null">false</span> };
    <span class="tok-kw">var</span> v3: Variant = .none;

    <span class="tok-kw">try</span> expect(v1.truthy());
    <span class="tok-kw">try</span> expect(!v2.truthy());
    <span class="tok-kw">try</span> expect(!v3.truthy());
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_union_method.zig</kbd>
1/1 test_union_method.test.union method...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      <a href="#tagName">@tagName</a> can be used to return a <a href="#comptime">comptime</a>
      <code>[:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code> value representing the field name:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_tagName.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Small2 = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    a: <span class="tok-type">i32</span>,
    b: <span class="tok-type">bool</span>,
    c: <span class="tok-type">u8</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;@tagName&quot;</span> {
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@tagName</span>(Small2.a), <span class="tok-str">&quot;a&quot;</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_tagName.zig</kbd>
1/1 test_tagName.test.@tagName...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="extern-union"><a href="#toc-extern-union">extern union</a> <a class="hdr" href="#extern-union">§</a></h3>

      <p>
      An <code><span class="tok-kw">extern</span> <span class="tok-kw">union</span></code> has memory layout guaranteed to be compatible with
      the target C ABI.
      </p>
      <p>See also:</p><ul>
<li><a href="#extern-struct">extern struct</a></li>
</ul>

      

      <h3 id="packed-union"><a href="#toc-packed-union">packed union</a> <a class="hdr" href="#packed-union">§</a></h3>

      <p>A <code><span class="tok-kw">packed</span> <span class="tok-kw">union</span></code> has well-defined in-memory layout and is eligible
          to be in a <a href="#packed-struct">packed struct</a>.</p>
      

      <h3 id="Anonymous-Union-Literals"><a href="#toc-Anonymous-Union-Literals">Anonymous Union Literals</a> <a class="hdr" href="#Anonymous-Union-Literals">§</a></h3>

      <p><a href="#Anonymous-Struct-Literals">Anonymous Struct Literals</a> syntax can be used to initialize unions without specifying
      the type:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_anonymous_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Number = <span class="tok-kw">union</span> {
    int: <span class="tok-type">i32</span>,
    float: <span class="tok-type">f64</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;anonymous union literal syntax&quot;</span> {
    <span class="tok-kw">const</span> i: Number = .{ .int = <span class="tok-number">42</span> };
    <span class="tok-kw">const</span> f = makeNumber();
    <span class="tok-kw">try</span> expect(i.int == <span class="tok-number">42</span>);
    <span class="tok-kw">try</span> expect(f.float == <span class="tok-number">12.34</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">makeNumber</span>() Number {
    <span class="tok-kw">return</span> .{ .float = <span class="tok-number">12.34</span> };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_anonymous_union.zig</kbd>
1/1 test_anonymous_union.test.anonymous union literal syntax...OK
All 1 tests passed.
</samp></pre></figure>

      

      

      <h2 id="opaque"><a href="#toc-opaque">opaque</a> <a class="hdr" href="#opaque">§</a></h2>

      <p>
      <code><span class="tok-kw">opaque</span> {}</code> declares a new type with an unknown (but non-zero) size and alignment.
      It can contain declarations the same as <a href="#struct">structs</a>, <a href="#union">unions</a>,
      and <a href="#enum">enums</a>.
      </p>
      <p>
      This is typically used for type safety when interacting with C code that does not expose struct details.
      Example:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_opaque.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Derp = <span class="tok-kw">opaque</span> {};
<span class="tok-kw">const</span> Wat = <span class="tok-kw">opaque</span> {};

<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(d: *Derp) <span class="tok-type">void</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(w: *Wat) <span class="tok-kw">callconv</span>(.C) <span class="tok-type">void</span> {
    bar(w);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;call foo&quot;</span> {
    foo(<span class="tok-null">undefined</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_opaque.zig</kbd>
<span class="sgr-1m">doc/langref/test_opaque.zig:6:9: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type '*test_opaque.Derp', found '*test_opaque.Wat'
</span>    bar(w);
        <span class="sgr-32m">^
</span><span class="sgr-1m">doc/langref/test_opaque.zig:6:9: </span><span class="sgr-36m">note: </span><span class="sgr-1m">pointer type child 'test_opaque.Wat' cannot cast into pointer type child 'test_opaque.Derp'
</span><span class="sgr-1m">doc/langref/test_opaque.zig:2:13: </span><span class="sgr-36m">note: </span><span class="sgr-1m">opaque declared here
</span>const Wat = opaque {};
            <span class="sgr-32m">^~~~~~~~~
</span><span class="sgr-1m">doc/langref/test_opaque.zig:1:14: </span><span class="sgr-36m">note: </span><span class="sgr-1m">opaque declared here
</span>const Derp = opaque {};
             <span class="sgr-32m">^~~~~~~~~
</span><span class="sgr-1m">doc/langref/test_opaque.zig:4:18: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter type declared here
</span>extern fn bar(d: *Derp) void;
                 <span class="sgr-32m">^~~~~
</span>
</samp></pre></figure>

      

      <h2 id="Blocks"><a href="#toc-Blocks">Blocks</a> <a class="hdr" href="#Blocks">§</a></h2>

      <p>
      Blocks are used to limit the scope of variable declarations:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_blocks.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;access variable after block scope&quot;</span> {
    {
        <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
        _ = &amp;x;
    }
    x += <span class="tok-number">1</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_blocks.zig</kbd>
<span class="sgr-1m">doc/langref/test_blocks.zig:6:5: </span><span class="sgr-31m">error: </span><span class="sgr-1m">use of undeclared identifier 'x'
</span>    x += 1;
    <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <p>Blocks are expressions. When labeled, <code><span class="tok-kw">break</span></code> can be used
      to return a value from the block:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_labeled_break.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;labeled break from labeled block expression&quot;</span> {
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">123</span>;

    <span class="tok-kw">const</span> x = blk: {
        y += <span class="tok-number">1</span>;
        <span class="tok-kw">break</span> :blk y;
    };
    <span class="tok-kw">try</span> expect(x == <span class="tok-number">124</span>);
    <span class="tok-kw">try</span> expect(y == <span class="tok-number">124</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_labeled_break.zig</kbd>
1/1 test_labeled_break.test.labeled break from labeled block expression...OK
All 1 tests passed.
</samp></pre></figure>

      <p>Here, <code>blk</code> can be any name.</p>
      <p>See also:</p><ul>
<li><a href="#Labeled-while">Labeled while</a></li>
<li><a href="#Labeled-for">Labeled for</a></li>
</ul>


      <h3 id="Shadowing"><a href="#toc-Shadowing">Shadowing</a> <a class="hdr" href="#Shadowing">§</a></h3>

      <p><a href="#Identifiers">Identifiers</a> are never allowed to "hide" other identifiers by using the same name:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_shadowing.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> pi = <span class="tok-number">3.14</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;inside test block&quot;</span> {
    <span class="tok-comment">// Let's even go inside another block</span>
    {
        <span class="tok-kw">var</span> pi: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_shadowing.zig</kbd>
<span class="sgr-1m">doc/langref/test_shadowing.zig:6:13: </span><span class="sgr-31m">error: </span><span class="sgr-1m">local variable shadows declaration of 'pi'
</span>        var pi: i32 = 1234;
            <span class="sgr-32m">^~
</span><span class="sgr-1m">doc/langref/test_shadowing.zig:1:1: </span><span class="sgr-36m">note: </span><span class="sgr-1m">declared here
</span>const pi = 3.14;
<span class="sgr-32m">^~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>
      Because of this, when you read Zig code you can always rely on an identifier to consistently mean
      the same thing within the scope it is defined. Note that you can, however, use the same name if
      the scopes are separate:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_scopes.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;separate scopes&quot;</span> {
    {
        <span class="tok-kw">const</span> pi = <span class="tok-number">3.14</span>;
        _ = pi;
    }
    {
        <span class="tok-kw">var</span> pi: <span class="tok-type">bool</span> = <span class="tok-null">true</span>;
        _ = &amp;pi;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_scopes.zig</kbd>
1/1 test_scopes.test.separate scopes...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Empty-Blocks"><a href="#toc-Empty-Blocks">Empty Blocks</a> <a class="hdr" href="#Empty-Blocks">§</a></h3>

      <p>An empty block is equivalent to <code><span class="tok-type">void</span>{}</code>:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_empty_block.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> {
    <span class="tok-kw">const</span> a = {};
    <span class="tok-kw">const</span> b = <span class="tok-type">void</span>{};
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(a) == <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(b) == <span class="tok-type">void</span>);
    <span class="tok-kw">try</span> expect(a == b);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_empty_block.zig</kbd>
1/1 test_empty_block.test_0...OK
All 1 tests passed.
</samp></pre></figure>

      
      

      <h2 id="switch"><a href="#toc-switch">switch</a> <a class="hdr" href="#switch">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_switch.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;switch simple&quot;</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u64</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> zz: <span class="tok-type">u64</span> = <span class="tok-number">103</span>;

    <span class="tok-comment">// All branches of a switch expression must be able to be coerced to a</span>
    <span class="tok-comment">// common type.</span>
    <span class="tok-comment">//</span>
    <span class="tok-comment">// Branches cannot fallthrough. If fallthrough behavior is desired, combine</span>
    <span class="tok-comment">// the cases and use an if.</span>
    <span class="tok-kw">const</span> b = <span class="tok-kw">switch</span> (a) {
        <span class="tok-comment">// Multiple cases can be combined via a ','</span>
        <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> =&gt; <span class="tok-number">0</span>,

        <span class="tok-comment">// Ranges can be specified using the ... syntax. These are inclusive</span>
        <span class="tok-comment">// of both ends.</span>
        <span class="tok-number">5</span>...<span class="tok-number">100</span> =&gt; <span class="tok-number">1</span>,

        <span class="tok-comment">// Branches can be arbitrarily complex.</span>
        <span class="tok-number">101</span> =&gt; blk: {
            <span class="tok-kw">const</span> c: <span class="tok-type">u64</span> = <span class="tok-number">5</span>;
            <span class="tok-kw">break</span> :blk c * <span class="tok-number">2</span> + <span class="tok-number">1</span>;
        },

        <span class="tok-comment">// Switching on arbitrary expressions is allowed as long as the</span>
        <span class="tok-comment">// expression is known at compile-time.</span>
        zz =&gt; zz,
        blk: {
            <span class="tok-kw">const</span> d: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
            <span class="tok-kw">const</span> e: <span class="tok-type">u32</span> = <span class="tok-number">100</span>;
            <span class="tok-kw">break</span> :blk d + e;
        } =&gt; <span class="tok-number">107</span>,

        <span class="tok-comment">// The else branch catches everything not already captured.</span>
        <span class="tok-comment">// Else branches are mandatory unless the entire range of values</span>
        <span class="tok-comment">// is handled.</span>
        <span class="tok-kw">else</span> =&gt; <span class="tok-number">9</span>,
    };

    <span class="tok-kw">try</span> expect(b == <span class="tok-number">1</span>);
}

<span class="tok-comment">// Switch expressions can be used outside a function:</span>
<span class="tok-kw">const</span> os_msg = <span class="tok-kw">switch</span> (builtin.target.os.tag) {
    .linux =&gt; <span class="tok-str">&quot;we found a linux user&quot;</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;not a linux user&quot;</span>,
};

<span class="tok-comment">// Inside a function, switch statements implicitly are compile-time</span>
<span class="tok-comment">// evaluated if the target expression is compile-time known.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;switch inside function&quot;</span> {
    <span class="tok-kw">switch</span> (builtin.target.os.tag) {
        .fuchsia =&gt; {
            <span class="tok-comment">// On an OS other than fuchsia, block is not even analyzed,</span>
            <span class="tok-comment">// so this compile error is not triggered.</span>
            <span class="tok-comment">// On fuchsia this compile error would be triggered.</span>
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;fuchsia not supported&quot;</span>);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch.zig</kbd>
1/2 test_switch.test.switch simple...OK
2/2 test_switch.test.switch inside function...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
      <code><span class="tok-kw">switch</span></code> can be used to capture the field values
      of a <a href="#Tagged-union">Tagged union</a>. Modifications to the field values can be
      done by placing a <code>*</code> before the capture variable name,
      turning it into a pointer.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_switch_tagged_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;switch on tagged union&quot;</span> {
    <span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
        x: <span class="tok-type">u8</span>,
        y: <span class="tok-type">u8</span>,
    };
    <span class="tok-kw">const</span> Item = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        a: <span class="tok-type">u32</span>,
        c: Point,
        d,
        e: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">var</span> a = Item{ .c = Point{ .x = <span class="tok-number">1</span>, .y = <span class="tok-number">2</span> } };

    <span class="tok-comment">// Switching on more complex enums is allowed.</span>
    <span class="tok-kw">const</span> b = <span class="tok-kw">switch</span> (a) {
        <span class="tok-comment">// A capture group is allowed on a match, and will return the enum</span>
        <span class="tok-comment">// value matched. If the payload types of both cases are the same</span>
        <span class="tok-comment">// they can be put into the same switch prong.</span>
        Item.a, Item.e =&gt; |item| item,

        <span class="tok-comment">// A reference to the matched value can be obtained using `*` syntax.</span>
        Item.c =&gt; |*item| blk: {
            item.*.x += <span class="tok-number">1</span>;
            <span class="tok-kw">break</span> :blk <span class="tok-number">6</span>;
        },

        <span class="tok-comment">// No else is required if the types cases was exhaustively handled</span>
        Item.d =&gt; <span class="tok-number">8</span>,
    };

    <span class="tok-kw">try</span> expect(b == <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> expect(a.c.x == <span class="tok-number">2</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch_tagged_union.zig</kbd>
1/1 test_switch_tagged_union.test.switch on tagged union...OK
All 1 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#comptime">comptime</a></li>
<li><a href="#enum">enum</a></li>
<li><a href="#compileError">@compileError</a></li>
<li><a href="#Compile-Variables">Compile Variables</a></li>
</ul>


      <h3 id="Exhaustive-Switching"><a href="#toc-Exhaustive-Switching">Exhaustive Switching</a> <a class="hdr" href="#Exhaustive-Switching">§</a></h3>

      <p>
      When a <code><span class="tok-kw">switch</span></code> expression does not have an <code><span class="tok-kw">else</span></code> clause,
      it must exhaustively list all the possible values. Failure to do so is a compile error:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_unhandled_enumeration_value.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Color = <span class="tok-kw">enum</span> {
    auto,
    off,
    on,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;exhaustive switching&quot;</span> {
    <span class="tok-kw">const</span> color = Color.off;
    <span class="tok-kw">switch</span> (color) {
        Color.auto =&gt; {},
        Color.on =&gt; {},
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_unhandled_enumeration_value.zig</kbd>
<span class="sgr-1m">doc/langref/test_unhandled_enumeration_value.zig:9:5: </span><span class="sgr-31m">error: </span><span class="sgr-1m">switch must handle all possibilities
</span>    switch (color) {
    <span class="sgr-32m">^~~~~~
</span><span class="sgr-1m">doc/langref/test_unhandled_enumeration_value.zig:3:5: </span><span class="sgr-36m">note: </span><span class="sgr-1m">unhandled enumeration value: 'off'
</span>    off,
    <span class="sgr-32m">^~~
</span><span class="sgr-1m">doc/langref/test_unhandled_enumeration_value.zig:1:15: </span><span class="sgr-36m">note: </span><span class="sgr-1m">enum 'test_unhandled_enumeration_value.Color' declared here
</span>const Color = enum {
              <span class="sgr-32m">^~~~
</span>
</samp></pre></figure>

      

      <h3 id="Switching-with-Enum-Literals"><a href="#toc-Switching-with-Enum-Literals">Switching with Enum Literals</a> <a class="hdr" href="#Switching-with-Enum-Literals">§</a></h3>

      <p>
      <a href="#Enum-Literals">Enum Literals</a> can be useful to use with <code><span class="tok-kw">switch</span></code> to avoid
      repetitively specifying <a href="#enum">enum</a> or <a href="#union">union</a> types:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_exhaustive_switch.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Color = <span class="tok-kw">enum</span> {
    auto,
    off,
    on,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;enum literals with switch&quot;</span> {
    <span class="tok-kw">const</span> color = Color.off;
    <span class="tok-kw">const</span> result = <span class="tok-kw">switch</span> (color) {
        .auto =&gt; <span class="tok-null">false</span>,
        .on =&gt; <span class="tok-null">false</span>,
        .off =&gt; <span class="tok-null">true</span>,
    };
    <span class="tok-kw">try</span> expect(result);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_exhaustive_switch.zig</kbd>
1/1 test_exhaustive_switch.test.enum literals with switch...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="Labeled-switch"><a href="#toc-Labeled-switch">Labeled switch</a> <a class="hdr" href="#Labeled-switch">§</a></h3>

      <p>
      When a switch statement is labeled, it can be referenced from a
      <code><span class="tok-kw">break</span></code> or <code><span class="tok-kw">continue</span></code>.
      <code><span class="tok-kw">break</span></code> will return a value from the <code><span class="tok-kw">switch</span></code>.
      </p>
      <p>
      A <code><span class="tok-kw">continue</span></code> targeting a switch must have an
      operand. When executed, it will jump to the matching prong, as if the
      <code><span class="tok-kw">switch</span></code> were executed again with the <code><span class="tok-kw">continue</span></code>'s operand replacing the initial switch value.
      </p>

      <figure><figcaption class="zig-cap"><cite class="file">test_switch_continue.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;switch continue&quot;</span> {
    sw: <span class="tok-kw">switch</span> (<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">5</span>)) {
        <span class="tok-number">5</span> =&gt; <span class="tok-kw">continue</span> :sw <span class="tok-number">4</span>,

        <span class="tok-comment">// `continue` can occur multiple times within a single switch prong.</span>
        <span class="tok-number">2</span>...<span class="tok-number">4</span> =&gt; |v| {
            <span class="tok-kw">if</span> (v &gt; <span class="tok-number">3</span>) {
                <span class="tok-kw">continue</span> :sw <span class="tok-number">2</span>;
            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (v == <span class="tok-number">3</span>) {

                <span class="tok-comment">// `break` can target labeled loops.</span>
                <span class="tok-kw">break</span> :sw;
            }

            <span class="tok-kw">continue</span> :sw <span class="tok-number">1</span>;
        },

        <span class="tok-number">1</span> =&gt; <span class="tok-kw">return</span>,

        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch_continue.zig</kbd>
1/1 test_switch_continue.test.switch continue...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Semantically, this is equivalent to the following loop:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_switch_continue_equivalent.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;switch continue, equivalent loop&quot;</span> {
    <span class="tok-kw">var</span> sw: <span class="tok-type">i32</span> = <span class="tok-number">5</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">switch</span> (sw) {
            <span class="tok-number">5</span> =&gt; {
                sw = <span class="tok-number">4</span>;
                <span class="tok-kw">continue</span>;
            },
            <span class="tok-number">2</span>...<span class="tok-number">4</span> =&gt; |v| {
                <span class="tok-kw">if</span> (v &gt; <span class="tok-number">3</span>) {
                    sw = <span class="tok-number">2</span>;
                    <span class="tok-kw">continue</span>;
                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (v == <span class="tok-number">3</span>) {
                    <span class="tok-kw">break</span>;
                }

                sw = <span class="tok-number">1</span>;
                <span class="tok-kw">continue</span>;
            },
            <span class="tok-number">1</span> =&gt; <span class="tok-kw">return</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        }
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch_continue_equivalent.zig</kbd>
1/1 test_switch_continue_equivalent.test.switch continue, equivalent loop...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      This can improve clarity of (for example) state machines, where the syntax <code><span class="tok-kw">continue</span> :sw .next_state</code> is unambiguous, explicit, and immediately understandable.
      </p>
      <p>
      However, the motivating example is a switch on each element of an array, where using a single switch can improve clarity and performance:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_switch_dispatch_loop.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expectEqual = std.testing.expectEqual;

<span class="tok-kw">const</span> Instruction = <span class="tok-kw">enum</span> {
    add,
    mul,
    end,
};

<span class="tok-kw">fn</span> <span class="tok-fn">evaluate</span>(initial_stack: []<span class="tok-kw">const</span> <span class="tok-type">i32</span>, code: []<span class="tok-kw">const</span> Instruction) !<span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> stack = <span class="tok-kw">try</span> std.BoundedArray(<span class="tok-type">i32</span>, <span class="tok-number">8</span>).fromSlice(initial_stack);
    <span class="tok-kw">var</span> ip: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">return</span> vm: <span class="tok-kw">switch</span> (code[ip]) {
        <span class="tok-comment">// Because all code after `continue` is unreachable, this branch does</span>
        <span class="tok-comment">// not provide a result.</span>
        .add =&gt; {
            <span class="tok-kw">try</span> stack.append(stack.pop().? + stack.pop().?);

            ip += <span class="tok-number">1</span>;
            <span class="tok-kw">continue</span> :vm code[ip];
        },
        .mul =&gt; {
            <span class="tok-kw">try</span> stack.append(stack.pop().? * stack.pop().?);

            ip += <span class="tok-number">1</span>;
            <span class="tok-kw">continue</span> :vm code[ip];
        },
        .end =&gt; stack.pop().?,
    };
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;evaluate&quot;</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> evaluate(&amp;.{ <span class="tok-number">7</span>, <span class="tok-number">2</span>, -<span class="tok-number">3</span> }, &amp;.{ .mul, .add, .end });
    <span class="tok-kw">try</span> expectEqual(<span class="tok-number">1</span>, result);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_switch_dispatch_loop.zig</kbd>
1/1 test_switch_dispatch_loop.test.evaluate...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      If the operand to <code><span class="tok-kw">continue</span></code> is
      <a href="#comptime">comptime</a>-known, then it can be lowered to an unconditional branch
      to the relevant case. Such a branch is perfectly predicted, and hence
      typically very fast to execute.
      </p>

      <p>
      If the operand is runtime-known, each <code><span class="tok-kw">continue</span></code> can
      embed a conditional branch inline (ideally through a jump table), which
      allows a CPU to predict its target independently of any other prong. A
      loop-based lowering would force every branch through the same dispatch
      point, hindering branch prediction.
      </p>


      

      <h3 id="Inline-Switch-Prongs"><a href="#toc-Inline-Switch-Prongs">Inline Switch Prongs</a> <a class="hdr" href="#Inline-Switch-Prongs">§</a></h3>

      <p>
      Switch prongs can be marked as <code><span class="tok-kw">inline</span></code> to generate
      the prong's body for each possible value it could have, making the
      captured value <a href="#comptime">comptime</a>.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_inline_switch.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> expectError = std.testing.expectError;

<span class="tok-kw">fn</span> <span class="tok-fn">isFieldOptional</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, field_index: <span class="tok-type">usize</span>) !<span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(T).@&quot;struct&quot;.fields;
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (field_index) {
        <span class="tok-comment">// This prong is analyzed twice with `idx` being a</span>
        <span class="tok-comment">// comptime-known value each time.</span>
        <span class="tok-kw">inline</span> <span class="tok-number">0</span>, <span class="tok-number">1</span> =&gt; |idx| <span class="tok-builtin">@typeInfo</span>(fields[idx].<span class="tok-type">type</span>) == .optional,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IndexOutOfBounds,
    };
}

<span class="tok-kw">const</span> Struct1 = <span class="tok-kw">struct</span> { a: <span class="tok-type">u32</span>, b: ?<span class="tok-type">u32</span> };

<span class="tok-kw">test</span> <span class="tok-str">&quot;using @typeInfo with runtime values&quot;</span> {
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">try</span> expect(!<span class="tok-kw">try</span> isFieldOptional(Struct1, index));
    index += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(<span class="tok-kw">try</span> isFieldOptional(Struct1, index));
    index += <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expectError(<span class="tok-kw">error</span>.IndexOutOfBounds, isFieldOptional(Struct1, index));
}

<span class="tok-comment">// Calls to `isFieldOptional` on `Struct1` get unrolled to an equivalent</span>
<span class="tok-comment">// of this function:</span>
<span class="tok-kw">fn</span> <span class="tok-fn">isFieldOptionalUnrolled</span>(field_index: <span class="tok-type">usize</span>) !<span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (field_index) {
        <span class="tok-number">0</span> =&gt; <span class="tok-null">false</span>,
        <span class="tok-number">1</span> =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IndexOutOfBounds,
    };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_inline_switch.zig</kbd>
1/1 test_inline_switch.test.using @typeInfo with runtime values...OK
All 1 tests passed.
</samp></pre></figure>

      <p>The <code><span class="tok-kw">inline</span></code> keyword may also be combined with ranges:</p>
      <figure><figcaption class="zig-cap"><cite class="file">inline_prong_range.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">isFieldOptional</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, field_index: <span class="tok-type">usize</span>) !<span class="tok-type">bool</span> {
    <span class="tok-kw">const</span> fields = <span class="tok-builtin">@typeInfo</span>(T).@&quot;struct&quot;.fields;
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (field_index) {
        <span class="tok-kw">inline</span> <span class="tok-number">0</span>...fields.len - <span class="tok-number">1</span> =&gt; |idx| <span class="tok-builtin">@typeInfo</span>(fields[idx].<span class="tok-type">type</span>) == .optional,
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IndexOutOfBounds,
    };
}</code></pre></figure>

      <p>
      <code><span class="tok-kw">inline</span> <span class="tok-kw">else</span></code> prongs can be used as a type safe
      alternative to <code><span class="tok-kw">inline</span> <span class="tok-kw">for</span></code> loops:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_inline_else.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> SliceTypeA = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
    len: <span class="tok-type">usize</span>,
    ptr: [*]<span class="tok-type">u32</span>,
};
<span class="tok-kw">const</span> SliceTypeB = <span class="tok-kw">extern</span> <span class="tok-kw">struct</span> {
    ptr: [*]SliceTypeA,
    len: <span class="tok-type">usize</span>,
};
<span class="tok-kw">const</span> AnySlice = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    a: SliceTypeA,
    b: SliceTypeB,
    c: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    d: []AnySlice,
};

<span class="tok-kw">fn</span> <span class="tok-fn">withFor</span>(any: AnySlice) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> Tag = <span class="tok-builtin">@typeInfo</span>(AnySlice).@&quot;union&quot;.tag_type.?;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (<span class="tok-builtin">@typeInfo</span>(Tag).@&quot;enum&quot;.fields) |field| {
        <span class="tok-comment">// With `inline for` the function gets generated as</span>
        <span class="tok-comment">// a series of `if` statements relying on the optimizer</span>
        <span class="tok-comment">// to convert it to a switch.</span>
        <span class="tok-kw">if</span> (field.value == <span class="tok-builtin">@intFromEnum</span>(any)) {
            <span class="tok-kw">return</span> <span class="tok-builtin">@field</span>(any, field.name).len;
        }
    }
    <span class="tok-comment">// When using `inline for` the compiler doesn't know that every</span>
    <span class="tok-comment">// possible case has been handled requiring an explicit `unreachable`.</span>
    <span class="tok-kw">unreachable</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">withSwitch</span>(any: AnySlice) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (any) {
        <span class="tok-comment">// With `inline else` the function is explicitly generated</span>
        <span class="tok-comment">// as the desired switch and the compiler can check that</span>
        <span class="tok-comment">// every possible case is handled.</span>
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |slice| slice.len,
    };
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;inline for and inline else similarity&quot;</span> {
    <span class="tok-kw">const</span> any = AnySlice{ .c = <span class="tok-str">&quot;hello&quot;</span> };
    <span class="tok-kw">try</span> expect(withFor(any) == <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> expect(withSwitch(any) == <span class="tok-number">5</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_inline_else.zig</kbd>
1/1 test_inline_else.test.inline for and inline else similarity...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      When using an inline prong switching on an union an additional
      capture can be used to obtain the union's enum tag value.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_inline_switch_union_tag.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> U = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    a: <span class="tok-type">u32</span>,
    b: <span class="tok-type">f32</span>,
};

<span class="tok-kw">fn</span> <span class="tok-fn">getNum</span>(u: U) <span class="tok-type">u32</span> {
    <span class="tok-kw">switch</span> (u) {
        <span class="tok-comment">// Here `num` is a runtime-known value that is either</span>
        <span class="tok-comment">// `u.a` or `u.b` and `tag` is `u`'s comptime-known tag value.</span>
        <span class="tok-kw">inline</span> <span class="tok-kw">else</span> =&gt; |num, tag| {
            <span class="tok-kw">if</span> (tag == .b) {
                <span class="tok-kw">return</span> <span class="tok-builtin">@intFromFloat</span>(num);
            }
            <span class="tok-kw">return</span> num;
        },
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;test&quot;</span> {
    <span class="tok-kw">const</span> u = U{ .b = <span class="tok-number">42</span> };
    <span class="tok-kw">try</span> expect(getNum(u) == <span class="tok-number">42</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_inline_switch_union_tag.zig</kbd>
1/1 test_inline_switch_union_tag.test.test...OK
All 1 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#inline-while">inline while</a></li>
<li><a href="#inline-for">inline for</a></li>
</ul>

      
      

      <h2 id="while"><a href="#toc-while">while</a> <a class="hdr" href="#while">§</a></h2>

      <p>
      A while loop is used to repeatedly execute an expression until
      some condition is no longer true.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while basic&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) {
        i += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">try</span> expect(i == <span class="tok-number">10</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while.zig</kbd>
1/1 test_while.test.while basic...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Use <code><span class="tok-kw">break</span></code> to exit a while loop early.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while_break.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while break&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">if</span> (i == <span class="tok-number">10</span>)
            <span class="tok-kw">break</span>;
        i += <span class="tok-number">1</span>;
    }
    <span class="tok-kw">try</span> expect(i == <span class="tok-number">10</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while_break.zig</kbd>
1/1 test_while_break.test.while break...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Use <code><span class="tok-kw">continue</span></code> to jump back to the beginning of the loop.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while_continue.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while continue&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        i += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (i &lt; <span class="tok-number">10</span>)
            <span class="tok-kw">continue</span>;
        <span class="tok-kw">break</span>;
    }
    <span class="tok-kw">try</span> expect(i == <span class="tok-number">10</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while_continue.zig</kbd>
1/1 test_while_continue.test.while continue...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      While loops support a continue expression which is executed when the loop
      is continued. The <code><span class="tok-kw">continue</span></code> keyword respects this expression.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while_continue_expression.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while loop continue expression&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {}
    <span class="tok-kw">try</span> expect(i == <span class="tok-number">10</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;while loop continue expression, more complicated&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> j: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">while</span> (i * j &lt; <span class="tok-number">2000</span>) : ({
        i *= <span class="tok-number">2</span>;
        j *= <span class="tok-number">3</span>;
    }) {
        <span class="tok-kw">const</span> my_ij = i * j;
        <span class="tok-kw">try</span> expect(my_ij &lt; <span class="tok-number">2000</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while_continue_expression.zig</kbd>
1/2 test_while_continue_expression.test.while loop continue expression...OK
2/2 test_while_continue_expression.test.while loop continue expression, more complicated...OK
All 2 tests passed.
</samp></pre></figure>

      <p>
      While loops are expressions. The result of the expression is the
      result of the <code><span class="tok-kw">else</span></code> clause of a while loop, which is executed when
      the condition of the while loop is tested as false.
      </p>
      <p>
      <code><span class="tok-kw">break</span></code>, like <code><span class="tok-kw">return</span></code>, accepts a value
              parameter. This is the result of the <code><span class="tok-kw">while</span></code> expression.
                  When you <code><span class="tok-kw">break</span></code> from a while loop, the <code><span class="tok-kw">else</span></code> branch is not
      evaluated.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while_else.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while else&quot;</span> {
    <span class="tok-kw">try</span> expect(rangeHasNumber(<span class="tok-number">0</span>, <span class="tok-number">10</span>, <span class="tok-number">5</span>));
    <span class="tok-kw">try</span> expect(!rangeHasNumber(<span class="tok-number">0</span>, <span class="tok-number">10</span>, <span class="tok-number">15</span>));
}

<span class="tok-kw">fn</span> <span class="tok-fn">rangeHasNumber</span>(begin: <span class="tok-type">usize</span>, end: <span class="tok-type">usize</span>, number: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">var</span> i = begin;
    <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; end) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (i == number) {
            <span class="tok-kw">break</span> <span class="tok-null">true</span>;
        }
    } <span class="tok-kw">else</span> <span class="tok-null">false</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while_else.zig</kbd>
1/1 test_while_else.test.while else...OK
All 1 tests passed.
</samp></pre></figure>

      <h3 id="Labeled-while"><a href="#toc-Labeled-while">Labeled while</a> <a class="hdr" href="#Labeled-while">§</a></h3>

      <p>When a <code><span class="tok-kw">while</span></code> loop is labeled, it can be referenced from a <code><span class="tok-kw">break</span></code>
              or <code><span class="tok-kw">continue</span></code> from within a nested loop:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while_nested_break.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;nested break&quot;</span> {
    outer: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">break</span> :outer;
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;nested continue&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    outer: <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">continue</span> :outer;
        }
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while_nested_break.zig</kbd>
1/2 test_while_nested_break.test.nested break...OK
2/2 test_while_nested_break.test.nested continue...OK
All 2 tests passed.
</samp></pre></figure>

      
      <h3 id="while-with-Optionals"><a href="#toc-while-with-Optionals">while with Optionals</a> <a class="hdr" href="#while-with-Optionals">§</a></h3>

      <p>
      Just like <a href="#if">if</a> expressions, while loops can take an optional as the
      condition and capture the payload. When <a href="#null">null</a> is encountered the loop
      exits.
      </p>
      <p>
      When the <code>|x|</code> syntax is present on a <code><span class="tok-kw">while</span></code> expression,
      the while condition must have an <a href="#Optional-Type">Optional Type</a>.
      </p>
      <p>
      The <code><span class="tok-kw">else</span></code> branch is allowed on optional iteration. In this case, it will
      be executed on the first null value encountered.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while_null_capture.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while null capture&quot;</span> {
    <span class="tok-kw">var</span> sum1: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    numbers_left = <span class="tok-number">3</span>;
    <span class="tok-kw">while</span> (eventuallyNullSequence()) |value| {
        sum1 += value;
    }
    <span class="tok-kw">try</span> expect(sum1 == <span class="tok-number">3</span>);

    <span class="tok-comment">// null capture with an else block</span>
    <span class="tok-kw">var</span> sum2: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    numbers_left = <span class="tok-number">3</span>;
    <span class="tok-kw">while</span> (eventuallyNullSequence()) |value| {
        sum2 += value;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> expect(sum2 == <span class="tok-number">3</span>);
    }

    <span class="tok-comment">// null capture with a continue expression</span>
    <span class="tok-kw">var</span> i: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> sum3: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    numbers_left = <span class="tok-number">3</span>;
    <span class="tok-kw">while</span> (eventuallyNullSequence()) |value| : (i += <span class="tok-number">1</span>) {
        sum3 += value;
    }
    <span class="tok-kw">try</span> expect(i == <span class="tok-number">3</span>);
}

<span class="tok-kw">var</span> numbers_left: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">eventuallyNullSequence</span>() ?<span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (numbers_left == <span class="tok-number">0</span>) <span class="tok-null">null</span> <span class="tok-kw">else</span> blk: {
        numbers_left -= <span class="tok-number">1</span>;
        <span class="tok-kw">break</span> :blk numbers_left;
    };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while_null_capture.zig</kbd>
1/1 test_while_null_capture.test.while null capture...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="while-with-Error-Unions"><a href="#toc-while-with-Error-Unions">while with Error Unions</a> <a class="hdr" href="#while-with-Error-Unions">§</a></h3>

      <p>
      Just like <a href="#if">if</a> expressions, while loops can take an error union as
      the condition and capture the payload or the error code. When the
      condition results in an error code the else branch is evaluated and
      the loop is finished.
      </p>
      <p>
      When the <code><span class="tok-kw">else</span> |x|</code> syntax is present on a <code><span class="tok-kw">while</span></code> expression,
      the while condition must have an <a href="#Error-Union-Type">Error Union Type</a>.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_while_error_capture.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while error union capture&quot;</span> {
    <span class="tok-kw">var</span> sum1: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    numbers_left = <span class="tok-number">3</span>;
    <span class="tok-kw">while</span> (eventuallyErrorSequence()) |value| {
        sum1 += value;
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">try</span> expect(err == <span class="tok-kw">error</span>.ReachedZero);
    }
}

<span class="tok-kw">var</span> numbers_left: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">eventuallyErrorSequence</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (numbers_left == <span class="tok-number">0</span>) <span class="tok-kw">error</span>.ReachedZero <span class="tok-kw">else</span> blk: {
        numbers_left -= <span class="tok-number">1</span>;
        <span class="tok-kw">break</span> :blk numbers_left;
    };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_while_error_capture.zig</kbd>
1/1 test_while_error_capture.test.while error union capture...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="inline-while"><a href="#toc-inline-while">inline while</a> <a class="hdr" href="#inline-while">§</a></h3>

      <p>
      While loops can be inlined. This causes the loop to be unrolled, which
      allows the code to do some things which only work at compile time,
      such as use types as first class values.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_inline_while.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;inline while loop&quot;</span> {
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; <span class="tok-number">3</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> T = <span class="tok-kw">switch</span> (i) {
            <span class="tok-number">0</span> =&gt; <span class="tok-type">f32</span>,
            <span class="tok-number">1</span> =&gt; <span class="tok-type">i8</span>,
            <span class="tok-number">2</span> =&gt; <span class="tok-type">bool</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
        sum += typeNameLength(T);
    }
    <span class="tok-kw">try</span> expect(sum == <span class="tok-number">9</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">typeNameLength</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@typeName</span>(T).len;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_inline_while.zig</kbd>
1/1 test_inline_while.test.inline while loop...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      It is recommended to use <code><span class="tok-kw">inline</span></code> loops only for one of these reasons:
      </p>
      <ul>
        <li>You need the loop to execute at <a href="#comptime">comptime</a> for the semantics to work.</li>
        <li>
        You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.
        </li>
      </ul>
      
      <p>See also:</p><ul>
<li><a href="#if">if</a></li>
<li><a href="#Optionals">Optionals</a></li>
<li><a href="#Errors">Errors</a></li>
<li><a href="#comptime">comptime</a></li>
<li><a href="#unreachable">unreachable</a></li>
</ul>

      
      <h2 id="for"><a href="#toc-for">for</a> <a class="hdr" href="#for">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_for.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;for basics&quot;</span> {
    <span class="tok-kw">const</span> items = [_]<span class="tok-type">i32</span>{ <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">0</span> };
    <span class="tok-kw">var</span> sum: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;

    <span class="tok-comment">// For loops iterate over slices and arrays.</span>
    <span class="tok-kw">for</span> (items) |value| {
        <span class="tok-comment">// Break and continue are supported.</span>
        <span class="tok-kw">if</span> (value == <span class="tok-number">0</span>) {
            <span class="tok-kw">continue</span>;
        }
        sum += value;
    }
    <span class="tok-kw">try</span> expect(sum == <span class="tok-number">16</span>);

    <span class="tok-comment">// To iterate over a portion of a slice, reslice.</span>
    <span class="tok-kw">for</span> (items[<span class="tok-number">0</span>..<span class="tok-number">1</span>]) |value| {
        sum += value;
    }
    <span class="tok-kw">try</span> expect(sum == <span class="tok-number">20</span>);

    <span class="tok-comment">// To access the index of iteration, specify a second condition as well</span>
    <span class="tok-comment">// as a second capture value.</span>
    <span class="tok-kw">var</span> sum2: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (items, <span class="tok-number">0</span>..) |_, i| {
        <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(i) == <span class="tok-type">usize</span>);
        sum2 += <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intCast</span>(i));
    }
    <span class="tok-kw">try</span> expect(sum2 == <span class="tok-number">10</span>);

    <span class="tok-comment">// To iterate over consecutive integers, use the range syntax.</span>
    <span class="tok-comment">// Unbounded range is always a compile error.</span>
    <span class="tok-kw">var</span> sum3: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (<span class="tok-number">0</span>..<span class="tok-number">5</span>) |i| {
        sum3 += i;
    }
    <span class="tok-kw">try</span> expect(sum3 == <span class="tok-number">10</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;multi object for&quot;</span> {
    <span class="tok-kw">const</span> items = [_]<span class="tok-type">usize</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> };
    <span class="tok-kw">const</span> items2 = [_]<span class="tok-type">usize</span>{ <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span> };
    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-comment">// Iterate over multiple objects.</span>
    <span class="tok-comment">// All lengths must be equal at the start of the loop, otherwise detectable</span>
    <span class="tok-comment">// illegal behavior occurs.</span>
    <span class="tok-kw">for</span> (items, items2) |i, j| {
        count += i + j;
    }

    <span class="tok-kw">try</span> expect(count == <span class="tok-number">21</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;for reference&quot;</span> {
    <span class="tok-kw">var</span> items = [_]<span class="tok-type">i32</span>{ <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">2</span> };

    <span class="tok-comment">// Iterate over the slice by reference by</span>
    <span class="tok-comment">// specifying that the capture value is a pointer.</span>
    <span class="tok-kw">for</span> (&amp;items) |*value| {
        value.* += <span class="tok-number">1</span>;
    }

    <span class="tok-kw">try</span> expect(items[<span class="tok-number">0</span>] == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(items[<span class="tok-number">1</span>] == <span class="tok-number">5</span>);
    <span class="tok-kw">try</span> expect(items[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;for else&quot;</span> {
    <span class="tok-comment">// For allows an else attached to it, the same as a while loop.</span>
    <span class="tok-kw">const</span> items = [_]?<span class="tok-type">i32</span>{ <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-null">null</span>, <span class="tok-number">5</span> };

    <span class="tok-comment">// For loops can also be used as expressions.</span>
    <span class="tok-comment">// Similar to while loops, when you break from a for loop, the else branch is not evaluated.</span>
    <span class="tok-kw">var</span> sum: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> result = <span class="tok-kw">for</span> (items) |value| {
        <span class="tok-kw">if</span> (value != <span class="tok-null">null</span>) {
            sum += value.?;
        }
    } <span class="tok-kw">else</span> blk: {
        <span class="tok-kw">try</span> expect(sum == <span class="tok-number">12</span>);
        <span class="tok-kw">break</span> :blk sum;
    };
    <span class="tok-kw">try</span> expect(result == <span class="tok-number">12</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_for.zig</kbd>
1/4 test_for.test.for basics...OK
2/4 test_for.test.multi object for...OK
3/4 test_for.test.for reference...OK
4/4 test_for.test.for else...OK
All 4 tests passed.
</samp></pre></figure>

      <h3 id="Labeled-for"><a href="#toc-Labeled-for">Labeled for</a> <a class="hdr" href="#Labeled-for">§</a></h3>

      <p>When a <code><span class="tok-kw">for</span></code> loop is labeled, it can be referenced from a <code><span class="tok-kw">break</span></code>
              or <code><span class="tok-kw">continue</span></code> from within a nested loop:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_for_nested_break.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;nested break&quot;</span> {
    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    outer: <span class="tok-kw">for</span> (<span class="tok-number">1</span>..<span class="tok-number">6</span>) |_| {
        <span class="tok-kw">for</span> (<span class="tok-number">1</span>..<span class="tok-number">6</span>) |_| {
            count += <span class="tok-number">1</span>;
            <span class="tok-kw">break</span> :outer;
        }
    }
    <span class="tok-kw">try</span> expect(count == <span class="tok-number">1</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;nested continue&quot;</span> {
    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    outer: <span class="tok-kw">for</span> (<span class="tok-number">1</span>..<span class="tok-number">9</span>) |_| {
        <span class="tok-kw">for</span> (<span class="tok-number">1</span>..<span class="tok-number">6</span>) |_| {
            count += <span class="tok-number">1</span>;
            <span class="tok-kw">continue</span> :outer;
        }
    }

    <span class="tok-kw">try</span> expect(count == <span class="tok-number">8</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_for_nested_break.zig</kbd>
1/2 test_for_nested_break.test.nested break...OK
2/2 test_for_nested_break.test.nested continue...OK
All 2 tests passed.
</samp></pre></figure>

      
      <h3 id="inline-for"><a href="#toc-inline-for">inline for</a> <a class="hdr" href="#inline-for">§</a></h3>

      <p>
      For loops can be inlined. This causes the loop to be unrolled, which
      allows the code to do some things which only work at compile time,
      such as use types as first class values.
      The capture value and iterator value of inlined for loops are
      compile-time known.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_inline_for.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;inline for loop&quot;</span> {
    <span class="tok-kw">const</span> nums = [_]<span class="tok-type">i32</span>{ <span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">6</span> };
    <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (nums) |i| {
        <span class="tok-kw">const</span> T = <span class="tok-kw">switch</span> (i) {
            <span class="tok-number">2</span> =&gt; <span class="tok-type">f32</span>,
            <span class="tok-number">4</span> =&gt; <span class="tok-type">i8</span>,
            <span class="tok-number">6</span> =&gt; <span class="tok-type">bool</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
        sum += typeNameLength(T);
    }
    <span class="tok-kw">try</span> expect(sum == <span class="tok-number">9</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">typeNameLength</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@typeName</span>(T).len;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_inline_for.zig</kbd>
1/1 test_inline_for.test.inline for loop...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      It is recommended to use <code><span class="tok-kw">inline</span></code> loops only for one of these reasons:
      </p>
      <ul>
        <li>You need the loop to execute at <a href="#comptime">comptime</a> for the semantics to work.</li>
        <li>
        You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.
        </li>
      </ul>
      
      <p>See also:</p><ul>
<li><a href="#while">while</a></li>
<li><a href="#comptime">comptime</a></li>
<li><a href="#Arrays">Arrays</a></li>
<li><a href="#Slices">Slices</a></li>
</ul>

      
      <h2 id="if"><a href="#toc-if">if</a> <a class="hdr" href="#if">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_if.zig</cite></figcaption><pre><code><span class="tok-comment">// If expressions have three uses, corresponding to the three types:</span>
<span class="tok-comment">// * bool</span>
<span class="tok-comment">// * ?T</span>
<span class="tok-comment">// * anyerror!T</span>

<span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;if expression&quot;</span> {
    <span class="tok-comment">// If expressions are used instead of a ternary expression.</span>
    <span class="tok-kw">const</span> a: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u32</span> = <span class="tok-number">4</span>;
    <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (a != b) <span class="tok-number">47</span> <span class="tok-kw">else</span> <span class="tok-number">3089</span>;
    <span class="tok-kw">try</span> expect(result == <span class="tok-number">47</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;if boolean&quot;</span> {
    <span class="tok-comment">// If expressions test boolean conditions.</span>
    <span class="tok-kw">const</span> a: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u32</span> = <span class="tok-number">4</span>;
    <span class="tok-kw">if</span> (a != b) {
        <span class="tok-kw">try</span> expect(<span class="tok-null">true</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a == <span class="tok-number">9</span>) {
        <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">unreachable</span>;
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;if error union&quot;</span> {
    <span class="tok-comment">// If expressions test for errors.</span>
    <span class="tok-comment">// Note the |err| capture on the else.</span>

    <span class="tok-kw">const</span> a: <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (a) |value| {
        <span class="tok-kw">try</span> expect(value == <span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> |err| {
        _ = err;
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">const</span> b: <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> = <span class="tok-kw">error</span>.BadValue;
    <span class="tok-kw">if</span> (b) |value| {
        _ = value;
        <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">try</span> expect(err == <span class="tok-kw">error</span>.BadValue);
    }

    <span class="tok-comment">// The else and |err| capture is strictly required.</span>
    <span class="tok-kw">if</span> (a) |value| {
        <span class="tok-kw">try</span> expect(value == <span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> |_| {}

    <span class="tok-comment">// To check only the error value, use an empty block expression.</span>
    <span class="tok-kw">if</span> (b) |_| {} <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">try</span> expect(err == <span class="tok-kw">error</span>.BadValue);
    }

    <span class="tok-comment">// Access the value by reference using a pointer capture.</span>
    <span class="tok-kw">var</span> c: <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">if</span> (c) |*value| {
        value.* = <span class="tok-number">9</span>;
    } <span class="tok-kw">else</span> |_| {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">if</span> (c) |value| {
        <span class="tok-kw">try</span> expect(value == <span class="tok-number">9</span>);
    } <span class="tok-kw">else</span> |_| {
        <span class="tok-kw">unreachable</span>;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_if.zig</kbd>
1/3 test_if.test.if expression...OK
2/3 test_if.test.if boolean...OK
3/3 test_if.test.if error union...OK
All 3 tests passed.
</samp></pre></figure>

      <h3 id="if-with-Optionals"><a href="#toc-if-with-Optionals">if with Optionals</a> <a class="hdr" href="#if-with-Optionals">§</a></h3>


      <figure><figcaption class="zig-cap"><cite class="file">test_if_optionals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;if optional&quot;</span> {
    <span class="tok-comment">// If expressions test for null.</span>

    <span class="tok-kw">const</span> a: ?<span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (a) |value| {
        <span class="tok-kw">try</span> expect(value == <span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">const</span> b: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (b) |_| {
        <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> expect(<span class="tok-null">true</span>);
    }

    <span class="tok-comment">// The else is not required.</span>
    <span class="tok-kw">if</span> (a) |value| {
        <span class="tok-kw">try</span> expect(value == <span class="tok-number">0</span>);
    }

    <span class="tok-comment">// To test against null only, use the binary equality operator.</span>
    <span class="tok-kw">if</span> (b == <span class="tok-null">null</span>) {
        <span class="tok-kw">try</span> expect(<span class="tok-null">true</span>);
    }

    <span class="tok-comment">// Access the value by reference using a pointer capture.</span>
    <span class="tok-kw">var</span> c: ?<span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">if</span> (c) |*value| {
        value.* = <span class="tok-number">2</span>;
    }

    <span class="tok-kw">if</span> (c) |value| {
        <span class="tok-kw">try</span> expect(value == <span class="tok-number">2</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">unreachable</span>;
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;if error union with optional&quot;</span> {
    <span class="tok-comment">// If expressions test for errors before unwrapping optionals.</span>
    <span class="tok-comment">// The |optional_value| capture's type is ?u32.</span>

    <span class="tok-kw">const</span> a: <span class="tok-type">anyerror</span>!?<span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (a) |optional_value| {
        <span class="tok-kw">try</span> expect(optional_value.? == <span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> |err| {
        _ = err;
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">const</span> b: <span class="tok-type">anyerror</span>!?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (b) |optional_value| {
        <span class="tok-kw">try</span> expect(optional_value == <span class="tok-null">null</span>);
    } <span class="tok-kw">else</span> |_| {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">const</span> c: <span class="tok-type">anyerror</span>!?<span class="tok-type">u32</span> = <span class="tok-kw">error</span>.BadValue;
    <span class="tok-kw">if</span> (c) |optional_value| {
        _ = optional_value;
        <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">try</span> expect(err == <span class="tok-kw">error</span>.BadValue);
    }

    <span class="tok-comment">// Access the value by reference by using a pointer capture each time.</span>
    <span class="tok-kw">var</span> d: <span class="tok-type">anyerror</span>!?<span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">if</span> (d) |*optional_value| {
        <span class="tok-kw">if</span> (optional_value.*) |*value| {
            value.* = <span class="tok-number">9</span>;
        }
    } <span class="tok-kw">else</span> |_| {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">if</span> (d) |optional_value| {
        <span class="tok-kw">try</span> expect(optional_value.? == <span class="tok-number">9</span>);
    } <span class="tok-kw">else</span> |_| {
        <span class="tok-kw">unreachable</span>;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_if_optionals.zig</kbd>
1/2 test_if_optionals.test.if optional...OK
2/2 test_if_optionals.test.if error union with optional...OK
All 2 tests passed.
</samp></pre></figure>

      
      <p>See also:</p><ul>
<li><a href="#Optionals">Optionals</a></li>
<li><a href="#Errors">Errors</a></li>
</ul>

      
      <h2 id="defer"><a href="#toc-defer">defer</a> <a class="hdr" href="#defer">§</a></h2>

      <p>Executes an expression unconditionally at scope exit.</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_defer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> print = std.debug.print;

<span class="tok-kw">fn</span> <span class="tok-fn">deferExample</span>() !<span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;

    {
        <span class="tok-kw">defer</span> a = <span class="tok-number">2</span>;
        a = <span class="tok-number">1</span>;
    }
    <span class="tok-kw">try</span> expect(a == <span class="tok-number">2</span>);

    a = <span class="tok-number">5</span>;
    <span class="tok-kw">return</span> a;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;defer basics&quot;</span> {
    <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> deferExample()) == <span class="tok-number">5</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_defer.zig</kbd>
1/1 test_defer.test.defer basics...OK
All 1 tests passed.
</samp></pre></figure>

      <p>Defer expressions are evaluated in reverse order.</p>
      <figure><figcaption class="zig-cap"><cite class="file">defer_unwind.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> print = std.debug.print;

<span class="tok-kw">test</span> <span class="tok-str">&quot;defer unwinding&quot;</span> {
    print(<span class="tok-str">&quot;\n&quot;</span>, .{});

    <span class="tok-kw">defer</span> {
        print(<span class="tok-str">&quot;1 &quot;</span>, .{});
    }
    <span class="tok-kw">defer</span> {
        print(<span class="tok-str">&quot;2 &quot;</span>, .{});
    }
    <span class="tok-kw">if</span> (<span class="tok-null">false</span>) {
        <span class="tok-comment">// defers are not run if they are never executed.</span>
        <span class="tok-kw">defer</span> {
            print(<span class="tok-str">&quot;3 &quot;</span>, .{});
        }
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test defer_unwind.zig</kbd>
1/1 defer_unwind.test.defer unwinding...
2 1 OK
All 1 tests passed.
</samp></pre></figure>

      <p>Inside a defer expression the return statement is not allowed.</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_invalid_defer.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">deferInvalidExample</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">defer</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeferError;
    }

    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeferError;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_invalid_defer.zig</kbd>
<span class="sgr-1m">doc/langref/test_invalid_defer.zig:3:9: </span><span class="sgr-31m">error: </span><span class="sgr-1m">cannot return from defer expression
</span>        return error.DeferError;
        <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-1m">doc/langref/test_invalid_defer.zig:2:5: </span><span class="sgr-36m">note: </span><span class="sgr-1m">defer expression here
</span>    defer {
    <span class="sgr-32m">^~~~~
</span>
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#Errors">Errors</a></li>
</ul>

      
      <h2 id="unreachable"><a href="#toc-unreachable">unreachable</a> <a class="hdr" href="#unreachable">§</a></h2>

      <p>
      In <a href="#Debug">Debug</a> and <a href="#ReleaseSafe">ReleaseSafe</a> mode
      <code><span class="tok-kw">unreachable</span></code> emits a call to <code>panic</code> with the message <code>reached unreachable code</code>.
      </p>
      <p>
      In <a href="#ReleaseFast">ReleaseFast</a> and <a href="#ReleaseSmall">ReleaseSmall</a> mode, the optimizer uses the assumption that <code><span class="tok-kw">unreachable</span></code> code
      will never be hit to perform optimizations.
      </p>
      <h3 id="Basics"><a href="#toc-Basics">Basics</a> <a class="hdr" href="#Basics">§</a></h3>

      <figure><figcaption class="zig-cap"><cite class="file">test_unreachable.zig</cite></figcaption><pre><code><span class="tok-comment">// unreachable is used to assert that control flow will never reach a</span>
<span class="tok-comment">// particular location:</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;basic math&quot;</span> {
    <span class="tok-kw">const</span> x = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> y = <span class="tok-number">2</span>;
    <span class="tok-kw">if</span> (x + y != <span class="tok-number">3</span>) {
        <span class="tok-kw">unreachable</span>;
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_unreachable.zig</kbd>
1/1 test_unreachable.test.basic math...OK
All 1 tests passed.
</samp></pre></figure>

      <p>In fact, this is how <code>std.debug.assert</code> is implemented:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_assertion_failure.zig</cite></figcaption><pre><code><span class="tok-comment">// This is how std.debug.assert is implemented</span>
<span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>; <span class="tok-comment">// assertion failure</span>
}

<span class="tok-comment">// This test will fail because we hit unreachable.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;this will fail&quot;</span> {
    assert(<span class="tok-null">false</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_assertion_failure.zig</kbd>
1/1 test_assertion_failure.test.this will fail...thread 220435 panic: reached unreachable code
<span class="sgr-1m">/home/andy/src/zig/doc/langref/test_assertion_failure.zig:3:14</span>: <span class="sgr-2m">0x10489ad in assert (test)</span>
    if (!ok) unreachable; // assertion failure
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/test_assertion_failure.zig:8:11</span>: <span class="sgr-2m">0x104897a in test.this will fail (test)</span>
    assert(false);
          <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:214:25</span>: <span class="sgr-2m">0x10eedd5 in mainTerminal (test)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:62:28</span>: <span class="sgr-2m">0x10e736d in main (test)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10e68f2 in posixCallMainAndExit (test)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10e64cd in _start (test)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/src/zig/.zig-cache/o/51c9599b1e9a8f93217f914df57d48a3/test --seed=0xcd3102a8
</samp></pre></figure>

      
      <h3 id="At-Compile-Time"><a href="#toc-At-Compile-Time">At Compile-Time</a> <a class="hdr" href="#At-Compile-Time">§</a></h3>

      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_unreachable.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;type of unreachable&quot;</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-comment">// The type of unreachable is noreturn.</span>

        <span class="tok-comment">// However this assertion will still fail to compile because</span>
        <span class="tok-comment">// unreachable expressions are compile errors.</span>

        assert(<span class="tok-builtin">@TypeOf</span>(<span class="tok-kw">unreachable</span>) == <span class="tok-type">noreturn</span>);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_unreachable.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_unreachable.zig:10:16: </span><span class="sgr-31m">error: </span><span class="sgr-1m">unreachable code
</span>        assert(@TypeOf(unreachable) == noreturn);
               <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-1m">doc/langref/test_comptime_unreachable.zig:10:24: </span><span class="sgr-36m">note: </span><span class="sgr-1m">control flow is diverted here
</span>        assert(@TypeOf(unreachable) == noreturn);
                       <span class="sgr-32m">^~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#Zig-Test">Zig Test</a></li>
<li><a href="#Build-Mode">Build Mode</a></li>
<li><a href="#comptime">comptime</a></li>
</ul>

      
      
      <h2 id="noreturn"><a href="#toc-noreturn">noreturn</a> <a class="hdr" href="#noreturn">§</a></h2>

      <p>
      <code><span class="tok-type">noreturn</span></code> is the type of:
      </p>
      <ul>
          <li><code><span class="tok-kw">break</span></code></li>
          <li><code><span class="tok-kw">continue</span></code></li>
          <li><code><span class="tok-kw">return</span></code></li>
          <li><code><span class="tok-kw">unreachable</span></code></li>
          <li><code><span class="tok-kw">while</span> (<span class="tok-null">true</span>) {}</code></li>
      </ul>
      <p>When resolving types together, such as <code><span class="tok-kw">if</span></code> clauses or <code><span class="tok-kw">switch</span></code> prongs,
              the <code><span class="tok-type">noreturn</span></code> type is compatible with every other type. Consider:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_noreturn.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(condition: <span class="tok-type">bool</span>, b: <span class="tok-type">u32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> a = <span class="tok-kw">if</span> (condition) b <span class="tok-kw">else</span> <span class="tok-kw">return</span>;
    _ = a;
    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;do something with a&quot;</span>);
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;noreturn&quot;</span> {
    foo(<span class="tok-null">false</span>, <span class="tok-number">1</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_noreturn.zig</kbd>
1/1 test_noreturn.test.noreturn...OK
All 1 tests passed.
</samp></pre></figure>

      <p>Another use case for <code><span class="tok-type">noreturn</span></code> is the <code>exit</code> function:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_noreturn_from_exit.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> native_arch = builtin.cpu.arch;
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> WINAPI: std.builtin.CallingConvention = <span class="tok-kw">if</span> (native_arch == .x86) .Stdcall <span class="tok-kw">else</span> .C;
<span class="tok-kw">extern</span> <span class="tok-str">&quot;kernel32&quot;</span> <span class="tok-kw">fn</span> <span class="tok-fn">ExitProcess</span>(exit_code: <span class="tok-type">c_uint</span>) <span class="tok-kw">callconv</span>(WINAPI) <span class="tok-type">noreturn</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;foo&quot;</span> {
    <span class="tok-kw">const</span> value = bar() <span class="tok-kw">catch</span> ExitProcess(<span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(value == <span class="tok-number">1234</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_noreturn_from_exit.zig -target x86_64-windows --test-no-exec</kbd>
</samp></pre></figure>

      

      <h2 id="Functions"><a href="#toc-Functions">Functions</a> <a class="hdr" href="#Functions">§</a></h2>

      <figure><figcaption class="zig-cap"><cite class="file">test_functions.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> native_arch = builtin.cpu.arch;
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-comment">// Functions are declared like this</span>
<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> {
    <span class="tok-kw">if</span> (a == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> b;
    }

    <span class="tok-kw">return</span> a + b;
}

<span class="tok-comment">// The export specifier makes a function externally visible in the generated</span>
<span class="tok-comment">// object file, and makes it use the C ABI.</span>
<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> {
    <span class="tok-kw">return</span> a - b;
}

<span class="tok-comment">// The extern specifier is used to declare a function that will be resolved</span>
<span class="tok-comment">// at link time, when linking statically, or at runtime, when linking</span>
<span class="tok-comment">// dynamically. The quoted identifier after the extern keyword specifies</span>
<span class="tok-comment">// the library that has the function. (e.g. &quot;c&quot; -&gt; libc.so)</span>
<span class="tok-comment">// The callconv specifier changes the calling convention of the function.</span>
<span class="tok-kw">const</span> WINAPI: std.builtin.CallingConvention = <span class="tok-kw">if</span> (native_arch == .x86) .Stdcall <span class="tok-kw">else</span> .C;
<span class="tok-kw">extern</span> <span class="tok-str">&quot;kernel32&quot;</span> <span class="tok-kw">fn</span> <span class="tok-fn">ExitProcess</span>(exit_code: <span class="tok-type">u32</span>) <span class="tok-kw">callconv</span>(WINAPI) <span class="tok-type">noreturn</span>;
<span class="tok-kw">extern</span> <span class="tok-str">&quot;c&quot;</span> <span class="tok-kw">fn</span> <span class="tok-fn">atan2</span>(a: <span class="tok-type">f64</span>, b: <span class="tok-type">f64</span>) <span class="tok-type">f64</span>;

<span class="tok-comment">// The @branchHint builtin can be used to tell the optimizer that a function is rarely called (&quot;cold&quot;).</span>
<span class="tok-kw">fn</span> <span class="tok-fn">abort</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@branchHint</span>(.cold);
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {}
}

<span class="tok-comment">// The naked calling convention makes a function not have any function prologue or epilogue.</span>
<span class="tok-comment">// This can be useful when integrating with assembly.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">_start</span>() <span class="tok-kw">callconv</span>(.Naked) <span class="tok-type">noreturn</span> {
    abort();
}

<span class="tok-comment">// The inline calling convention forces a function to be inlined at all call sites.</span>
<span class="tok-comment">// If the function cannot be inlined, it is a compile-time error.</span>
<span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">shiftLeftOne</span>(a: <span class="tok-type">u32</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> a &lt;&lt; <span class="tok-number">1</span>;
}

<span class="tok-comment">// The pub specifier allows the function to be visible when importing.</span>
<span class="tok-comment">// Another file can use @import and call sub2</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub2</span>(a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> {
    <span class="tok-kw">return</span> a - b;
}

<span class="tok-comment">// Function pointers are prefixed with `*const `.</span>
<span class="tok-kw">const</span> Call2Op = *<span class="tok-kw">const</span> <span class="tok-kw">fn</span> (a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">doOp</span>(fnCall: Call2Op, op1: <span class="tok-type">i8</span>, op2: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> {
    <span class="tok-kw">return</span> fnCall(op1, op2);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;function&quot;</span> {
    <span class="tok-kw">try</span> expect(doOp(add, <span class="tok-number">5</span>, <span class="tok-number">6</span>) == <span class="tok-number">11</span>);
    <span class="tok-kw">try</span> expect(doOp(sub2, <span class="tok-number">5</span>, <span class="tok-number">6</span>) == -<span class="tok-number">1</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_functions.zig</kbd>
1/1 test_functions.test.function...OK
All 1 tests passed.
</samp></pre></figure>

      <p>There is a difference between a function <em>body</em> and a function <em>pointer</em>.
      Function bodies are <a href="#comptime">comptime</a>-only types while function <a href="#Pointers">Pointers</a> may be
      runtime-known.</p>
      <h3 id="Pass-by-value-Parameters"><a href="#toc-Pass-by-value-Parameters">Pass-by-value Parameters</a> <a class="hdr" href="#Pass-by-value-Parameters">§</a></h3>

      <p>
      Primitive types such as <a href="#Integers">Integers</a> and <a href="#Floats">Floats</a> passed as parameters
      are copied, and then the copy is available in the function body. This is called "passing by value".
      Copying a primitive type is essentially free and typically involves nothing more than
      setting a register.
      </p>
      <p>
      Structs, unions, and arrays can sometimes be more efficiently passed as a reference, since a copy
      could be arbitrarily expensive depending on the size. When these types are passed
      as parameters, Zig may choose to copy and pass by value, or pass by reference, whichever way
      Zig decides will be faster. This is made possible, in part, by the fact that parameters are immutable.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_pass_by_reference_or_value.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">i32</span>,
    y: <span class="tok-type">i32</span>,
};

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(point: Point) <span class="tok-type">i32</span> {
    <span class="tok-comment">// Here, `point` could be a reference, or a copy. The function body</span>
    <span class="tok-comment">// can ignore the difference and treat it as a value. Be very careful</span>
    <span class="tok-comment">// taking the address of the parameter - it should be treated as if</span>
    <span class="tok-comment">// the address will become invalid when the function returns.</span>
    <span class="tok-kw">return</span> point.x + point.y;
}

<span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;pass struct to function&quot;</span> {
    <span class="tok-kw">try</span> expect(foo(Point{ .x = <span class="tok-number">1</span>, .y = <span class="tok-number">2</span> }) == <span class="tok-number">3</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pass_by_reference_or_value.zig</kbd>
1/1 test_pass_by_reference_or_value.test.pass struct to function...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      For extern functions, Zig follows the C ABI for passing structs and unions by value.
      </p>
      
      <h3 id="Function-Parameter-Type-Inference"><a href="#toc-Function-Parameter-Type-Inference">Function Parameter Type Inference</a> <a class="hdr" href="#Function-Parameter-Type-Inference">§</a></h3>

      <p>
      Function parameters can be declared with <code><span class="tok-kw">anytype</span></code> in place of the type.
      In this case the parameter types will be inferred when the function is called.
      Use <a href="#TypeOf">@TypeOf</a> and <a href="#typeInfo">@typeInfo</a> to get information about the inferred type.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_fn_type_inference.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">fn</span> <span class="tok-fn">addFortyTwo</span>(x: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(x) {
    <span class="tok-kw">return</span> x + <span class="tok-number">42</span>;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;fn type inference&quot;</span> {
    <span class="tok-kw">try</span> expect(addFortyTwo(<span class="tok-number">1</span>) == <span class="tok-number">43</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(addFortyTwo(<span class="tok-number">1</span>)) == <span class="tok-type">comptime_int</span>);
    <span class="tok-kw">const</span> y: <span class="tok-type">i64</span> = <span class="tok-number">2</span>;
    <span class="tok-kw">try</span> expect(addFortyTwo(y) == <span class="tok-number">44</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(addFortyTwo(y)) == <span class="tok-type">i64</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_fn_type_inference.zig</kbd>
1/1 test_fn_type_inference.test.fn type inference...OK
All 1 tests passed.
</samp></pre></figure>


      

      <h3 id="inline-fn"><a href="#toc-inline-fn">inline fn</a> <a class="hdr" href="#inline-fn">§</a></h3>

      <p>
      Adding the <code><span class="tok-kw">inline</span></code> keyword to a function definition makes that
      function become <em>semantically inlined</em> at the callsite. This is
      not a hint to be possibly observed by optimization passes, but has
      implications on the types and values involved in the function call.
      </p>
      <p>
      Unlike normal function calls, arguments at an inline function callsite which are
      compile-time known are treated as <a href="#Compile-Time-Parameters">Compile Time Parameters</a>. This can potentially
      propagate all the way to the return value:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">inline_call.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;inline function call&quot;</span> {
    <span class="tok-kw">if</span> (foo(<span class="tok-number">1200</span>, <span class="tok-number">34</span>) != <span class="tok-number">1234</span>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;bad&quot;</span>);
    }
}

<span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a + b;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test inline_call.zig</kbd>
1/1 inline_call.test.inline function call...OK
All 1 tests passed.
</samp></pre></figure>

      <p>If <code><span class="tok-kw">inline</span></code> is removed, the test fails with the compile error
      instead of passing.</p>
      <p>It is generally better to let the compiler decide when to inline a
      function, except for these scenarios:</p>
      <ul>
        <li>To change how many stack frames are in the call stack, for debugging purposes.</li>
        <li>To force comptime-ness of the arguments to propagate to the return value of the function, as in the above example.</li>
        <li>Real world performance measurements demand it.</li>
      </ul>
      <p>Note that <code><span class="tok-kw">inline</span></code> actually <em>restricts</em>
      what the compiler is allowed to do. This can harm binary size,
      compilation speed, and even runtime performance.</p>
      

      <h3 id="Function-Reflection"><a href="#toc-Function-Reflection">Function Reflection</a> <a class="hdr" href="#Function-Reflection">§</a></h3>

      <figure><figcaption class="zig-cap"><cite class="file">test_fn_reflection.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> math = std.math;
<span class="tok-kw">const</span> testing = std.testing;

<span class="tok-kw">test</span> <span class="tok-str">&quot;fn reflection&quot;</span> {
    <span class="tok-kw">try</span> testing.expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(testing.expect)).@&quot;fn&quot;.params[<span class="tok-number">0</span>].<span class="tok-type">type</span>.? == <span class="tok-type">bool</span>);
    <span class="tok-kw">try</span> testing.expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(testing.tmpDir)).@&quot;fn&quot;.return_type.? == testing.TmpDir);

    <span class="tok-kw">try</span> testing.expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(math.Log2Int)).@&quot;fn&quot;.is_generic);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_fn_reflection.zig</kbd>
1/1 test_fn_reflection.test.fn reflection...OK
All 1 tests passed.
</samp></pre></figure>

      
      
      <h2 id="Errors"><a href="#toc-Errors">Errors</a> <a class="hdr" href="#Errors">§</a></h2>

      <h3 id="Error-Set-Type"><a href="#toc-Error-Set-Type">Error Set Type</a> <a class="hdr" href="#Error-Set-Type">§</a></h3>

      <p>
      An error set is like an <a href="#enum">enum</a>.
      However, each error name across the entire compilation gets assigned an unsigned integer
      greater than 0. You are allowed to declare the same error name more than once, and if you do, it
      gets assigned the same integer value.
      </p>
      <p>
      The error set type defaults to a <code><span class="tok-type">u16</span></code>, though if the maximum number of distinct
      error values is provided via the <kbd>--error-limit [num]</kbd> command line parameter an integer type
      with the minimum number of bits required to represent all of the error values will be used.
      </p>
      <p>
      You can <a href="#Type-Coercion">coerce</a> an error from a subset to a superset:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_error_subset_to_superset.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> FileOpenError = <span class="tok-kw">error</span>{
    AccessDenied,
    OutOfMemory,
    FileNotFound,
};

<span class="tok-kw">const</span> AllocationError = <span class="tok-kw">error</span>{
    OutOfMemory,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;coerce subset to superset&quot;</span> {
    <span class="tok-kw">const</span> err = foo(AllocationError.OutOfMemory);
    <span class="tok-kw">try</span> std.testing.expect(err == FileOpenError.OutOfMemory);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(err: AllocationError) FileOpenError {
    <span class="tok-kw">return</span> err;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_error_subset_to_superset.zig</kbd>
1/1 test_coerce_error_subset_to_superset.test.coerce subset to superset...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      But you cannot <a href="#Type-Coercion">coerce</a> an error from a superset to a subset:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_error_superset_to_subset.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> FileOpenError = <span class="tok-kw">error</span>{
    AccessDenied,
    OutOfMemory,
    FileNotFound,
};

<span class="tok-kw">const</span> AllocationError = <span class="tok-kw">error</span>{
    OutOfMemory,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;coerce superset to subset&quot;</span> {
    foo(FileOpenError.OutOfMemory) <span class="tok-kw">catch</span> {};
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(err: FileOpenError) AllocationError {
    <span class="tok-kw">return</span> err;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_error_superset_to_subset.zig</kbd>
<span class="sgr-1m">doc/langref/test_coerce_error_superset_to_subset.zig:16:12: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type 'error{OutOfMemory}', found 'error{AccessDenied,OutOfMemory,FileNotFound}'
</span>    return err;
           <span class="sgr-32m">^~~
</span><span class="sgr-1m">doc/langref/test_coerce_error_superset_to_subset.zig:16:12: </span><span class="sgr-36m">note: </span><span class="sgr-1m">'error.AccessDenied' not a member of destination error set
</span><span class="sgr-1m">doc/langref/test_coerce_error_superset_to_subset.zig:16:12: </span><span class="sgr-36m">note: </span><span class="sgr-1m">'error.FileNotFound' not a member of destination error set
</span><span class="sgr-1m">doc/langref/test_coerce_error_superset_to_subset.zig:15:28: </span><span class="sgr-36m">note: </span><span class="sgr-1m">function return type declared here
</span>fn foo(err: FileOpenError) AllocationError {
                           <span class="sgr-32m">^~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>
      There is a shortcut for declaring an error set with only 1 value, and then getting that value:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">single_value_error_set_shortcut.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> err = <span class="tok-kw">error</span>.FileNotFound;</code></pre></figure>

      <p>This is equivalent to:</p>
      <figure><figcaption class="zig-cap"><cite class="file">single_value_error_set.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> err = (<span class="tok-kw">error</span>{FileNotFound}).FileNotFound;</code></pre></figure>

      <p>
      This becomes useful when using <a href="#Inferred-Error-Sets">Inferred Error Sets</a>.
      </p>
      <h4 id="The-Global-Error-Set"><a href="#toc-The-Global-Error-Set">The Global Error Set</a> <a class="hdr" href="#The-Global-Error-Set">§</a></h4>

      <p><code><span class="tok-type">anyerror</span></code> refers to the global error set.
      This is the error set that contains all errors in the entire compilation unit, i.e. it is the union of all other error sets.
      </p>
      <p>
      You can <a href="#Type-Coercion">coerce</a> any error set to the global one, and you can explicitly
      cast an error of the global error set to a non-global one. This inserts a language-level
      assert to make sure the error value is in fact in the destination error set.
      </p>
      <p>
      The global error set should generally be avoided because it prevents the
      compiler from knowing what errors are possible at compile-time. Knowing
      the error set at compile-time is better for generated documentation and
      helpful error messages, such as forgetting a possible error value in a <a href="#switch">switch</a>.
      </p>
      
      
      <h3 id="Error-Union-Type"><a href="#toc-Error-Union-Type">Error Union Type</a> <a class="hdr" href="#Error-Union-Type">§</a></h3>

      <p>
      An error set type and normal type can be combined with the <code>!</code>
      binary operator to form an error union type. You are likely to use an
      error union type more often than an error set type by itself.
      </p>
      <p>
      Here is a function to parse a string into a 64-bit integer:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">error_union_parsing_u64.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> maxInt = std.math.maxInt;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseU64</span>(buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, radix: <span class="tok-type">u8</span>) !<span class="tok-type">u64</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">for</span> (buf) |c| {
        <span class="tok-kw">const</span> digit = charToDigit(c);

        <span class="tok-kw">if</span> (digit &gt;= radix) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidChar;
        }

        <span class="tok-comment">// x *= radix</span>
        <span class="tok-kw">var</span> ov = <span class="tok-builtin">@mulWithOverflow</span>(x, radix);
        <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OverFlow;

        <span class="tok-comment">// x += digit</span>
        ov = <span class="tok-builtin">@addWithOverflow</span>(ov[<span class="tok-number">0</span>], digit);
        <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OverFlow;
        x = ov[<span class="tok-number">0</span>];
    }

    <span class="tok-kw">return</span> x;
}

<span class="tok-kw">fn</span> <span class="tok-fn">charToDigit</span>(c: <span class="tok-type">u8</span>) <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (c) {
        <span class="tok-str">'0'</span>...<span class="tok-str">'9'</span> =&gt; c - <span class="tok-str">'0'</span>,
        <span class="tok-str">'A'</span>...<span class="tok-str">'Z'</span> =&gt; c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>,
        <span class="tok-str">'a'</span>...<span class="tok-str">'z'</span> =&gt; c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>,
        <span class="tok-kw">else</span> =&gt; maxInt(<span class="tok-type">u8</span>),
    };
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;parse u64&quot;</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> parseU64(<span class="tok-str">&quot;1234&quot;</span>, <span class="tok-number">10</span>);
    <span class="tok-kw">try</span> std.testing.expect(result == <span class="tok-number">1234</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test error_union_parsing_u64.zig</kbd>
1/1 error_union_parsing_u64.test.parse u64...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Notice the return type is <code>!<span class="tok-type">u64</span></code>. This means that the function
      either returns an unsigned 64 bit integer, or an error. We left off the error set
      to the left of the <code>!</code>, so the error set is inferred.
      </p>
      <p>
      Within the function definition, you can see some return statements that return
      an error, and at the bottom a return statement that returns a <code><span class="tok-type">u64</span></code>.
          Both types <a href="#Type-Coercion">coerce</a> to <code><span class="tok-type">anyerror</span>!<span class="tok-type">u64</span></code>.
      </p>
      <p>
      What it looks like to use this function varies depending on what you're
      trying to do. One of the following:
      </p>
      <ul>
        <li>You want to provide a default value if it returned an error.</li>
        <li>If it returned an error then you want to return the same error.</li>
        <li>You know with complete certainty it will not return an error, so want to unconditionally unwrap it.</li>
        <li>You want to take a different action for each possible error.</li>
      </ul>
      <h4 id="catch"><a href="#toc-catch">catch</a> <a class="hdr" href="#catch">§</a></h4>

      <p>If you want to provide a default value, you can use the <code><span class="tok-kw">catch</span></code> binary operator:</p>
      <figure><figcaption class="zig-cap"><cite class="file">catch.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> parseU64 = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;error_union_parsing_u64.zig&quot;</span>).parseU64;

<span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = parseU64(str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-number">13</span>;
    _ = number; <span class="tok-comment">// ...</span>
}</code></pre></figure>

      <p>
      In this code, <code>number</code> will be equal to the successfully parsed string, or
          a default value of 13. The type of the right hand side of the binary <code><span class="tok-kw">catch</span></code> operator must
              match the unwrapped error union type, or be of type <code><span class="tok-type">noreturn</span></code>.
      </p>
     <p>
      If you want to provide a default value with
      <code><span class="tok-kw">catch</span></code> after performing some logic, you
      can combine <code><span class="tok-kw">catch</span></code> with named <a href="#Blocks">Blocks</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">handle_error_with_catch_block.zig.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> parseU64 = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;error_union_parsing_u64.zig&quot;</span>).parseU64;

<span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = parseU64(str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> blk: {
        <span class="tok-comment">// do things</span>
        <span class="tok-kw">break</span> :blk <span class="tok-number">13</span>;
    };
    _ = number; <span class="tok-comment">// number is now initialized</span>
}</code></pre></figure>

      
      <h4 id="try"><a href="#toc-try">try</a> <a class="hdr" href="#try">§</a></h4>

      <p>Let's say you wanted to return the error if you got one, otherwise continue with the
      function logic:</p>
      <figure><figcaption class="zig-cap"><cite class="file">catch_err_return.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> parseU64 = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;error_union_parsing_u64.zig&quot;</span>).parseU64;

<span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = parseU64(str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">return</span> err;
    _ = number; <span class="tok-comment">// ...</span>
}</code></pre></figure>

      <p>
      There is a shortcut for this. The <code><span class="tok-kw">try</span></code> expression:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">try.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> parseU64 = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;error_union_parsing_u64.zig&quot;</span>).parseU64;

<span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = <span class="tok-kw">try</span> parseU64(str, <span class="tok-number">10</span>);
    _ = number; <span class="tok-comment">// ...</span>
}</code></pre></figure>

      <p>
      <code><span class="tok-kw">try</span></code> evaluates an error union expression. If it is an error, it returns
      from the current function with the same error. Otherwise, the expression results in
      the unwrapped value.
      </p>
      
      <p>
        Maybe you know with complete certainty that an expression will never be an error.
        In this case you can do this:
      </p>
      <code><span class="tok-kw">const</span> number = parseU64(<span class="tok-str">&quot;1234&quot;</span>, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</code>
      <p>
      Here we know for sure that "1234" will parse successfully. So we put the
      <code><span class="tok-kw">unreachable</span></code> value on the right hand side.
      <code><span class="tok-kw">unreachable</span></code> invokes safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>, so
      in <a href="#Debug">Debug</a> and <a href="#ReleaseSafe">ReleaseSafe</a>, triggers a safety panic by default. So, while
      we're debugging the application, if there <em>was</em> a surprise error here, the application
      would crash appropriately.
      </p>
      <p>
      You may want to take a different action for every situation. For that, we combine
      the <a href="#if">if</a> and <a href="#switch">switch</a> expression:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">handle_all_error_scenarios.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (parseU64(str, <span class="tok-number">10</span>)) |number| {
        doSomethingWithNumber(number);
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Overflow =&gt; {
            <span class="tok-comment">// handle overflow...</span>
        },
        <span class="tok-comment">// we promise that InvalidChar won't happen (or crash in debug mode if it does)</span>
        <span class="tok-kw">error</span>.InvalidChar =&gt; <span class="tok-kw">unreachable</span>,
    }
}</code></pre></figure>
      <p>
      Finally, you may want to handle only some errors. For that, you can capture the unhandled
      errors in the <code><span class="tok-kw">else</span></code> case, which now contains a narrower error set:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">handle_some_error_scenarios.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">doAnotherThing</span>(str: []<span class="tok-type">u8</span>) <span class="tok-kw">error</span>{InvalidChar}!<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (parseU64(str, <span class="tok-number">10</span>)) |number| {
        doSomethingWithNumber(number);
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Overflow =&gt; {
            <span class="tok-comment">// handle overflow...</span>
        },
        <span class="tok-kw">else</span> =&gt; |leftover_err| <span class="tok-kw">return</span> leftover_err,
    }
}</code></pre></figure>
      <p>
      You must use the variable capture syntax. If you don't need the
      variable, you can capture with <code>_</code> and avoid the
      <code><span class="tok-kw">switch</span></code>.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">handle_no_error_scenarios.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">doADifferentThing</span>(str: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (parseU64(str, <span class="tok-number">10</span>)) |number| {
        doSomethingWithNumber(number);
    } <span class="tok-kw">else</span> |_| {
        <span class="tok-comment">// do as you'd like</span>
    }
}</code></pre></figure>
      <h4 id="errdefer"><a href="#toc-errdefer">errdefer</a> <a class="hdr" href="#errdefer">§</a></h4>

      <p>
      The other component to error handling is defer statements.
      In addition to an unconditional <a href="#defer">defer</a>, Zig has <code><span class="tok-kw">errdefer</span></code>,
      which evaluates the deferred expression on block exit path if and only if
      the function returned with an error from the block.
      </p>
      <p>
      Example:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">errdefer_example.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">createFoo</span>(param: <span class="tok-type">i32</span>) !Foo {
    <span class="tok-kw">const</span> foo = <span class="tok-kw">try</span> tryToAllocateFoo();
    <span class="tok-comment">// now we have allocated foo. we need to free it if the function fails.</span>
    <span class="tok-comment">// but we want to return it if the function succeeds.</span>
    <span class="tok-kw">errdefer</span> deallocateFoo(foo);

    <span class="tok-kw">const</span> tmp_buf = allocateTmpBuffer() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;
    <span class="tok-comment">// tmp_buf is truly a temporary resource, and we for sure want to clean it up</span>
    <span class="tok-comment">// before this block leaves scope</span>
    <span class="tok-kw">defer</span> deallocateTmpBuffer(tmp_buf);

    <span class="tok-kw">if</span> (param &gt; <span class="tok-number">1337</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidParam;

    <span class="tok-comment">// here the errdefer will not run since we're returning success from the function.</span>
    <span class="tok-comment">// but the defer will run!</span>
    <span class="tok-kw">return</span> foo;
}</code></pre></figure>
      <p>
      The neat thing about this is that you get robust error handling without
      the verbosity and cognitive overhead of trying to make sure every exit path
      is covered. The deallocation code is always directly following the allocation code.
      </p>
      <p>
      The <code><span class="tok-kw">errdefer</span></code> statement can optionally capture the error:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_errdefer_capture.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">fn</span> <span class="tok-fn">captureError</span>(captured: *?<span class="tok-type">anyerror</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">errdefer</span> |err| {
        captured.* = err;
    }
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.GeneralFailure;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;errdefer capture&quot;</span> {
    <span class="tok-kw">var</span> captured: ?<span class="tok-type">anyerror</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">if</span> (captureError(&amp;captured)) <span class="tok-kw">unreachable</span> <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">try</span> std.testing.expectEqual(<span class="tok-kw">error</span>.GeneralFailure, captured.?);
        <span class="tok-kw">try</span> std.testing.expectEqual(<span class="tok-kw">error</span>.GeneralFailure, err);
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_errdefer_capture.zig</kbd>
1/1 test_errdefer_capture.test.errdefer capture...OK
All 1 tests passed.
</samp></pre></figure>
      
      <p>
      A couple of other tidbits about error handling:
      </p>
      <ul>
        <li>These primitives give enough expressiveness that it's completely practical
            to have failing to check for an error be a compile error. If you really want
            to ignore the error, you can add <code><span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span></code> and
            get the added benefit of crashing in Debug and ReleaseSafe modes if your assumption was wrong.
        </li>
        <li>
          Since Zig understands error types, it can pre-weight branches in favor of
          errors not occurring. Just a small optimization benefit that is not available
          in other languages.
        </li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#defer">defer</a></li>
<li><a href="#if">if</a></li>
<li><a href="#switch">switch</a></li>
</ul>


      <p>An error union is created with the <code>!</code> binary operator.
      You can use compile-time reflection to access the child type of an error union:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_error_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;error union&quot;</span> {
    <span class="tok-kw">var</span> foo: <span class="tok-type">anyerror</span>!<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;

    <span class="tok-comment">// Coerce from child type of an error union:</span>
    foo = <span class="tok-number">1234</span>;

    <span class="tok-comment">// Coerce from an error set:</span>
    foo = <span class="tok-kw">error</span>.SomeError;

    <span class="tok-comment">// Use compile-time reflection to access the payload type of an error union:</span>
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(foo)).error_union.payload == <span class="tok-type">i32</span>);

    <span class="tok-comment">// Use compile-time reflection to access the error set type of an error union:</span>
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(foo)).error_union.error_set == <span class="tok-type">anyerror</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_error_union.zig</kbd>
1/1 test_error_union.test.error union...OK
All 1 tests passed.
</samp></pre></figure>

      <h4 id="Merging-Error-Sets"><a href="#toc-Merging-Error-Sets">Merging Error Sets</a> <a class="hdr" href="#Merging-Error-Sets">§</a></h4>

      <p>
      Use the <code>||</code> operator to merge two error sets together. The resulting
      error set contains the errors of both error sets. Doc comments from the left-hand
      side override doc comments from the right-hand side. In this example, the doc
      comments for <code>C.PathNotFound</code> is <code>A doc comment</code>.
      </p>
      <p>
      This is especially useful for functions which return different error sets depending
      on <a href="#comptime">comptime</a> branches. For example, the Zig standard library uses
      <code>LinuxFileOpenError || WindowsFileOpenError</code> for the error set of opening
      files.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_merging_error_sets.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> A = <span class="tok-kw">error</span>{
    NotDir,

    <span class="tok-comment">/// A doc comment</span>
    PathNotFound,
};
<span class="tok-kw">const</span> B = <span class="tok-kw">error</span>{
    OutOfMemory,

    <span class="tok-comment">/// B doc comment</span>
    PathNotFound,
};

<span class="tok-kw">const</span> C = A || B;

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() C!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;merge error sets&quot;</span> {
    <span class="tok-kw">if</span> (foo()) {
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unexpected&quot;</span>);
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unexpected&quot;</span>),
        <span class="tok-kw">error</span>.PathNotFound =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unexpected&quot;</span>),
        <span class="tok-kw">error</span>.NotDir =&gt; {},
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_merging_error_sets.zig</kbd>
1/1 test_merging_error_sets.test.merge error sets...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h4 id="Inferred-Error-Sets"><a href="#toc-Inferred-Error-Sets">Inferred Error Sets</a> <a class="hdr" href="#Inferred-Error-Sets">§</a></h4>

      <p>
      Because many functions in Zig return a possible error, Zig supports inferring the error set.
      To infer the error set for a function, prepend the <code>!</code> operator to the function’s return type, like <code>!T</code>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_inferred_error_sets.zig</cite></figcaption><pre><code><span class="tok-comment">// With an inferred error set</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add_inferred</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) !T {
    <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(a, b);
    <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    <span class="tok-kw">return</span> ov[<span class="tok-number">0</span>];
}

<span class="tok-comment">// With an explicit error set</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add_explicit</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) Error!T {
    <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(a, b);
    <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
    <span class="tok-kw">return</span> ov[<span class="tok-number">0</span>];
}

<span class="tok-kw">const</span> Error = <span class="tok-kw">error</span>{
    Overflow,
};

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;inferred error set&quot;</span> {
    <span class="tok-kw">if</span> (add_inferred(<span class="tok-type">u8</span>, <span class="tok-number">255</span>, <span class="tok-number">1</span>)) |_| <span class="tok-kw">unreachable</span> <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Overflow =&gt; {}, <span class="tok-comment">// ok</span>
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_inferred_error_sets.zig</kbd>
1/1 test_inferred_error_sets.test.inferred error set...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      When a function has an inferred error set, that function becomes generic and thus it becomes
      trickier to do certain things with it, such as obtain a function pointer, or have an error
      set that is consistent across different build targets. Additionally, inferred error sets
      are incompatible with recursion.
      </p>
      <p>
      In these situations, it is recommended to use an explicit error set. You can generally start
      with an empty error set and let compile errors guide you toward completing the set.
      </p>
      <p>
      These limitations may be overcome in a future version of Zig.
      </p>
      
      
      <h3 id="Error-Return-Traces"><a href="#toc-Error-Return-Traces">Error Return Traces</a> <a class="hdr" href="#Error-Return-Traces">§</a></h3>

      <p>
      Error Return Traces show all the points in the code that an error was returned to the calling function. This makes it practical to use <a href="#try">try</a> everywhere and then still be able to know what happened if an error ends up bubbling all the way out of your application.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">error_return_trace.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> foo(<span class="tok-number">12</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: <span class="tok-type">i32</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (x &gt;= <span class="tok-number">5</span>) {
        <span class="tok-kw">try</span> bar();
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> bang2();
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (baz()) {
        <span class="tok-kw">try</span> quux();
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">try</span> hello(),
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">baz</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> bang1();
}

<span class="tok-kw">fn</span> <span class="tok-fn">quux</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">hello</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang1</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang2</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe error_return_trace.zig</kbd>
$ <kbd>./error_return_trace</kbd>
error: PermissionDenied
<span class="sgr-1m">/home/andy/src/zig/doc/langref/error_return_trace.zig:34:5</span>: <span class="sgr-2m">0x10de6f8 in bang1 (error_return_trace)</span>
    return error.FileNotFound;
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/error_return_trace.zig:22:5</span>: <span class="sgr-2m">0x10de723 in baz (error_return_trace)</span>
    try bang1();
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/error_return_trace.zig:38:5</span>: <span class="sgr-2m">0x10de748 in bang2 (error_return_trace)</span>
    return error.PermissionDenied;
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/error_return_trace.zig:30:5</span>: <span class="sgr-2m">0x10de7b3 in hello (error_return_trace)</span>
    try bang2();
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/error_return_trace.zig:17:31</span>: <span class="sgr-2m">0x10de858 in bar (error_return_trace)</span>
        error.FileNotFound =&gt; try hello(),
                              <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/error_return_trace.zig:7:9</span>: <span class="sgr-2m">0x10de8c0 in foo (error_return_trace)</span>
        try bar();
        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/error_return_trace.zig:2:5</span>: <span class="sgr-2m">0x10de918 in main (error_return_trace)</span>
    try foo(12);
    <span class="sgr-32m">^</span>
</samp></pre></figure>

      <p>
      Look closely at this example. This is no stack trace.
      </p>
      <p>
      You can see that the final error bubbled up was <code>PermissionDenied</code>,
          but the original error that started this whole thing was <code>FileNotFound</code>. In the <code>bar</code> function, the code handles the original error code,
      and then returns another one, from the switch statement. Error Return Traces make this clear, whereas a stack trace would look like this:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">stack_trace.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    foo(<span class="tok-number">12</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: <span class="tok-type">i32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (x &gt;= <span class="tok-number">5</span>) {
        bar();
    } <span class="tok-kw">else</span> {
        bang2();
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (baz()) {
        quux();
    } <span class="tok-kw">else</span> {
        hello();
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">baz</span>() <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> bang1();
}

<span class="tok-kw">fn</span> <span class="tok-fn">quux</span>() <span class="tok-type">void</span> {
    bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">hello</span>() <span class="tok-type">void</span> {
    bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang1</span>() <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang2</span>() <span class="tok-type">void</span> {
    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;PermissionDenied&quot;</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe stack_trace.zig</kbd>
$ <kbd>./stack_trace</kbd>
thread 216810 panic: PermissionDenied
<span class="sgr-1m">/home/andy/src/zig/doc/langref/stack_trace.zig:38:5</span>: <span class="sgr-2m">0x10df2bc in bang2 (stack_trace)</span>
    @panic(&quot;PermissionDenied&quot;);
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/stack_trace.zig:30:10</span>: <span class="sgr-2m">0x10dfb38 in hello (stack_trace)</span>
    bang2();
         <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/stack_trace.zig:17:14</span>: <span class="sgr-2m">0x10df290 in bar (stack_trace)</span>
        hello();
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/stack_trace.zig:7:12</span>: <span class="sgr-2m">0x10df0b4 in foo (stack_trace)</span>
        bar();
           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/stack_trace.zig:2:8</span>: <span class="sgr-2m">0x10de84d in main (stack_trace)</span>
    foo(12);
       <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de352 in posixCallMainAndExit (stack_trace)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10ddf2d in _start (stack_trace)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>
      Here, the stack trace does not explain how the control
      flow in <code>bar</code> got to the <code>hello()</code> call.
      One would have to open a debugger or further instrument the application
      in order to find out. The error return trace, on the other hand,
      shows exactly how the error bubbled up.
      </p>
      <p>
      This debugging feature makes it easier to iterate quickly on code that
      robustly handles all error conditions. This means that Zig developers
      will naturally find themselves writing correct, robust code in order
      to increase their development pace.
      </p>
      <p>
      Error Return Traces are enabled by default in <a href="#Debug">Debug</a> and <a href="#ReleaseSafe">ReleaseSafe</a> builds and disabled by default in <a href="#ReleaseFast">ReleaseFast</a> and <a href="#ReleaseSmall">ReleaseSmall</a> builds.
      </p>
      <p>
      There are a few ways to activate this error return tracing feature:
      </p>
      <ul>
        <li>Return an error from main</li>
        <li>An error makes its way to <code><span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span></code> and you have not overridden the default panic handler</li>
        <li>Use <a href="#errorReturnTrace">errorReturnTrace</a> to access the current return trace. You can use <code>std.debug.dumpStackTrace</code> to print it. This function returns comptime-known <a href="#null">null</a> when building without error return tracing support.</li>
      </ul>
      <h4 id="Implementation-Details"><a href="#toc-Implementation-Details">Implementation Details</a> <a class="hdr" href="#Implementation-Details">§</a></h4>

      <p>
      To analyze performance cost, there are two cases:
      </p>
      <ul>
        <li>when no errors are returned</li>
        <li>when returning errors</li>
      </ul>
      <p>
      For the case when no errors are returned, the cost is a single memory write operation, only in the first non-failable function in the call graph that calls a failable function, i.e. when a function returning <code><span class="tok-type">void</span></code> calls a function returning <code><span class="tok-kw">error</span></code>.
      This is to initialize this struct in the stack memory:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">stack_trace_struct.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StackTrace = <span class="tok-kw">struct</span> {
    index: <span class="tok-type">usize</span>,
    instruction_addresses: [N]<span class="tok-type">usize</span>,
};</code></pre></figure>
      <p>
      Here, N is the maximum function call depth as determined by call graph analysis. Recursion is ignored and counts for 2.
      </p>
      <p>
      A pointer to <code>StackTrace</code> is passed as a secret parameter to every function that can return an error, but it's always the first parameter, so it can likely sit in a register and stay there.
      </p>
      <p>
      That's it for the path when no errors occur. It's practically free in terms of performance.
      </p>
      <p>
      When generating the code for a function that returns an error, just before the <code><span class="tok-kw">return</span></code> statement (only for the <code><span class="tok-kw">return</span></code> statements that return errors), Zig generates a call to this function:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">zig_return_error_fn.zig</cite></figcaption><pre><code><span class="tok-comment">// marked as &quot;no-inline&quot; in LLVM IR</span>
<span class="tok-kw">fn</span> <span class="tok-fn">__zig_return_error</span>(stack_trace: *StackTrace) <span class="tok-type">void</span> {
    stack_trace.instruction_addresses[stack_trace.index] = <span class="tok-builtin">@returnAddress</span>();
    stack_trace.index = (stack_trace.index + <span class="tok-number">1</span>) % N;
}</code></pre></figure>
      <p>
      The cost is 2 math operations plus some memory reads and writes. The memory accessed is constrained and should remain cached for the duration of the error return bubbling.
      </p>
      <p>
      As for code size cost, 1 function call before a return statement is no big deal. Even so,
      I have <a href="https://github.com/ziglang/zig/issues/690">a plan</a> to make the call to
      <code>__zig_return_error</code> a tail call, which brings the code size cost down to actually zero. What is a return statement in code without error return tracing can become a jump instruction in code with error return tracing.
      </p>
      
      
      
      <h2 id="Optionals"><a href="#toc-Optionals">Optionals</a> <a class="hdr" href="#Optionals">§</a></h2>

      <p>
      One area that Zig provides safety without compromising efficiency or
      readability is with the optional type.
      </p>
      <p>
      The question mark symbolizes the optional type. You can convert a type to an optional
      type by putting a question mark in front of it, like this:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">optional_integer.zig</cite></figcaption><pre><code><span class="tok-comment">// normal integer</span>
<span class="tok-kw">const</span> normal_int: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;

<span class="tok-comment">// optional integer</span>
<span class="tok-kw">const</span> optional_int: ?<span class="tok-type">i32</span> = <span class="tok-number">5678</span>;</code></pre></figure>

      <p>
      Now the variable <code>optional_int</code> could be an <code><span class="tok-type">i32</span></code>, or <code><span class="tok-null">null</span></code>.
      </p>
      <p>
      Instead of integers, let's talk about pointers. Null references are the source of many runtime
      exceptions, and even stand accused of being
      <a href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/">the worst mistake of computer science</a>.
      </p>
      <p>Zig does not have them.</p>
      <p>
      Instead, you can use an optional pointer. This secretly compiles down to a normal pointer,
      since we know we can use 0 as the null value for the optional type. But the compiler
      can check your work and make sure you don't assign null to something that can't be null.
      </p>
      <p>
      Typically the downside of not having null is that it makes the code more verbose to
      write. But, let's compare some equivalent C code and Zig code.
      </p>
      <p>
      Task: call malloc, if the result is null, return null.
      </p>
      <p>C code</p>
      <figure><figcaption class="c-cap"><cite class="file">call_malloc_in_c.c</cite></figcaption><pre><code>// malloc prototype included for reference
void *malloc(size_t size);

struct Foo *do_a_thing(void) {
    char *ptr = malloc(1234);
    if (!ptr) return NULL;
    // ...
}</code></pre></figure>
      <p>Zig code</p>
      <figure><figcaption class="zig-cap"><cite class="file">call_malloc_from_zig.zig</cite></figcaption><pre><code><span class="tok-comment">// malloc prototype included for reference</span>
<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">malloc</span>(size: <span class="tok-type">usize</span>) ?[*]<span class="tok-type">u8</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>() ?*Foo {
    <span class="tok-kw">const</span> ptr = malloc(<span class="tok-number">1234</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    _ = ptr; <span class="tok-comment">// ...</span>
}</code></pre></figure>
      <p>
        Here, Zig is at least as convenient, if not more, than C. And, the type of "ptr"
        is <code>[*]<span class="tok-type">u8</span></code> <em>not</em> <code>?[*]<span class="tok-type">u8</span></code>. The <code><span class="tok-kw">orelse</span></code> keyword
                    unwrapped the optional type and therefore <code>ptr</code> is guaranteed to be non-null everywhere
        it is used in the function.
      </p>
      <p>
        The other form of checking against NULL you might see looks like this:
      </p>
      <figure><figcaption class="c-cap"><cite class="file">checking_null_in_c.c</cite></figcaption><pre><code>void do_a_thing(struct Foo *foo) {
    // do some stuff

    if (foo) {
        do_something_with_foo(foo);
    }

    // do some stuff
}</code></pre></figure>
      <p>
        In Zig you can accomplish the same thing:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">checking_null_in_zig.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {};
<span class="tok-kw">fn</span> <span class="tok-fn">doSomethingWithFoo</span>(foo: *Foo) <span class="tok-type">void</span> {
    _ = foo;
}

<span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(optional_foo: ?*Foo) <span class="tok-type">void</span> {
    <span class="tok-comment">// do some stuff</span>

    <span class="tok-kw">if</span> (optional_foo) |foo| {
        doSomethingWithFoo(foo);
    }

    <span class="tok-comment">// do some stuff</span>
}</code></pre></figure>

      <p>
      Once again, the notable thing here is that inside the if block,
      <code>foo</code> is no longer an optional pointer, it is a pointer, which
      cannot be null.
      </p>
      <p>
      One benefit to this is that functions which take pointers as arguments can
      be annotated with the "nonnull" attribute - <code>__attribute__((nonnull))</code> in
      <a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html">GCC</a>.
      The optimizer can sometimes make better decisions knowing that pointer arguments
      cannot be null.
      </p>
      <h3 id="Optional-Type"><a href="#toc-Optional-Type">Optional Type</a> <a class="hdr" href="#Optional-Type">§</a></h3>

      <p>An optional is created by putting <code>?</code> in front of a type. You can use compile-time
      reflection to access the child type of an optional:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_optional_type.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;optional type&quot;</span> {
    <span class="tok-comment">// Declare an optional and coerce from null:</span>
    <span class="tok-kw">var</span> foo: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-comment">// Coerce from child type of an optional</span>
    foo = <span class="tok-number">1234</span>;

    <span class="tok-comment">// Use compile-time reflection to access the child type of the optional:</span>
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(foo)).optional.child == <span class="tok-type">i32</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_optional_type.zig</kbd>
1/1 test_optional_type.test.optional type...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h3 id="null"><a href="#toc-null">null</a> <a class="hdr" href="#null">§</a></h3>

      <p>
      Just like <a href="#undefined">undefined</a>, <code><span class="tok-null">null</span></code> has its own type, and the only way to use it is to
      cast it to a different type:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">null.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> optional_value: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;</code></pre></figure>

      
      <h3 id="Optional-Pointers"><a href="#toc-Optional-Pointers">Optional Pointers</a> <a class="hdr" href="#Optional-Pointers">§</a></h3>

      <p>An optional pointer is guaranteed to be the same size as a pointer. The <code><span class="tok-null">null</span></code> of
      the optional is guaranteed to be address 0.</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_optional_pointer.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;optional pointers&quot;</span> {
    <span class="tok-comment">// Pointers cannot be null. If you want a null pointer, use the optional</span>
    <span class="tok-comment">// prefix `?` to make the pointer type optional.</span>
    <span class="tok-kw">var</span> ptr: ?*<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    ptr = &amp;x;

    <span class="tok-kw">try</span> expect(ptr.?.* == <span class="tok-number">1</span>);

    <span class="tok-comment">// Optional pointers are the same size as normal pointers, because pointer</span>
    <span class="tok-comment">// value 0 is used as the null value.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@sizeOf</span>(?*<span class="tok-type">i32</span>) == <span class="tok-builtin">@sizeOf</span>(*<span class="tok-type">i32</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_optional_pointer.zig</kbd>
1/1 test_optional_pointer.test.optional pointers...OK
All 1 tests passed.
</samp></pre></figure>

      

      <p>See also:</p><ul>
<li><a href="#while-with-Optionals">while with Optionals</a></li>
<li><a href="#if-with-Optionals">if with Optionals</a></li>
</ul>

      
      <h2 id="Casting"><a href="#toc-Casting">Casting</a> <a class="hdr" href="#Casting">§</a></h2>

      <p>
      A <strong>type cast</strong> converts a value of one type to another.
      Zig has <a href="#Type-Coercion">Type Coercion</a> for conversions that are known to be completely safe and unambiguous,
      and <a href="#Explicit-Casts">Explicit Casts</a> for conversions that one would not want to happen on accident.
      There is also a third kind of type conversion called <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for
      the case when a result type must be decided given multiple operand types.
      </p>
      <h3 id="Type-Coercion"><a href="#toc-Type-Coercion">Type Coercion</a> <a class="hdr" href="#Type-Coercion">§</a></h3>

      <p>
      Type coercion occurs when one type is expected, but different type is provided:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_type_coercion.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;type coercion - variable declaration&quot;</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u16</span> = a;
    _ = b;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;type coercion - function call&quot;</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">1</span>;
    foo(a);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(b: <span class="tok-type">u16</span>) <span class="tok-type">void</span> {
    _ = b;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;type coercion - @as builtin&quot;</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> b = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, a);
    _ = b;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_type_coercion.zig</kbd>
1/3 test_type_coercion.test.type coercion - variable declaration...OK
2/3 test_type_coercion.test.type coercion - function call...OK
3/3 test_type_coercion.test.type coercion - @as builtin...OK
All 3 tests passed.
</samp></pre></figure>

      <p>
      Type coercions are only allowed when it is completely unambiguous how to get from one type to another,
      and the transformation is guaranteed to be safe. There is one exception, which is <a href="#C-Pointers">C Pointers</a>.
      </p>
      <h4 id="Type-Coercion-Stricter-Qualification"><a href="#toc-Type-Coercion-Stricter-Qualification">Type Coercion: Stricter Qualification</a> <a class="hdr" href="#Type-Coercion-Stricter-Qualification">§</a></h4>

      <p>
      Values which have the same representation at runtime can be cast to increase the strictness
      of the qualifiers, no matter how nested the qualifiers are:
      </p>
      <ul>
          <li><code><span class="tok-kw">const</span></code> - non-const to const is allowed</li>
          <li><code><span class="tok-kw">volatile</span></code> - non-volatile to volatile is allowed</li>
          <li><code><span class="tok-kw">align</span></code> - bigger to smaller alignment is allowed </li>
          <li><a href="#Error-Set-Type">error sets</a> to supersets is allowed</li>
      </ul>
      <p>
      These casts are no-ops at runtime since the value representation does not change.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_no_op_casts.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;type coercion - const qualification&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> b: *<span class="tok-type">i32</span> = &amp;a;
    foo(b);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(_: *<span class="tok-kw">const</span> <span class="tok-type">i32</span>) <span class="tok-type">void</span> {}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_no_op_casts.zig</kbd>
1/1 test_no_op_casts.test.type coercion - const qualification...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      In addition, pointers coerce to const optional pointers:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_pointer_coerce_const_optional.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> mem = std.mem;

<span class="tok-kw">test</span> <span class="tok-str">&quot;cast *[1][*:0]const u8 to []const ?[*:0]const u8&quot;</span> {
    <span class="tok-kw">const</span> window_name = [<span class="tok-number">1</span>][*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{<span class="tok-str">&quot;window name&quot;</span>};
    <span class="tok-kw">const</span> x: []<span class="tok-kw">const</span> ?[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;window_name;
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, mem.span(x[<span class="tok-number">0</span>].?), <span class="tok-str">&quot;window name&quot;</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_pointer_coerce_const_optional.zig</kbd>
1/1 test_pointer_coerce_const_optional.test.cast *[1][*:0]const u8 to []const ?[*:0]const u8...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h4 id="Type-Coercion-Integer-and-Float-Widening"><a href="#toc-Type-Coercion-Integer-and-Float-Widening">Type Coercion: Integer and Float Widening</a> <a class="hdr" href="#Type-Coercion-Integer-and-Float-Widening">§</a></h4>

      <p>
      <a href="#Integers">Integers</a> coerce to integer types which can represent every value of the old type, and likewise
      <a href="#Floats">Floats</a> coerce to float types which can represent every value of the old type.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_integer_widening.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> mem = std.mem;

<span class="tok-kw">test</span> <span class="tok-str">&quot;integer widening&quot;</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">250</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u16</span> = a;
    <span class="tok-kw">const</span> c: <span class="tok-type">u32</span> = b;
    <span class="tok-kw">const</span> d: <span class="tok-type">u64</span> = c;
    <span class="tok-kw">const</span> e: <span class="tok-type">u64</span> = d;
    <span class="tok-kw">const</span> f: <span class="tok-type">u128</span> = e;
    <span class="tok-kw">try</span> expect(f == a);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;implicit unsigned integer to signed integer&quot;</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = <span class="tok-number">250</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i16</span> = a;
    <span class="tok-kw">try</span> expect(b == <span class="tok-number">250</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;float widening&quot;</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">f16</span> = <span class="tok-number">12.34</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">f32</span> = a;
    <span class="tok-kw">const</span> c: <span class="tok-type">f64</span> = b;
    <span class="tok-kw">const</span> d: <span class="tok-type">f128</span> = c;
    <span class="tok-kw">try</span> expect(d == a);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_integer_widening.zig</kbd>
1/3 test_integer_widening.test.integer widening...OK
2/3 test_integer_widening.test.implicit unsigned integer to signed integer...OK
3/3 test_integer_widening.test.float widening...OK
All 3 tests passed.
</samp></pre></figure>

      
      <h4 id="Type-Coercion-Float-to-Int"><a href="#toc-Type-Coercion-Float-to-Int">Type Coercion: Float to Int</a> <a class="hdr" href="#Type-Coercion-Float-to-Int">§</a></h4>

      <p>
      A compiler error is appropriate because this ambiguous expression leaves the compiler
      two choices about the coercion.
      </p>
      <ul>
        <li>Cast <code><span class="tok-number">54.0</span></code> to <code><span class="tok-type">comptime_int</span></code> resulting in <code><span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-number">10</span>)</code>, which is casted to <code><span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">10</span>)</code></li>
        <li>Cast <code><span class="tok-number">5</span></code> to <code><span class="tok-type">comptime_float</span></code> resulting in <code><span class="tok-builtin">@as</span>(<span class="tok-type">comptime_float</span>, <span class="tok-number">10.8</span>)</code>, which is casted to <code><span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">10.8</span>)</code></li>
      </ul>
      <figure><figcaption class="zig-cap"><cite class="file">test_ambiguous_coercion.zig</cite></figcaption><pre><code><span class="tok-comment">// Compile time coercion of float to int</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;implicit cast to comptime_int&quot;</span> {
    <span class="tok-kw">const</span> f: <span class="tok-type">f32</span> = <span class="tok-number">54.0</span> / <span class="tok-number">5</span>;
    _ = f;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_ambiguous_coercion.zig</kbd>
<span class="sgr-1m">doc/langref/test_ambiguous_coercion.zig:3:25: </span><span class="sgr-31m">error: </span><span class="sgr-1m">ambiguous coercion of division operands 'comptime_float' and 'comptime_int'; non-zero remainder '4'
</span>    const f: f32 = 54.0 / 5;
                   <span class="sgr-32m">~~~~~^~~
</span>
</samp></pre></figure>

      
      <h4 id="Type-Coercion-Slices-Arrays-and-Pointers"><a href="#toc-Type-Coercion-Slices-Arrays-and-Pointers">Type Coercion: Slices, Arrays and Pointers</a> <a class="hdr" href="#Type-Coercion-Slices-Arrays-and-Pointers">§</a></h4>

      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_slices_arrays_and_pointers.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-comment">// You can assign constant pointers to arrays to a slice with</span>
<span class="tok-comment">// const modifier on the element type. Useful in particular for</span>
<span class="tok-comment">// String literals.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;*const [N]T to []const T&quot;</span> {
    <span class="tok-kw">const</span> x1: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>;
    <span class="tok-kw">const</span> x2: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[<span class="tok-number">5</span>]<span class="tok-type">u8</span>{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-number">111</span> };
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, x1, x2));

    <span class="tok-kw">const</span> y: []<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;[<span class="tok-number">2</span>]<span class="tok-type">f32</span>{ <span class="tok-number">1.2</span>, <span class="tok-number">3.4</span> };
    <span class="tok-kw">try</span> expect(y[<span class="tok-number">0</span>] == <span class="tok-number">1.2</span>);
}

<span class="tok-comment">// Likewise, it works when the destination type is an error union.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;*const [N]T to E![]const T&quot;</span> {
    <span class="tok-kw">const</span> x1: <span class="tok-type">anyerror</span>![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>;
    <span class="tok-kw">const</span> x2: <span class="tok-type">anyerror</span>![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[<span class="tok-number">5</span>]<span class="tok-type">u8</span>{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-number">111</span> };
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> x1, <span class="tok-kw">try</span> x2));

    <span class="tok-kw">const</span> y: <span class="tok-type">anyerror</span>![]<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;[<span class="tok-number">2</span>]<span class="tok-type">f32</span>{ <span class="tok-number">1.2</span>, <span class="tok-number">3.4</span> };
    <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> y)[<span class="tok-number">0</span>] == <span class="tok-number">1.2</span>);
}

<span class="tok-comment">// Likewise, it works when the destination type is an optional.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;*const [N]T to ?[]const T&quot;</span> {
    <span class="tok-kw">const</span> x1: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>;
    <span class="tok-kw">const</span> x2: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[<span class="tok-number">5</span>]<span class="tok-type">u8</span>{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-number">111</span> };
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, x1.?, x2.?));

    <span class="tok-kw">const</span> y: ?[]<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;[<span class="tok-number">2</span>]<span class="tok-type">f32</span>{ <span class="tok-number">1.2</span>, <span class="tok-number">3.4</span> };
    <span class="tok-kw">try</span> expect(y.?[<span class="tok-number">0</span>] == <span class="tok-number">1.2</span>);
}

<span class="tok-comment">// In this cast, the array length becomes the slice length.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;*[N]T to []T&quot;</span> {
    <span class="tok-kw">var</span> buf: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>.*;
    <span class="tok-kw">const</span> x: []<span class="tok-type">u8</span> = &amp;buf;
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, x, <span class="tok-str">&quot;hello&quot;</span>));

    <span class="tok-kw">const</span> buf2 = [<span class="tok-number">2</span>]<span class="tok-type">f32</span>{ <span class="tok-number">1.2</span>, <span class="tok-number">3.4</span> };
    <span class="tok-kw">const</span> x2: []<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;buf2;
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">f32</span>, x2, &amp;[<span class="tok-number">2</span>]<span class="tok-type">f32</span>{ <span class="tok-number">1.2</span>, <span class="tok-number">3.4</span> }));
}

<span class="tok-comment">// Single-item pointers to arrays can be coerced to many-item pointers.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;*[N]T to [*]T&quot;</span> {
    <span class="tok-kw">var</span> buf: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>.*;
    <span class="tok-kw">const</span> x: [*]<span class="tok-type">u8</span> = &amp;buf;
    <span class="tok-kw">try</span> expect(x[<span class="tok-number">4</span>] == <span class="tok-str">'o'</span>);
    <span class="tok-comment">// x[5] would be an uncaught out of bounds pointer dereference!</span>
}

<span class="tok-comment">// Likewise, it works when the destination type is an optional.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;*[N]T to ?[*]T&quot;</span> {
    <span class="tok-kw">var</span> buf: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>.*;
    <span class="tok-kw">const</span> x: ?[*]<span class="tok-type">u8</span> = &amp;buf;
    <span class="tok-kw">try</span> expect(x.?[<span class="tok-number">4</span>] == <span class="tok-str">'o'</span>);
}

<span class="tok-comment">// Single-item pointers can be cast to len-1 single-item arrays.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;*T to *[1]T&quot;</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> y: *[<span class="tok-number">1</span>]<span class="tok-type">i32</span> = &amp;x;
    <span class="tok-kw">const</span> z: [*]<span class="tok-type">i32</span> = y;
    <span class="tok-kw">try</span> expect(z[<span class="tok-number">0</span>] == <span class="tok-number">1234</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_slices_arrays_and_pointers.zig</kbd>
1/7 test_coerce_slices_arrays_and_pointers.test.*const [N]T to []const T...OK
2/7 test_coerce_slices_arrays_and_pointers.test.*const [N]T to E![]const T...OK
3/7 test_coerce_slices_arrays_and_pointers.test.*const [N]T to ?[]const T...OK
4/7 test_coerce_slices_arrays_and_pointers.test.*[N]T to []T...OK
5/7 test_coerce_slices_arrays_and_pointers.test.*[N]T to [*]T...OK
6/7 test_coerce_slices_arrays_and_pointers.test.*[N]T to ?[*]T...OK
7/7 test_coerce_slices_arrays_and_pointers.test.*T to *[1]T...OK
All 7 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#C-Pointers">C Pointers</a></li>
</ul>

      
      <h4 id="Type-Coercion-Optionals"><a href="#toc-Type-Coercion-Optionals">Type Coercion: Optionals</a> <a class="hdr" href="#Type-Coercion-Optionals">§</a></h4>

      <p>
      The payload type of <a href="#Optionals">Optionals</a>, as well as <a href="#null">null</a>, coerce to the optional type.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_optionals.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;coerce to optionals&quot;</span> {
    <span class="tok-kw">const</span> x: ?<span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> y: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">try</span> expect(x.? == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> expect(y == <span class="tok-null">null</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_optionals.zig</kbd>
1/1 test_coerce_optionals.test.coerce to optionals...OK
All 1 tests passed.
</samp></pre></figure>

      <p>Optionals work nested inside the <a href="#Error-Union-Type">Error Union Type</a>, too:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_optional_wrapped_error_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;coerce to optionals wrapped in error union&quot;</span> {
    <span class="tok-kw">const</span> x: <span class="tok-type">anyerror</span>!?<span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> y: <span class="tok-type">anyerror</span>!?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> x).? == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> y) == <span class="tok-null">null</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_optional_wrapped_error_union.zig</kbd>
1/1 test_coerce_optional_wrapped_error_union.test.coerce to optionals wrapped in error union...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h4 id="Type-Coercion-Error-Unions"><a href="#toc-Type-Coercion-Error-Unions">Type Coercion: Error Unions</a> <a class="hdr" href="#Type-Coercion-Error-Unions">§</a></h4>

      <p>The payload type of an <a href="#Error-Union-Type">Error Union Type</a> as well as the <a href="#Error-Set-Type">Error Set Type</a>
      coerce to the error union type:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_to_error_union.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;coercion to error unions&quot;</span> {
    <span class="tok-kw">const</span> x: <span class="tok-type">anyerror</span>!<span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> y: <span class="tok-type">anyerror</span>!<span class="tok-type">i32</span> = <span class="tok-kw">error</span>.Failure;

    <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> x) == <span class="tok-number">1234</span>);
    <span class="tok-kw">try</span> std.testing.expectError(<span class="tok-kw">error</span>.Failure, y);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_to_error_union.zig</kbd>
1/1 test_coerce_to_error_union.test.coercion to error unions...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h4 id="Type-Coercion-Compile-Time-Known-Numbers"><a href="#toc-Type-Coercion-Compile-Time-Known-Numbers">Type Coercion: Compile-Time Known Numbers</a> <a class="hdr" href="#Type-Coercion-Compile-Time-Known-Numbers">§</a></h4>

      <p>When a number is <a href="#comptime">comptime</a>-known to be representable in the destination type,
      it may be coerced:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_large_to_small.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;coercing large integer type to smaller one when value is comptime-known to fit&quot;</span> {
    <span class="tok-kw">const</span> x: <span class="tok-type">u64</span> = <span class="tok-number">255</span>;
    <span class="tok-kw">const</span> y: <span class="tok-type">u8</span> = x;
    <span class="tok-kw">try</span> expect(y == <span class="tok-number">255</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_large_to_small.zig</kbd>
1/1 test_coerce_large_to_small.test.coercing large integer type to smaller one when value is comptime-known to fit...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h4 id="Type-Coercion-Unions-and-Enums"><a href="#toc-Type-Coercion-Unions-and-Enums">Type Coercion: Unions and Enums</a> <a class="hdr" href="#Type-Coercion-Unions-and-Enums">§</a></h4>

      <p>Tagged unions can be coerced to enums, and enums can be coerced to tagged unions
      when they are <a href="#comptime">comptime</a>-known to be a field of the union that has only one possible value, such as
      <a href="#void">void</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_unions_enums.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> E = <span class="tok-kw">enum</span> {
    one,
    two,
    three,
};

<span class="tok-kw">const</span> U = <span class="tok-kw">union</span>(E) {
    one: <span class="tok-type">i32</span>,
    two: <span class="tok-type">f32</span>,
    three,
};

<span class="tok-kw">const</span> U2 = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    a: <span class="tok-type">void</span>,
    b: <span class="tok-type">f32</span>,

    <span class="tok-kw">fn</span> <span class="tok-fn">tag</span>(self: U2) <span class="tok-type">usize</span> {
        <span class="tok-kw">switch</span> (self) {
            .a =&gt; <span class="tok-kw">return</span> <span class="tok-number">1</span>,
            .b =&gt; <span class="tok-kw">return</span> <span class="tok-number">2</span>,
        }
    }
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;coercion between unions and enums&quot;</span> {
    <span class="tok-kw">const</span> u = U{ .two = <span class="tok-number">12.34</span> };
    <span class="tok-kw">const</span> e: E = u; <span class="tok-comment">// coerce union to enum</span>
    <span class="tok-kw">try</span> expect(e == E.two);

    <span class="tok-kw">const</span> three = E.three;
    <span class="tok-kw">const</span> u_2: U = three; <span class="tok-comment">// coerce enum to union</span>
    <span class="tok-kw">try</span> expect(u_2 == E.three);

    <span class="tok-kw">const</span> u_3: U = .three; <span class="tok-comment">// coerce enum literal to union</span>
    <span class="tok-kw">try</span> expect(u_3 == E.three);

    <span class="tok-kw">const</span> u_4: U2 = .a; <span class="tok-comment">// coerce enum literal to union with inferred enum tag type.</span>
    <span class="tok-kw">try</span> expect(u_4.tag() == <span class="tok-number">1</span>);

    <span class="tok-comment">// The following example is invalid.</span>
    <span class="tok-comment">// error: coercion from enum '@TypeOf(.enum_literal)' to union 'test_coerce_unions_enum.U2' must initialize 'f32' field 'b'</span>
    <span class="tok-comment">//var u_5: U2 = .b;</span>
    <span class="tok-comment">//try expect(u_5.tag() == 2);</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_unions_enums.zig</kbd>
1/1 test_coerce_unions_enums.test.coercion between unions and enums...OK
All 1 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#union">union</a></li>
<li><a href="#enum">enum</a></li>
</ul>

      
      <h4 id="Type-Coercion-undefined"><a href="#toc-Type-Coercion-undefined">Type Coercion: undefined</a> <a class="hdr" href="#Type-Coercion-undefined">§</a></h4>

      <p><a href="#undefined">undefined</a> can be coerced to any type.</p>
      

      <h4 id="Type-Coercion-Tuples-to-Arrays"><a href="#toc-Type-Coercion-Tuples-to-Arrays">Type Coercion: Tuples to Arrays</a> <a class="hdr" href="#Type-Coercion-Tuples-to-Arrays">§</a></h4>

      <p><a href="#Tuples">Tuples</a> can be coerced to arrays, if all of the fields have the same type.</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_coerce_tuples_arrays.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Tuple = <span class="tok-kw">struct</span> { <span class="tok-type">u8</span>, <span class="tok-type">u8</span> };
<span class="tok-kw">test</span> <span class="tok-str">&quot;coercion from homogeneous tuple to array&quot;</span> {
    <span class="tok-kw">const</span> tuple: Tuple = .{ <span class="tok-number">5</span>, <span class="tok-number">6</span> };
    <span class="tok-kw">const</span> array: [<span class="tok-number">2</span>]<span class="tok-type">u8</span> = tuple;
    _ = array;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_coerce_tuples_arrays.zig</kbd>
1/1 test_coerce_tuples_arrays.test.coercion from homogeneous tuple to array...OK
All 1 tests passed.
</samp></pre></figure>

      
      

      <h3 id="Explicit-Casts"><a href="#toc-Explicit-Casts">Explicit Casts</a> <a class="hdr" href="#Explicit-Casts">§</a></h3>

      <p>
      Explicit casts are performed via <a href="#Builtin-Functions">Builtin Functions</a>.
      Some explicit casts are safe; some are not.
      Some explicit casts perform language-level assertions; some do not.
      Some explicit casts are no-ops at runtime; some are not.
      </p>
      <ul>
          <li><a href="#bitCast">@bitCast</a> - change type but maintain bit representation</li>
          <li><a href="#alignCast">@alignCast</a> - make a pointer have more alignment</li>
          <li><a href="#enumFromInt">@enumFromInt</a> - obtain an enum value based on its integer tag value</li>
          <li><a href="#errorFromInt">@errorFromInt</a> - obtain an error code based on its integer value</li>
          <li><a href="#errorCast">@errorCast</a> - convert to a smaller error set</li>
          <li><a href="#floatCast">@floatCast</a> - convert a larger float to a smaller float</li>
          <li><a href="#floatFromInt">@floatFromInt</a> - convert an integer to a float value</li>
          <li><a href="#intCast">@intCast</a> - convert between integer types</li>
          <li><a href="#intFromBool">@intFromBool</a> - convert true to 1 and false to 0</li>
          <li><a href="#intFromEnum">@intFromEnum</a> - obtain the integer tag value of an enum or tagged union</li>
          <li><a href="#intFromError">@intFromError</a> - obtain the integer value of an error code</li>
          <li><a href="#intFromFloat">@intFromFloat</a> - obtain the integer part of a float value</li>
          <li><a href="#intFromPtr">@intFromPtr</a> - obtain the address of a pointer</li>
          <li><a href="#ptrFromInt">@ptrFromInt</a> - convert an address to a pointer</li>
          <li><a href="#ptrCast">@ptrCast</a> - convert between pointer types</li>
          <li><a href="#truncate">@truncate</a> - convert between integer types, chopping off bits</li>
      </ul>
      

      <h3 id="Peer-Type-Resolution"><a href="#toc-Peer-Type-Resolution">Peer Type Resolution</a> <a class="hdr" href="#Peer-Type-Resolution">§</a></h3>

      <p>Peer Type Resolution occurs in these places:</p>
      <ul>
        <li><a href="#switch">switch</a> expressions</li>
        <li><a href="#if">if</a> expressions</li>
        <li><a href="#while">while</a> expressions</li>
        <li><a href="#for">for</a> expressions</li>
        <li>Multiple break statements in a block</li>
        <li>Some <a href="#Table-of-Operators">binary operations</a></li>
      </ul>
      <p>
      This kind of type resolution chooses a type that all peer types can coerce into. Here are
      some examples:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_peer_type_resolution.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> mem = std.mem;

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer resolve int widening&quot;</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">i8</span> = <span class="tok-number">12</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i16</span> = <span class="tok-number">34</span>;
    <span class="tok-kw">const</span> c = a + b;
    <span class="tok-kw">try</span> expect(c == <span class="tok-number">46</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(c) == <span class="tok-type">i16</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer resolve arrays of different size to const slice&quot;</span> {
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">true</span>), <span class="tok-str">&quot;true&quot;</span>));
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">false</span>), <span class="tok-str">&quot;false&quot;</span>));
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">true</span>), <span class="tok-str">&quot;true&quot;</span>));
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">false</span>), <span class="tok-str">&quot;false&quot;</span>));
}
<span class="tok-kw">fn</span> <span class="tok-fn">boolToStr</span>(b: <span class="tok-type">bool</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (b) <span class="tok-str">&quot;true&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;false&quot;</span>;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer resolve array and const slice&quot;</span> {
    <span class="tok-kw">try</span> testPeerResolveArrayConstSlice(<span class="tok-null">true</span>);
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> testPeerResolveArrayConstSlice(<span class="tok-null">true</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">testPeerResolveArrayConstSlice</span>(b: <span class="tok-type">bool</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> value1 = <span class="tok-kw">if</span> (b) <span class="tok-str">&quot;aoeu&quot;</span> <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">&quot;zz&quot;</span>);
    <span class="tok-kw">const</span> value2 = <span class="tok-kw">if</span> (b) <span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">&quot;zz&quot;</span>) <span class="tok-kw">else</span> <span class="tok-str">&quot;aoeu&quot;</span>;
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, value1, <span class="tok-str">&quot;aoeu&quot;</span>));
    <span class="tok-kw">try</span> expect(mem.eql(<span class="tok-type">u8</span>, value2, <span class="tok-str">&quot;zz&quot;</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer type resolution: ?T and T&quot;</span> {
    <span class="tok-kw">try</span> expect(peerTypeTAndOptionalT(<span class="tok-null">true</span>, <span class="tok-null">false</span>).? == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(peerTypeTAndOptionalT(<span class="tok-null">false</span>, <span class="tok-null">false</span>).? == <span class="tok-number">3</span>);
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">try</span> expect(peerTypeTAndOptionalT(<span class="tok-null">true</span>, <span class="tok-null">false</span>).? == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect(peerTypeTAndOptionalT(<span class="tok-null">false</span>, <span class="tok-null">false</span>).? == <span class="tok-number">3</span>);
    }
}
<span class="tok-kw">fn</span> <span class="tok-fn">peerTypeTAndOptionalT</span>(c: <span class="tok-type">bool</span>, b: <span class="tok-type">bool</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (c) {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (b) <span class="tok-null">null</span> <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);
    }

    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">3</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer type resolution: *[0]u8 and []const u8&quot;</span> {
    <span class="tok-kw">try</span> expect(peerTypeEmptyArrayAndSlice(<span class="tok-null">true</span>, <span class="tok-str">&quot;hi&quot;</span>).len == <span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(peerTypeEmptyArrayAndSlice(<span class="tok-null">false</span>, <span class="tok-str">&quot;hi&quot;</span>).len == <span class="tok-number">1</span>);
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">try</span> expect(peerTypeEmptyArrayAndSlice(<span class="tok-null">true</span>, <span class="tok-str">&quot;hi&quot;</span>).len == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect(peerTypeEmptyArrayAndSlice(<span class="tok-null">false</span>, <span class="tok-str">&quot;hi&quot;</span>).len == <span class="tok-number">1</span>);
    }
}
<span class="tok-kw">fn</span> <span class="tok-fn">peerTypeEmptyArrayAndSlice</span>(a: <span class="tok-type">bool</span>, slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (a) {
        <span class="tok-kw">return</span> &amp;[_]<span class="tok-type">u8</span>{};
    }

    <span class="tok-kw">return</span> slice[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;peer type resolution: *[0]u8, []const u8, and anyerror![]u8&quot;</span> {
    {
        <span class="tok-kw">var</span> data = <span class="tok-str">&quot;hi&quot;</span>.*;
        <span class="tok-kw">const</span> slice = data[<span class="tok-number">0</span>..];
        <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">true</span>, slice)).len == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">false</span>, slice)).len == <span class="tok-number">1</span>);
    }
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> data = <span class="tok-str">&quot;hi&quot;</span>.*;
        <span class="tok-kw">const</span> slice = data[<span class="tok-number">0</span>..];
        <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">true</span>, slice)).len == <span class="tok-number">0</span>);
        <span class="tok-kw">try</span> expect((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">false</span>, slice)).len == <span class="tok-number">1</span>);
    }
}
<span class="tok-kw">fn</span> <span class="tok-fn">peerTypeEmptyArrayAndSliceAndError</span>(a: <span class="tok-type">bool</span>, slice: []<span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (a) {
        <span class="tok-kw">return</span> &amp;[_]<span class="tok-type">u8</span>{};
    }

    <span class="tok-kw">return</span> slice[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer type resolution: *const T and ?*T&quot;</span> {
    <span class="tok-kw">const</span> a: *<span class="tok-kw">const</span> <span class="tok-type">usize</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0x123456780</span>);
    <span class="tok-kw">const</span> b: ?*<span class="tok-type">usize</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0x123456780</span>);
    <span class="tok-kw">try</span> expect(a == b);
    <span class="tok-kw">try</span> expect(b == a);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer type resolution: error union switch&quot;</span> {
    <span class="tok-comment">// The non-error and error cases are only peers if the error case is just a switch expression;</span>
    <span class="tok-comment">// the pattern `if (x) {...} else |err| blk: { switch (err) {...} }` does not consider the</span>
    <span class="tok-comment">// non-error and error case to be peers.</span>
    <span class="tok-kw">var</span> a: <span class="tok-kw">error</span>{ A, B, C }!<span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    _ = &amp;a;
    <span class="tok-kw">const</span> b = <span class="tok-kw">if</span> (a) |x|
        x + <span class="tok-number">3</span>
    <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.A =&gt; <span class="tok-number">0</span>,
        <span class="tok-kw">error</span>.B =&gt; <span class="tok-number">1</span>,
        <span class="tok-kw">error</span>.C =&gt; <span class="tok-null">null</span>,
    };
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(b) == ?<span class="tok-type">u32</span>);

    <span class="tok-comment">// The non-error and error cases are only peers if the error case is just a switch expression;</span>
    <span class="tok-comment">// the pattern `x catch |err| blk: { switch (err) {...} }` does not consider the unwrapped `x`</span>
    <span class="tok-comment">// and error case to be peers.</span>
    <span class="tok-kw">const</span> c = a <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.A =&gt; <span class="tok-number">0</span>,
        <span class="tok-kw">error</span>.B =&gt; <span class="tok-number">1</span>,
        <span class="tok-kw">error</span>.C =&gt; <span class="tok-null">null</span>,
    };
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@TypeOf</span>(c) == ?<span class="tok-type">u32</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_peer_type_resolution.zig</kbd>
1/8 test_peer_type_resolution.test.peer resolve int widening...OK
2/8 test_peer_type_resolution.test.peer resolve arrays of different size to const slice...OK
3/8 test_peer_type_resolution.test.peer resolve array and const slice...OK
4/8 test_peer_type_resolution.test.peer type resolution: ?T and T...OK
5/8 test_peer_type_resolution.test.peer type resolution: *[0]u8 and []const u8...OK
6/8 test_peer_type_resolution.test.peer type resolution: *[0]u8, []const u8, and anyerror![]u8...OK
7/8 test_peer_type_resolution.test.peer type resolution: *const T and ?*T...OK
8/8 test_peer_type_resolution.test.peer type resolution: error union switch...OK
All 8 tests passed.
</samp></pre></figure>

      
      

      <h2 id="Zero-Bit-Types"><a href="#toc-Zero-Bit-Types">Zero Bit Types</a> <a class="hdr" href="#Zero-Bit-Types">§</a></h2>

      <p>For some types, <a href="#sizeOf">@sizeOf</a> is 0:</p>
      <ul>
          <li><a href="#void">void</a></li>
          <li>The <a href="#Integers">Integers</a> <code><span class="tok-type">u0</span></code> and <code><span class="tok-type">i0</span></code>.</li>
          <li><a href="#Arrays">Arrays</a> and <a href="#Vectors">Vectors</a> with len 0, or with an element type that is a zero bit type.</li>
          <li>An <a href="#enum">enum</a> with only 1 tag.</li>
          <li>A <a href="#struct">struct</a> with all fields being zero bit types.</li>
          <li>A <a href="#union">union</a> with only 1 field which is a zero bit type.</li>
      </ul>
      <p>
      These types can only ever have one possible value, and thus
      require 0 bits to represent. Code that makes use of these types is
      not included in the final generated code:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">zero_bit_types.zig</cite></figcaption><pre><code><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">entry</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">void</span> = {};
    <span class="tok-kw">var</span> y: <span class="tok-type">void</span> = {};
    x = y;
    y = x;
}</code></pre></figure>

      <p>When this turns into machine code, there is no code generated in the
      body of <code>entry</code>, even in <a href="#Debug">Debug</a> mode. For example, on x86_64:</p>
      <pre><code>0000000000000010 &lt;entry&gt;:
  10:	55                   	push   %rbp
  11:	48 89 e5             	mov    %rsp,%rbp
  14:	5d                   	pop    %rbp
  15:	c3                   	retq   </code></pre>
      <p>These assembly instructions do not have any code associated with the void values -
      they only perform the function call prologue and epilogue.</p>

      <h3 id="void"><a href="#toc-void">void</a> <a class="hdr" href="#void">§</a></h3>

      <p>
      <code><span class="tok-type">void</span></code> can be useful for instantiating generic types. For example, given a
          <code>Map(Key, Value)</code>, one can pass <code><span class="tok-type">void</span></code> for the <code>Value</code>
                      type to make it into a <code>Set</code>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_void_in_hashmap.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;turn HashMap into a set with void&quot;</span> {
    <span class="tok-kw">var</span> map = std.AutoHashMap(<span class="tok-type">i32</span>, <span class="tok-type">void</span>).init(std.testing.allocator);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">try</span> map.put(<span class="tok-number">1</span>, {});
    <span class="tok-kw">try</span> map.put(<span class="tok-number">2</span>, {});

    <span class="tok-kw">try</span> expect(map.contains(<span class="tok-number">2</span>));
    <span class="tok-kw">try</span> expect(!map.contains(<span class="tok-number">3</span>));

    _ = map.remove(<span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(!map.contains(<span class="tok-number">2</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_void_in_hashmap.zig</kbd>
1/1 test_void_in_hashmap.test.turn HashMap into a set with void...OK
All 1 tests passed.
</samp></pre></figure>

      <p>Note that this is different from using a dummy value for the hash map value.
      By using <code><span class="tok-type">void</span></code> as the type of the value, the hash map entry type has no value field, and
      thus the hash map takes up less space. Further, all the code that deals with storing and loading the
      value is deleted, as seen above.
      </p>
      <p>
      <code><span class="tok-type">void</span></code> is distinct from <code><span class="tok-type">anyopaque</span></code>.
      <code><span class="tok-type">void</span></code> has a known size of 0 bytes, and <code><span class="tok-type">anyopaque</span></code> has an unknown, but non-zero, size.
      </p>
      <p>
      Expressions of type <code><span class="tok-type">void</span></code> are the only ones whose value can be ignored. For example, ignoring
      a non-<code><span class="tok-type">void</span></code> expression is a compile error:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_expression_ignored.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;ignoring expression value&quot;</span> {
    foo();
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_expression_ignored.zig</kbd>
<span class="sgr-1m">doc/langref/test_expression_ignored.zig:2:8: </span><span class="sgr-31m">error: </span><span class="sgr-1m">value of type 'i32' ignored
</span>    foo();
    <span class="sgr-32m">~~~^~
</span><span class="sgr-1m">doc/langref/test_expression_ignored.zig:2:8: </span><span class="sgr-36m">note: </span><span class="sgr-1m">all non-void values must be used
</span><span class="sgr-1m">doc/langref/test_expression_ignored.zig:2:8: </span><span class="sgr-36m">note: </span><span class="sgr-1m">to discard the value, assign it to '_'
</span>
</samp></pre></figure>

      <p>However, if the expression has type <code><span class="tok-type">void</span></code>, there will be no error. Expression results can be explicitly ignored by assigning them to <code>_</code>. </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_void_ignored.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;void is ignored&quot;</span> {
    returnsVoid();
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;explicitly ignoring expression value&quot;</span> {
    _ = foo();
}

<span class="tok-kw">fn</span> <span class="tok-fn">returnsVoid</span>() <span class="tok-type">void</span> {}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_void_ignored.zig</kbd>
1/2 test_void_ignored.test.void is ignored...OK
2/2 test_void_ignored.test.explicitly ignoring expression value...OK
All 2 tests passed.
</samp></pre></figure>

      
      

      <h2 id="Result-Location-Semantics"><a href="#toc-Result-Location-Semantics">Result Location Semantics</a> <a class="hdr" href="#Result-Location-Semantics">§</a></h2>

      <p>
      During compilation, every Zig expression and sub-expression is assigned optional result location
      information. This information dictates what type the expression should have (its result type), and
      where the resulting value should be placed in memory (its result location). The information is
      optional in the sense that not every expression has this information: assignment to
      <code>_</code>, for instance, does not provide any information about the type of an
      expression, nor does it provide a concrete memory location to place it in.
      </p>
      <p>
      As a motivating example, consider the statement <code><span class="tok-kw">const</span> x: <span class="tok-type">u32</span> = <span class="tok-number">42</span>;</code>. The type
      annotation here provides a result type of <code><span class="tok-type">u32</span></code> to the initialization expression
      <code><span class="tok-number">42</span></code>, instructing the compiler to coerce this integer (initially of type
      <code><span class="tok-type">comptime_int</span></code>) to this type. We will see more examples shortly.
      </p>
      <p>
      This is not an implementation detail: the logic outlined above is codified into the Zig language
      specification, and is the primary mechanism of type inference in the language. This system is
      collectively referred to as "Result Location Semantics".
      </p>
      <h3 id="Result-Types"><a href="#toc-Result-Types">Result Types</a> <a class="hdr" href="#Result-Types">§</a></h3>

      <p>
      Result types are propagated recursively through expressions where possible. For instance, if the
      expression <code>&amp;e</code> has result type <code>*<span class="tok-type">u32</span></code>, then
      <code>e</code> is given a result type of <code><span class="tok-type">u32</span></code>, allowing the
      language to perform this coercion before taking a reference.
      </p>
      <p>
      The result type mechanism is utilized by casting builtins such as <code><span class="tok-builtin">@intCast</span></code>.
      Rather than taking as an argument the type to cast to, these builtins use their result type to
      determine this information. The result type is often known from context; where it is not, the
      <code><span class="tok-builtin">@as</span></code> builtin can be used to explicitly provide a result type.
      </p>
      <p>
      We can break down the result types for each component of a simple expression as follows:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">result_type_propagation.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expectEqual = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expectEqual;
<span class="tok-kw">test</span> <span class="tok-str">&quot;result type propagates through struct initializer&quot;</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> { x: <span class="tok-type">u32</span> };
    <span class="tok-kw">const</span> val: <span class="tok-type">u64</span> = <span class="tok-number">123</span>;
    <span class="tok-kw">const</span> s: S = .{ .x = <span class="tok-builtin">@intCast</span>(val) };
    <span class="tok-comment">// .{ .x = @intCast(val) }   has result type `S` due to the type annotation</span>
    <span class="tok-comment">//         @intCast(val)     has result type `u32` due to the type of the field `S.x`</span>
    <span class="tok-comment">//                  val      has no result type, as it is permitted to be any integer type</span>
    <span class="tok-kw">try</span> expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">123</span>), s.x);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test result_type_propagation.zig</kbd>
1/1 result_type_propagation.test.result type propagates through struct initializer...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      This result type information is useful for the aforementioned cast builtins, as well as to avoid
      the construction of pre-coercion values, and to avoid the need for explicit type coercions in some
      cases. The following table details how some common expressions propagate result types, where
      <code>x</code> and <code>y</code> are arbitrary sub-expressions.
      </p>
      <div class="table-wrapper">
      <table>
        <thead>
          <tr>
            <th scope="col">Expression</th>
            <th scope="col">Parent Result Type</th>
            <th scope="col">Sub-expression Result Type</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th scope="row"><code><span class="tok-kw">const</span> val: T = x</code></th>
            <td>-</td>
            <td><code>x</code> is a <code>T</code></td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-kw">var</span> val: T = x</code></th>
            <td>-</td>
            <td><code>x</code> is a <code>T</code></td>
          </tr>
          <tr>
            <th scope="row"><code>val = x</code></th>
            <td>-</td>
            <td><code>x</code> is a <code><span class="tok-builtin">@TypeOf</span>(val)</code></td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-builtin">@as</span>(T, x)</code></th>
            <td>-</td>
            <td><code>x</code> is a <code>T</code></td>
          </tr>
          <tr>
            <th scope="row"><code>&amp;x</code></th>
            <td><code>*T</code></td>
            <td><code>x</code> is a <code>T</code></td>
          </tr>
          <tr>
            <th scope="row"><code>&amp;x</code></th>
            <td><code>[]T</code></td>
            <td><code>x</code> is some array of <code>T</code></td>
          </tr>
          <tr>
            <th scope="row"><code>f(x)</code></th>
            <td>-</td>
            <td><code>x</code> has the type of the first parameter of <code>f</code></td>
          </tr>
          <tr>
            <th scope="row"><code>.{x}</code></th>
            <td><code>T</code></td>
            <td><code>x</code> is a <code>std.meta.FieldType(T, .@&quot;0&quot;)</code></td>
          </tr>
          <tr>
            <th scope="row"><code>.{ .a = x }</code></th>
            <td><code>T</code></td>
            <td><code>x</code> is a <code>std.meta.FieldType(T, .a)</code></td>
          </tr>
          <tr>
            <th scope="row"><code>T{x}</code></th>
            <td>-</td>
            <td><code>x</code> is a <code>std.meta.FieldType(T, .@&quot;0&quot;)</code></td>
          </tr>
          <tr>
            <th scope="row"><code>T{ .a = x }</code></th>
            <td>-</td>
            <td><code>x</code> is a <code>std.meta.FieldType(T, .a)</code></td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-builtin">@Type</span>(x)</code></th>
            <td>-</td>
            <td><code>x</code> is a <code>std.builtin.Type</code></td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-builtin">@typeInfo</span>(x)</code></th>
            <td>-</td>
            <td><code>x</code> is a <code><span class="tok-type">type</span></code></td>
          </tr>
          <tr>
            <th scope="row"><code>x &lt;&lt; y</code></th>
            <td>-</td>
            <td><code>y</code> is a <code>std.math.Log2IntCeil(<span class="tok-builtin">@TypeOf</span>(x))</code></td>
          </tr>
        </tbody>
      </table>
      </div>
      
      <h3 id="Result-Locations"><a href="#toc-Result-Locations">Result Locations</a> <a class="hdr" href="#Result-Locations">§</a></h3>

      <p>
      In addition to result type information, every expression may be optionally assigned a result
      location: a pointer to which the value must be directly written. This system can be used to prevent
      intermediate copies when initializing data structures, which can be important for types which must
      have a fixed memory address ("pinned" types).
      </p>
      <p>
      When compiling the simple assignment expression <code>x = e</code>, many languages would
      create the temporary value <code>e</code> on the stack, and then assign it to
      <code>x</code>, potentially performing a type coercion in the process. Zig approaches this
      differently. The expression <code>e</code> is given a result type matching the type of
      <code>x</code>, and a result location of <code>&amp;x</code>. For many syntactic
      forms of <code>e</code>, this has no practical impact. However, it can have important
      semantic effects when working with more complex syntax forms.
      </p>
      <p>
      For instance, if the expression <code>.{ .a = x, .b = y }</code> has a result location of
      <code>ptr</code>, then <code>x</code> is given a result location of
      <code>&amp;ptr.a</code>, and <code>y</code> a result location of <code>&amp;ptr.b</code>.
      Without this system, this expression would construct a temporary struct value entirely on the stack, and
      only then copy it to the destination address. In essence, Zig desugars the assignment
      <code>foo = .{ .a = x, .b = y }</code> to the two statements <code>foo.a = x; foo.b = y;</code>.
      </p>
      <p>
      This can sometimes be important when assigning an aggregate value where the initialization
      expression depends on the previous value of the aggregate. The easiest way to demonstrate this is by
      attempting to swap fields of a struct or array - the following logic looks sound, but in fact is not:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">result_location_interfering_with_swap.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;
<span class="tok-kw">test</span> <span class="tok-str">&quot;attempt to swap array elements with array initializer&quot;</span> {
    <span class="tok-kw">var</span> arr: [<span class="tok-number">2</span>]<span class="tok-type">u32</span> = .{ <span class="tok-number">1</span>, <span class="tok-number">2</span> };
    arr = .{ arr[<span class="tok-number">1</span>], arr[<span class="tok-number">0</span>] };
    <span class="tok-comment">// The previous line is equivalent to the following two lines:</span>
    <span class="tok-comment">//   arr[0] = arr[1];</span>
    <span class="tok-comment">//   arr[1] = arr[0];</span>
    <span class="tok-comment">// So this fails!</span>
    <span class="tok-kw">try</span> expect(arr[<span class="tok-number">0</span>] == <span class="tok-number">2</span>); <span class="tok-comment">// succeeds</span>
    <span class="tok-kw">try</span> expect(arr[<span class="tok-number">1</span>] == <span class="tok-number">1</span>); <span class="tok-comment">// fails</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test result_location_interfering_with_swap.zig</kbd>
1/1 result_location_interfering_with_swap.test.attempt to swap array elements with array initializer...FAIL (TestUnexpectedResult)
<span class="sgr-1m">/home/andy/src/zig/lib/std/testing.zig:580:14</span>: <span class="sgr-2m">0x104896f in expect (test)</span>
    if (!ok) return error.TestUnexpectedResult;
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/result_location_interfering_with_swap.zig:10:5</span>: <span class="sgr-2m">0x1048a55 in test.attempt to swap array elements with array initializer (test)</span>
    try expect(arr[1] == 1); // fails
    <span class="sgr-32m">^</span>
0 passed; 0 skipped; 1 failed.
error: the following test command failed with exit code 1:
/home/andy/src/zig/.zig-cache/o/1ab5fe7528c3fb20f26dc032b4e272d9/test --seed=0x35f0babc
</samp></pre></figure>

      <p>
      The following table details how some common expressions propagate result locations, where
      <code>x</code> and <code>y</code> are arbitrary sub-expressions. Note that
      some expressions cannot provide meaningful result locations to sub-expressions, even if they
      themselves have a result location.
      </p>
      <div class="table-wrapper">
      <table>
        <thead>
          <tr>
            <th scope="col">Expression</th>
            <th scope="col">Result Location</th>
            <th scope="col">Sub-expression Result Locations</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th scope="row"><code><span class="tok-kw">const</span> val: T = x</code></th>
            <td>-</td>
            <td><code>x</code> has result location <code>&amp;val</code></td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-kw">var</span> val: T = x</code></th>
            <td>-</td>
            <td><code>x</code> has result location <code>&amp;val</code></td>
          </tr>
          <tr>
            <th scope="row"><code>val = x</code></th>
            <td>-</td>
            <td><code>x</code> has result location <code>&amp;val</code></td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-builtin">@as</span>(T, x)</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> has no result location</td>
          </tr>
          <tr>
            <th scope="row"><code>&amp;x</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> has no result location</td>
          </tr>
          <tr>
            <th scope="row"><code>f(x)</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> has no result location</td>
          </tr>
          <tr>
            <th scope="row"><code>.{x}</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> has result location <code>&amp;ptr[<span class="tok-number">0</span>]</code></td>
          </tr>
          <tr>
            <th scope="row"><code>.{ .a = x }</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> has result location <code>&amp;ptr.a</code></td>
          </tr>
          <tr>
            <th scope="row"><code>T{x}</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> has no result location (typed initializers do not propagate result locations)</td>
          </tr>
          <tr>
            <th scope="row"><code>T{ .a = x }</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> has no result location (typed initializers do not propagate result locations)</td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-builtin">@Type</span>(x)</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> has no result location</td>
          </tr>
          <tr>
            <th scope="row"><code><span class="tok-builtin">@typeInfo</span>(x)</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> has no result location</td>
          </tr>
          <tr>
            <th scope="row"><code>x &lt;&lt; y</code></th>
            <td><code>ptr</code></td>
            <td><code>x</code> and <code>y</code> do not have result locations</td>
          </tr>
        </tbody>
      </table>
      </div>
      
      

      <h2 id="usingnamespace"><a href="#toc-usingnamespace">usingnamespace</a> <a class="hdr" href="#usingnamespace">§</a></h2>

      <p>
      <code><span class="tok-kw">usingnamespace</span></code> is a declaration that mixes all the public
      declarations of the operand, which must be a <a href="#struct">struct</a>, <a href="#union">union</a>, <a href="#enum">enum</a>,
      or <a href="#opaque">opaque</a>, into the namespace:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_usingnamespace.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;using std namespace&quot;</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">usingnamespace</span> <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
    };
    <span class="tok-kw">try</span> S.testing.expect(<span class="tok-null">true</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_usingnamespace.zig</kbd>
1/1 test_usingnamespace.test.using std namespace...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      <code><span class="tok-kw">usingnamespace</span></code> has an important use case when organizing the public
      API of a file or package. For example, one might have <code class="file">c.zig</code> with all of the
      <a href="#Import-from-C-Header-File">C imports</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">c.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">usingnamespace</span> <span class="tok-builtin">@cImport</span>({
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;epoxy/gl.h&quot;</span>);
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;GLFW/glfw3.h&quot;</span>);
    <span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;STBI_ONLY_PNG&quot;</span>, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;STBI_NO_STDIO&quot;</span>, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;stb_image.h&quot;</span>);
});</code></pre></figure>
      <p>
      The above example demonstrates using <code><span class="tok-kw">pub</span></code> to qualify the
      <code><span class="tok-kw">usingnamespace</span></code> additionally makes the imported declarations
      <code><span class="tok-kw">pub</span></code>. This can be used to forward declarations, giving precise control
      over what declarations a given file exposes.
      </p>
      


      <h2 id="comptime"><a href="#toc-comptime">comptime</a> <a class="hdr" href="#comptime">§</a></h2>

      <p>
      Zig places importance on the concept of whether an expression is known at compile-time.
      There are a few different places this concept is used, and these building blocks are used
      to keep the language small, readable, and powerful.
      </p>
      <h3 id="Introducing-the-Compile-Time-Concept"><a href="#toc-Introducing-the-Compile-Time-Concept">Introducing the Compile-Time Concept</a> <a class="hdr" href="#Introducing-the-Compile-Time-Concept">§</a></h3>

      <h4 id="Compile-Time-Parameters"><a href="#toc-Compile-Time-Parameters">Compile-Time Parameters</a> <a class="hdr" href="#Compile-Time-Parameters">§</a></h4>

      <p>
      Compile-time parameters is how Zig implements generics. It is compile-time duck typing.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">compile-time_duck_typing.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a &gt; b) a <span class="tok-kw">else</span> b;
}
<span class="tok-kw">fn</span> <span class="tok-fn">gimmeTheBiggerFloat</span>(a: <span class="tok-type">f32</span>, b: <span class="tok-type">f32</span>) <span class="tok-type">f32</span> {
    <span class="tok-kw">return</span> max(<span class="tok-type">f32</span>, a, b);
}
<span class="tok-kw">fn</span> <span class="tok-fn">gimmeTheBiggerInteger</span>(a: <span class="tok-type">u64</span>, b: <span class="tok-type">u64</span>) <span class="tok-type">u64</span> {
    <span class="tok-kw">return</span> max(<span class="tok-type">u64</span>, a, b);
}</code></pre></figure>

      <p>
      In Zig, types are first-class citizens. They can be assigned to variables, passed as parameters to functions,
      and returned from functions. However, they can only be used in expressions which are known at <em>compile-time</em>,
      which is why the parameter <code>T</code> in the above snippet must be marked with <code><span class="tok-kw">comptime</span></code>.
      </p>
      <p>
      A <code><span class="tok-kw">comptime</span></code> parameter means that:
      </p>
      <ul>
        <li>At the callsite, the value must be known at compile-time, or it is a compile error.</li>
        <li>In the function definition, the value is known at compile-time.</li>
      </ul>
      <p>
      For example, if we were to introduce another function to the above snippet:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_unresolved_comptime_value.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a &gt; b) a <span class="tok-kw">else</span> b;
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;try to pass a runtime type&quot;</span> {
    foo(<span class="tok-null">false</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(condition: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = max(<span class="tok-kw">if</span> (condition) <span class="tok-type">f32</span> <span class="tok-kw">else</span> <span class="tok-type">u64</span>, <span class="tok-number">1234</span>, <span class="tok-number">5678</span>);
    _ = result;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_unresolved_comptime_value.zig</kbd>
<span class="sgr-1m">doc/langref/test_unresolved_comptime_value.zig:8:28: </span><span class="sgr-31m">error: </span><span class="sgr-1m">unable to resolve comptime value
</span>    const result = max(if (condition) f32 else u64, 1234, 5678);
                           <span class="sgr-32m">^~~~~~~~~
</span><span class="sgr-1m">doc/langref/test_unresolved_comptime_value.zig:8:24: </span><span class="sgr-36m">note: </span><span class="sgr-1m">argument to comptime parameter must be comptime-known
</span>    const result = max(if (condition) f32 else u64, 1234, 5678);
                       <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-1m">doc/langref/test_unresolved_comptime_value.zig:1:8: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter declared comptime here
</span>fn max(comptime T: type, a: T, b: T) T {
       <span class="sgr-32m">^~~~~~~~
</span>
</samp></pre></figure>

      <p>
      This is an error because the programmer attempted to pass a value only known at run-time
      to a function which expects a value known at compile-time.
      </p>
      <p>
      Another way to get an error is if we pass a type that violates the type checker when the
      function is analyzed. This is what it means to have <em>compile-time duck typing</em>.
      </p>
      <p>
      For example:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_mismatched_type.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a &gt; b) a <span class="tok-kw">else</span> b;
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;try to compare bools&quot;</span> {
    _ = max(<span class="tok-type">bool</span>, <span class="tok-null">true</span>, <span class="tok-null">false</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_mismatched_type.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_mismatched_type.zig:2:18: </span><span class="sgr-31m">error: </span><span class="sgr-1m">operator &gt; not allowed for type 'bool'
</span>    return if (a &gt; b) a else b;
               <span class="sgr-32m">~~^~~
</span>
</samp></pre></figure>

      <p>
      On the flip side, inside the function definition with the <code><span class="tok-kw">comptime</span></code> parameter, the
      value is known at compile-time. This means that we actually could make this work for the bool type
      if we wanted to:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_max_with_bool.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">if</span> (T == <span class="tok-type">bool</span>) {
        <span class="tok-kw">return</span> a <span class="tok-kw">or</span> b;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a &gt; b) {
        <span class="tok-kw">return</span> a;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> b;
    }
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;try to compare bools&quot;</span> {
    <span class="tok-kw">try</span> <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect(max(<span class="tok-type">bool</span>, <span class="tok-null">false</span>, <span class="tok-null">true</span>) == <span class="tok-null">true</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_max_with_bool.zig</kbd>
1/1 test_comptime_max_with_bool.test.try to compare bools...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      This works because Zig implicitly inlines <code><span class="tok-kw">if</span></code> expressions when the condition
      is known at compile-time, and the compiler guarantees that it will skip analysis of
      the branch not taken.
      </p>
      <p>
      This means that the actual function generated for <code>max</code> in this situation looks like
      this:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">compiler_generated_function.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(a: <span class="tok-type">bool</span>, b: <span class="tok-type">bool</span>) <span class="tok-type">bool</span> {
    {
        <span class="tok-kw">return</span> a <span class="tok-kw">or</span> b;
    }
}</code></pre></figure>

      <p>
      All the code that dealt with compile-time known values is eliminated and we are left with only
      the necessary run-time code to accomplish the task.
      </p>
      <p>
      This works the same way for <code><span class="tok-kw">switch</span></code> expressions - they are implicitly inlined
      when the target expression is compile-time known.
      </p>
      
      <h4 id="Compile-Time-Variables"><a href="#toc-Compile-Time-Variables">Compile-Time Variables</a> <a class="hdr" href="#Compile-Time-Variables">§</a></h4>

      <p>
      In Zig, the programmer can label variables as <code><span class="tok-kw">comptime</span></code>. This guarantees to the compiler
      that every load and store of the variable is performed at compile-time. Any violation of this results in a
      compile error.
      </p>
      <p>
      This combined with the fact that we can <code><span class="tok-kw">inline</span></code> loops allows us to write
      a function which is partially evaluated at compile-time and partially at run-time.
      </p>
      <p>
      For example:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_evaluation.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">const</span> CmdFn = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    func: <span class="tok-kw">fn</span> (<span class="tok-type">i32</span>) <span class="tok-type">i32</span>,
};

<span class="tok-kw">const</span> cmd_fns = [_]CmdFn{
    CmdFn{ .name = <span class="tok-str">&quot;one&quot;</span>, .func = one },
    CmdFn{ .name = <span class="tok-str">&quot;two&quot;</span>, .func = two },
    CmdFn{ .name = <span class="tok-str">&quot;three&quot;</span>, .func = three },
};
<span class="tok-kw">fn</span> <span class="tok-fn">one</span>(value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> value + <span class="tok-number">1</span>;
}
<span class="tok-kw">fn</span> <span class="tok-fn">two</span>(value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> value + <span class="tok-number">2</span>;
}
<span class="tok-kw">fn</span> <span class="tok-fn">three</span>(value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> value + <span class="tok-number">3</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(<span class="tok-kw">comptime</span> prefix_char: <span class="tok-type">u8</span>, start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; cmd_fns.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (cmd_fns[i].name[<span class="tok-number">0</span>] == prefix_char) {
            result = cmd_fns[i].func(result);
        }
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;perform fn&quot;</span> {
    <span class="tok-kw">try</span> expect(performFn(<span class="tok-str">'t'</span>, <span class="tok-number">1</span>) == <span class="tok-number">6</span>);
    <span class="tok-kw">try</span> expect(performFn(<span class="tok-str">'o'</span>, <span class="tok-number">0</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(performFn(<span class="tok-str">'w'</span>, <span class="tok-number">99</span>) == <span class="tok-number">99</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_evaluation.zig</kbd>
1/1 test_comptime_evaluation.test.perform fn...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      This example is a bit contrived, because the compile-time evaluation component is unnecessary;
      this code would work fine if it was all done at run-time. But it does end up generating
      different code. In this example, the function <code>performFn</code> is generated three different times,
          for the different values of <code>prefix_char</code> provided:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">performFn_1</cite></figcaption><pre><code><span class="tok-comment">// From the line:</span>
<span class="tok-comment">// expect(performFn('t', 1) == 6);</span>
<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    result = two(result);
    result = three(result);
    <span class="tok-kw">return</span> result;
}</code></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">performFn_2</cite></figcaption><pre><code><span class="tok-comment">// From the line:</span>
<span class="tok-comment">// expect(performFn('o', 0) == 1);</span>
<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    result = one(result);
    <span class="tok-kw">return</span> result;
}</code></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">performFn_3</cite></figcaption><pre><code><span class="tok-comment">// From the line:</span>
<span class="tok-comment">// expect(performFn('w', 99) == 99);</span>
<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    _ = &amp;result;
    <span class="tok-kw">return</span> result;
}</code></pre></figure>
      <p>
      Note that this happens even in a debug build.
      This is not a way to write more optimized code, but it is a way to make sure that what <em>should</em> happen
      at compile-time, <em>does</em> happen at compile-time. This catches more errors and allows expressiveness
      that in other languages requires using macros, generated code, or a preprocessor to accomplish.
      </p>
      
      <h4 id="Compile-Time-Expressions"><a href="#toc-Compile-Time-Expressions">Compile-Time Expressions</a> <a class="hdr" href="#Compile-Time-Expressions">§</a></h4>

      <p>
      In Zig, it matters whether a given expression is known at compile-time or run-time. A programmer can
      use a <code><span class="tok-kw">comptime</span></code> expression to guarantee that the expression will be evaluated at compile-time.
      If this cannot be accomplished, the compiler will emit an error. For example:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_call_extern_function.zig</cite></figcaption><pre><code><span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">exit</span>() <span class="tok-type">noreturn</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;foo&quot;</span> {
    <span class="tok-kw">comptime</span> {
        exit();
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_call_extern_function.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_call_extern_function.zig:5:13: </span><span class="sgr-31m">error: </span><span class="sgr-1m">comptime call of extern function
</span>        exit();
        <span class="sgr-32m">~~~~^~
</span><span class="sgr-1m">doc/langref/test_comptime_call_extern_function.zig:4:5: </span><span class="sgr-36m">note: </span><span class="sgr-1m">'comptime' keyword forces comptime evaluation
</span>    comptime {
    <span class="sgr-32m">^~~~~~~~
</span>
</samp></pre></figure>

      <p>
      It doesn't make sense that a program could call <code>exit()</code> (or any other external function)
          at compile-time, so this is a compile error. However, a <code><span class="tok-kw">comptime</span></code> expression does much
      more than sometimes cause a compile error.
      </p>
      <p>
      Within a <code><span class="tok-kw">comptime</span></code> expression:
      </p>
      <ul>
          <li>All variables are <code><span class="tok-kw">comptime</span></code> variables.</li>
          <li>All <code><span class="tok-kw">if</span></code>, <code><span class="tok-kw">while</span></code>, <code><span class="tok-kw">for</span></code>, and <code><span class="tok-kw">switch</span></code>
          expressions are evaluated at compile-time, or emit a compile error if this is not possible.</li>
          <li>All <code><span class="tok-kw">return</span></code> and <code><span class="tok-kw">try</span></code> expressions are invalid (unless the function itself is called at compile-time).</li>
          <li>All code with runtime side effects or depending on runtime values emits a compile error.</li>
          <li>All function calls cause the compiler to interpret the function at compile-time, emitting a
          compile error if the function tries to do something that has global runtime side effects.</li>
      </ul>
      <p>
      This means that a programmer can create a function which is called both at compile-time and run-time, with
      no modification to the function required.
      </p>
      <p>
      Let's look at an example:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_fibonacci_recursion.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">u32</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">if</span> (index &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> index;
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;fibonacci&quot;</span> {
    <span class="tok-comment">// test fibonacci at run-time</span>
    <span class="tok-kw">try</span> expect(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);

    <span class="tok-comment">// test fibonacci at compile-time</span>
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_fibonacci_recursion.zig</kbd>
1/1 test_fibonacci_recursion.test.fibonacci...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Imagine if we had forgotten the base case of the recursive function and tried to run the tests:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_fibonacci_comptime_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">u32</span>) <span class="tok-type">u32</span> {
    <span class="tok-comment">//if (index &lt; 2) return index;</span>
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;fibonacci&quot;</span> {
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_fibonacci_comptime_overflow.zig</kbd>
<span class="sgr-1m">doc/langref/test_fibonacci_comptime_overflow.zig:5:28: </span><span class="sgr-31m">error: </span><span class="sgr-1m">overflow of integer type 'u32' with value '-1'
</span>    return fibonacci(index - 1) + fibonacci(index - 2);
                     <span class="sgr-32m">~~~~~~^~~
</span><span class="sgr-1m">doc/langref/test_fibonacci_comptime_overflow.zig:5:21: </span><span class="sgr-36m">note: </span><span class="sgr-1m">called from here</span><span class="sgr-2m"> (7 times)
</span>    return fibonacci(index - 1) + fibonacci(index - 2);
           <span class="sgr-32m">~~~~~~~~~^~~~~~~~~~~
</span><span class="sgr-1m">doc/langref/test_fibonacci_comptime_overflow.zig:9:34: </span><span class="sgr-36m">note: </span><span class="sgr-1m">called from here
</span>    try comptime expect(fibonacci(7) == 13);
                        <span class="sgr-32m">~~~~~~~~~^~~
</span>
</samp></pre></figure>

      <p>
      The compiler produces an error which is a stack trace from trying to evaluate the
      function at compile-time.
      </p>
      <p>
      Luckily, we used an unsigned integer, and so when we tried to subtract 1 from 0, it triggered
      <a href="#Illegal-Behavior">Illegal Behavior</a>, which is always a compile error if the compiler knows it happened.
      But what would have happened if we used a signed integer?
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">fibonacci_comptime_infinite_recursion.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-comment">//if (index &lt; 2) return index;</span>
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;fibonacci&quot;</span> {
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> assert(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);
}</code></pre></figure>

      <p>
      The compiler is supposed to notice that evaluating this function at
      compile-time took more than 1000 branches, and thus emits an error and
      gives up. If the programmer wants to increase the budget for compile-time
      computation, they can use a built-in function called
      <a href="#setEvalBranchQuota">@setEvalBranchQuota</a> to change the default number 1000 to
      something else.
      </p>
      <p>
      However, there is a <a href="https://github.com/ziglang/zig/issues/13724">design
      flaw in the compiler</a> causing it to stack overflow instead of having the proper
      behavior here. I'm terribly sorry about that. I hope to get this resolved
      before the next release.
      </p>
      <p>
      What if we fix the base case, but put the wrong value in the
      <code>expect</code> line?
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_fibonacci_comptime_unreachable.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">if</span> (index &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> index;
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;fibonacci&quot;</span> {
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> assert(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">99999</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_fibonacci_comptime_unreachable.zig</kbd>
<span class="sgr-1m">lib/std/debug.zig:522:14: </span><span class="sgr-31m">error: </span><span class="sgr-1m">reached unreachable code
</span>    if (!ok) unreachable; // assertion failure
             <span class="sgr-32m">^~~~~~~~~~~
</span><span class="sgr-1m">doc/langref/test_fibonacci_comptime_unreachable.zig:9:24: </span><span class="sgr-36m">note: </span><span class="sgr-1m">called from here
</span>    try comptime assert(fibonacci(7) == 99999);
                 <span class="sgr-32m">~~~~~~^~~~~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>


      <p>
      At <a href="#Containers">container</a> level (outside of any function), all expressions are implicitly
      <code><span class="tok-kw">comptime</span></code> expressions. This means that we can use functions to
      initialize complex static data. For example:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_container-level_comptime_expressions.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> first_25_primes = firstNPrimes(<span class="tok-number">25</span>);
<span class="tok-kw">const</span> sum_of_first_25_primes = sum(&amp;first_25_primes);

<span class="tok-kw">fn</span> <span class="tok-fn">firstNPrimes</span>(<span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) [n]<span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> prime_list: [n]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> next_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> test_number: <span class="tok-type">i32</span> = <span class="tok-number">2</span>;
    <span class="tok-kw">while</span> (next_index &lt; prime_list.len) : (test_number += <span class="tok-number">1</span>) {
        <span class="tok-kw">var</span> test_prime_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> is_prime = <span class="tok-null">true</span>;
        <span class="tok-kw">while</span> (test_prime_index &lt; next_index) : (test_prime_index += <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (test_number % prime_list[test_prime_index] == <span class="tok-number">0</span>) {
                is_prime = <span class="tok-null">false</span>;
                <span class="tok-kw">break</span>;
            }
        }
        <span class="tok-kw">if</span> (is_prime) {
            prime_list[next_index] = test_number;
            next_index += <span class="tok-number">1</span>;
        }
    }
    <span class="tok-kw">return</span> prime_list;
}

<span class="tok-kw">fn</span> <span class="tok-fn">sum</span>(numbers: []<span class="tok-kw">const</span> <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (numbers) |x| {
        result += x;
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;variable values&quot;</span> {
    <span class="tok-kw">try</span> <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect(sum_of_first_25_primes == <span class="tok-number">1060</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_container-level_comptime_expressions.zig</kbd>
1/1 test_container-level_comptime_expressions.test.variable values...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      When we compile this program, Zig generates the constants
      with the answer pre-computed. Here are the lines from the generated LLVM IR:
      </p>
      <pre><code class="llvm">@0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97]
@1 = internal unnamed_addr constant i32 1060</code></pre>
      <p>
      Note that we did not have to do anything special with the syntax of these functions. For example,
      we could call the <code>sum</code> function as is with a slice of numbers whose length and values were
      only known at run-time.
      </p>
      
      
      <h3 id="Generic-Data-Structures"><a href="#toc-Generic-Data-Structures">Generic Data Structures</a> <a class="hdr" href="#Generic-Data-Structures">§</a></h3>

      <p>
      Zig uses comptime capabilities to implement generic data structures without introducing any
      special-case syntax.
      </p>
      <p>
			Here is an example of a generic <code>List</code> data structure.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">generic_data_structure.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">List</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        items: []T,
        len: <span class="tok-type">usize</span>,
    };
}

<span class="tok-comment">// The generic List data structure can be instantiated by passing in a type:</span>
<span class="tok-kw">var</span> buffer: [<span class="tok-number">10</span>]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">var</span> list = List(<span class="tok-type">i32</span>){
    .items = &amp;buffer,
    .len = <span class="tok-number">0</span>,
};</code></pre></figure>

      <p>
      That's it. It's a function that returns an anonymous <code><span class="tok-kw">struct</span></code>.
      For the purposes of error messages and debugging, Zig infers the name
      <code><span class="tok-str">&quot;List(i32)&quot;</span></code> from the function name and parameters invoked when creating
      the anonymous struct.
      </p>
      <p>
      To explicitly give a type a name, we assign it to a constant.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">anonymous_struct_name.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
    next: ?*Node,
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
};

<span class="tok-kw">var</span> node_a = Node{
    .next = <span class="tok-null">null</span>,
    .name = <span class="tok-str">&quot;Node A&quot;</span>,
};

<span class="tok-kw">var</span> node_b = Node{
    .next = &amp;node_a,
    .name = <span class="tok-str">&quot;Node B&quot;</span>,
};</code></pre></figure>

      <p>
      In this example, the <code>Node</code> struct refers to itself.
      This works because all top level declarations are order-independent.
      As long as the compiler can determine the size of the struct, it is free to refer to itself.
      In this case, <code>Node</code> refers to itself as a pointer, which has a
      well-defined size at compile time, so it works fine.
      </p>
      
      <h3 id="Case-Study-print-in-Zig"><a href="#toc-Case-Study-print-in-Zig">Case Study: print in Zig</a> <a class="hdr" href="#Case-Study-print-in-Zig">§</a></h3>

      <p>
      Putting all of this together, let's see how <code>print</code> works in Zig.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">print.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">const</span> a_number: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> a_string = <span class="tok-str">&quot;foobar&quot;</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    print(<span class="tok-str">&quot;here is a string: '{s}' here is a number: {}\n&quot;</span>, .{ a_string, a_number });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe print.zig</kbd>
$ <kbd>./print</kbd>
here is a string: 'foobar' here is a number: 1234
</samp></pre></figure>


      <p>
      Let's crack open the implementation of this and see how it works:
      </p>

      <figure><figcaption class="zig-cap"><cite class="file">poc_print_fn.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Writer = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// Calls print and then flushes the buffer.</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(self: *Writer, <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
        <span class="tok-kw">const</span> State = <span class="tok-kw">enum</span> {
            start,
            open_brace,
            close_brace,
        };

        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> start_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> state = State.start;
        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> next_arg: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

        <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (format, <span class="tok-number">0</span>..) |c, i| {
            <span class="tok-kw">switch</span> (state) {
                State.start =&gt; <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'{'</span> =&gt; {
                        <span class="tok-kw">if</span> (start_index &lt; i) <span class="tok-kw">try</span> self.write(format[start_index..i]);
                        state = State.open_brace;
                    },
                    <span class="tok-str">'}'</span> =&gt; {
                        <span class="tok-kw">if</span> (start_index &lt; i) <span class="tok-kw">try</span> self.write(format[start_index..i]);
                        state = State.close_brace;
                    },
                    <span class="tok-kw">else</span> =&gt; {},
                },
                State.open_brace =&gt; <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'{'</span> =&gt; {
                        state = State.start;
                        start_index = i;
                    },
                    <span class="tok-str">'}'</span> =&gt; {
                        <span class="tok-kw">try</span> self.printValue(args[next_arg]);
                        next_arg += <span class="tok-number">1</span>;
                        state = State.start;
                        start_index = i + <span class="tok-number">1</span>;
                    },
                    <span class="tok-str">'s'</span> =&gt; {
                        <span class="tok-kw">continue</span>;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unknown format character: &quot;</span> ++ [<span class="tok-number">1</span>]<span class="tok-type">u8</span>{c}),
                },
                State.close_brace =&gt; <span class="tok-kw">switch</span> (c) {
                    <span class="tok-str">'}'</span> =&gt; {
                        state = State.start;
                        start_index = i;
                    },
                    <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Single '}' encountered in format string&quot;</span>),
                },
            }
        }
        <span class="tok-kw">comptime</span> {
            <span class="tok-kw">if</span> (args.len != next_arg) {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unused arguments&quot;</span>);
            }
            <span class="tok-kw">if</span> (state != State.start) {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Incomplete format string: &quot;</span> ++ format);
            }
        }
        <span class="tok-kw">if</span> (start_index &lt; format.len) {
            <span class="tok-kw">try</span> self.write(format[start_index..format.len]);
        }
        <span class="tok-kw">try</span> self.flush();
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *Writer, value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        _ = self;
        _ = value;
    }
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printValue</span>(self: *Writer, value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        _ = self;
        _ = value;
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">flush</span>(self: *Writer) !<span class="tok-type">void</span> {
        _ = self;
    }
};</code></pre></figure>

      <p>
      This is a proof of concept implementation; the actual function in the standard library has more
      formatting capabilities.
      </p>
      <p>
      Note that this is not hard-coded into the Zig compiler; this is userland code in the standard library.
      </p>
      <p>
      When this function is analyzed from our example code above, Zig partially evaluates the function
      and emits a function that actually looks like this:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">Emitted print Function</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(self: *Writer, arg0: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, arg1: <span class="tok-type">i32</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.write(<span class="tok-str">&quot;here is a string: '&quot;</span>);
    <span class="tok-kw">try</span> self.printValue(arg0);
    <span class="tok-kw">try</span> self.write(<span class="tok-str">&quot;' here is a number: &quot;</span>);
    <span class="tok-kw">try</span> self.printValue(arg1);
    <span class="tok-kw">try</span> self.write(<span class="tok-str">&quot;\n&quot;</span>);
    <span class="tok-kw">try</span> self.flush();
}</code></pre></figure>
      <p>
      <code>printValue</code> is a function that takes a parameter of any type, and does different things depending
      on the type:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">poc_printValue_fn.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Writer = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printValue</span>(self: *Writer, value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(value))) {
            .int =&gt; {
                <span class="tok-kw">return</span> self.writeInt(value);
            },
            .float =&gt; {
                <span class="tok-kw">return</span> self.writeFloat(value);
            },
            .pointer =&gt; {
                <span class="tok-kw">return</span> self.write(value);
            },
            <span class="tok-kw">else</span> =&gt; {
                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to print type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(value)) ++ <span class="tok-str">&quot;'&quot;</span>);
            },
        }
    }

    <span class="tok-kw">fn</span> <span class="tok-fn">write</span>(self: *Writer, value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
        _ = self;
        _ = value;
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">writeInt</span>(self: *Writer, value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        _ = self;
        _ = value;
    }
    <span class="tok-kw">fn</span> <span class="tok-fn">writeFloat</span>(self: *Writer, value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
        _ = self;
        _ = value;
    }
};</code></pre></figure>

      <p>
      And now, what happens if we give too many arguments to <code>print</code>?
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_print_too_many_args.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">const</span> a_number: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> a_string = <span class="tok-str">&quot;foobar&quot;</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;print too many arguments&quot;</span> {
    print(<span class="tok-str">&quot;here is a string: '{s}' here is a number: {}\n&quot;</span>, .{
        a_string,
        a_number,
        a_number,
    });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_print_too_many_args.zig</kbd>
<span class="sgr-1m">lib/std/fmt.zig:211:18: </span><span class="sgr-31m">error: </span><span class="sgr-1m">unused argument in 'here is a string: '{s}' here is a number: {}
                               '
</span>            1 =&gt; @compileError(&quot;unused argument in '&quot; ++ fmt ++ &quot;'&quot;),
                 <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>
      Zig gives programmers the tools needed to protect themselves against their own mistakes.
      </p>
      <p>
      Zig doesn't care whether the format argument is a string literal,
      only that it is a compile-time known value that can be coerced to a <code>[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">print_comptime-known_format.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">const</span> a_number: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> a_string = <span class="tok-str">&quot;foobar&quot;</span>;
<span class="tok-kw">const</span> fmt = <span class="tok-str">&quot;here is a string: '{s}' here is a number: {}\n&quot;</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    print(fmt, .{ a_string, a_number });
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe print_comptime-known_format.zig</kbd>
$ <kbd>./print_comptime-known_format</kbd>
here is a string: 'foobar' here is a number: 1234
</samp></pre></figure>

      <p>
      This works fine.
      </p>
      <p>
      Zig does not special case string formatting in the compiler and instead exposes enough power to accomplish this
      task in userland. It does so without introducing another language on top of Zig, such as
      a macro language or a preprocessor language. It's Zig all the way down.
      </p>
      
      <p>See also:</p><ul>
<li><a href="#inline-while">inline while</a></li>
<li><a href="#inline-for">inline for</a></li>
</ul>

      
      <h2 id="Assembly"><a href="#toc-Assembly">Assembly</a> <a class="hdr" href="#Assembly">§</a></h2>

      <p>
      For some use cases, it may be necessary to directly control the machine code generated
      by Zig programs, rather than relying on Zig's code generation. For these cases, one
      can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux
      using inline assembly:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">inline_assembly.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-kw">const</span> msg = <span class="tok-str">&quot;hello world\n&quot;</span>;
    _ = syscall3(SYS_write, STDOUT_FILENO, <span class="tok-builtin">@intFromPtr</span>(msg), msg.len);
    _ = syscall1(SYS_exit, <span class="tok-number">0</span>);
    <span class="tok-kw">unreachable</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SYS_write = <span class="tok-number">1</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SYS_exit = <span class="tok-number">60</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> STDOUT_FILENO = <span class="tok-number">1</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">syscall1</span>(number: <span class="tok-type">usize</span>, arg1: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;syscall&quot;</span>
        : [ret] <span class="tok-str">&quot;={rax}&quot;</span> (-&gt; <span class="tok-type">usize</span>),
        : [number] <span class="tok-str">&quot;{rax}&quot;</span> (number),
          [arg1] <span class="tok-str">&quot;{rdi}&quot;</span> (arg1),
        : <span class="tok-str">&quot;rcx&quot;</span>, <span class="tok-str">&quot;r11&quot;</span>
    );
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">syscall3</span>(number: <span class="tok-type">usize</span>, arg1: <span class="tok-type">usize</span>, arg2: <span class="tok-type">usize</span>, arg3: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;syscall&quot;</span>
        : [ret] <span class="tok-str">&quot;={rax}&quot;</span> (-&gt; <span class="tok-type">usize</span>),
        : [number] <span class="tok-str">&quot;{rax}&quot;</span> (number),
          [arg1] <span class="tok-str">&quot;{rdi}&quot;</span> (arg1),
          [arg2] <span class="tok-str">&quot;{rsi}&quot;</span> (arg2),
          [arg3] <span class="tok-str">&quot;{rdx}&quot;</span> (arg3),
        : <span class="tok-str">&quot;rcx&quot;</span>, <span class="tok-str">&quot;r11&quot;</span>
    );
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe inline_assembly.zig -target x86_64-linux</kbd>
$ <kbd>./inline_assembly</kbd>
hello world
</samp></pre></figure>

      <p>
      Dissecting the syntax:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">Assembly Syntax Explained.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">syscall1</span>(number: <span class="tok-type">usize</span>, arg1: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-comment">// Inline assembly is an expression which returns a value.</span>
    <span class="tok-comment">// the `asm` keyword begins the expression.</span>
    <span class="tok-kw">return</span> <span class="tok-kw">asm</span>
    <span class="tok-comment">// `volatile` is an optional modifier that tells Zig this</span>
    <span class="tok-comment">// inline assembly expression has side-effects. Without</span>
    <span class="tok-comment">// `volatile`, Zig is allowed to delete the inline assembly</span>
    <span class="tok-comment">// code if the result is unused.</span>
    <span class="tok-kw">volatile</span> (
    <span class="tok-comment">// Next is a comptime string which is the assembly code.</span>
    <span class="tok-comment">// Inside this string one may use `%[ret]`, `%[number]`,</span>
    <span class="tok-comment">// or `%[arg1]` where a register is expected, to specify</span>
    <span class="tok-comment">// the register that Zig uses for the argument or return value,</span>
    <span class="tok-comment">// if the register constraint strings are used. However in</span>
    <span class="tok-comment">// the below code, this is not used. A literal `%` can be</span>
    <span class="tok-comment">// obtained by escaping it with a double percent: `%%`.</span>
    <span class="tok-comment">// Often multiline string syntax comes in handy here.</span>
        <span class="tok-str">\\syscall</span>
        <span class="tok-comment">// Next is the output. It is possible in the future Zig will</span>
        <span class="tok-comment">// support multiple outputs, depending on how</span>
        <span class="tok-comment">// https://github.com/ziglang/zig/issues/215 is resolved.</span>
        <span class="tok-comment">// It is allowed for there to be no outputs, in which case</span>
        <span class="tok-comment">// this colon would be directly followed by the colon for the inputs.</span>
        :
        <span class="tok-comment">// This specifies the name to be used in `%[ret]` syntax in</span>
        <span class="tok-comment">// the above assembly string. This example does not use it,</span>
        <span class="tok-comment">// but the syntax is mandatory.</span>
          [ret]
          <span class="tok-comment">// Next is the output constraint string. This feature is still</span>
          <span class="tok-comment">// considered unstable in Zig, and so LLVM/GCC documentation</span>
          <span class="tok-comment">// must be used to understand the semantics.</span>
          <span class="tok-comment">// http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string</span>
          <span class="tok-comment">// https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html</span>
          <span class="tok-comment">// In this example, the constraint string means &quot;the result value of</span>
          <span class="tok-comment">// this inline assembly instruction is whatever is in $rax&quot;.</span>
          <span class="tok-str">&quot;={rax}&quot;</span>
          <span class="tok-comment">// Next is either a value binding, or `-&gt;` and then a type. The</span>
          <span class="tok-comment">// type is the result type of the inline assembly expression.</span>
          <span class="tok-comment">// If it is a value binding, then `%[ret]` syntax would be used</span>
          <span class="tok-comment">// to refer to the register bound to the value.</span>
          (-&gt; <span class="tok-type">usize</span>),
          <span class="tok-comment">// Next is the list of inputs.</span>
          <span class="tok-comment">// The constraint for these inputs means, &quot;when the assembly code is</span>
          <span class="tok-comment">// executed, $rax shall have the value of `number` and $rdi shall have</span>
          <span class="tok-comment">// the value of `arg1`&quot;. Any number of input parameters is allowed,</span>
          <span class="tok-comment">// including none.</span>
        : [number] <span class="tok-str">&quot;{rax}&quot;</span> (number),
          [arg1] <span class="tok-str">&quot;{rdi}&quot;</span> (arg1),
          <span class="tok-comment">// Next is the list of clobbers. These declare a set of registers whose</span>
          <span class="tok-comment">// values will not be preserved by the execution of this assembly code.</span>
          <span class="tok-comment">// These do not include output or input registers. The special clobber</span>
          <span class="tok-comment">// value of &quot;memory&quot; means that the assembly writes to arbitrary undeclared</span>
          <span class="tok-comment">// memory locations - not only the memory pointed to by a declared indirect</span>
          <span class="tok-comment">// output. In this example we list $rcx and $r11 because it is known the</span>
          <span class="tok-comment">// kernel syscall does not preserve these registers.</span>
        : <span class="tok-str">&quot;rcx&quot;</span>, <span class="tok-str">&quot;r11&quot;</span>
    );
}</code></pre></figure>

      <p>
      For x86 and x86_64 targets, the syntax is AT&amp;T syntax, rather than the more
      popular Intel syntax. This is due to technical constraints; assembly parsing is
      provided by LLVM and its support for Intel syntax is buggy and not well tested.
      </p>
      <p>
      Some day Zig may have its own assembler. This would allow it to integrate more seamlessly
      into the language, as well as be compatible with the popular NASM syntax. This documentation
      section will be updated before 1.0.0 is released, with a conclusive statement about the status
      of AT&amp;T vs Intel/NASM syntax.
      </p>
      <h3 id="Output-Constraints"><a href="#toc-Output-Constraints">Output Constraints</a> <a class="hdr" href="#Output-Constraints">§</a></h3>

      <p>
      Output constraints are still considered to be unstable in Zig, and
      so
      <a href="http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string">LLVM documentation</a>
      and
      <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">GCC documentation</a>
      must be used to understand the semantics.
      </p>
      <p>
      Note that some breaking changes to output constraints are planned with
      <a href="https://github.com/ziglang/zig/issues/215">issue #215</a>.
      </p>
      

      <h3 id="Input-Constraints"><a href="#toc-Input-Constraints">Input Constraints</a> <a class="hdr" href="#Input-Constraints">§</a></h3>

      <p>
      Input constraints are still considered to be unstable in Zig, and
      so
      <a href="http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string">LLVM documentation</a>
      and
      <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">GCC documentation</a>
      must be used to understand the semantics.
      </p>
      <p>
      Note that some breaking changes to input constraints are planned with
      <a href="https://github.com/ziglang/zig/issues/215">issue #215</a>.
      </p>
      

      <h3 id="Clobbers"><a href="#toc-Clobbers">Clobbers</a> <a class="hdr" href="#Clobbers">§</a></h3>

      <p>
      Clobbers are the set of registers whose values will not be preserved by the execution of
      the assembly code. These do not include output or input registers. The special clobber
      value of <code><span class="tok-str">&quot;memory&quot;</span></code> means that the assembly causes writes to
      arbitrary undeclared memory locations - not only the memory pointed to by a declared
      indirect output.
      </p>
      <p>
      Failure to declare the full set of clobbers for a given inline assembly
      expression is unchecked <a href="#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      

      <h3 id="Global-Assembly"><a href="#toc-Global-Assembly">Global Assembly</a> <a class="hdr" href="#Global-Assembly">§</a></h3>

      <p>
      When an assembly expression occurs in a <a href="#Containers">container</a> level <a href="#comptime">comptime</a> block, this is
      <strong>global assembly</strong>.
      </p>
      <p>
      This kind of assembly has different rules than inline assembly. First, <code><span class="tok-kw">volatile</span></code>
      is not valid because all global assembly is unconditionally included.
      Second, there are no inputs, outputs, or clobbers. All global assembly is concatenated
      verbatim into one long string and assembled together. There are no template substitution rules regarding
      <code>%</code> as there are in inline assembly expressions.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_global_assembly.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">comptime</span> {
    <span class="tok-kw">asm</span> (
        <span class="tok-str">\\.global my_func;</span>
        <span class="tok-str">\\.type my_func, @function;</span>
        <span class="tok-str">\\my_func:</span>
        <span class="tok-str">\\  lea (%rdi,%rsi,1),%eax</span>
        <span class="tok-str">\\  retq</span>
    );
}

<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">my_func</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;global assembly&quot;</span> {
    <span class="tok-kw">try</span> expect(my_func(<span class="tok-number">12</span>, <span class="tok-number">34</span>) == <span class="tok-number">46</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_global_assembly.zig -target x86_64-linux</kbd>
1/1 test_global_assembly.test.global assembly...OK
All 1 tests passed.
</samp></pre></figure>

      
      

      <h2 id="Atomics"><a href="#toc-Atomics">Atomics</a> <a class="hdr" href="#Atomics">§</a></h2>

      <p>TODO: @atomic rmw</p>
      <p>TODO: builtin atomic memory ordering enum</p>

      <p>See also:</p><ul>
<li><a href="#atomicLoad">@atomicLoad</a></li>
<li><a href="#atomicStore">@atomicStore</a></li>
<li><a href="#atomicRmw">@atomicRmw</a></li>
<li><a href="#cmpxchgWeak">@cmpxchgWeak</a></li>
<li><a href="#cmpxchgStrong">@cmpxchgStrong</a></li>
</ul>


      

      <h2 id="Async-Functions"><a href="#toc-Async-Functions">Async Functions</a> <a class="hdr" href="#Async-Functions">§</a></h2>

      <p>Async functions regressed with the release of 0.11.0. Their future in
      the Zig language is unclear due to multiple unsolved problems:</p>
      <ul>
        <li>LLVM's lack of ability to optimize them.</li>
        <li>Third-party debuggers' lack of ability to debug them.</li>
        <li><a href="https://github.com/ziglang/zig/issues/5913">The cancellation problem</a>.</li>
        <li>Async function pointers preventing the stack size from being known.</li>
      </ul>
      <p>These problems are surmountable, but it will take time. The Zig team
      is currently focused on other priorities.</p>
      

      <h2 id="Builtin-Functions"><a href="#toc-Builtin-Functions">Builtin Functions</a> <a class="hdr" href="#Builtin-Functions">§</a></h2>

      <p>
      Builtin functions are provided by the compiler and are prefixed with <code>@</code>.
      The <code><span class="tok-kw">comptime</span></code> keyword on a parameter means that the parameter must be known
      at compile time.
      </p>
      <h3 id="addrSpaceCast"><a href="#toc-addrSpaceCast">@addrSpaceCast</a> <a class="hdr" href="#addrSpaceCast">§</a></h3>

      <pre><code><span class="tok-builtin">@addrSpaceCast</span>(ptr: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Converts a pointer from one address space to another. The new address space is inferred
			based on the result type. Depending on the current target and address spaces, this cast
			may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting
			pointer points to the same memory location as the pointer operand. It is always valid to
			cast a pointer between the same address spaces.
      </p>
      
      <h3 id="addWithOverflow"><a href="#toc-addWithOverflow">@addWithOverflow</a> <a class="hdr" href="#addWithOverflow">§</a></h3>

      <pre><code><span class="tok-builtin">@addWithOverflow</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-kw">anytype</span>) <span class="tok-kw">struct</span> { <span class="tok-builtin">@TypeOf</span>(a, b), <span class="tok-type">u1</span> }</code></pre>
      <p>
      Performs <code>a + b</code> and returns a tuple with the result and a possible overflow bit.
      </p>
      
      <h3 id="alignCast"><a href="#toc-alignCast">@alignCast</a> <a class="hdr" href="#alignCast">§</a></h3>

      <pre><code><span class="tok-builtin">@alignCast</span>(ptr: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      <code>ptr</code> can be <code>*T</code>, <code>?*T</code>, or <code>[]T</code>.
			Changes the alignment of a pointer. The alignment to use is inferred based on the result type.
      </p>
      <p>A <a href="#Incorrect-Pointer-Alignment">pointer alignment safety check</a> is added
      to the generated code to make sure the pointer is aligned as promised.</p>

      
      <h3 id="alignOf"><a href="#toc-alignOf">@alignOf</a> <a class="hdr" href="#alignOf">§</a></h3>

      <pre><code><span class="tok-builtin">@alignOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      This function returns the number of bytes that this type should be aligned to
      for the current target to match the C ABI. When the child type of a pointer has
      this alignment, the alignment can be omitted from the type.
      </p>
      <pre><code><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;
<span class="tok-kw">comptime</span> {
    assert(*<span class="tok-type">u32</span> == *<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">u32</span>)) <span class="tok-type">u32</span>);
}</code></pre>
      <p>
      The result is a target-specific compile time constant. It is guaranteed to be
      less than or equal to <a href="#sizeOf">@sizeOf(T)</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Alignment">Alignment</a></li>
</ul>

      

      <h3 id="as"><a href="#toc-as">@as</a> <a class="hdr" href="#as">§</a></h3>

      <pre><code><span class="tok-builtin">@as</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, expression) T</code></pre>
      <p>
      Performs <a href="#Type-Coercion">Type Coercion</a>. This cast is allowed when the conversion is unambiguous and safe,
      and is the preferred way to convert between types, whenever possible.
      </p>
      

      <h3 id="atomicLoad"><a href="#toc-atomicLoad">@atomicLoad</a> <a class="hdr" href="#atomicLoad">§</a></h3>

      <pre><code><span class="tok-builtin">@atomicLoad</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *<span class="tok-kw">const</span> T, <span class="tok-kw">comptime</span> ordering: AtomicOrder) T</code></pre>
      <p>
      This builtin function atomically dereferences a pointer to a <code>T</code> and returns the value.
      </p>
      <p>
      <code>T</code> must be a pointer, a <code><span class="tok-type">bool</span></code>, a float,
      an integer or an enum.
      </p>
      <p><code>AtomicOrder</code> can be found with <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).builtin.AtomicOrder</code>.</p>
      <p>See also:</p><ul>
<li><a href="#atomicStore">@atomicStore</a></li>
<li><a href="#atomicRmw">@atomicRmw</a></li>
<li><a href="#cmpxchgWeak">@cmpxchgWeak</a></li>
<li><a href="#cmpxchgStrong">@cmpxchgStrong</a></li>
</ul>

      

      <h3 id="atomicRmw"><a href="#toc-atomicRmw">@atomicRmw</a> <a class="hdr" href="#atomicRmw">§</a></h3>

      <pre><code><span class="tok-builtin">@atomicRmw</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, <span class="tok-kw">comptime</span> op: AtomicRmwOp, operand: T, <span class="tok-kw">comptime</span> ordering: AtomicOrder) T</code></pre>
      <p>
      This builtin function dereferences a pointer to a <code>T</code> and atomically
      modifies the value and returns the previous value.
      </p>
      <p>
      <code>T</code> must be a pointer, a <code><span class="tok-type">bool</span></code>, a float,
      an integer or an enum.
      </p>
      <p><code>AtomicOrder</code> can be found with <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).builtin.AtomicOrder</code>.</p>
      <p><code>AtomicRmwOp</code> can be found with <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).builtin.AtomicRmwOp</code>.</p>
      <p>See also:</p><ul>
<li><a href="#atomicStore">@atomicStore</a></li>
<li><a href="#atomicLoad">@atomicLoad</a></li>
<li><a href="#cmpxchgWeak">@cmpxchgWeak</a></li>
<li><a href="#cmpxchgStrong">@cmpxchgStrong</a></li>
</ul>

      

      <h3 id="atomicStore"><a href="#toc-atomicStore">@atomicStore</a> <a class="hdr" href="#atomicStore">§</a></h3>

      <pre><code><span class="tok-builtin">@atomicStore</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, value: T, <span class="tok-kw">comptime</span> ordering: AtomicOrder) <span class="tok-type">void</span></code></pre>
      <p>
      This builtin function dereferences a pointer to a <code>T</code> and atomically stores the given value.
      </p>
      <p>
      <code>T</code> must be a pointer, a <code><span class="tok-type">bool</span></code>, a float,
      an integer or an enum.
      </p>
      <p><code>AtomicOrder</code> can be found with <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).builtin.AtomicOrder</code>.</p>
      <p>See also:</p><ul>
<li><a href="#atomicLoad">@atomicLoad</a></li>
<li><a href="#atomicRmw">@atomicRmw</a></li>
<li><a href="#cmpxchgWeak">@cmpxchgWeak</a></li>
<li><a href="#cmpxchgStrong">@cmpxchgStrong</a></li>
</ul>

      

      <h3 id="bitCast"><a href="#toc-bitCast">@bitCast</a> <a class="hdr" href="#bitCast">§</a></h3>

      <pre><code><span class="tok-builtin">@bitCast</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Converts a value of one type to another type. The return type is the
			inferred result type.
      </p>
      <p>
      Asserts that <code><span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(value)) == <span class="tok-builtin">@sizeOf</span>(DestType)</code>.
      </p>
      <p>
      Asserts that <code><span class="tok-builtin">@typeInfo</span>(DestType) != .pointer</code>. Use <code><span class="tok-builtin">@ptrCast</span></code> or <code><span class="tok-builtin">@ptrFromInt</span></code> if you need this.
      </p>
      <p>
      Can be used for these things for example:
      </p>
      <ul>
          <li>Convert <code><span class="tok-type">f32</span></code> to <code><span class="tok-type">u32</span></code> bits</li>
          <li>Convert <code><span class="tok-type">i32</span></code> to <code><span class="tok-type">u32</span></code> preserving twos complement</li>
      </ul>
      <p>
      Works at compile-time if <code>value</code> is known at compile time. It's a compile error to bitcast a value of undefined layout; this means that, besides the restriction from types which possess dedicated casting builtins (enums, pointers, error sets), bare structs, error unions, slices, optionals, and any other type without a well-defined memory layout, also cannot be used in this operation.
      </p>
      

      <h3 id="bitOffsetOf"><a href="#toc-bitOffsetOf">@bitOffsetOf</a> <a class="hdr" href="#bitOffsetOf">§</a></h3>

      <pre><code><span class="tok-builtin">@bitOffsetOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      Returns the bit offset of a field relative to its containing struct.
      </p>
      <p>
      For non <a href="#packed-struct">packed structs</a>, this will always be divisible by <code><span class="tok-number">8</span></code>.
      For packed structs, non-byte-aligned fields will share a byte offset, but they will have different
      bit offsets.
      </p>
      <p>See also:</p><ul>
<li><a href="#offsetOf">@offsetOf</a></li>
</ul>

      

      <h3 id="bitSizeOf"><a href="#toc-bitSizeOf">@bitSizeOf</a> <a class="hdr" href="#bitSizeOf">§</a></h3>

      <pre><code><span class="tok-builtin">@bitSizeOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      This function returns the number of bits it takes to store <code>T</code> in memory if the type
      were a field in a packed struct/union.
      The result is a target-specific compile time constant.
      </p>
      <p>
      This function measures the size at runtime. For types that are disallowed at runtime, such as
      <code><span class="tok-type">comptime_int</span></code> and <code><span class="tok-type">type</span></code>, the result is <code><span class="tok-number">0</span></code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#sizeOf">@sizeOf</a></li>
<li><a href="#typeInfo">@typeInfo</a></li>
</ul>

      

      <h3 id="branchHint"><a href="#toc-branchHint">@branchHint</a> <a class="hdr" href="#branchHint">§</a></h3>

      <pre><code><span class="tok-builtin">@branchHint</span>(hint: BranchHint) <span class="tok-type">void</span></code></pre>
      <p>Hints to the optimizer how likely a given branch of control flow is to be reached.</p>
      <p><code>BranchHint</code> can be found with <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).builtin.BranchHint</code>.</p>
      <p>This function is only valid as the first statement in a control flow branch, or the first statement in a function.</p>
      

      <h3 id="breakpoint"><a href="#toc-breakpoint">@breakpoint</a> <a class="hdr" href="#breakpoint">§</a></h3>

      <pre><code><span class="tok-builtin">@breakpoint</span>() <span class="tok-type">void</span></code></pre>
      <p>
      This function inserts a platform-specific debug trap instruction which causes
      debuggers to break there.
      Unlike for <code><span class="tok-builtin">@trap</span>()</code>, execution may continue after this point if the program is resumed.
      </p>
      <p>
      This function is only valid within function scope.
      </p>
      <p>See also:</p><ul>
<li><a href="#trap">@trap</a></li>
</ul>

      

      <h3 id="mulAdd"><a href="#toc-mulAdd">@mulAdd</a> <a class="hdr" href="#mulAdd">§</a></h3>

      <pre><code><span class="tok-builtin">@mulAdd</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T, c: T) T</code></pre>
      <p>
      Fused multiply-add, similar to <code>(a * b) + c</code>, except
      only rounds once, and is thus more accurate.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats.
      </p>
      

      <h3 id="byteSwap"><a href="#toc-byteSwap">@byteSwap</a> <a class="hdr" href="#byteSwap">§</a></h3>

      <pre><code><span class="tok-builtin">@byteSwap</span>(operand: <span class="tok-kw">anytype</span>) T</code></pre>
      <p><code><span class="tok-builtin">@TypeOf</span>(operand)</code> must be an integer type or an integer vector type with bit count evenly divisible by 8.</p>
      <p><code>operand</code> may be an <a href="#Integers">integer</a> or <a href="#Vectors">vector</a>.</p>
      <p>
      Swaps the byte order of the integer. This converts a big endian integer to a little endian integer,
      and converts a little endian integer to a big endian integer.
      </p>
      <p>
      Note that for the purposes of memory layout with respect to endianness, the integer type should be
      related to the number of bytes reported by <a href="#sizeOf">@sizeOf</a> bytes. This is demonstrated with
      <code><span class="tok-type">u24</span></code>. <code><span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u24</span>) == <span class="tok-number">4</span></code>, which means that a
      <code><span class="tok-type">u24</span></code> stored in memory takes 4 bytes, and those 4 bytes are what are swapped on
      a little vs big endian system. On the other hand, if <code>T</code> is specified to
      be <code><span class="tok-type">u24</span></code>, then only 3 bytes are reversed.
      </p>
      

      <h3 id="bitReverse"><a href="#toc-bitReverse">@bitReverse</a> <a class="hdr" href="#bitReverse">§</a></h3>

      <pre><code><span class="tok-builtin">@bitReverse</span>(integer: <span class="tok-kw">anytype</span>) T</code></pre>
      <p><code><span class="tok-builtin">@TypeOf</span>(<span class="tok-kw">anytype</span>)</code> accepts any integer type or integer vector type.</p>
      <p>
      Reverses the bitpattern of an integer value, including the sign bit if applicable.
      </p>
      <p>
      For example 0b10110110 (<code><span class="tok-type">u8</span> = <span class="tok-number">182</span></code>, <code><span class="tok-type">i8</span> = -<span class="tok-number">74</span></code>)
      becomes 0b01101101 (<code><span class="tok-type">u8</span> = <span class="tok-number">109</span></code>, <code><span class="tok-type">i8</span> = <span class="tok-number">109</span></code>).
      </p>
      

      <h3 id="offsetOf"><a href="#toc-offsetOf">@offsetOf</a> <a class="hdr" href="#offsetOf">§</a></h3>

      <pre><code><span class="tok-builtin">@offsetOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      Returns the byte offset of a field relative to its containing struct.
      </p>
      <p>See also:</p><ul>
<li><a href="#bitOffsetOf">@bitOffsetOf</a></li>
</ul>

      

      <h3 id="call"><a href="#toc-call">@call</a> <a class="hdr" href="#call">§</a></h3>

      <pre><code><span class="tok-builtin">@call</span>(modifier: std.builtin.CallModifier, function: <span class="tok-kw">anytype</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Calls a function, in the same way that invoking an expression with parentheses does:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_call_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;noinline function call&quot;</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@call</span>(.auto, add, .{ <span class="tok-number">3</span>, <span class="tok-number">9</span> }) == <span class="tok-number">12</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a + b;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_call_builtin.zig</kbd>
1/1 test_call_builtin.test.noinline function call...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      <code><span class="tok-builtin">@call</span></code> allows more flexibility than normal function call syntax does. The
      <code>CallModifier</code> enum is reproduced here:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">builtin.CallModifier struct.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CallModifier = <span class="tok-kw">enum</span> {
    <span class="tok-comment">/// Equivalent to function call syntax.</span>
    auto,

    <span class="tok-comment">/// Equivalent to async keyword used with function call syntax.</span>
    async_kw,

    <span class="tok-comment">/// Prevents tail call optimization. This guarantees that the return</span>
    <span class="tok-comment">/// address will point to the callsite, as opposed to the callsite's</span>
    <span class="tok-comment">/// callsite. If the call is otherwise required to be tail-called</span>
    <span class="tok-comment">/// or inlined, a compile error is emitted instead.</span>
    never_tail,

    <span class="tok-comment">/// Guarantees that the call will not be inlined. If the call is</span>
    <span class="tok-comment">/// otherwise required to be inlined, a compile error is emitted instead.</span>
    never_inline,

    <span class="tok-comment">/// Asserts that the function call will not suspend. This allows a</span>
    <span class="tok-comment">/// non-async function to call an async function.</span>
    no_async,

    <span class="tok-comment">/// Guarantees that the call will be generated with tail call optimization.</span>
    <span class="tok-comment">/// If this is not possible, a compile error is emitted instead.</span>
    always_tail,

    <span class="tok-comment">/// Guarantees that the call will be inlined at the callsite.</span>
    <span class="tok-comment">/// If this is not possible, a compile error is emitted instead.</span>
    always_inline,

    <span class="tok-comment">/// Evaluates the call at compile-time. If the call cannot be completed at</span>
    <span class="tok-comment">/// compile-time, a compile error is emitted instead.</span>
    compile_time,
};</code></pre></figure>

      

      <h3 id="cDefine"><a href="#toc-cDefine">@cDefine</a> <a class="hdr" href="#cDefine">§</a></h3>

      <pre><code><span class="tok-builtin">@cDefine</span>(<span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, value) <span class="tok-type">void</span></code></pre>
      <p>
      This function can only occur inside <code><span class="tok-builtin">@cImport</span></code>.
      </p>
      <p>
      This appends <code>#define $name $value</code> to the <code><span class="tok-builtin">@cImport</span></code>
      temporary buffer.
      </p>
      <p>
      To define without a value, like this:
      </p>
      <pre><code class="c">#define _GNU_SOURCE</code></pre>
      <p>
      Use the void value, like this:
      </p>
      <pre><code><span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;_GNU_SOURCE&quot;</span>, {})</code></pre>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cInclude">@cInclude</a></li>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cUndef">@cUndef</a></li>
<li><a href="#void">void</a></li>
</ul>

      
      <h3 id="cImport"><a href="#toc-cImport">@cImport</a> <a class="hdr" href="#cImport">§</a></h3>

      <pre><code><span class="tok-builtin">@cImport</span>(expression) <span class="tok-type">type</span></code></pre>
      <p>
      This function parses C code and imports the functions, types, variables,
      and compatible macro definitions into a new empty struct type, and then
      returns that type.
      </p>
      <p>
      <code>expression</code> is interpreted at compile time. The builtin functions
          <code><span class="tok-builtin">@cInclude</span></code>, <code><span class="tok-builtin">@cDefine</span></code>, and <code><span class="tok-builtin">@cUndef</span></code> work
      within this expression, appending to a temporary buffer which is then parsed as C code.
      </p>
      <p>
      Usually you should only have one <code><span class="tok-builtin">@cImport</span></code> in your entire application, because it saves the compiler
      from invoking clang multiple times, and prevents inline functions from being duplicated.
      </p>
      <p>
      Reasons for having multiple <code><span class="tok-builtin">@cImport</span></code> expressions would be:
      </p>
      <ul>
          <li>To avoid a symbol collision, for example if foo.h and bar.h both <code>#define CONNECTION_COUNT</code></li>
        <li>To analyze the C code with different preprocessor defines</li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cInclude">@cInclude</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cUndef">@cUndef</a></li>
</ul>

      
      <h3 id="cInclude"><a href="#toc-cInclude">@cInclude</a> <a class="hdr" href="#cInclude">§</a></h3>

      <pre><code><span class="tok-builtin">@cInclude</span>(<span class="tok-kw">comptime</span> path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre>
      <p>
      This function can only occur inside <code><span class="tok-builtin">@cImport</span></code>.
      </p>
      <p>
      This appends <code>#include &lt;$path&gt;\n</code> to the <code>c_import</code>
      temporary buffer.
      </p>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cUndef">@cUndef</a></li>
</ul>

      

      <h3 id="clz"><a href="#toc-clz">@clz</a> <a class="hdr" href="#clz">§</a></h3>

      <pre><code><span class="tok-builtin">@clz</span>(operand: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p><code><span class="tok-builtin">@TypeOf</span>(operand)</code> must be an integer type or an integer vector type.</p>
      <p><code>operand</code> may be an <a href="#Integers">integer</a> or <a href="#Vectors">vector</a>.</p>
      <p>
      Counts the number of most-significant (leading in a big-endian sense) zeroes in an integer - "count leading zeroes".
      </p>
      <p>
      The return type is an unsigned integer or vector of unsigned integers with the minimum number
      of bits that can represent the bit count of the integer type.
      </p>
      <p>
      If <code>operand</code> is zero, <code><span class="tok-builtin">@clz</span></code> returns the bit width
      of integer type <code>T</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#ctz">@ctz</a></li>
<li><a href="#popCount">@popCount</a></li>
</ul>

      

      <h3 id="cmpxchgStrong"><a href="#toc-cmpxchgStrong">@cmpxchgStrong</a> <a class="hdr" href="#cmpxchgStrong">§</a></h3>

      <pre><code><span class="tok-builtin">@cmpxchgStrong</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T</code></pre>
      <p>
      This function performs a strong atomic compare-and-exchange operation, returning <code><span class="tok-null">null</span></code>
      if the current value is the given expected value. It's the equivalent of this code,
      except atomic:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">not_atomic_cmpxchgStrong.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">cmpxchgStrongButNotAtomic</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T) ?T {
    <span class="tok-kw">const</span> old_value = ptr.*;
    <span class="tok-kw">if</span> (old_value == expected_value) {
        ptr.* = new_value;
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> old_value;
    }
}</code></pre></figure>

      <p>
      If you are using cmpxchg in a retry loop, <a href="#cmpxchgWeak">@cmpxchgWeak</a> is the better choice, because it can be implemented
      more efficiently in machine instructions.
      </p>
      <p>
      <code>T</code> must be a pointer, a <code><span class="tok-type">bool</span></code>, a float,
      an integer or an enum.
      </p>
      <p><code><span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(ptr)).pointer.alignment</code> must be <code>&gt;= <span class="tok-builtin">@sizeOf</span>(T).</code></p>
      <p><code>AtomicOrder</code> can be found with <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).builtin.AtomicOrder</code>.</p>
      <p>See also:</p><ul>
<li><a href="#atomicStore">@atomicStore</a></li>
<li><a href="#atomicLoad">@atomicLoad</a></li>
<li><a href="#atomicRmw">@atomicRmw</a></li>
<li><a href="#cmpxchgWeak">@cmpxchgWeak</a></li>
</ul>

      

      <h3 id="cmpxchgWeak"><a href="#toc-cmpxchgWeak">@cmpxchgWeak</a> <a class="hdr" href="#cmpxchgWeak">§</a></h3>

      <pre><code><span class="tok-builtin">@cmpxchgWeak</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T</code></pre>
      <p>
      This function performs a weak atomic compare-and-exchange operation, returning <code><span class="tok-null">null</span></code>
      if the current value is the given expected value. It's the equivalent of this code,
      except atomic:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">cmpxchgWeakButNotAtomic</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">cmpxchgWeakButNotAtomic</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T) ?T {
    <span class="tok-kw">const</span> old_value = ptr.*;
    <span class="tok-kw">if</span> (old_value == expected_value <span class="tok-kw">and</span> usuallyTrueButSometimesFalse()) {
        ptr.* = new_value;
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> old_value;
    }
}</code></pre></figure>
      <p>
      If you are using cmpxchg in a retry loop, the sporadic failure will be no problem, and <code>cmpxchgWeak</code>
      is the better choice, because it can be implemented more efficiently in machine instructions.
      However if you need a stronger guarantee, use <a href="#cmpxchgStrong">@cmpxchgStrong</a>.
      </p>
      <p>
      <code>T</code> must be a pointer, a <code><span class="tok-type">bool</span></code>, a float,
      an integer or an enum.
      </p>
      <p><code><span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(ptr)).pointer.alignment</code> must be <code>&gt;= <span class="tok-builtin">@sizeOf</span>(T).</code></p>
      <p><code>AtomicOrder</code> can be found with <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).builtin.AtomicOrder</code>.</p>
      <p>See also:</p><ul>
<li><a href="#atomicStore">@atomicStore</a></li>
<li><a href="#atomicLoad">@atomicLoad</a></li>
<li><a href="#atomicRmw">@atomicRmw</a></li>
<li><a href="#cmpxchgStrong">@cmpxchgStrong</a></li>
</ul>

      

      <h3 id="compileError"><a href="#toc-compileError">@compileError</a> <a class="hdr" href="#compileError">§</a></h3>

      <pre><code><span class="tok-builtin">@compileError</span>(<span class="tok-kw">comptime</span> msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">noreturn</span></code></pre>
      <p>
      This function, when semantically analyzed, causes a compile error with the
      message <code>msg</code>.
      </p>
      <p>
      There are several ways that code avoids being semantically checked, such as
      using <code><span class="tok-kw">if</span></code> or <code><span class="tok-kw">switch</span></code> with compile time constants,
              and <code><span class="tok-kw">comptime</span></code> functions.
      </p>
      

      <h3 id="compileLog"><a href="#toc-compileLog">@compileLog</a> <a class="hdr" href="#compileLog">§</a></h3>

      <pre><code><span class="tok-builtin">@compileLog</span>(...) <span class="tok-type">void</span></code></pre>
      <p>
      This function prints the arguments passed to it at compile-time.
      </p>
      <p>
      To prevent accidentally leaving compile log statements in a codebase,
      a compilation error is added to the build, pointing to the compile
      log statement. This error prevents code from being generated, but
      does not otherwise interfere with analysis.
      </p>
      <p>
      This function can be used to do "printf debugging" on
      compile-time executing code.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_compileLog_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">const</span> num1 = blk: {
    <span class="tok-kw">var</span> val1: <span class="tok-type">i32</span> = <span class="tok-number">99</span>;
    <span class="tok-builtin">@compileLog</span>(<span class="tok-str">&quot;comptime val1 = &quot;</span>, val1);
    val1 = val1 + <span class="tok-number">1</span>;
    <span class="tok-kw">break</span> :blk val1;
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;main&quot;</span> {
    <span class="tok-builtin">@compileLog</span>(<span class="tok-str">&quot;comptime in main&quot;</span>);

    print(<span class="tok-str">&quot;Runtime in main, num1 = {}.\n&quot;</span>, .{num1});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_compileLog_builtin.zig</kbd>
<span class="sgr-1m">doc/langref/test_compileLog_builtin.zig:11:5: </span><span class="sgr-31m">error: </span><span class="sgr-1m">found compile log statement
</span>    @compileLog(&quot;comptime in main&quot;);
    <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-1m">doc/langref/test_compileLog_builtin.zig:5:5: </span><span class="sgr-36m">note: </span><span class="sgr-1m">also here
</span>    @compileLog(&quot;comptime val1 = &quot;, val1);
    <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span>
Compile Log Output:
@as(*const [16:0]u8, &quot;comptime in main&quot;)
@as(*const [16:0]u8, &quot;comptime val1 = &quot;), @as(i32, 99)
</samp></pre></figure>

      

      <h3 id="constCast"><a href="#toc-constCast">@constCast</a> <a class="hdr" href="#constCast">§</a></h3>

      <pre><code><span class="tok-builtin">@constCast</span>(value: <span class="tok-kw">anytype</span>) DestType</code></pre>
      <p>
      Remove <code><span class="tok-kw">const</span></code> qualifier from a pointer.
      </p>
      

      <h3 id="ctz"><a href="#toc-ctz">@ctz</a> <a class="hdr" href="#ctz">§</a></h3>

      <pre><code><span class="tok-builtin">@ctz</span>(operand: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p><code><span class="tok-builtin">@TypeOf</span>(operand)</code> must be an integer type or an integer vector type.</p>
      <p><code>operand</code> may be an <a href="#Integers">integer</a> or <a href="#Vectors">vector</a>.</p>
      <p>
      Counts the number of least-significant (trailing in a big-endian sense) zeroes in an integer - "count trailing zeroes".
      </p>
      <p>
      The return type is an unsigned integer or vector of unsigned integers with the minimum number
      of bits that can represent the bit count of the integer type.
      </p>
      <p>
      If <code>operand</code> is zero, <code><span class="tok-builtin">@ctz</span></code> returns
      the bit width of integer type <code>T</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#clz">@clz</a></li>
<li><a href="#popCount">@popCount</a></li>
</ul>

      

      <h3 id="cUndef"><a href="#toc-cUndef">@cUndef</a> <a class="hdr" href="#cUndef">§</a></h3>

      <pre><code><span class="tok-builtin">@cUndef</span>(<span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span></code></pre>
      <p>
      This function can only occur inside <code><span class="tok-builtin">@cImport</span></code>.
      </p>
      <p>
      This appends <code>#undef $name</code> to the <code><span class="tok-builtin">@cImport</span></code>
      temporary buffer.
      </p>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cInclude">@cInclude</a></li>
</ul>

      

      <h3 id="cVaArg"><a href="#toc-cVaArg">@cVaArg</a> <a class="hdr" href="#cVaArg">§</a></h3>

      <pre><code><span class="tok-builtin">@cVaArg</span>(operand: *std.builtin.VaList, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) T</code></pre>
      <p>
      Implements the C macro <code>va_arg</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#cVaCopy">@cVaCopy</a></li>
<li><a href="#cVaEnd">@cVaEnd</a></li>
<li><a href="#cVaStart">@cVaStart</a></li>
</ul>

      
      <h3 id="cVaCopy"><a href="#toc-cVaCopy">@cVaCopy</a> <a class="hdr" href="#cVaCopy">§</a></h3>

      <pre><code><span class="tok-builtin">@cVaCopy</span>(src: *std.builtin.VaList) std.builtin.VaList</code></pre>
      <p>
      Implements the C macro <code>va_copy</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#cVaArg">@cVaArg</a></li>
<li><a href="#cVaEnd">@cVaEnd</a></li>
<li><a href="#cVaStart">@cVaStart</a></li>
</ul>

      
      <h3 id="cVaEnd"><a href="#toc-cVaEnd">@cVaEnd</a> <a class="hdr" href="#cVaEnd">§</a></h3>

      <pre><code><span class="tok-builtin">@cVaEnd</span>(src: *std.builtin.VaList) <span class="tok-type">void</span></code></pre>
      <p>
      Implements the C macro <code>va_end</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#cVaArg">@cVaArg</a></li>
<li><a href="#cVaCopy">@cVaCopy</a></li>
<li><a href="#cVaStart">@cVaStart</a></li>
</ul>

      
      <h3 id="cVaStart"><a href="#toc-cVaStart">@cVaStart</a> <a class="hdr" href="#cVaStart">§</a></h3>

      <pre><code><span class="tok-builtin">@cVaStart</span>() std.builtin.VaList</code></pre>
      <p>
      Implements the C macro <code>va_start</code>. Only valid inside a variadic function.
      </p>
      <p>See also:</p><ul>
<li><a href="#cVaArg">@cVaArg</a></li>
<li><a href="#cVaCopy">@cVaCopy</a></li>
<li><a href="#cVaEnd">@cVaEnd</a></li>
</ul>

      

      <h3 id="divExact"><a href="#toc-divExact">@divExact</a> <a class="hdr" href="#divExact">§</a></h3>

      <pre><code><span class="tok-builtin">@divExact</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      Exact division. Caller guarantees <code>denominator != <span class="tok-number">0</span></code> and
          <code><span class="tok-builtin">@divTrunc</span>(numerator, denominator) * denominator == numerator</code>.
      </p>
      <ul>
          <li><code><span class="tok-builtin">@divExact</span>(<span class="tok-number">6</span>, <span class="tok-number">3</span>) == <span class="tok-number">2</span></code></li>
          <li><code><span class="tok-builtin">@divExact</span>(a, b) * b == a</code></li>
      </ul>
      <p>For a function that returns a possible error code, use <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divExact</code>.</p>
      <p>See also:</p><ul>
<li><a href="#divTrunc">@divTrunc</a></li>
<li><a href="#divFloor">@divFloor</a></li>
</ul>

      
      <h3 id="divFloor"><a href="#toc-divFloor">@divFloor</a> <a class="hdr" href="#divFloor">§</a></h3>

      <pre><code><span class="tok-builtin">@divFloor</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      Floored division. Rounds toward negative infinity. For unsigned integers it is
      the same as <code>numerator / denominator</code>. Caller guarantees <code>denominator != <span class="tok-number">0</span></code> and
              <code>!(<span class="tok-builtin">@typeInfo</span>(T) == .int <span class="tok-kw">and</span> T.is_signed <span class="tok-kw">and</span> numerator == std.math.minInt(T) <span class="tok-kw">and</span> denominator == -<span class="tok-number">1</span>)</code>.
      </p>
      <ul>
          <li><code><span class="tok-builtin">@divFloor</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == -<span class="tok-number">2</span></code></li>
          <li><code>(<span class="tok-builtin">@divFloor</span>(a, b) * b) + <span class="tok-builtin">@mod</span>(a, b) == a</code></li>
      </ul>
      <p>For a function that returns a possible error code, use <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divFloor</code>.</p>
      <p>See also:</p><ul>
<li><a href="#divTrunc">@divTrunc</a></li>
<li><a href="#divExact">@divExact</a></li>
</ul>

      
      <h3 id="divTrunc"><a href="#toc-divTrunc">@divTrunc</a> <a class="hdr" href="#divTrunc">§</a></h3>

      <pre><code><span class="tok-builtin">@divTrunc</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      Truncated division. Rounds toward zero. For unsigned integers it is
      the same as <code>numerator / denominator</code>. Caller guarantees <code>denominator != <span class="tok-number">0</span></code> and
              <code>!(<span class="tok-builtin">@typeInfo</span>(T) == .int <span class="tok-kw">and</span> T.is_signed <span class="tok-kw">and</span> numerator == std.math.minInt(T) <span class="tok-kw">and</span> denominator == -<span class="tok-number">1</span>)</code>.
      </p>
      <ul>
          <li><code><span class="tok-builtin">@divTrunc</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == -<span class="tok-number">1</span></code></li>
          <li><code>(<span class="tok-builtin">@divTrunc</span>(a, b) * b) + <span class="tok-builtin">@rem</span>(a, b) == a</code></li>
      </ul>
      <p>For a function that returns a possible error code, use <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divTrunc</code>.</p>
      <p>See also:</p><ul>
<li><a href="#divFloor">@divFloor</a></li>
<li><a href="#divExact">@divExact</a></li>
</ul>

      

      <h3 id="embedFile"><a href="#toc-embedFile">@embedFile</a> <a class="hdr" href="#embedFile">§</a></h3>

      <pre><code><span class="tok-builtin">@embedFile</span>(<span class="tok-kw">comptime</span> path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<span class="tok-kw">const</span> [N:<span class="tok-number">0</span>]<span class="tok-type">u8</span></code></pre>
      <p>
      This function returns a compile time constant pointer to null-terminated,
      fixed-size array with length equal to the byte count of the file given by
      <code>path</code>. The contents of the array are the contents of the file.
      This is equivalent to a <a href="#String-Literals-and-Unicode-Code-Point-Literals">string literal</a>
      with the file contents.
      </p>
      <p>
      <code>path</code> is absolute or relative to the current file, just like <code><span class="tok-builtin">@import</span></code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#import">@import</a></li>
</ul>

      

      <h3 id="enumFromInt"><a href="#toc-enumFromInt">@enumFromInt</a> <a class="hdr" href="#enumFromInt">§</a></h3>

      <pre><code><span class="tok-builtin">@enumFromInt</span>(integer: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Converts an integer into an <a href="#enum">enum</a> value. The return type is the inferred result type.
      </p>
      <p>
      Attempting to convert an integer with no corresponding value in the enum invokes
      safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>.
      Note that a <a href="#Non-exhaustive-enum">non-exhaustive enum</a> has corresponding values for all
      integers in the enum's integer tag type: the <code>_</code> value represents all
      the remaining unnamed integers in the enum's tag type.
      </p>
      <p>See also:</p><ul>
<li><a href="#intFromEnum">@intFromEnum</a></li>
</ul>

      

      <h3 id="errorFromInt"><a href="#toc-errorFromInt">@errorFromInt</a> <a class="hdr" href="#errorFromInt">§</a></h3>

      <pre><code><span class="tok-builtin">@errorFromInt</span>(value: std.meta.Int(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">anyerror</span>))) <span class="tok-type">anyerror</span></code></pre>
      <p>
      Converts from the integer representation of an error into <a href="#The-Global-Error-Set">The Global Error Set</a> type.
      </p>
      <p>
      It is generally recommended to avoid this
      cast, as the integer representation of an error is not stable across source code changes.
      </p>
      <p>
      Attempting to convert an integer that does not correspond to any error results in
      safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#intFromError">@intFromError</a></li>
</ul>

      

      <h3 id="errorName"><a href="#toc-errorName">@errorName</a> <a class="hdr" href="#errorName">§</a></h3>

      <pre><code><span class="tok-builtin">@errorName</span>(err: <span class="tok-type">anyerror</span>) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre>
      <p>
      This function returns the string representation of an error. The string representation
      of <code><span class="tok-kw">error</span>.OutOfMem</code> is <code><span class="tok-str">&quot;OutOfMem&quot;</span></code>.
      </p>
      <p>
      If there are no calls to <code><span class="tok-builtin">@errorName</span></code> in an entire application,
      or all calls have a compile-time known value for <code>err</code>, then no
      error name table will be generated.
      </p>
      

      <h3 id="errorReturnTrace"><a href="#toc-errorReturnTrace">@errorReturnTrace</a> <a class="hdr" href="#errorReturnTrace">§</a></h3>

      <pre><code><span class="tok-builtin">@errorReturnTrace</span>() ?*builtin.StackTrace</code></pre>
      <p>
      If the binary is built with error return tracing, and this function is invoked in a
      function that calls a function with an error or error union return type, returns a
      stack trace object. Otherwise returns <a href="#null">null</a>.
      </p>
      

      <h3 id="errorCast"><a href="#toc-errorCast">@errorCast</a> <a class="hdr" href="#errorCast">§</a></h3>

      <pre><code><span class="tok-builtin">@errorCast</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Converts an error set or error union value from one error set to another error set. The return type is the
			inferred result type. Attempting to convert an error which is not in the destination error
			set results in safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      

      <h3 id="export"><a href="#toc-export">@export</a> <a class="hdr" href="#export">§</a></h3>

      <pre><code><span class="tok-builtin">@export</span>(<span class="tok-kw">comptime</span> ptr: *<span class="tok-kw">const</span> <span class="tok-type">anyopaque</span>, <span class="tok-kw">comptime</span> options: std.builtin.ExportOptions) <span class="tok-type">void</span></code></pre>
      <p>Creates a symbol in the output object file which refers to the target of <code>ptr</code>.</p>
      <p><code>ptr</code> must point to a global variable or a comptime-known constant.</p>
      <p>
      This builtin can be called from a <a href="#comptime">comptime</a> block to conditionally export symbols.
      When <code>ptr</code> points to a function with the C calling convention and
      <code>options.linkage</code> is <code>.Strong</code>, this is equivalent to
      the <code><span class="tok-kw">export</span></code> keyword used on a function:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">export_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-builtin">@export</span>(&amp;internalName, .{ .name = <span class="tok-str">&quot;foo&quot;</span>, .linkage = .strong });
}

<span class="tok-kw">fn</span> <span class="tok-fn">internalName</span>() <span class="tok-kw">callconv</span>(.C) <span class="tok-type">void</span> {}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj export_builtin.zig</kbd>
</samp></pre></figure>

      <p>This is equivalent to:</p>
      <figure><figcaption class="zig-cap"><cite class="file">export_builtin_equivalent_code.zig</cite></figcaption><pre><code><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj export_builtin_equivalent_code.zig</kbd>
</samp></pre></figure>

      <p>Note that even when using <code><span class="tok-kw">export</span></code>, the <code>@&quot;foo&quot;</code> syntax for
      <a href="#Identifiers">identifiers</a> can be used to choose any string for the symbol name:</p>
      <figure><figcaption class="zig-cap"><cite class="file">export_any_symbol_name.zig</cite></figcaption><pre><code><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">@&quot;A function name that is a complete sentence.&quot;</span>() <span class="tok-type">void</span> {}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-obj export_any_symbol_name.zig</kbd>
</samp></pre></figure>

      <p>
      When looking at the resulting object, you can see the symbol is used verbatim:
      </p>
      <pre><code>00000000000001f0 T A function name that is a complete sentence.</code></pre>
      <p>See also:</p><ul>
<li><a href="#Exporting-a-C-Library">Exporting a C Library</a></li>
</ul>

      

      <h3 id="extern"><a href="#toc-extern">@extern</a> <a class="hdr" href="#extern">§</a></h3>

      <pre><code><span class="tok-builtin">@extern</span>(T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> options: std.builtin.ExternOptions) T</code></pre>
      <p>
      Creates a reference to an external symbol in the output object file.
      T must be a pointer type.
      </p>
      <p>See also:</p><ul>
<li><a href="#export">@export</a></li>
</ul>

      

      <h3 id="field"><a href="#toc-field">@field</a> <a class="hdr" href="#field">§</a></h3>

      <pre><code><span class="tok-builtin">@field</span>(lhs: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) (field)</code></pre>
      <p>Performs field access by a compile-time string. Works on both fields and declarations.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_field_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">u32</span>,
    y: <span class="tok-type">u32</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">var</span> z: <span class="tok-type">u32</span> = <span class="tok-number">1</span>;
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;field access by string&quot;</span> {
    <span class="tok-kw">const</span> expect = std.testing.expect;
    <span class="tok-kw">var</span> p = Point{ .x = <span class="tok-number">0</span>, .y = <span class="tok-number">0</span> };

    <span class="tok-builtin">@field</span>(p, <span class="tok-str">&quot;x&quot;</span>) = <span class="tok-number">4</span>;
    <span class="tok-builtin">@field</span>(p, <span class="tok-str">&quot;y&quot;</span>) = <span class="tok-builtin">@field</span>(p, <span class="tok-str">&quot;x&quot;</span>) + <span class="tok-number">1</span>;

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@field</span>(p, <span class="tok-str">&quot;x&quot;</span>) == <span class="tok-number">4</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@field</span>(p, <span class="tok-str">&quot;y&quot;</span>) == <span class="tok-number">5</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;decl access by string&quot;</span> {
    <span class="tok-kw">const</span> expect = std.testing.expect;

    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@field</span>(Point, <span class="tok-str">&quot;z&quot;</span>) == <span class="tok-number">1</span>);

    <span class="tok-builtin">@field</span>(Point, <span class="tok-str">&quot;z&quot;</span>) = <span class="tok-number">2</span>;
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@field</span>(Point, <span class="tok-str">&quot;z&quot;</span>) == <span class="tok-number">2</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_field_builtin.zig</kbd>
1/2 test_field_builtin.test.field access by string...OK
2/2 test_field_builtin.test.decl access by string...OK
All 2 tests passed.
</samp></pre></figure>


      

      <h3 id="fieldParentPtr"><a href="#toc-fieldParentPtr">@fieldParentPtr</a> <a class="hdr" href="#fieldParentPtr">§</a></h3>

      <pre><code><span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, field_ptr: *T) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Given a pointer to a struct field, returns a pointer to the struct containing that field.
      The return type (and struct in question) is the inferred result type.
      </p>
      <p>
      If <code>field_ptr</code> does not point to the <code>field_name</code> field of an instance of
      the result type, and the result type has ill-defined layout, invokes unchecked <a href="#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      

      <h3 id="FieldType"><a href="#toc-FieldType">@FieldType</a> <a class="hdr" href="#FieldType">§</a></h3>

      <pre><code><span class="tok-builtin">@FieldType</span>(<span class="tok-kw">comptime</span> Type: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">type</span></code></pre>
      <p>
      Given a type and the name of one of its fields, returns the type of that field.
      </p>
      

      <h3 id="floatCast"><a href="#toc-floatCast">@floatCast</a> <a class="hdr" href="#floatCast">§</a></h3>

      <pre><code><span class="tok-builtin">@floatCast</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Convert from one float type to another. This cast is safe, but may cause the
      numeric value to lose precision. The return type is the inferred result type.
      </p>
      

      <h3 id="floatFromInt"><a href="#toc-floatFromInt">@floatFromInt</a> <a class="hdr" href="#floatFromInt">§</a></h3>

      <pre><code><span class="tok-builtin">@floatFromInt</span>(int: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Converts an integer to the closest floating point representation. The return type is the inferred result type.
			To convert the other way, use <a href="#intFromFloat">@intFromFloat</a>. This operation is legal
      for all values of all integer types.
      </p>
      

      <h3 id="frameAddress"><a href="#toc-frameAddress">@frameAddress</a> <a class="hdr" href="#frameAddress">§</a></h3>

      <pre><code><span class="tok-builtin">@frameAddress</span>() <span class="tok-type">usize</span></code></pre>
      <p>
      This function returns the base pointer of the current stack frame.
      </p>
      <p>
      The implications of this are target-specific and not consistent across all
      platforms. The frame address may not be available in release mode due to
      aggressive optimizations.
      </p>
      <p>
      This function is only valid within function scope.
      </p>
      

      <h3 id="hasDecl"><a href="#toc-hasDecl">@hasDecl</a> <a class="hdr" href="#hasDecl">§</a></h3>

      <pre><code><span class="tok-builtin">@hasDecl</span>(<span class="tok-kw">comptime</span> Container: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre>
      <p>
      Returns whether or not a <a href="#Containers">container</a> has a declaration
      matching <code>name</code>.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_hasDecl_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
    nope: <span class="tok-type">i32</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">var</span> blah = <span class="tok-str">&quot;xxx&quot;</span>;
    <span class="tok-kw">const</span> hi = <span class="tok-number">1</span>;
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;@hasDecl&quot;</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@hasDecl</span>(Foo, <span class="tok-str">&quot;blah&quot;</span>));

    <span class="tok-comment">// Even though `hi` is private, @hasDecl returns true because this test is</span>
    <span class="tok-comment">// in the same file scope as Foo. It would return false if Foo was declared</span>
    <span class="tok-comment">// in a different file.</span>
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@hasDecl</span>(Foo, <span class="tok-str">&quot;hi&quot;</span>));

    <span class="tok-comment">// @hasDecl is for declarations; not fields.</span>
    <span class="tok-kw">try</span> expect(!<span class="tok-builtin">@hasDecl</span>(Foo, <span class="tok-str">&quot;nope&quot;</span>));
    <span class="tok-kw">try</span> expect(!<span class="tok-builtin">@hasDecl</span>(Foo, <span class="tok-str">&quot;nope1234&quot;</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_hasDecl_builtin.zig</kbd>
1/1 test_hasDecl_builtin.test.@hasDecl...OK
All 1 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#hasField">@hasField</a></li>
</ul>

      

      <h3 id="hasField"><a href="#toc-hasField">@hasField</a> <a class="hdr" href="#hasField">§</a></h3>

      <pre><code><span class="tok-builtin">@hasField</span>(<span class="tok-kw">comptime</span> Container: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre>
      <p>Returns whether the field name of a struct, union, or enum exists.</p>
      <p>
      The result is a compile time constant.
      </p>
      <p>
      It does not include functions, variables, or constants.
      </p>
      <p>See also:</p><ul>
<li><a href="#hasDecl">@hasDecl</a></li>
</ul>

      

      <h3 id="import"><a href="#toc-import">@import</a> <a class="hdr" href="#import">§</a></h3>

      <pre><code><span class="tok-builtin">@import</span>(<span class="tok-kw">comptime</span> path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">type</span></code></pre>
      <p>
      This function finds a zig file corresponding to <code>path</code> and adds it to the build,
      if it is not already added.
      </p>
      <p>
      Zig source files are implicitly structs, with a name equal to the file's basename with the extension
      truncated. <code><span class="tok-builtin">@import</span></code> returns the struct type corresponding to the file.
      </p>
      <p>
      Declarations which have the <code><span class="tok-kw">pub</span></code> keyword may be referenced from a different
      source file than the one they are declared in.
      </p>
      <p>
      <code>path</code> can be a relative path or it can be the name of a package.
      If it is a relative path, it is relative to the file that contains the <code><span class="tok-builtin">@import</span></code>
      function call.
      </p>
      <p>
      The following packages are always available:
      </p>
      <ul>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>)</code> - Zig Standard Library</li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>)</code> - Target-specific information
              The command <code>zig build-exe --show-builtin</code> outputs the source to stdout for reference.
          </li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>)</code> - Root source file
              This is usually <code>src/main.zig</code> but depends on what file is built.
          </li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
<li><a href="#embedFile">@embedFile</a></li>
</ul>

      

      <h3 id="inComptime"><a href="#toc-inComptime">@inComptime</a> <a class="hdr" href="#inComptime">§</a></h3>

      <pre><code><span class="tok-builtin">@inComptime</span>() <span class="tok-type">bool</span></code></pre>
      <p>
      Returns whether the builtin was run in a <code><span class="tok-kw">comptime</span></code> context. The result is a compile-time constant.
      </p>
      <p>
      This can be used to provide alternative, comptime-friendly implementations of functions. It should not be used, for instance, to exclude certain functions from being evaluated at comptime.
      </p>
      <p>See also:</p><ul>
<li><a href="#comptime">comptime</a></li>
</ul>

      

      <h3 id="intCast"><a href="#toc-intCast">@intCast</a> <a class="hdr" href="#intCast">§</a></h3>

      <pre><code><span class="tok-builtin">@intCast</span>(int: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Converts an integer to another integer while keeping the same numerical value.
			The return type is the inferred result type.
      Attempting to convert a number which is out of range of the destination type results in
      safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_intCast_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;integer cast panic&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u16</span> = <span class="tok-number">0xabcd</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;a;
    <span class="tok-kw">const</span> b: <span class="tok-type">u8</span> = <span class="tok-builtin">@intCast</span>(a);
    _ = b;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_intCast_builtin.zig</kbd>
1/1 test_intCast_builtin.test.integer cast panic...thread 222197 panic: integer cast truncated bits
<span class="sgr-1m">/home/andy/src/zig/doc/langref/test_intCast_builtin.zig:4:19</span>: <span class="sgr-2m">0x1048978 in test.integer cast panic (test)</span>
    const b: u8 = @intCast(a);
                  <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:214:25</span>: <span class="sgr-2m">0x10eedb5 in mainTerminal (test)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:62:28</span>: <span class="sgr-2m">0x10e734d in main (test)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10e68d2 in posixCallMainAndExit (test)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10e64ad in _start (test)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/src/zig/.zig-cache/o/df39e05f4dd3b2dc748e167908afb941/test --seed=0x9bc4417f
</samp></pre></figure>

      <p>
      To truncate the significant bits of a number out of range of the destination type, use <a href="#truncate">@truncate</a>.
      </p>
      <p>
      If <code>T</code> is <code><span class="tok-type">comptime_int</span></code>,
      then this is semantically equivalent to <a href="#Type-Coercion">Type Coercion</a>.
      </p>
      

      <h3 id="intFromBool"><a href="#toc-intFromBool">@intFromBool</a> <a class="hdr" href="#intFromBool">§</a></h3>

      <pre><code><span class="tok-builtin">@intFromBool</span>(value: <span class="tok-type">bool</span>) <span class="tok-type">u1</span></code></pre>
      <p>
      Converts <code><span class="tok-null">true</span></code> to <code><span class="tok-builtin">@as</span>(<span class="tok-type">u1</span>, <span class="tok-number">1</span>)</code> and <code><span class="tok-null">false</span></code> to
                  <code><span class="tok-builtin">@as</span>(<span class="tok-type">u1</span>, <span class="tok-number">0</span>)</code>.
      </p>
      

      <h3 id="intFromEnum"><a href="#toc-intFromEnum">@intFromEnum</a> <a class="hdr" href="#intFromEnum">§</a></h3>

      <pre><code><span class="tok-builtin">@intFromEnum</span>(enum_or_tagged_union: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Converts an enumeration value into its integer tag type. When a tagged union is passed,
      the tag value is used as the enumeration value.
      </p>
      <p>
      If there is only one possible enum value, the result is a <code><span class="tok-type">comptime_int</span></code>
      known at <a href="#comptime">comptime</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#enumFromInt">@enumFromInt</a></li>
</ul>

      

      <h3 id="intFromError"><a href="#toc-intFromError">@intFromError</a> <a class="hdr" href="#intFromError">§</a></h3>

      <pre><code><span class="tok-builtin">@intFromError</span>(err: <span class="tok-kw">anytype</span>) std.meta.Int(.unsigned, <span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">anyerror</span>))</code></pre>
      <p>
      Supports the following types:
      </p>
      <ul>
          <li><a href="#The-Global-Error-Set">The Global Error Set</a></li>
          <li><a href="#Error-Set-Type">Error Set Type</a></li>
          <li><a href="#Error-Union-Type">Error Union Type</a></li>
      </ul>
      <p>
      Converts an error to the integer representation of an error.
      </p>
      <p>
      It is generally recommended to avoid this
      cast, as the integer representation of an error is not stable across source code changes.
      </p>
      <p>See also:</p><ul>
<li><a href="#errorFromInt">@errorFromInt</a></li>
</ul>

      

      <h3 id="intFromFloat"><a href="#toc-intFromFloat">@intFromFloat</a> <a class="hdr" href="#intFromFloat">§</a></h3>

      <pre><code><span class="tok-builtin">@intFromFloat</span>(float: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Converts the integer part of a floating point number to the inferred result type.
      </p>
      <p>
      If the integer part of the floating point number cannot fit in the destination type,
      it invokes safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#floatFromInt">@floatFromInt</a></li>
</ul>

      

      <h3 id="intFromPtr"><a href="#toc-intFromPtr">@intFromPtr</a> <a class="hdr" href="#intFromPtr">§</a></h3>

      <pre><code><span class="tok-builtin">@intFromPtr</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-type">usize</span></code></pre>
      <p>
      Converts <code>value</code> to a <code><span class="tok-type">usize</span></code> which is the address of the pointer.
      <code>value</code> can be <code>*T</code> or <code>?*T</code>.
      </p>
      <p>To convert the other way, use <a href="#ptrFromInt">@ptrFromInt</a></p>
      

      <h3 id="max"><a href="#toc-max">@max</a> <a class="hdr" href="#max">§</a></h3>

      <pre><code><span class="tok-builtin">@max</span>(...) T</code></pre>
      <p>
      Takes two or more arguments and returns the biggest value included (the maximum). This builtin accepts integers, floats, and vectors of either. In the latter case, the operation is performed element wise.
      </p>
      <p>
      NaNs are handled as follows: return the biggest non-NaN value included. If all operands are NaN, return NaN.
      </p>
      <p>See also:</p><ul>
<li><a href="#min">@min</a></li>
<li><a href="#Vectors">Vectors</a></li>
</ul>

      

      <h3 id="memcpy"><a href="#toc-memcpy">@memcpy</a> <a class="hdr" href="#memcpy">§</a></h3>

      <pre><code><span class="tok-builtin">@memcpy</span>(<span class="tok-kw">noalias</span> dest, <span class="tok-kw">noalias</span> source) <span class="tok-type">void</span></code></pre>
      <p>This function copies bytes from one region of memory to another.</p>
      <p><code>dest</code> must be a mutable slice, a mutable pointer to an array, or
        a mutable many-item <a href="#Pointers">pointer</a>. It may have any
        alignment, and it may have any element type.</p>
      <p><code>source</code> must be a slice, a pointer to
        an array, or a many-item <a href="#Pointers">pointer</a>. It may
        have any alignment, and it may have any element type.</p>
      <p>The <code>source</code> element type must have the same in-memory
        representation as the <code>dest</code> element type.</p>
      <p>Similar to <a href="#for">for</a> loops, at least one of <code>source</code> and
        <code>dest</code> must provide a length, and if two lengths are provided,
        they must be equal.</p>
      <p>Finally, the two memory regions must not overlap.</p>
      

      <h3 id="memset"><a href="#toc-memset">@memset</a> <a class="hdr" href="#memset">§</a></h3>

      <pre><code><span class="tok-builtin">@memset</span>(dest, elem) <span class="tok-type">void</span></code></pre>
      <p>This function sets all the elements of a memory region to <code>elem</code>.</p>
      <p><code>dest</code> must be a mutable slice or a mutable pointer to an array.
      It may have any alignment, and it may have any element type.</p>
      <p><code>elem</code> is coerced to the element type of <code>dest</code>.</p>
      <p>For securely zeroing out sensitive contents from memory, you should use
      <code>std.crypto.secureZero</code></p>
      

      <h3 id="min"><a href="#toc-min">@min</a> <a class="hdr" href="#min">§</a></h3>

      <pre><code><span class="tok-builtin">@min</span>(...) T</code></pre>
      <p>
      Takes two or more arguments and returns the smallest value included (the minimum). This builtin accepts integers, floats, and vectors of either. In the latter case, the operation is performed element wise.
      </p>
      <p>
      NaNs are handled as follows: return the smallest non-NaN value included. If all operands are NaN, return NaN.
      </p>
      <p>See also:</p><ul>
<li><a href="#max">@max</a></li>
<li><a href="#Vectors">Vectors</a></li>
</ul>

      

      <h3 id="wasmMemorySize"><a href="#toc-wasmMemorySize">@wasmMemorySize</a> <a class="hdr" href="#wasmMemorySize">§</a></h3>

      <pre><code><span class="tok-builtin">@wasmMemorySize</span>(index: <span class="tok-type">u32</span>) <span class="tok-type">usize</span></code></pre>
      <p>
      This function returns the size of the Wasm memory identified by <code>index</code> as
      an unsigned value in units of Wasm pages. Note that each Wasm page is 64KB in size.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms usually useful for allocator
      designers targeting Wasm. So unless you are writing a new allocator from scratch, you should use
      something like <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).heap.WasmPageAllocator</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#wasmMemoryGrow">@wasmMemoryGrow</a></li>
</ul>

      

      <h3 id="wasmMemoryGrow"><a href="#toc-wasmMemoryGrow">@wasmMemoryGrow</a> <a class="hdr" href="#wasmMemoryGrow">§</a></h3>

      <pre><code><span class="tok-builtin">@wasmMemoryGrow</span>(index: <span class="tok-type">u32</span>, delta: <span class="tok-type">usize</span>) <span class="tok-type">isize</span></code></pre>
      <p>
      This function increases the size of the Wasm memory identified by <code>index</code> by
      <code>delta</code> in units of unsigned number of Wasm pages. Note that each Wasm page
      is 64KB in size. On success, returns previous memory size; on failure, if the allocation fails,
      returns -1.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms usually useful for allocator
      designers targeting Wasm. So unless you are writing a new allocator from scratch, you should use
      something like <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).heap.WasmPageAllocator</code>.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_wasmMemoryGrow_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> native_arch = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).target.cpu.arch;
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;@wasmMemoryGrow&quot;</span> {
    <span class="tok-kw">if</span> (native_arch != .wasm32) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">const</span> prev = <span class="tok-builtin">@wasmMemorySize</span>(<span class="tok-number">0</span>);
    <span class="tok-kw">try</span> expect(prev == <span class="tok-builtin">@wasmMemoryGrow</span>(<span class="tok-number">0</span>, <span class="tok-number">1</span>));
    <span class="tok-kw">try</span> expect(prev + <span class="tok-number">1</span> == <span class="tok-builtin">@wasmMemorySize</span>(<span class="tok-number">0</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_wasmMemoryGrow_builtin.zig</kbd>
1/1 test_wasmMemoryGrow_builtin.test.@wasmMemoryGrow...SKIP
0 passed; 1 skipped; 0 failed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#wasmMemorySize">@wasmMemorySize</a></li>
</ul>

      

      <h3 id="mod"><a href="#toc-mod">@mod</a> <a class="hdr" href="#mod">§</a></h3>

      <pre><code><span class="tok-builtin">@mod</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      Modulus division. For unsigned integers this is the same as
      <code>numerator % denominator</code>. Caller guarantees <code>denominator &gt; <span class="tok-number">0</span></code>, otherwise the
      operation will result in a <a href="#Remainder-Division-by-Zero">Remainder Division by Zero</a> when runtime safety checks are enabled.
      </p>
      <ul>
          <li><code><span class="tok-builtin">@mod</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == <span class="tok-number">1</span></code></li>
          <li><code>(<span class="tok-builtin">@divFloor</span>(a, b) * b) + <span class="tok-builtin">@mod</span>(a, b) == a</code></li>
      </ul>
      <p>For a function that returns an error code, see <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.mod</code>.</p>
      <p>See also:</p><ul>
<li><a href="#rem">@rem</a></li>
</ul>

      

      <h3 id="mulWithOverflow"><a href="#toc-mulWithOverflow">@mulWithOverflow</a> <a class="hdr" href="#mulWithOverflow">§</a></h3>

      <pre><code><span class="tok-builtin">@mulWithOverflow</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-kw">anytype</span>) <span class="tok-kw">struct</span> { <span class="tok-builtin">@TypeOf</span>(a, b), <span class="tok-type">u1</span> }</code></pre>
      <p>
      Performs <code>a * b</code> and returns a tuple with the result and a possible overflow bit.
      </p>
      

      <h3 id="panic"><a href="#toc-panic">@panic</a> <a class="hdr" href="#panic">§</a></h3>

      <pre><code><span class="tok-builtin">@panic</span>(message: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">noreturn</span></code></pre>
      <p>
      Invokes the panic handler function. By default the panic handler function
      calls the public <code>panic</code> function exposed in the root source file, or
      if there is not one specified, the <code>std.builtin.default_panic</code>
      function from <code>std/builtin.zig</code>.
      </p>
      <p>Generally it is better to use <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.panic</code>.
          However, <code><span class="tok-builtin">@panic</span></code> can be useful for 2 scenarios:
      </p>
      <ul>
        <li>From library code, calling the programmer's panic function if they exposed one in the root source file.</li>
        <li>When mixing C and Zig code, calling the canonical panic implementation across multiple .o files.</li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Panic-Handler">Panic Handler</a></li>
</ul>

      

      <h3 id="popCount"><a href="#toc-popCount">@popCount</a> <a class="hdr" href="#popCount">§</a></h3>

      <pre><code><span class="tok-builtin">@popCount</span>(operand: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p><code><span class="tok-builtin">@TypeOf</span>(operand)</code> must be an integer type.</p>
      <p><code>operand</code> may be an <a href="#Integers">integer</a> or <a href="#Vectors">vector</a>.</p>
      <p>
      Counts the number of bits set in an integer - "population count".
      </p>
      <p>
      The return type is an unsigned integer or vector of unsigned integers with the minimum number
      of bits that can represent the bit count of the integer type.
      </p>
      <p>See also:</p><ul>
<li><a href="#ctz">@ctz</a></li>
<li><a href="#clz">@clz</a></li>
</ul>

      

      <h3 id="prefetch"><a href="#toc-prefetch">@prefetch</a> <a class="hdr" href="#prefetch">§</a></h3>

      <pre><code><span class="tok-builtin">@prefetch</span>(ptr: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> options: PrefetchOptions) <span class="tok-type">void</span></code></pre>
      <p>
      This builtin tells the compiler to emit a prefetch instruction if supported by the
      target CPU. If the target CPU does not support the requested prefetch instruction,
      this builtin is a no-op. This function has no effect on the behavior of the program,
      only on the performance characteristics.
      </p>
      <p>
      The <code>ptr</code> argument may be any pointer type and determines the memory
      address to prefetch. This function does not dereference the pointer, it is perfectly legal
      to pass a pointer to invalid memory to this function and no Illegal Behavior will result.
      </p>
      <p><code>PrefetchOptions</code> can be found with <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).builtin.PrefetchOptions</code>.</p>
      

      <h3 id="ptrCast"><a href="#toc-ptrCast">@ptrCast</a> <a class="hdr" href="#ptrCast">§</a></h3>

      <pre><code><span class="tok-builtin">@ptrCast</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Converts a pointer of one type to a pointer of another type. The return type is the inferred result type.
      </p>
      <p>
      <a href="#Optional-Pointers">Optional Pointers</a> are allowed. Casting an optional pointer which is <a href="#null">null</a>
      to a non-optional pointer invokes safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      <p>
      <code><span class="tok-builtin">@ptrCast</span></code> cannot be used for:
      </p>
      <ul>
          <li>Removing <code><span class="tok-kw">const</span></code> qualifier, use <a href="#constCast">@constCast</a>.</li>
          <li>Removing <code><span class="tok-kw">volatile</span></code> qualifier, use <a href="#volatileCast">@volatileCast</a>.</li>
          <li>Changing pointer address space, use <a href="#addrSpaceCast">@addrSpaceCast</a>.</li>
          <li>Increasing pointer alignment, use <a href="#alignCast">@alignCast</a>.</li>
          <li>Casting a non-slice pointer to a slice, use slicing syntax <code>ptr[start..end]</code>.</li>
      </ul>
      

      <h3 id="ptrFromInt"><a href="#toc-ptrFromInt">@ptrFromInt</a> <a class="hdr" href="#ptrFromInt">§</a></h3>

      <pre><code><span class="tok-builtin">@ptrFromInt</span>(address: <span class="tok-type">usize</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Converts an integer to a <a href="#Pointers">pointer</a>. The return type is the inferred result type.
			To convert the other way, use <a href="#intFromPtr">@intFromPtr</a>. Casting an address of 0 to a destination type
      which in not <a href="#Optional-Pointers">optional</a> and does not have the <code><span class="tok-kw">allowzero</span></code> attribute will result in a
      <a href="#Pointer-Cast-Invalid-Null">Pointer Cast Invalid Null</a> panic when runtime safety checks are enabled.
      </p>
      <p>
      If the destination pointer type does not allow address zero and <code>address</code>
      is zero, this invokes safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      

      <h3 id="rem"><a href="#toc-rem">@rem</a> <a class="hdr" href="#rem">§</a></h3>

      <pre><code><span class="tok-builtin">@rem</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      Remainder division. For unsigned integers this is the same as
      <code>numerator % denominator</code>. Caller guarantees <code>denominator &gt; <span class="tok-number">0</span></code>, otherwise the
      operation will result in a <a href="#Remainder-Division-by-Zero">Remainder Division by Zero</a> when runtime safety checks are enabled.
      </p>
      <ul>
          <li><code><span class="tok-builtin">@rem</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == -<span class="tok-number">2</span></code></li>
          <li><code>(<span class="tok-builtin">@divTrunc</span>(a, b) * b) + <span class="tok-builtin">@rem</span>(a, b) == a</code></li>
      </ul>
      <p>For a function that returns an error code, see <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.rem</code>.</p>
      <p>See also:</p><ul>
<li><a href="#mod">@mod</a></li>
</ul>

      

      <h3 id="returnAddress"><a href="#toc-returnAddress">@returnAddress</a> <a class="hdr" href="#returnAddress">§</a></h3>

      <pre><code><span class="tok-builtin">@returnAddress</span>() <span class="tok-type">usize</span></code></pre>
      <p>
      This function returns the address of the next machine code instruction that will be executed
      when the current function returns.
      </p>
      <p>
      The implications of this are target-specific and not consistent across
      all platforms.
      </p>
      <p>
      This function is only valid within function scope. If the function gets inlined into
      a calling function, the returned address will apply to the calling function.
      </p>
      

      <h3 id="select"><a href="#toc-select">@select</a> <a class="hdr" href="#select">§</a></h3>

      <pre><code><span class="tok-builtin">@select</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, pred: <span class="tok-builtin">@Vector</span>(len, <span class="tok-type">bool</span>), a: <span class="tok-builtin">@Vector</span>(len, T), b: <span class="tok-builtin">@Vector</span>(len, T)) <span class="tok-builtin">@Vector</span>(len, T)</code></pre>
      <p>
      Selects values element-wise from <code>a</code> or <code>b</code> based on <code>pred</code>. If <code>pred[i]</code> is <code><span class="tok-null">true</span></code>, the corresponding element in the result will be <code>a[i]</code> and otherwise <code>b[i]</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Vectors">Vectors</a></li>
</ul>

      

      <h3 id="setEvalBranchQuota"><a href="#toc-setEvalBranchQuota">@setEvalBranchQuota</a> <a class="hdr" href="#setEvalBranchQuota">§</a></h3>

      <pre><code><span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-kw">comptime</span> new_quota: <span class="tok-type">u32</span>) <span class="tok-type">void</span></code></pre>
      <p>
      Increase the maximum number of backwards branches that compile-time code
      execution can use before giving up and making a compile error.
      </p>
      <p>
      If the <code>new_quota</code> is smaller than the default quota (<code><span class="tok-number">1000</span></code>) or
      a previously explicitly set quota, it is ignored.
      </p>
      <p>
      Example:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_without_setEvalBranchQuota_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;foo&quot;</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; <span class="tok-number">1001</span>) : (i += <span class="tok-number">1</span>) {}
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_without_setEvalBranchQuota_builtin.zig</kbd>
<span class="sgr-1m">doc/langref/test_without_setEvalBranchQuota_builtin.zig:4:9: </span><span class="sgr-31m">error: </span><span class="sgr-1m">evaluation exceeded 1000 backwards branches
</span>        while (i &lt; 1001) : (i += 1) {}
        <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span class="sgr-1m">doc/langref/test_without_setEvalBranchQuota_builtin.zig:4:9: </span><span class="sgr-36m">note: </span><span class="sgr-1m">use @setEvalBranchQuota() to raise the branch limit from 1000
</span>
</samp></pre></figure>

      <p>Now we use <code><span class="tok-builtin">@setEvalBranchQuota</span></code>:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_setEvalBranchQuota_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;foo&quot;</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">1001</span>);
        <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; <span class="tok-number">1001</span>) : (i += <span class="tok-number">1</span>) {}
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_setEvalBranchQuota_builtin.zig</kbd>
1/1 test_setEvalBranchQuota_builtin.test.foo...OK
All 1 tests passed.
</samp></pre></figure>


      <p>See also:</p><ul>
<li><a href="#comptime">comptime</a></li>
</ul>

      

      <h3 id="setFloatMode"><a href="#toc-setFloatMode">@setFloatMode</a> <a class="hdr" href="#setFloatMode">§</a></h3>

      <pre><code><span class="tok-builtin">@setFloatMode</span>(<span class="tok-kw">comptime</span> mode: FloatMode) <span class="tok-type">void</span></code></pre>
      <p>Changes the current scope's rules about how floating point operations are defined.</p>
      <ul>
        <li>
            <code>Strict</code> (default) - Floating point operations follow strict IEEE compliance.
        </li>
        <li>
            <code>Optimized</code> - Floating point operations may do all of the following:
          <ul>
            <li>Assume the arguments and result are not NaN. Optimizations are required to retain legal behavior over NaNs, but the value of the result is undefined.</li>
            <li>Assume the arguments and result are not +/-Inf. Optimizations are required to retain legal behavior over +/-Inf, but the value of the result is undefined.</li>
            <li>Treat the sign of a zero argument or result as insignificant.</li>
            <li>Use the reciprocal of an argument rather than perform division.</li>
            <li>Perform floating-point contraction (e.g. fusing a multiply followed by an addition into a fused multiply-add).</li>
            <li>Perform algebraically equivalent transformations that may change results in floating point (e.g. reassociate).</li>
          </ul>
          This is equivalent to <code>-ffast-math</code> in GCC.
        </li>
      </ul>
      <p>
      The floating point mode is inherited by child scopes, and can be overridden in any scope.
      You can set the floating point mode in a struct or module scope by using a comptime block.
      </p>
      <p><code>FloatMode</code> can be found with <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).builtin.FloatMode</code>.</p>
      <p>See also:</p><ul>
<li><a href="#Floating-Point-Operations">Floating Point Operations</a></li>
</ul>

      

      <h3 id="setRuntimeSafety"><a href="#toc-setRuntimeSafety">@setRuntimeSafety</a> <a class="hdr" href="#setRuntimeSafety">§</a></h3>

      <pre><code><span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-kw">comptime</span> safety_on: <span class="tok-type">bool</span>) <span class="tok-type">void</span></code></pre>
      <p>
      Sets whether runtime safety checks are enabled for the scope that contains the function call.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_setRuntimeSafety_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;@setRuntimeSafety&quot;</span> {
    <span class="tok-comment">// The builtin applies to the scope that it is called in. So here, integer overflow</span>
    <span class="tok-comment">// will not be caught in ReleaseFast and ReleaseSmall modes:</span>
    <span class="tok-comment">// var x: u8 = 255;</span>
    <span class="tok-comment">// x += 1; // Unchecked Illegal Behavior in ReleaseFast/ReleaseSmall modes.</span>
    {
        <span class="tok-comment">// However this block has safety enabled, so safety checks happen here,</span>
        <span class="tok-comment">// even in ReleaseFast and ReleaseSmall modes.</span>
        <span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">true</span>);
        <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
        x += <span class="tok-number">1</span>;

        {
            <span class="tok-comment">// The value can be overridden at any scope. So here integer overflow</span>
            <span class="tok-comment">// would not be caught in any build mode.</span>
            <span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">false</span>);
            <span class="tok-comment">// var x: u8 = 255;</span>
            <span class="tok-comment">// x += 1; // Unchecked Illegal Behavior in all build modes.</span>
        }
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_setRuntimeSafety_builtin.zig -OReleaseFast</kbd>
1/1 test_setRuntimeSafety_builtin.test.@setRuntimeSafety...thread 222792 panic: integer overflow
<span class="sgr-1m">/home/andy/src/zig/doc/langref/test_setRuntimeSafety_builtin.zig:11:11</span>: <span class="sgr-2m">0x100b1f8 in test.@setRuntimeSafety (test)</span>
        x += 1;
          <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:214:25</span>: <span class="sgr-2m">0x1033308 in main (test)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10319ad in posixCallMainAndExit (test)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10314cd in _start (test)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/src/zig/.zig-cache/o/fb1876bcfd12bd21ad987d48fd800b31/test --seed=0x3a9b5544
</samp></pre></figure>

      <p>Note: it is <a href="https://github.com/ziglang/zig/issues/978">planned</a> to replace
      <code><span class="tok-builtin">@setRuntimeSafety</span></code> with <code>@optimizeFor</code></p>

      

      <h3 id="shlExact"><a href="#toc-shlExact">@shlExact</a> <a class="hdr" href="#shlExact">§</a></h3>

      <pre><code><span class="tok-builtin">@shlExact</span>(value: T, shift_amt: Log2T) T</code></pre>
      <p>
      Performs the left shift operation (<code>&lt;&lt;</code>).
      For unsigned integers, the result is <a href="#undefined">undefined</a> if any 1 bits
      are shifted out. For signed integers, the result is <a href="#undefined">undefined</a> if
      any bits that disagree with the resultant sign bit are shifted out.
      </p>
      <p>
      The type of <code>shift_amt</code> is an unsigned integer with <code>log2(<span class="tok-builtin">@typeInfo</span>(T).int.bits)</code> bits.
      This is because <code>shift_amt &gt;= <span class="tok-builtin">@typeInfo</span>(T).int.bits</code> triggers safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      <p>
      <code><span class="tok-type">comptime_int</span></code> is modeled as an integer with an infinite number of bits,
      meaning that in such case, <code><span class="tok-builtin">@shlExact</span></code> always produces a result and
      cannot produce a compile error.
      </p>
      <p>See also:</p><ul>
<li><a href="#shrExact">@shrExact</a></li>
<li><a href="#shlWithOverflow">@shlWithOverflow</a></li>
</ul>

      

      <h3 id="shlWithOverflow"><a href="#toc-shlWithOverflow">@shlWithOverflow</a> <a class="hdr" href="#shlWithOverflow">§</a></h3>

      <pre><code><span class="tok-builtin">@shlWithOverflow</span>(a: <span class="tok-kw">anytype</span>, shift_amt: Log2T) <span class="tok-kw">struct</span> { <span class="tok-builtin">@TypeOf</span>(a), <span class="tok-type">u1</span> }</code></pre>
      <p>
      Performs <code>a &lt;&lt; b</code> and returns a tuple with the result and a possible overflow bit.
      </p>
      <p>
      The type of <code>shift_amt</code> is an unsigned integer with <code>log2(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(a)).int.bits)</code> bits.
      This is because <code>shift_amt &gt;= <span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(a)).int.bits</code> triggers safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#shlExact">@shlExact</a></li>
<li><a href="#shrExact">@shrExact</a></li>
</ul>

      

      <h3 id="shrExact"><a href="#toc-shrExact">@shrExact</a> <a class="hdr" href="#shrExact">§</a></h3>

      <pre><code><span class="tok-builtin">@shrExact</span>(value: T, shift_amt: Log2T) T</code></pre>
      <p>
      Performs the right shift operation (<code>&gt;&gt;</code>). Caller guarantees
      that the shift will not shift any 1 bits out.
      </p>
      <p>
      The type of <code>shift_amt</code> is an unsigned integer with <code>log2(<span class="tok-builtin">@typeInfo</span>(T).int.bits)</code> bits.
      This is because <code>shift_amt &gt;= <span class="tok-builtin">@typeInfo</span>(T).int.bits</code> triggers safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#shlExact">@shlExact</a></li>
<li><a href="#shlWithOverflow">@shlWithOverflow</a></li>
</ul>

      

      <h3 id="shuffle"><a href="#toc-shuffle">@shuffle</a> <a class="hdr" href="#shuffle">§</a></h3>

      <pre><code><span class="tok-builtin">@shuffle</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, a: <span class="tok-builtin">@Vector</span>(a_len, E), b: <span class="tok-builtin">@Vector</span>(b_len, E), <span class="tok-kw">comptime</span> mask: <span class="tok-builtin">@Vector</span>(mask_len, <span class="tok-type">i32</span>)) <span class="tok-builtin">@Vector</span>(mask_len, E)</code></pre>
      <p>
      Constructs a new <a href="#Vectors">vector</a> by selecting elements from <code>a</code> and
      <code>b</code> based on <code>mask</code>.
      </p>
      <p>
      Each element in <code>mask</code> selects an element from either <code>a</code> or
      <code>b</code>. Positive numbers select from <code>a</code> starting at 0.
      Negative values select from <code>b</code>, starting at <code>-<span class="tok-number">1</span></code> and going down.
      It is recommended to use the <code>~</code> operator for indexes from <code>b</code>
      so that both indexes can start from <code><span class="tok-number">0</span></code> (i.e. <code>~<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">0</span>)</code> is
      <code>-<span class="tok-number">1</span></code>).
      </p>
      <p>
      For each element of <code>mask</code>, if it or the selected value from
      <code>a</code> or <code>b</code> is <code><span class="tok-null">undefined</span></code>,
      then the resulting element is <code><span class="tok-null">undefined</span></code>.
      </p>
      <p>
      <code>a_len</code> and <code>b_len</code> may differ in length. Out-of-bounds element
      indexes in <code>mask</code> result in compile errors.
      </p>
      <p>
      If <code>a</code> or <code>b</code> is <code><span class="tok-null">undefined</span></code>, it
      is equivalent to a vector of all <code><span class="tok-null">undefined</span></code> with the same length as the other vector.
      If both vectors are <code><span class="tok-null">undefined</span></code>, <code><span class="tok-builtin">@shuffle</span></code> returns
      a vector with all elements <code><span class="tok-null">undefined</span></code>.
      </p>
      <p>
      <code>E</code> must be an <a href="#Integers">integer</a>, <a href="#Floats">float</a>,
      <a href="#Pointers">pointer</a>, or <code><span class="tok-type">bool</span></code>. The mask may be any vector length, and its
      length determines the result length.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_shuffle_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;vector @shuffle&quot;</span> {
    <span class="tok-kw">const</span> a = <span class="tok-builtin">@Vector</span>(<span class="tok-number">7</span>, <span class="tok-type">u8</span>){ <span class="tok-str">'o'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'r'</span>, <span class="tok-str">'z'</span>, <span class="tok-str">'w'</span> };
    <span class="tok-kw">const</span> b = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">u8</span>){ <span class="tok-str">'w'</span>, <span class="tok-str">'d'</span>, <span class="tok-str">'!'</span>, <span class="tok-str">'x'</span> };

    <span class="tok-comment">// To shuffle within a single vector, pass undefined as the second argument.</span>
    <span class="tok-comment">// Notice that we can re-order, duplicate, or omit elements of the input vector</span>
    <span class="tok-kw">const</span> mask1 = <span class="tok-builtin">@Vector</span>(<span class="tok-number">5</span>, <span class="tok-type">i32</span>){ <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span> };
    <span class="tok-kw">const</span> res1: <span class="tok-builtin">@Vector</span>(<span class="tok-number">5</span>, <span class="tok-type">u8</span>) = <span class="tok-builtin">@shuffle</span>(<span class="tok-type">u8</span>, a, <span class="tok-null">undefined</span>, mask1);
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">5</span>]<span class="tok-type">u8</span>, res1), <span class="tok-str">&quot;hello&quot;</span>));

    <span class="tok-comment">// Combining two vectors</span>
    <span class="tok-kw">const</span> mask2 = <span class="tok-builtin">@Vector</span>(<span class="tok-number">6</span>, <span class="tok-type">i32</span>){ -<span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">4</span>, <span class="tok-number">1</span>, -<span class="tok-number">2</span>, -<span class="tok-number">3</span> };
    <span class="tok-kw">const</span> res2: <span class="tok-builtin">@Vector</span>(<span class="tok-number">6</span>, <span class="tok-type">u8</span>) = <span class="tok-builtin">@shuffle</span>(<span class="tok-type">u8</span>, a, b, mask2);
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">6</span>]<span class="tok-type">u8</span>, res2), <span class="tok-str">&quot;world!&quot;</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_shuffle_builtin.zig</kbd>
1/1 test_shuffle_builtin.test.vector @shuffle...OK
All 1 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#Vectors">Vectors</a></li>
</ul>

      

      <h3 id="sizeOf"><a href="#toc-sizeOf">@sizeOf</a> <a class="hdr" href="#sizeOf">§</a></h3>

      <pre><code><span class="tok-builtin">@sizeOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      This function returns the number of bytes it takes to store <code>T</code> in memory.
      The result is a target-specific compile time constant.
      </p>
      <p>
      This size may contain padding bytes. If there were two consecutive T in memory, the padding would be the offset
      in bytes between element at index 0 and the element at index 1. For <a href="#Integers">integer</a>,
      consider whether you want to use <code><span class="tok-builtin">@sizeOf</span>(T)</code> or
      <code><span class="tok-builtin">@typeInfo</span>(T).int.bits</code>.
      </p>
      <p>
      This function measures the size at runtime. For types that are disallowed at runtime, such as
      <code><span class="tok-type">comptime_int</span></code> and <code><span class="tok-type">type</span></code>, the result is <code><span class="tok-number">0</span></code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#bitSizeOf">@bitSizeOf</a></li>
<li><a href="#typeInfo">@typeInfo</a></li>
</ul>

      

      <h3 id="splat"><a href="#toc-splat">@splat</a> <a class="hdr" href="#splat">§</a></h3>

      <pre><code><span class="tok-builtin">@splat</span>(scalar: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Produces a vector where each element is the value <code>scalar</code>.
      The return type and thus the length of the vector is inferred.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_splat_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;vector @splat&quot;</span> {
    <span class="tok-kw">const</span> scalar: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
    <span class="tok-kw">const</span> result: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">u32</span>) = <span class="tok-builtin">@splat</span>(scalar);
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u32</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">4</span>]<span class="tok-type">u32</span>, result), &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">5</span>, <span class="tok-number">5</span>, <span class="tok-number">5</span>, <span class="tok-number">5</span> }));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_splat_builtin.zig</kbd>
1/1 test_splat_builtin.test.vector @splat...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      <code>scalar</code> must be an <a href="#Integers">integer</a>, <a href="#Primitive-Types">bool</a>,
      <a href="#Floats">float</a>, or <a href="#Pointers">pointer</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Vectors">Vectors</a></li>
<li><a href="#shuffle">@shuffle</a></li>
</ul>

      

      <h3 id="reduce"><a href="#toc-reduce">@reduce</a> <a class="hdr" href="#reduce">§</a></h3>

      <pre><code><span class="tok-builtin">@reduce</span>(<span class="tok-kw">comptime</span> op: std.builtin.ReduceOp, value: <span class="tok-kw">anytype</span>) E</code></pre>
      <p>
      Transforms a <a href="#Vectors">vector</a> into a scalar value (of type <code>E</code>)
      by performing a sequential horizontal reduction of its elements using the
      specified operator <code>op</code>.
      </p>
      <p>
      Not every operator is available for every vector element type:
      </p>
      <ul>
          <li>Every operator is available for <a href="#Integers">integer</a> vectors.</li>
          <li><code>.And</code>, <code>.Or</code>,
            <code>.Xor</code> are additionally available for
            <code><span class="tok-type">bool</span></code> vectors,</li>
          <li><code>.Min</code>, <code>.Max</code>,
            <code>.Add</code>, <code>.Mul</code> are
            additionally available for <a href="#Floats">floating point</a> vectors,</li>
      </ul>
      <p>
      Note that <code>.Add</code> and <code>.Mul</code>
      reductions on integral types are wrapping; when applied on floating point
      types the operation associativity is preserved, unless the float mode is
      set to <code>Optimized</code>.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_reduce_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;vector @reduce&quot;</span> {
    <span class="tok-kw">const</span> V = <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>);
    <span class="tok-kw">const</span> value = V{ <span class="tok-number">1</span>, -<span class="tok-number">1</span>, <span class="tok-number">1</span>, -<span class="tok-number">1</span> };
    <span class="tok-kw">const</span> result = value &gt; <span class="tok-builtin">@as</span>(V, <span class="tok-builtin">@splat</span>(<span class="tok-number">0</span>));
    <span class="tok-comment">// result is { true, false, true, false };</span>
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@TypeOf</span>(result) == <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">bool</span>));
    <span class="tok-kw">const</span> is_all_true = <span class="tok-builtin">@reduce</span>(.And, result);
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@TypeOf</span>(is_all_true) == <span class="tok-type">bool</span>);
    <span class="tok-kw">try</span> expect(is_all_true == <span class="tok-null">false</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_reduce_builtin.zig</kbd>
1/1 test_reduce_builtin.test.vector @reduce...OK
All 1 tests passed.
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#Vectors">Vectors</a></li>
<li><a href="#setFloatMode">@setFloatMode</a></li>
</ul>

      

      <h3 id="src"><a href="#toc-src">@src</a> <a class="hdr" href="#src">§</a></h3>

      <pre><code><span class="tok-builtin">@src</span>() std.builtin.SourceLocation</code></pre>
      <p>
      Returns a <code>SourceLocation</code> struct representing the function's name and location in the source code. This must be called in a function.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_src_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;@src&quot;</span> {
    <span class="tok-kw">try</span> doTheTest();
}

<span class="tok-kw">fn</span> <span class="tok-fn">doTheTest</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> src = <span class="tok-builtin">@src</span>();

    <span class="tok-kw">try</span> expect(src.line == <span class="tok-number">9</span>);
    <span class="tok-kw">try</span> expect(src.column == <span class="tok-number">17</span>);
    <span class="tok-kw">try</span> expect(std.mem.endsWith(<span class="tok-type">u8</span>, src.fn_name, <span class="tok-str">&quot;doTheTest&quot;</span>));
    <span class="tok-kw">try</span> expect(std.mem.endsWith(<span class="tok-type">u8</span>, src.file, <span class="tok-str">&quot;test_src_builtin.zig&quot;</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_src_builtin.zig</kbd>
1/1 test_src_builtin.test.@src...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h3 id="sqrt"><a href="#toc-sqrt">@sqrt</a> <a class="hdr" href="#sqrt">§</a></h3>

      <pre><code><span class="tok-builtin">@sqrt</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Performs the square root of a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="sin"><a href="#toc-sin">@sin</a> <a class="hdr" href="#sin">§</a></h3>

      <pre><code><span class="tok-builtin">@sin</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Sine trigonometric function on a floating point number in radians. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats.
      </p>
      

      <h3 id="cos"><a href="#toc-cos">@cos</a> <a class="hdr" href="#cos">§</a></h3>

      <pre><code><span class="tok-builtin">@cos</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Cosine trigonometric function on a floating point number in radians. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats.
      </p>
      

      <h3 id="tan"><a href="#toc-tan">@tan</a> <a class="hdr" href="#tan">§</a></h3>

      <pre><code><span class="tok-builtin">@tan</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Tangent trigonometric function on a floating point number in radians.
      Uses a dedicated hardware instruction when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats.
      </p>
      

      <h3 id="exp"><a href="#toc-exp">@exp</a> <a class="hdr" href="#exp">§</a></h3>

      <pre><code><span class="tok-builtin">@exp</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Base-e exponential function on a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="exp2"><a href="#toc-exp2">@exp2</a> <a class="hdr" href="#exp2">§</a></h3>

      <pre><code><span class="tok-builtin">@exp2</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Base-2 exponential function on a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="log"><a href="#toc-log">@log</a> <a class="hdr" href="#log">§</a></h3>

      <pre><code><span class="tok-builtin">@log</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the natural logarithm of a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="log2"><a href="#toc-log2">@log2</a> <a class="hdr" href="#log2">§</a></h3>

      <pre><code><span class="tok-builtin">@log2</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the logarithm to the base 2 of a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="log10"><a href="#toc-log10">@log10</a> <a class="hdr" href="#log10">§</a></h3>

      <pre><code><span class="tok-builtin">@log10</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the logarithm to the base 10 of a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="abs"><a href="#toc-abs">@abs</a> <a class="hdr" href="#abs">§</a></h3>

      <pre><code><span class="tok-builtin">@abs</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Returns the absolute value of an integer or a floating point number. Uses a dedicated hardware instruction
      when available.

      The return type is always an unsigned integer of the same bit width as the operand if the operand is an integer.
      Unsigned integer operands are supported. The builtin cannot overflow for signed integer operands.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a>, <a href="#Integers">Integers</a> and <a href="#Vectors">Vectors</a> of floats or integers.
      </p>
      
      <h3 id="floor"><a href="#toc-floor">@floor</a> <a class="hdr" href="#floor">§</a></h3>

      <pre><code><span class="tok-builtin">@floor</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the largest integral value not greater than the given floating point number.
      Uses a dedicated hardware instruction when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="ceil"><a href="#toc-ceil">@ceil</a> <a class="hdr" href="#ceil">§</a></h3>

      <pre><code><span class="tok-builtin">@ceil</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the smallest integral value not less than the given floating point number.
      Uses a dedicated hardware instruction when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="trunc"><a href="#toc-trunc">@trunc</a> <a class="hdr" href="#trunc">§</a></h3>

      <pre><code><span class="tok-builtin">@trunc</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Rounds the given floating point number to an integer, towards zero.
      Uses a dedicated hardware instruction when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats.
      </p>
      
      <h3 id="round"><a href="#toc-round">@round</a> <a class="hdr" href="#round">§</a></h3>

      <pre><code><span class="tok-builtin">@round</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Rounds the given floating point number to the nearest integer. If two integers are equally close, rounds away from zero.
      Uses a dedicated hardware instruction when available.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_round_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;@round&quot;</span> {
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@round</span>(<span class="tok-number">1.4</span>) == <span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@round</span>(<span class="tok-number">1.5</span>) == <span class="tok-number">2</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@round</span>(-<span class="tok-number">1.4</span>) == -<span class="tok-number">1</span>);
    <span class="tok-kw">try</span> expect(<span class="tok-builtin">@round</span>(-<span class="tok-number">2.5</span>) == -<span class="tok-number">3</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_round_builtin.zig</kbd>
1/1 test_round_builtin.test.@round...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats.
      </p>
      

      <h3 id="subWithOverflow"><a href="#toc-subWithOverflow">@subWithOverflow</a> <a class="hdr" href="#subWithOverflow">§</a></h3>

      <pre><code><span class="tok-builtin">@subWithOverflow</span>(a: <span class="tok-kw">anytype</span>, b: <span class="tok-kw">anytype</span>) <span class="tok-kw">struct</span> { <span class="tok-builtin">@TypeOf</span>(a, b), <span class="tok-type">u1</span> }</code></pre>
      <p>
      Performs <code>a - b</code> and returns a tuple with the result and a possible overflow bit.
      </p>
      

      <h3 id="tagName"><a href="#toc-tagName">@tagName</a> <a class="hdr" href="#tagName">§</a></h3>

      <pre><code><span class="tok-builtin">@tagName</span>(value: <span class="tok-kw">anytype</span>) [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre>
      <p>
      Converts an enum value or union value to a string literal representing the name.</p><p>If the enum is non-exhaustive and the tag value does not map to a name, it invokes safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      

      <h3 id="This"><a href="#toc-This">@This</a> <a class="hdr" href="#This">§</a></h3>

      <pre><code><span class="tok-builtin">@This</span>() <span class="tok-type">type</span></code></pre>
      <p>
      Returns the innermost struct, enum, or union that this function call is inside.
      This can be useful for an anonymous struct that needs to refer to itself:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_this_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;@This()&quot;</span> {
    <span class="tok-kw">var</span> items = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> list = List(<span class="tok-type">i32</span>){ .items = items[<span class="tok-number">0</span>..] };
    <span class="tok-kw">try</span> expect(list.length() == <span class="tok-number">4</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">List</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        items: []T,

        <span class="tok-kw">fn</span> <span class="tok-fn">length</span>(self: Self) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.items.len;
        }
    };
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_this_builtin.zig</kbd>
1/1 test_this_builtin.test.@This()...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      When <code><span class="tok-builtin">@This</span>()</code> is used at file scope, it returns a reference to the
      struct that corresponds to the current file.
      </p>
      

      <h3 id="trap"><a href="#toc-trap">@trap</a> <a class="hdr" href="#trap">§</a></h3>

      <pre><code><span class="tok-builtin">@trap</span>() <span class="tok-type">noreturn</span></code></pre>
      <p>
      This function inserts a platform-specific trap/jam instruction which can be used to exit the program abnormally.
      This may be implemented by explicitly emitting an invalid instruction which may cause an illegal instruction exception of some sort.
      Unlike for <code><span class="tok-builtin">@breakpoint</span>()</code>, execution does not continue after this point.
      </p>
      <p>
      Outside function scope, this builtin causes a compile error.
      </p>
      <p>See also:</p><ul>
<li><a href="#breakpoint">@breakpoint</a></li>
</ul>

      

      <h3 id="truncate"><a href="#toc-truncate">@truncate</a> <a class="hdr" href="#truncate">§</a></h3>

      <pre><code><span class="tok-builtin">@truncate</span>(integer: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      This function truncates bits from an integer type, resulting in a smaller
      or same-sized integer type. The return type is the inferred result type.
      </p>
      <p>
      This function always truncates the significant bits of the integer, regardless
      of endianness on the target platform.
      </p>
      <p>
      Calling <code><span class="tok-builtin">@truncate</span></code> on a number out of range of the destination type is well defined and working code:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_truncate_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;integer truncation&quot;</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u16</span> = <span class="tok-number">0xabcd</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u8</span> = <span class="tok-builtin">@truncate</span>(a);
    <span class="tok-kw">try</span> expect(b == <span class="tok-number">0xcd</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_truncate_builtin.zig</kbd>
1/1 test_truncate_builtin.test.integer truncation...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Use <a href="#intCast">@intCast</a> to convert numbers guaranteed to fit the destination type.
      </p>
      

      <h3 id="Type"><a href="#toc-Type">@Type</a> <a class="hdr" href="#Type">§</a></h3>

      <pre><code><span class="tok-builtin">@Type</span>(<span class="tok-kw">comptime</span> info: std.builtin.Type) <span class="tok-type">type</span></code></pre>
      <p>
      This function is the inverse of <a href="#typeInfo">@typeInfo</a>. It reifies type information
      into a <code><span class="tok-type">type</span></code>.
      </p>
      <p>
      It is available for the following types:
      </p>
      <ul>
          <li><code><span class="tok-type">type</span></code></li>
          <li><code><span class="tok-type">noreturn</span></code></li>
          <li><code><span class="tok-type">void</span></code></li>
          <li><code><span class="tok-type">bool</span></code></li>
          <li><a href="#Integers">Integers</a> - The maximum bit count for an integer type is <code><span class="tok-number">65535</span></code>.</li>
          <li><a href="#Floats">Floats</a></li>
          <li><a href="#Pointers">Pointers</a></li>
          <li><code><span class="tok-type">comptime_int</span></code></li>
          <li><code><span class="tok-type">comptime_float</span></code></li>
          <li><code><span class="tok-builtin">@TypeOf</span>(<span class="tok-null">undefined</span>)</code></li>
          <li><code><span class="tok-builtin">@TypeOf</span>(<span class="tok-null">null</span>)</code></li>
          <li><a href="#Arrays">Arrays</a></li>
          <li><a href="#Optionals">Optionals</a></li>
          <li><a href="#Error-Set-Type">Error Set Type</a></li>
          <li><a href="#Error-Union-Type">Error Union Type</a></li>
          <li><a href="#Vectors">Vectors</a></li>
          <li><a href="#opaque">opaque</a></li>
          <li><code><span class="tok-kw">anyframe</span></code></li>
          <li><a href="#struct">struct</a></li>
          <li><a href="#enum">enum</a></li>
          <li><a href="#Enum-Literals">Enum Literals</a></li>
          <li><a href="#union">union</a></li>
          <li><a href="#Functions">Functions</a></li>
      </ul>
      
      <h3 id="typeInfo"><a href="#toc-typeInfo">@typeInfo</a> <a class="hdr" href="#typeInfo">§</a></h3>

      <pre><code><span class="tok-builtin">@typeInfo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) std.builtin.Type</code></pre>
      <p>
      Provides type reflection.
      </p>
      <p>
      Type information of <a href="#struct">structs</a>, <a href="#union">unions</a>, <a href="#enum">enums</a>, and
      <a href="#Error-Set-Type">error sets</a> has fields which are guaranteed to be in the same
      order as appearance in the source file.
      </p>
      <p>
      Type information of <a href="#struct">structs</a>, <a href="#union">unions</a>, <a href="#enum">enums</a>, and
      <a href="#opaque">opaques</a> has declarations, which are also guaranteed to be in the same
      order as appearance in the source file.
      </p>
      

      <h3 id="typeName"><a href="#toc-typeName">@typeName</a> <a class="hdr" href="#typeName">§</a></h3>

      <pre><code><span class="tok-builtin">@typeName</span>(T: <span class="tok-type">type</span>) *<span class="tok-kw">const</span> [N:<span class="tok-number">0</span>]<span class="tok-type">u8</span></code></pre>
      <p>
      This function returns the string representation of a type, as
      an array. It is equivalent to a string literal of the type name.
      The returned type name is fully qualified with the parent namespace included
      as part of the type name with a series of dots.
      </p>
      

      <h3 id="TypeOf"><a href="#toc-TypeOf">@TypeOf</a> <a class="hdr" href="#TypeOf">§</a></h3>

      <pre><code><span class="tok-builtin">@TypeOf</span>(...) <span class="tok-type">type</span></code></pre>
      <p>
      <code><span class="tok-builtin">@TypeOf</span></code> is a special builtin function that takes any (non-zero) number of expressions
      as parameters and returns the type of the result, using <a href="#Peer-Type-Resolution">Peer Type Resolution</a>.
      </p>
      <p>
      The expressions are evaluated, however they are guaranteed to have no <em>runtime</em> side-effects:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_TypeOf_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;no runtime side effects&quot;</span> {
    <span class="tok-kw">var</span> data: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(foo(<span class="tok-type">i32</span>, &amp;data));
    <span class="tok-kw">try</span> <span class="tok-kw">comptime</span> expect(T == <span class="tok-type">i32</span>);
    <span class="tok-kw">try</span> expect(data == <span class="tok-number">0</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T) T {
    ptr.* += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> ptr.*;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_TypeOf_builtin.zig</kbd>
1/1 test_TypeOf_builtin.test.no runtime side effects...OK
All 1 tests passed.
</samp></pre></figure>

      

      <h3 id="unionInit"><a href="#toc-unionInit">@unionInit</a> <a class="hdr" href="#unionInit">§</a></h3>

      <pre><code><span class="tok-builtin">@unionInit</span>(<span class="tok-kw">comptime</span> Union: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> active_field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, init_expr) Union</code></pre>
      <p>
      This is the same thing as <a href="#union">union</a> initialization syntax, except that the field name is a
      <a href="#comptime">comptime</a>-known value rather than an identifier token.
      </p>
      <p>
      <code><span class="tok-builtin">@unionInit</span></code> forwards its <a href="#Result-Location-Semantics">result location</a> to <code>init_expr</code>.
      </p>
      


      <h3 id="Vector"><a href="#toc-Vector">@Vector</a> <a class="hdr" href="#Vector">§</a></h3>

      <pre><code><span class="tok-builtin">@Vector</span>(len: <span class="tok-type">comptime_int</span>, Element: <span class="tok-type">type</span>) <span class="tok-type">type</span></code></pre>
      <p>Creates <a href="#Vectors">Vectors</a>.</p>
      

      <h3 id="volatileCast"><a href="#toc-volatileCast">@volatileCast</a> <a class="hdr" href="#volatileCast">§</a></h3>

      <pre><code><span class="tok-builtin">@volatileCast</span>(value: <span class="tok-kw">anytype</span>) DestType</code></pre>
      <p>
      Remove <code><span class="tok-kw">volatile</span></code> qualifier from a pointer.
      </p>
      

      <h3 id="workGroupId"><a href="#toc-workGroupId">@workGroupId</a> <a class="hdr" href="#workGroupId">§</a></h3>

      <pre><code><span class="tok-builtin">@workGroupId</span>(<span class="tok-kw">comptime</span> dimension: <span class="tok-type">u32</span>) <span class="tok-type">u32</span></code></pre>
      <p>
      Returns the index of the work group in the current kernel invocation in dimension <code>dimension</code>.
      </p>
      

      <h3 id="workGroupSize"><a href="#toc-workGroupSize">@workGroupSize</a> <a class="hdr" href="#workGroupSize">§</a></h3>

      <pre><code><span class="tok-builtin">@workGroupSize</span>(<span class="tok-kw">comptime</span> dimension: <span class="tok-type">u32</span>) <span class="tok-type">u32</span></code></pre>
      <p>
      Returns the number of work items that a work group has in dimension <code>dimension</code>.
      </p>
      

      <h3 id="workItemId"><a href="#toc-workItemId">@workItemId</a> <a class="hdr" href="#workItemId">§</a></h3>

      <pre><code><span class="tok-builtin">@workItemId</span>(<span class="tok-kw">comptime</span> dimension: <span class="tok-type">u32</span>) <span class="tok-type">u32</span></code></pre>
      <p>
      Returns the index of the work item in the work group in dimension <code>dimension</code>. This function returns values between <code><span class="tok-number">0</span></code> (inclusive) and <code><span class="tok-builtin">@workGroupSize</span>(dimension)</code> (exclusive).
      </p>
      

      

      <h2 id="Build-Mode"><a href="#toc-Build-Mode">Build Mode</a> <a class="hdr" href="#Build-Mode">§</a></h2>

      <p>
      Zig has four build modes:
      </p>
      <ul>
        <li><a href="#Debug">Debug</a> (default)</li>
        <li><a href="#ReleaseFast">ReleaseFast</a></li>
        <li><a href="#ReleaseSafe">ReleaseSafe</a></li>
        <li><a href="#ReleaseSmall">ReleaseSmall</a></li>
      </ul>
      <p>
      To add standard build options to a <code class="file">build.zig</code> file:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">build.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *std.Build) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> optimize = b.standardOptimizeOption(.{});
    <span class="tok-kw">const</span> exe = b.addExecutable(.{
        .name = <span class="tok-str">&quot;example&quot;</span>,
        .root_source_file = b.path(<span class="tok-str">&quot;example.zig&quot;</span>),
        .optimize = optimize,
    });
    b.default_step.dependOn(&amp;exe.step);
}</code></pre></figure>

      <p>
      This causes these options to be available:
      </p>
      <dl>
        <dt><kbd>-Doptimize=Debug</kbd></dt><dd>Optimizations off and safety on (default)</dd>
        <dt><kbd>-Doptimize=ReleaseSafe</kbd></dt><dd>Optimizations on and safety on</dd>
        <dt><kbd>-Doptimize=ReleaseFast</kbd></dt><dd>Optimizations on and safety off</dd>
        <dt><kbd>-Doptimize=ReleaseSmall</kbd></dt><dd>Size optimizations on and safety off</dd>
      </dl>
      <h3 id="Debug"><a href="#toc-Debug">Debug</a> <a class="hdr" href="#Debug">§</a></h3>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe example.zig</kbd>
</samp></pre></figure>
      <ul>
        <li>Fast compilation speed</li>
        <li>Safety checks enabled</li>
        <li>Slow runtime performance</li>
        <li>Large binary size</li>
        <li>No reproducible build requirement</li>
      </ul>
      
      <h3 id="ReleaseFast"><a href="#toc-ReleaseFast">ReleaseFast</a> <a class="hdr" href="#ReleaseFast">§</a></h3>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe example.zig -O ReleaseFast</kbd>
</samp></pre></figure>
      <ul>
        <li>Fast runtime performance</li>
        <li>Safety checks disabled</li>
        <li>Slow compilation speed</li>
        <li>Large binary size</li>
        <li>Reproducible build</li>
      </ul>
      
      <h3 id="ReleaseSafe"><a href="#toc-ReleaseSafe">ReleaseSafe</a> <a class="hdr" href="#ReleaseSafe">§</a></h3>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe example.zig -O ReleaseSafe</kbd>
</samp></pre></figure>
      <ul>
        <li>Medium runtime performance</li>
        <li>Safety checks enabled</li>
        <li>Slow compilation speed</li>
        <li>Large binary size</li>
        <li>Reproducible build</li>
      </ul>
      
      <h3 id="ReleaseSmall"><a href="#toc-ReleaseSmall">ReleaseSmall</a> <a class="hdr" href="#ReleaseSmall">§</a></h3>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe example.zig -O ReleaseSmall</kbd>
</samp></pre></figure>
      <ul>
        <li>Medium runtime performance</li>
        <li>Safety checks disabled</li>
        <li>Slow compilation speed</li>
        <li>Small binary size</li>
        <li>Reproducible build</li>
      </ul>
      
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
<li><a href="#Zig-Build-System">Zig Build System</a></li>
<li><a href="#Illegal-Behavior">Illegal Behavior</a></li>
</ul>

      

      <h2 id="Single-Threaded-Builds"><a href="#toc-Single-Threaded-Builds">Single Threaded Builds</a> <a class="hdr" href="#Single-Threaded-Builds">§</a></h2>

      <p>Zig has a compile option <kbd>-fsingle-threaded</kbd> which has the following effects:</p>
      <ul>
        <li>All <a href="#Thread-Local-Variables">Thread Local Variables</a> are treated as regular <a href="#Container-Level-Variables">Container Level Variables</a>.</li>
        <li>The overhead of <a href="#Async-Functions">Async Functions</a> becomes equivalent to function call overhead.</li>
        <li>The <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).single_threaded</code> becomes <code><span class="tok-null">true</span></code>
          and therefore various userland APIs which read this variable become more efficient.
          For example <code>std.Mutex</code> becomes
          an empty data structure and all of its functions become no-ops.</li>
      </ul>
      

      <h2 id="Illegal-Behavior"><a href="#toc-Illegal-Behavior">Illegal Behavior</a> <a class="hdr" href="#Illegal-Behavior">§</a></h2>

      <p>
      Many operations in Zig trigger what is known as "Illegal Behavior" (IB). If Illegal Behavior is detected at
      compile-time, Zig emits a compile error and refuses to continue. Otherwise, when Illegal Behavior is not caught
      at compile-time, it falls into one of two categories.
      </p>
      <p>
      Some Illegal Behavior is <em>safety-checked</em>: this means that the compiler will insert "safety checks"
      anywhere that the Illegal Behavior may occur at runtime, to determine whether it is about to happen. If it
      is, the safety check "fails", which triggers a panic.
      </p>
      <p>
      All other Illegal Behavior is <em>unchecked</em>, meaning the compiler is unable to insert safety checks for
      it. If Unchecked Illegal Behavior is invoked at runtime, anything can happen: usually that will be some kind of
      crash, but the optimizer is free to make Unchecked Illegal Behavior do anything, such as calling arbitrary functions
      or clobbering arbitrary data. This is similar to the concept of "undefined behavior" in some other languages. Note that
      Unchecked Illegal Behavior still always results in a compile error if evaluated at <a href="#comptime">comptime</a>, because the Zig
      compiler is able to perform more sophisticated checks at compile-time than at runtime.
      </p>
      <p>
      Most Illegal Behavior is safety-checked. However, to facilitate optimizations, safety checks are disabled by default
      in the <a href="#ReleaseFast">ReleaseFast</a> and <a href="#ReleaseSmall">ReleaseSmall</a> optimization modes. Safety checks can also be enabled or disabled
      on a per-block basis, overriding the default for the current optimization mode, using <a href="#setRuntimeSafety">@setRuntimeSafety</a>. When
      safety checks are disabled, Safety-Checked Illegal Behavior behaves like Unchecked Illegal Behavior; that is, any behavior
      may result from invoking it.
      </p>
      <p>
      When a safety check fails, Zig's default panic handler crashes with a stack trace, like this:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_illegal_behavior.zig</cite></figcaption><pre><code><span class="tok-kw">test</span> <span class="tok-str">&quot;safety check&quot;</span> {
    <span class="tok-kw">unreachable</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_illegal_behavior.zig</kbd>
1/1 test_illegal_behavior.test.safety check...thread 210560 panic: reached unreachable code
<span class="sgr-1m">/home/andy/src/zig/doc/langref/test_illegal_behavior.zig:2:5</span>: <span class="sgr-2m">0x1048948 in test.safety check (test)</span>
    unreachable;
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:214:25</span>: <span class="sgr-2m">0x10eed75 in mainTerminal (test)</span>
        if (test_fn.func()) |_| {
                        <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/compiler/test_runner.zig:62:28</span>: <span class="sgr-2m">0x10e730d in main (test)</span>
        return mainTerminal();
                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10e6892 in posixCallMainAndExit (test)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10e646d in _start (test)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
error: the following test command crashed:
/home/andy/src/zig/.zig-cache/o/ad5fcf79fd9ccd7e0493595fe81df80a/test --seed=0x4cb0f272
</samp></pre></figure>

      <h3 id="Reaching-Unreachable-Code"><a href="#toc-Reaching-Unreachable-Code">Reaching Unreachable Code</a> <a class="hdr" href="#Reaching-Unreachable-Code">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_reaching_unreachable.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    assert(<span class="tok-null">false</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>; <span class="tok-comment">// assertion failure</span>
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_reaching_unreachable.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_reaching_unreachable.zig:5:14: </span><span class="sgr-31m">error: </span><span class="sgr-1m">reached unreachable code
</span>    if (!ok) unreachable; // assertion failure
             <span class="sgr-32m">^~~~~~~~~~~
</span><span class="sgr-1m">doc/langref/test_comptime_reaching_unreachable.zig:2:11: </span><span class="sgr-36m">note: </span><span class="sgr-1m">called from here
</span>    assert(false);
    <span class="sgr-32m">~~~~~~^~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_reaching_unreachable.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    std.debug.assert(<span class="tok-null">false</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_reaching_unreachable.zig</kbd>
$ <kbd>./runtime_reaching_unreachable</kbd>
thread 217396 panic: reached unreachable code
<span class="sgr-1m">/home/andy/src/zig/lib/std/debug.zig:522:14</span>: <span class="sgr-2m">0x1048a9d in assert (runtime_reaching_unreachable)</span>
    if (!ok) unreachable; // assertion failure
             <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_reaching_unreachable.zig:4:21</span>: <span class="sgr-2m">0x10de72a in main (runtime_reaching_unreachable)</span>
    std.debug.assert(false);
                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de232 in posixCallMainAndExit (runtime_reaching_unreachable)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10dde0d in _start (runtime_reaching_unreachable)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Index-out-of-Bounds"><a href="#toc-Index-out-of-Bounds">Index out of Bounds</a> <a class="hdr" href="#Index-out-of-Bounds">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_index_out_of_bounds.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> array: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>.*;
    <span class="tok-kw">const</span> garbage = array[<span class="tok-number">5</span>];
    _ = garbage;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_index_out_of_bounds.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_index_out_of_bounds.zig:3:27: </span><span class="sgr-31m">error: </span><span class="sgr-1m">index 5 outside array of length 5
</span>    const garbage = array[5];
                          <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_index_out_of_bounds.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x = foo(<span class="tok-str">&quot;hello&quot;</span>);
    _ = x;
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> x[<span class="tok-number">5</span>];
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_index_out_of_bounds.zig</kbd>
$ <kbd>./runtime_index_out_of_bounds</kbd>
thread 219134 panic: index out of bounds: index 5, len 5
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_index_out_of_bounds.zig:7:13</span>: <span class="sgr-2m">0x10df001 in foo (runtime_index_out_of_bounds)</span>
    return x[5];
            <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_index_out_of_bounds.zig:2:18</span>: <span class="sgr-2m">0x10de766 in main (runtime_index_out_of_bounds)</span>
    const x = foo(&quot;hello&quot;);
                 <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de262 in posixCallMainAndExit (runtime_index_out_of_bounds)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10dde3d in _start (runtime_index_out_of_bounds)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Cast-Negative-Number-to-Unsigned-Integer"><a href="#toc-Cast-Negative-Number-to-Unsigned-Integer">Cast Negative Number to Unsigned Integer</a> <a class="hdr" href="#Cast-Negative-Number-to-Unsigned-Integer">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_cast.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> value: <span class="tok-type">i32</span> = -<span class="tok-number">1</span>;
    <span class="tok-kw">const</span> unsigned: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(value);
    _ = unsigned;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_cast.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_invalid_cast.zig:3:36: </span><span class="sgr-31m">error: </span><span class="sgr-1m">type 'u32' cannot represent integer value '-1'
</span>    const unsigned: u32 = @intCast(value);
                                   <span class="sgr-32m">^~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> value: <span class="tok-type">i32</span> = -<span class="tok-number">1</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;value;
    <span class="tok-kw">const</span> unsigned: <span class="tok-type">u32</span> = <span class="tok-builtin">@intCast</span>(value);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{unsigned});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_cast.zig</kbd>
$ <kbd>./runtime_invalid_cast</kbd>
thread 212398 panic: attempt to cast negative value to unsigned integer
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_invalid_cast.zig:6:27</span>: <span class="sgr-2m">0x10de866 in main (runtime_invalid_cast)</span>
    const unsigned: u32 = @intCast(value);
                          <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de352 in posixCallMainAndExit (runtime_invalid_cast)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10ddf2d in _start (runtime_invalid_cast)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>
      To obtain the maximum value of an unsigned integer, use <code>std.math.maxInt</code>.
      </p>
      
      <h3 id="Cast-Truncates-Data"><a href="#toc-Cast-Truncates-Data">Cast Truncates Data</a> <a class="hdr" href="#Cast-Truncates-Data">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_cast_truncate.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> spartan_count: <span class="tok-type">u16</span> = <span class="tok-number">300</span>;
    <span class="tok-kw">const</span> byte: <span class="tok-type">u8</span> = <span class="tok-builtin">@intCast</span>(spartan_count);
    _ = byte;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_cast_truncate.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_invalid_cast_truncate.zig:3:31: </span><span class="sgr-31m">error: </span><span class="sgr-1m">type 'u8' cannot represent integer value '300'
</span>    const byte: u8 = @intCast(spartan_count);
                              <span class="sgr-32m">^~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_cast_truncate.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> spartan_count: <span class="tok-type">u16</span> = <span class="tok-number">300</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;spartan_count;
    <span class="tok-kw">const</span> byte: <span class="tok-type">u8</span> = <span class="tok-builtin">@intCast</span>(spartan_count);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{byte});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_cast_truncate.zig</kbd>
$ <kbd>./runtime_invalid_cast_truncate</kbd>
thread 212601 panic: integer cast truncated bits
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_invalid_cast_truncate.zig:6:22</span>: <span class="sgr-2m">0x10de8f8 in main (runtime_invalid_cast_truncate)</span>
    const byte: u8 = @intCast(spartan_count);
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de3e2 in posixCallMainAndExit (runtime_invalid_cast_truncate)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10ddfbd in _start (runtime_invalid_cast_truncate)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>
      To truncate bits, use <a href="#truncate">@truncate</a>.
      </p>
      
      <h3 id="Integer-Overflow"><a href="#toc-Integer-Overflow">Integer Overflow</a> <a class="hdr" href="#Integer-Overflow">§</a></h3>

      <h4 id="Default-Operations"><a href="#toc-Default-Operations">Default Operations</a> <a class="hdr" href="#Default-Operations">§</a></h4>

      <p>The following operators can cause integer overflow:</p>
      <ul>
          <li><code>+</code> (addition)</li>
          <li><code>-</code> (subtraction)</li>
          <li><code>-</code> (negation)</li>
          <li><code>*</code> (multiplication)</li>
          <li><code>/</code> (division)</li>
        <li><a href="#divTrunc">@divTrunc</a> (division)</li>
        <li><a href="#divFloor">@divFloor</a> (division)</li>
        <li><a href="#divExact">@divExact</a> (division)</li>
      </ul>
      <p>Example with addition at compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
    byte += <span class="tok-number">1</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_overflow.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_overflow.zig:3:10: </span><span class="sgr-31m">error: </span><span class="sgr-1m">overflow of integer type 'u8' with value '256'
</span>    byte += 1;
    <span class="sgr-32m">~~~~~^~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
    byte += <span class="tok-number">1</span>;
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{byte});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_overflow.zig</kbd>
$ <kbd>./runtime_overflow</kbd>
thread 217657 panic: integer overflow
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_overflow.zig:5:10</span>: <span class="sgr-2m">0x10de8f9 in main (runtime_overflow)</span>
    byte += 1;
         <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de3e2 in posixCallMainAndExit (runtime_overflow)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10ddfbd in _start (runtime_overflow)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h4 id="Standard-Library-Math-Functions"><a href="#toc-Standard-Library-Math-Functions">Standard Library Math Functions</a> <a class="hdr" href="#Standard-Library-Math-Functions">§</a></h4>

      <p>These functions provided by the standard library return possible errors.</p>
      <ul>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.add</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.sub</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.mul</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divTrunc</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divFloor</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divExact</code></li>
          <li><code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.shl</code></li>
      </ul>
      <p>Example of catching an overflow for addition:</p>
      <figure><figcaption class="zig-cap"><cite class="file">math_add.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> math = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math;
<span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;

    byte = <span class="tok-kw">if</span> (math.add(<span class="tok-type">u8</span>, byte, <span class="tok-number">1</span>)) |result| result <span class="tok-kw">else</span> |err| {
        print(<span class="tok-str">&quot;unable to add one: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)});
        <span class="tok-kw">return</span> err;
    };

    print(<span class="tok-str">&quot;result: {}\n&quot;</span>, .{byte});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe math_add.zig</kbd>
$ <kbd>./math_add</kbd>
unable to add one: Overflow
error: Overflow
<span class="sgr-1m">/home/andy/src/zig/lib/std/math.zig:565:21</span>: <span class="sgr-2m">0x10dea25 in add__anon_24023 (math_add)</span>
    if (ov[1] != 0) return error.Overflow;
                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/math_add.zig:8:9</span>: <span class="sgr-2m">0x10de9bb in main (math_add)</span>
        return err;
        <span class="sgr-32m">^</span>
</samp></pre></figure>

      
      <h4 id="Builtin-Overflow-Functions"><a href="#toc-Builtin-Overflow-Functions">Builtin Overflow Functions</a> <a class="hdr" href="#Builtin-Overflow-Functions">§</a></h4>

      <p>
      These builtins return a tuple containing whether there was an overflow
      (as a <code><span class="tok-type">u1</span></code>) and the possibly overflowed bits of the operation:
      </p>
      <ul>
          <li><a href="#addWithOverflow">@addWithOverflow</a></li>
          <li><a href="#subWithOverflow">@subWithOverflow</a></li>
          <li><a href="#mulWithOverflow">@mulWithOverflow</a></li>
          <li><a href="#shlWithOverflow">@shlWithOverflow</a></li>
      </ul>
      <p>
      Example of <a href="#addWithOverflow">@addWithOverflow</a>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">addWithOverflow_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;

    <span class="tok-kw">const</span> ov = <span class="tok-builtin">@addWithOverflow</span>(byte, <span class="tok-number">10</span>);
    <span class="tok-kw">if</span> (ov[<span class="tok-number">1</span>] != <span class="tok-number">0</span>) {
        print(<span class="tok-str">&quot;overflowed result: {}\n&quot;</span>, .{ov[<span class="tok-number">0</span>]});
    } <span class="tok-kw">else</span> {
        print(<span class="tok-str">&quot;result: {}\n&quot;</span>, .{ov[<span class="tok-number">0</span>]});
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe addWithOverflow_builtin.zig</kbd>
$ <kbd>./addWithOverflow_builtin</kbd>
overflowed result: 9
</samp></pre></figure>

      
      <h4 id="Wrapping-Operations"><a href="#toc-Wrapping-Operations">Wrapping Operations</a> <a class="hdr" href="#Wrapping-Operations">§</a></h4>

      <p>
      These operations have guaranteed wraparound semantics.
      </p>
      <ul>
          <li><code>+%</code> (wraparound addition)</li>
          <li><code>-%</code> (wraparound subtraction)</li>
          <li><code>-%</code> (wraparound negation)</li>
          <li><code>*%</code> (wraparound multiplication)</li>
      </ul>
      <figure><figcaption class="zig-cap"><cite class="file">test_wraparound_semantics.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> minInt = std.math.minInt;
<span class="tok-kw">const</span> maxInt = std.math.maxInt;

<span class="tok-kw">test</span> <span class="tok-str">&quot;wraparound addition and subtraction&quot;</span> {
    <span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = maxInt(<span class="tok-type">i32</span>);
    <span class="tok-kw">const</span> min_val = x +% <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(min_val == minInt(<span class="tok-type">i32</span>));
    <span class="tok-kw">const</span> max_val = min_val -% <span class="tok-number">1</span>;
    <span class="tok-kw">try</span> expect(max_val == maxInt(<span class="tok-type">i32</span>));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_wraparound_semantics.zig</kbd>
1/1 test_wraparound_semantics.test.wraparound addition and subtraction...OK
All 1 tests passed.
</samp></pre></figure>

      
      
      <h3 id="Exact-Left-Shift-Overflow"><a href="#toc-Exact-Left-Shift-Overflow">Exact Left Shift Overflow</a> <a class="hdr" href="#Exact-Left-Shift-Overflow">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_shlExact_overwlow.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> x = <span class="tok-builtin">@shlExact</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0b01010101</span>), <span class="tok-number">2</span>);
    _ = x;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_shlExact_overwlow.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_shlExact_overwlow.zig:2:15: </span><span class="sgr-31m">error: </span><span class="sgr-1m">operation caused overflow
</span>    const x = @shlExact(@as(u8, 0b01010101), 2);
              <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_shlExact_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">0b01010101</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;x;
    <span class="tok-kw">const</span> y = <span class="tok-builtin">@shlExact</span>(x, <span class="tok-number">2</span>);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{y});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_shlExact_overflow.zig</kbd>
$ <kbd>./runtime_shlExact_overflow</kbd>
thread 222268 panic: left shift overflowed bits
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_shlExact_overflow.zig:6:5</span>: <span class="sgr-2m">0x10de981 in main (runtime_shlExact_overflow)</span>
    const y = @shlExact(x, 2);
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de442 in posixCallMainAndExit (runtime_shlExact_overflow)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10de01d in _start (runtime_shlExact_overflow)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Exact-Right-Shift-Overflow"><a href="#toc-Exact-Right-Shift-Overflow">Exact Right Shift Overflow</a> <a class="hdr" href="#Exact-Right-Shift-Overflow">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_shrExact_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> x = <span class="tok-builtin">@shrExact</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0b10101010</span>), <span class="tok-number">2</span>);
    _ = x;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_shrExact_overflow.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_shrExact_overflow.zig:2:15: </span><span class="sgr-31m">error: </span><span class="sgr-1m">exact shift shifted out 1 bits
</span>    const x = @shrExact(@as(u8, 0b10101010), 2);
              <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_shrExact_overflow.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">0b10101010</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;x;
    <span class="tok-kw">const</span> y = <span class="tok-builtin">@shrExact</span>(x, <span class="tok-number">2</span>);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{y});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_shrExact_overflow.zig</kbd>
$ <kbd>./runtime_shrExact_overflow</kbd>
thread 215275 panic: right shift overflowed bits
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_shrExact_overflow.zig:6:5</span>: <span class="sgr-2m">0x10de97d in main (runtime_shrExact_overflow)</span>
    const y = @shrExact(x, 2);
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de442 in posixCallMainAndExit (runtime_shrExact_overflow)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10de01d in _start (runtime_shrExact_overflow)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Division-by-Zero"><a href="#toc-Division-by-Zero">Division by Zero</a> <a class="hdr" href="#Division-by-Zero">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> c = a / b;
    _ = c;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_division_by_zero.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_division_by_zero.zig:4:19: </span><span class="sgr-31m">error: </span><span class="sgr-1m">division by zero here causes undefined behavior
</span>    const c = a / b;
                  <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    _ = .{ &amp;a, &amp;b };
    <span class="tok-kw">const</span> c = a / b;
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{c});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_division_by_zero.zig</kbd>
$ <kbd>./runtime_division_by_zero</kbd>
thread 213940 panic: division by zero
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_division_by_zero.zig:7:17</span>: <span class="sgr-2m">0x10de89a in main (runtime_division_by_zero)</span>
    const c = a / b;
                <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de352 in posixCallMainAndExit (runtime_division_by_zero)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10ddf2d in _start (runtime_division_by_zero)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Remainder-Division-by-Zero"><a href="#toc-Remainder-Division-by-Zero">Remainder Division by Zero</a> <a class="hdr" href="#Remainder-Division-by-Zero">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_remainder_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">i32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> c = a % b;
    _ = c;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_remainder_division_by_zero.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_remainder_division_by_zero.zig:4:19: </span><span class="sgr-31m">error: </span><span class="sgr-1m">division by zero here causes undefined behavior
</span>    const c = a % b;
                  <span class="sgr-32m">^
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_remainder_division_by_zero.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    _ = .{ &amp;a, &amp;b };
    <span class="tok-kw">const</span> c = a % b;
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{c});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_remainder_division_by_zero.zig</kbd>
$ <kbd>./runtime_remainder_division_by_zero</kbd>
thread 209979 panic: division by zero
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_remainder_division_by_zero.zig:7:17</span>: <span class="sgr-2m">0x10de89a in main (runtime_remainder_division_by_zero)</span>
    const c = a % b;
                <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de352 in posixCallMainAndExit (runtime_remainder_division_by_zero)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10ddf2d in _start (runtime_remainder_division_by_zero)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Exact-Division-Remainder"><a href="#toc-Exact-Division-Remainder">Exact Division Remainder</a> <a class="hdr" href="#Exact-Division-Remainder">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_divExact_remainder.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">const</span> c = <span class="tok-builtin">@divExact</span>(a, b);
    _ = c;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_divExact_remainder.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_divExact_remainder.zig:4:15: </span><span class="sgr-31m">error: </span><span class="sgr-1m">exact division produced remainder
</span>    const c = @divExact(a, b);
              <span class="sgr-32m">^~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_divExact_remainder.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    _ = .{ &amp;a, &amp;b };
    <span class="tok-kw">const</span> c = <span class="tok-builtin">@divExact</span>(a, b);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{c});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_divExact_remainder.zig</kbd>
$ <kbd>./runtime_divExact_remainder</kbd>
thread 212495 panic: exact division produced remainder
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_divExact_remainder.zig:7:15</span>: <span class="sgr-2m">0x10de8bb in main (runtime_divExact_remainder)</span>
    const c = @divExact(a, b);
              <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de352 in posixCallMainAndExit (runtime_divExact_remainder)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10ddf2d in _start (runtime_divExact_remainder)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Attempt-to-Unwrap-Null"><a href="#toc-Attempt-to-Unwrap-Null">Attempt to Unwrap Null</a> <a class="hdr" href="#Attempt-to-Unwrap-Null">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_unwrap_null.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> number = optional_number.?;
    _ = number;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_unwrap_null.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_unwrap_null.zig:3:35: </span><span class="sgr-31m">error: </span><span class="sgr-1m">unable to unwrap null
</span>    const number = optional_number.?;
                   <span class="sgr-32m">~~~~~~~~~~~~~~~^~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_unwrap_null.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    _ = &amp;optional_number;
    <span class="tok-kw">const</span> number = optional_number.?;
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{number});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_unwrap_null.zig</kbd>
$ <kbd>./runtime_unwrap_null</kbd>
thread 212451 panic: attempt to use null value
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_unwrap_null.zig:6:35</span>: <span class="sgr-2m">0x10de886 in main (runtime_unwrap_null)</span>
    const number = optional_number.?;
                                  <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de352 in posixCallMainAndExit (runtime_unwrap_null)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10ddf2d in _start (runtime_unwrap_null)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>One way to avoid this crash is to test for null instead of assuming non-null, with
      the <code><span class="tok-kw">if</span></code> expression:</p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_null_with_if.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">if</span> (optional_number) |number| {
        print(<span class="tok-str">&quot;got number: {}\n&quot;</span>, .{number});
    } <span class="tok-kw">else</span> {
        print(<span class="tok-str">&quot;it's null\n&quot;</span>, .{});
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe testing_null_with_if.zig</kbd>
$ <kbd>./testing_null_with_if</kbd>
it's null
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#Optionals">Optionals</a></li>
</ul>

      
      <h3 id="Attempt-to-Unwrap-Error"><a href="#toc-Attempt-to-Unwrap-Error">Attempt to Unwrap Error</a> <a class="hdr" href="#Attempt-to-Unwrap-Error">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_unwrap_error.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> number = getNumberOrFail() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    _ = number;
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_unwrap_error.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_unwrap_error.zig:2:44: </span><span class="sgr-31m">error: </span><span class="sgr-1m">caught unexpected error 'UnableToReturnNumber'
</span>    const number = getNumberOrFail() catch unreachable;
                                           <span class="sgr-32m">^~~~~~~~~~~
</span><span class="sgr-1m">doc/langref/test_comptime_unwrap_error.zig:7:18: </span><span class="sgr-36m">note: </span><span class="sgr-1m">error returned here
</span>    return error.UnableToReturnNumber;
                 <span class="sgr-32m">^~~~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_unwrap_error.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = getNumberOrFail() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{number});
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_unwrap_error.zig</kbd>
$ <kbd>./runtime_unwrap_error</kbd>
thread 214943 panic: attempt to unwrap error: UnableToReturnNumber
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_unwrap_error.zig:9:5</span>: <span class="sgr-2m">0x10df16f in getNumberOrFail (runtime_unwrap_error)</span>
    return error.UnableToReturnNumber;
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_unwrap_error.zig:4:44</span>: <span class="sgr-2m">0x10de901 in main (runtime_unwrap_error)</span>
    const number = getNumberOrFail() catch unreachable;
                                           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de3c2 in posixCallMainAndExit (runtime_unwrap_error)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10ddf9d in _start (runtime_unwrap_error)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>One way to avoid this crash is to test for an error instead of assuming a successful result, with
      the <code><span class="tok-kw">if</span></code> expression:</p>
      <figure><figcaption class="zig-cap"><cite class="file">testing_error_with_if.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = getNumberOrFail();

    <span class="tok-kw">if</span> (result) |number| {
        print(<span class="tok-str">&quot;got number: {}\n&quot;</span>, .{number});
    } <span class="tok-kw">else</span> |err| {
        print(<span class="tok-str">&quot;got error: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)});
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe testing_error_with_if.zig</kbd>
$ <kbd>./testing_error_with_if</kbd>
got error: UnableToReturnNumber
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#Errors">Errors</a></li>
</ul>

      
      <h3 id="Invalid-Error-Code"><a href="#toc-Invalid-Error-Code">Invalid Error Code</a> <a class="hdr" href="#Invalid-Error-Code">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_error_code.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> err = <span class="tok-kw">error</span>.AnError;
    <span class="tok-kw">const</span> number = <span class="tok-builtin">@intFromError</span>(err) + <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> invalid_err = <span class="tok-builtin">@errorFromInt</span>(number);
    _ = invalid_err;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_error_code.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_invalid_error_code.zig:4:39: </span><span class="sgr-31m">error: </span><span class="sgr-1m">integer value '11' represents no error
</span>    const invalid_err = @errorFromInt(number);
                                      <span class="sgr-32m">^~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_error_code.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> err = <span class="tok-kw">error</span>.AnError;
    <span class="tok-kw">var</span> number = <span class="tok-builtin">@intFromError</span>(err) + <span class="tok-number">500</span>;
    _ = &amp;number;
    <span class="tok-kw">const</span> invalid_err = <span class="tok-builtin">@errorFromInt</span>(number);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{invalid_err});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_error_code.zig</kbd>
$ <kbd>./runtime_invalid_error_code</kbd>
thread 222506 panic: invalid error code
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_invalid_error_code.zig:7:5</span>: <span class="sgr-2m">0x10de916 in main (runtime_invalid_error_code)</span>
    const invalid_err = @errorFromInt(number);
    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de3b2 in posixCallMainAndExit (runtime_invalid_error_code)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10ddf8d in _start (runtime_invalid_error_code)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Invalid-Enum-Cast"><a href="#toc-Invalid-Enum-Cast">Invalid Enum Cast</a> <a class="hdr" href="#Invalid-Enum-Cast">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_enum_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    a,
    b,
    c,
};
<span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u2</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">const</span> b: Foo = <span class="tok-builtin">@enumFromInt</span>(a);
    _ = b;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_enum_cast.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_invalid_enum_cast.zig:8:20: </span><span class="sgr-31m">error: </span><span class="sgr-1m">enum 'test_comptime_invalid_enum_cast.Foo' has no tag with value '3'
</span>    const b: Foo = @enumFromInt(a);
                   <span class="sgr-32m">^~~~~~~~~~~~~~~
</span><span class="sgr-1m">doc/langref/test_comptime_invalid_enum_cast.zig:1:13: </span><span class="sgr-36m">note: </span><span class="sgr-1m">enum declared here
</span>const Foo = enum {
            <span class="sgr-32m">^~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_enum_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    a,
    b,
    c,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u2</span> = <span class="tok-number">3</span>;
    _ = &amp;a;
    <span class="tok-kw">const</span> b: Foo = <span class="tok-builtin">@enumFromInt</span>(a);
    std.debug.print(<span class="tok-str">&quot;value: {s}\n&quot;</span>, .{<span class="tok-builtin">@tagName</span>(b)});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_enum_cast.zig</kbd>
$ <kbd>./runtime_invalid_enum_cast</kbd>
thread 220434 panic: invalid enum value
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_invalid_enum_cast.zig:12:20</span>: <span class="sgr-2m">0x10de8da in main (runtime_invalid_enum_cast)</span>
    const b: Foo = @enumFromInt(a);
                   <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de3c2 in posixCallMainAndExit (runtime_invalid_enum_cast)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10ddf9d in _start (runtime_invalid_enum_cast)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      

      <h3 id="Invalid-Error-Set-Cast"><a href="#toc-Invalid-Error-Set-Cast">Invalid Error Set Cast</a> <a class="hdr" href="#Invalid-Error-Set-Cast">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_error_set_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> Set1 = <span class="tok-kw">error</span>{
    A,
    B,
};
<span class="tok-kw">const</span> Set2 = <span class="tok-kw">error</span>{
    A,
    C,
};
<span class="tok-kw">comptime</span> {
    _ = <span class="tok-builtin">@as</span>(Set2, <span class="tok-builtin">@errorCast</span>(Set1.B));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_error_set_cast.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_invalid_error_set_cast.zig:10:19: </span><span class="sgr-31m">error: </span><span class="sgr-1m">'error.B' not a member of error set 'error{A,C}'
</span>    _ = @as(Set2, @errorCast(Set1.B));
                  <span class="sgr-32m">^~~~~~~~~~~~~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_error_set_cast.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Set1 = <span class="tok-kw">error</span>{
    A,
    B,
};
<span class="tok-kw">const</span> Set2 = <span class="tok-kw">error</span>{
    A,
    C,
};
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    foo(Set1.B);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(set1: Set1) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x: Set2 = <span class="tok-builtin">@errorCast</span>(set1);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{x});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_error_set_cast.zig</kbd>
$ <kbd>./runtime_invalid_error_set_cast</kbd>
thread 217676 panic: invalid error code
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_invalid_error_set_cast.zig:15:21</span>: <span class="sgr-2m">0x10df1cd in foo (runtime_invalid_error_set_cast)</span>
    const x: Set2 = @errorCast(set1);
                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_invalid_error_set_cast.zig:12:8</span>: <span class="sgr-2m">0x10de8fc in main (runtime_invalid_error_set_cast)</span>
    foo(Set1.B);
       <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de3f2 in posixCallMainAndExit (runtime_invalid_error_set_cast)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10ddfcd in _start (runtime_invalid_error_set_cast)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      

      <h3 id="Incorrect-Pointer-Alignment"><a href="#toc-Incorrect-Pointer-Alignment">Incorrect Pointer Alignment</a> <a class="hdr" href="#Incorrect-Pointer-Alignment">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_incorrect_pointer_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> ptr: *<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">i32</span> = <span class="tok-builtin">@ptrFromInt</span>(<span class="tok-number">0x1</span>);
    <span class="tok-kw">const</span> aligned: *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">i32</span> = <span class="tok-builtin">@alignCast</span>(ptr);
    _ = aligned;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_incorrect_pointer_alignment.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_incorrect_pointer_alignment.zig:3:47: </span><span class="sgr-31m">error: </span><span class="sgr-1m">pointer address 0x1 is not aligned to 4 bytes
</span>    const aligned: *align(4) i32 = @alignCast(ptr);
                                              <span class="sgr-32m">^~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_incorrect_pointer_alignment.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> array <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = [_]<span class="tok-type">u32</span>{ <span class="tok-number">0x11111111</span>, <span class="tok-number">0x11111111</span> };
    <span class="tok-kw">const</span> bytes = mem.sliceAsBytes(array[<span class="tok-number">0</span>..]);
    <span class="tok-kw">if</span> (foo(bytes) != <span class="tok-number">0x11111111</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Wrong;
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(bytes: []<span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> slice4 = bytes[<span class="tok-number">1</span>..<span class="tok-number">5</span>];
    <span class="tok-kw">const</span> int_slice = mem.bytesAsSlice(<span class="tok-type">u32</span>, <span class="tok-builtin">@as</span>([]<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>, <span class="tok-builtin">@alignCast</span>(slice4)));
    <span class="tok-kw">return</span> int_slice[<span class="tok-number">0</span>];
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_incorrect_pointer_alignment.zig</kbd>
$ <kbd>./runtime_incorrect_pointer_alignment</kbd>
thread 222554 panic: incorrect alignment
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_incorrect_pointer_alignment.zig:9:64</span>: <span class="sgr-2m">0x10de7c2 in foo (runtime_incorrect_pointer_alignment)</span>
    const int_slice = mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));
                                                               <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_incorrect_pointer_alignment.zig:5:12</span>: <span class="sgr-2m">0x10de6bf in main (runtime_incorrect_pointer_alignment)</span>
    if (foo(bytes) != 0x11111111) return error.Wrong;
           <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:656:37</span>: <span class="sgr-2m">0x10de5aa in posixCallMainAndExit (runtime_incorrect_pointer_alignment)</span>
            const result = root.main() catch |err| {
                                    <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10de15d in _start (runtime_incorrect_pointer_alignment)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      
      <h3 id="Wrong-Union-Field-Access"><a href="#toc-Wrong-Union-Field-Access">Wrong Union Field Access</a> <a class="hdr" href="#Wrong-Union-Field-Access">§</a></h3>

      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_wrong_union_field_access.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    f.float = <span class="tok-number">12.34</span>;
}

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_wrong_union_field_access.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_wrong_union_field_access.zig:3:6: </span><span class="sgr-31m">error: </span><span class="sgr-1m">access of union field 'float' while field 'int' is active
</span>    f.float = 12.34;
    <span class="sgr-32m">~^~~~~~
</span><span class="sgr-1m">doc/langref/test_comptime_wrong_union_field_access.zig:6:13: </span><span class="sgr-36m">note: </span><span class="sgr-1m">union declared here
</span>const Foo = union {
            <span class="sgr-32m">^~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_wrong_union_field_access.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    bar(&amp;f);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(f: *Foo) <span class="tok-type">void</span> {
    f.float = <span class="tok-number">12.34</span>;
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{f.float});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_wrong_union_field_access.zig</kbd>
$ <kbd>./runtime_wrong_union_field_access</kbd>
thread 215740 panic: access of union field 'float' while field 'int' is active
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_wrong_union_field_access.zig:14:6</span>: <span class="sgr-2m">0x10e49e8 in bar (runtime_wrong_union_field_access)</span>
    f.float = 12.34;
     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_wrong_union_field_access.zig:10:8</span>: <span class="sgr-2m">0x10e413c in main (runtime_wrong_union_field_access)</span>
    bar(&amp;f);
       <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10e3c32 in posixCallMainAndExit (runtime_wrong_union_field_access)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10e380d in _start (runtime_wrong_union_field_access)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      <p>
      This safety is not available for <code><span class="tok-kw">extern</span></code> or <code><span class="tok-kw">packed</span></code> unions.
      </p>
      <p>
      To change the active field of a union, assign the entire union, like this:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">change_active_union_field.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    bar(&amp;f);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(f: *Foo) <span class="tok-type">void</span> {
    f.* = Foo{ .float = <span class="tok-number">12.34</span> };
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{f.float});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe change_active_union_field.zig</kbd>
$ <kbd>./change_active_union_field</kbd>
value: 1.234e1
</samp></pre></figure>

      <p>
      To change the active field of a union when a meaningful value for the field is not known,
      use <a href="#undefined">undefined</a>, like this:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">undefined_active_union_field.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    f = Foo{ .float = <span class="tok-null">undefined</span> };
    bar(&amp;f);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{f.float});
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(f: *Foo) <span class="tok-type">void</span> {
    f.float = <span class="tok-number">12.34</span>;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe undefined_active_union_field.zig</kbd>
$ <kbd>./undefined_active_union_field</kbd>
value: 1.234e1
</samp></pre></figure>

      <p>See also:</p><ul>
<li><a href="#union">union</a></li>
<li><a href="#extern-union">extern union</a></li>
</ul>

      

      <h3 id="Out-of-Bounds-Float-to-Integer-Cast"><a href="#toc-Out-of-Bounds-Float-to-Integer-Cast">Out of Bounds Float to Integer Cast</a> <a class="hdr" href="#Out-of-Bounds-Float-to-Integer-Cast">§</a></h3>

      <p>
      This happens when casting a float to an integer where the float has a value outside the
      integer type's range.
      </p>
      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_out_of_bounds_float_to_integer_cast.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> float: <span class="tok-type">f32</span> = <span class="tok-number">4294967296</span>;
    <span class="tok-kw">const</span> int: <span class="tok-type">i32</span> = <span class="tok-builtin">@intFromFloat</span>(float);
    _ = int;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_out_of_bounds_float_to_integer_cast.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_out_of_bounds_float_to_integer_cast.zig:3:36: </span><span class="sgr-31m">error: </span><span class="sgr-1m">float value '4294967296' cannot be stored in integer type 'i32'
</span>    const int: i32 = @intFromFloat(float);
                                   <span class="sgr-32m">^~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_out_of_bounds_float_to_integer_cast.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> float: <span class="tok-type">f32</span> = <span class="tok-number">4294967296</span>; <span class="tok-comment">// runtime-known</span>
    _ = &amp;float;
    <span class="tok-kw">const</span> int: <span class="tok-type">i32</span> = <span class="tok-builtin">@intFromFloat</span>(float);
    _ = int;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_out_of_bounds_float_to_integer_cast.zig</kbd>
$ <kbd>./runtime_out_of_bounds_float_to_integer_cast</kbd>
thread 215812 panic: integer part of floating point value out of bounds
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_out_of_bounds_float_to_integer_cast.zig:4:22</span>: <span class="sgr-2m">0x10de7a9 in main (runtime_out_of_bounds_float_to_integer_cast)</span>
    const int: i32 = @intFromFloat(float);
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de252 in posixCallMainAndExit (runtime_out_of_bounds_float_to_integer_cast)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10dde2d in _start (runtime_out_of_bounds_float_to_integer_cast)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      

      <h3 id="Pointer-Cast-Invalid-Null"><a href="#toc-Pointer-Cast-Invalid-Null">Pointer Cast Invalid Null</a> <a class="hdr" href="#Pointer-Cast-Invalid-Null">§</a></h3>

      <p>
      This happens when casting a pointer with the address 0 to a pointer which may not have the address 0.
      For example, <a href="#C-Pointers">C Pointers</a>, <a href="#Optional-Pointers">Optional Pointers</a>, and <a href="#allowzero">allowzero</a> pointers
      allow address zero, but normal <a href="#Pointers">Pointers</a> do not.
      </p>
      <p>At compile-time:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_comptime_invalid_null_pointer_cast.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> opt_ptr: ?*<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> ptr: *<span class="tok-type">i32</span> = <span class="tok-builtin">@ptrCast</span>(opt_ptr);
    _ = ptr;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_comptime_invalid_null_pointer_cast.zig</kbd>
<span class="sgr-1m">doc/langref/test_comptime_invalid_null_pointer_cast.zig:3:32: </span><span class="sgr-31m">error: </span><span class="sgr-1m">null pointer casted to type '*i32'
</span>    const ptr: *i32 = @ptrCast(opt_ptr);
                               <span class="sgr-32m">^~~~~~~
</span>
</samp></pre></figure>

      <p>At runtime:</p>
      <figure><figcaption class="zig-cap"><cite class="file">runtime_invalid_null_pointer_cast.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> opt_ptr: ?*<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    _ = &amp;opt_ptr;
    <span class="tok-kw">const</span> ptr: *<span class="tok-type">i32</span> = <span class="tok-builtin">@ptrCast</span>(opt_ptr);
    _ = ptr;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe runtime_invalid_null_pointer_cast.zig</kbd>
$ <kbd>./runtime_invalid_null_pointer_cast</kbd>
thread 214922 panic: cast causes pointer to be null
<span class="sgr-1m">/home/andy/src/zig/doc/langref/runtime_invalid_null_pointer_cast.zig:4:23</span>: <span class="sgr-2m">0x10de75c in main (runtime_invalid_null_pointer_cast)</span>
    const ptr: *i32 = @ptrCast(opt_ptr);
                      <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:647:22</span>: <span class="sgr-2m">0x10de232 in posixCallMainAndExit (runtime_invalid_null_pointer_cast)</span>
            root.main();
                     <span class="sgr-32m">^</span>
<span class="sgr-1m">/home/andy/src/zig/lib/std/start.zig:271:5</span>: <span class="sgr-2m">0x10dde0d in _start (runtime_invalid_null_pointer_cast)</span>
    asm volatile (switch (native_arch) {
    <span class="sgr-32m">^</span>
<span class="sgr-1m">???:?:?</span>: <span class="sgr-2m">0x0 in ??? (???)</span>
(process terminated by signal)
</samp></pre></figure>

      

      
      <h2 id="Memory"><a href="#toc-Memory">Memory</a> <a class="hdr" href="#Memory">§</a></h2>

      <p>
      The Zig language performs no memory management on behalf of the programmer. This is
      why Zig has no runtime, and why Zig code works seamlessly in so many environments,
      including real-time software, operating system kernels, embedded devices, and
      low latency servers. As a consequence, Zig programmers must always be able to answer
      the question:
      </p>
      <p><a href="#Where-are-the-bytes">Where are the bytes?</a></p>
      <p>
      Like Zig, the C programming language has manual memory management. However, unlike Zig,
      C has a default allocator - <code>malloc</code>, <code>realloc</code>, and <code>free</code>.
      When linking against libc, Zig exposes this allocator with <code>std.heap.c_allocator</code>.
      However, by convention, there is no default allocator in Zig. Instead, functions which need to
      allocate accept an <code>Allocator</code> parameter. Likewise, data structures such as
      <code>std.ArrayList</code> accept an <code>Allocator</code> parameter in
      their initialization functions:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_allocator.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> Allocator = std.mem.Allocator;
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;using an allocator&quot;</span> {
    <span class="tok-kw">var</span> buffer: [<span class="tok-number">100</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> fba = std.heap.FixedBufferAllocator.init(&amp;buffer);
    <span class="tok-kw">const</span> allocator = fba.allocator();
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> concat(allocator, <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-str">&quot;bar&quot;</span>);
    <span class="tok-kw">try</span> expect(std.mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foobar&quot;</span>, result));
}

<span class="tok-kw">fn</span> <span class="tok-fn">concat</span>(allocator: Allocator, a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, a.len + b.len);
    <span class="tok-builtin">@memcpy</span>(result[<span class="tok-number">0</span>..a.len], a);
    <span class="tok-builtin">@memcpy</span>(result[a.len..], b);
    <span class="tok-kw">return</span> result;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_allocator.zig</kbd>
1/1 test_allocator.test.using an allocator...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      In the above example, 100 bytes of stack memory are used to initialize a
      <code>FixedBufferAllocator</code>, which is then passed to a function.
      As a convenience there is a global <code>FixedBufferAllocator</code>
      available for quick tests at <code>std.testing.allocator</code>,
      which will also perform basic leak detection.
      </p>
      <p>
      Zig has a general purpose allocator available to be imported
      with <code>std.heap.GeneralPurposeAllocator</code>. However, it is still recommended to
      follow the <a href="#Choosing-an-Allocator">Choosing an Allocator</a> guide.
      </p>

      <h3 id="Choosing-an-Allocator"><a href="#toc-Choosing-an-Allocator">Choosing an Allocator</a> <a class="hdr" href="#Choosing-an-Allocator">§</a></h3>

      <p>What allocator to use depends on a number of factors. Here is a flow chart to help you decide:
      </p>
      <ol>
          <li>
              Are you making a library? In this case, best to accept an <code>Allocator</code>
              as a parameter and allow your library's users to decide what allocator to use.
          </li>
          <li>Are you linking libc? In this case, <code>std.heap.c_allocator</code> is likely
              the right choice, at least for your main allocator.</li>
          <li>
              Need to use the same allocator in multiple threads? Use one of your choice
              wrapped around <code>std.heap.ThreadSafeAllocator</code>
          </li>
          <li>
              Is the maximum number of bytes that you will need bounded by a number known at
              <a href="#comptime">comptime</a>? In this case, use <code>std.heap.FixedBufferAllocator</code>.
          </li>
          <li>
              Is your program a command line application which runs from start to end without any fundamental
              cyclical pattern (such as a video game main loop, or a web server request handler),
              such that it would make sense to free everything at once at the end?
              In this case, it is recommended to follow this pattern:
      <figure><figcaption class="zig-cap"><cite class="file">cli_allocation.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    <span class="tok-kw">defer</span> arena.deinit();

    <span class="tok-kw">const</span> allocator = arena.allocator();

    <span class="tok-kw">const</span> ptr = <span class="tok-kw">try</span> allocator.create(<span class="tok-type">i32</span>);
    std.debug.print(<span class="tok-str">&quot;ptr={*}\n&quot;</span>, .{ptr});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe cli_allocation.zig</kbd>
$ <kbd>./cli_allocation</kbd>
ptr=i32@7f23d195f010
</samp></pre></figure>

              When using this kind of allocator, there is no need to free anything manually. Everything
              gets freed at once with the call to <code>arena.deinit()</code>.
          </li>
          <li>
              Are the allocations part of a cyclical pattern such as a video game main loop, or a web
              server request handler? If the allocations can all be freed at once, at the end of the cycle,
              for example once the video game frame has been fully rendered, or the web server request has
              been served, then <code>std.heap.ArenaAllocator</code> is a great candidate. As
              demonstrated in the previous bullet point, this allows you to free entire arenas at once.
              Note also that if an upper bound of memory can be established, then
              <code>std.heap.FixedBufferAllocator</code> can be used as a further optimization.
          </li>
          <li>
              Are you writing a test, and you want to make sure <code><span class="tok-kw">error</span>.OutOfMemory</code>
              is handled correctly? In this case, use <code>std.testing.FailingAllocator</code>.
          </li>
          <li>
              Are you writing a test? In this case, use <code>std.testing.allocator</code>.
          </li>
          <li>
              Finally, if none of the above apply, you need a general purpose allocator.
              Zig's general purpose allocator is available as a function that takes a <a href="#comptime">comptime</a>
              <a href="#struct">struct</a> of configuration options and returns a type.
              Generally, you will set up one <code>std.heap.GeneralPurposeAllocator</code> in
              your main function, and then pass it or sub-allocators around to various parts of your
              application.
          </li>
          <li>
              You can also consider <a href="#Implementing-an-Allocator">Implementing an Allocator</a>.
          </li>
      </ol>
      

      <h3 id="Where-are-the-bytes"><a href="#toc-Where-are-the-bytes">Where are the bytes?</a> <a class="hdr" href="#Where-are-the-bytes">§</a></h3>

      <p>String literals such as <code><span class="tok-str">&quot;hello&quot;</span></code> are in the global constant data section.
      This is why it is an error to pass a string literal to a mutable slice, like this:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_string_literal_to_slice.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(s: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    _ = s;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;string literal to mutable slice&quot;</span> {
    foo(<span class="tok-str">&quot;hello&quot;</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_string_literal_to_slice.zig</kbd>
<span class="sgr-1m">doc/langref/test_string_literal_to_slice.zig:6:9: </span><span class="sgr-31m">error: </span><span class="sgr-1m">expected type '[]u8', found '*const [5:0]u8'
</span>    foo(&quot;hello&quot;);
        <span class="sgr-32m">^~~~~~~
</span><span class="sgr-1m">doc/langref/test_string_literal_to_slice.zig:6:9: </span><span class="sgr-36m">note: </span><span class="sgr-1m">cast discards const qualifier
</span><span class="sgr-1m">doc/langref/test_string_literal_to_slice.zig:1:11: </span><span class="sgr-36m">note: </span><span class="sgr-1m">parameter type declared here
</span>fn foo(s: []u8) void {
          <span class="sgr-32m">^~~~
</span>
</samp></pre></figure>

      <p>However if you make the slice constant, then it works:</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_string_literal_to_const_slice.zig</cite></figcaption><pre><code><span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    _ = s;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;string literal to constant slice&quot;</span> {
    foo(<span class="tok-str">&quot;hello&quot;</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_string_literal_to_const_slice.zig</kbd>
1/1 test_string_literal_to_const_slice.test.string literal to constant slice...OK
All 1 tests passed.
</samp></pre></figure>

      <p>
      Just like string literals, <code><span class="tok-kw">const</span></code> declarations, when the value is known at <a href="#comptime">comptime</a>,
      are stored in the global constant data section. Also <a href="#Compile-Time-Variables">Compile Time Variables</a> are stored
      in the global constant data section.
      </p>
      <p>
      <code><span class="tok-kw">var</span></code> declarations inside functions are stored in the function's stack frame. Once a function returns,
      any <a href="#Pointers">Pointers</a> to variables in the function's stack frame become invalid references, and
      dereferencing them becomes unchecked <a href="#Illegal-Behavior">Illegal Behavior</a>.
      </p>
      <p>
      <code><span class="tok-kw">var</span></code> declarations at the top level or in <a href="#struct">struct</a> declarations are stored in the global
      data section.
      </p>
      <p>
      The location of memory allocated with <code>allocator.alloc</code> or
      <code>allocator.create</code> is determined by the allocator's implementation.
      </p>
      <p>TODO: thread local variables</p>
      

      <h3 id="Implementing-an-Allocator"><a href="#toc-Implementing-an-Allocator">Implementing an Allocator</a> <a class="hdr" href="#Implementing-an-Allocator">§</a></h3>

      <p>Zig programmers can implement their own allocators by fulfilling the Allocator interface.
      In order to do this one must read carefully the documentation comments in std/mem.zig and
      then supply a <code>allocFn</code> and a <code>resizeFn</code>.
      </p>
      <p>
      There are many example allocators to look at for inspiration. Look at std/heap.zig and
      <code>std.heap.GeneralPurposeAllocator</code>.
      </p>
      

      <h3 id="Heap-Allocation-Failure"><a href="#toc-Heap-Allocation-Failure">Heap Allocation Failure</a> <a class="hdr" href="#Heap-Allocation-Failure">§</a></h3>

      <p>
      Many programming languages choose to handle the possibility of heap allocation failure by
      unconditionally crashing. By convention, Zig programmers do not consider this to be a
      satisfactory solution. Instead, <code><span class="tok-kw">error</span>.OutOfMemory</code> represents
      heap allocation failure, and Zig libraries return this error code whenever heap allocation
      failure prevented an operation from completing successfully.
      </p>
      <p>
      Some have argued that because some operating systems such as Linux have memory overcommit enabled by
      default, it is pointless to handle heap allocation failure. There are many problems with this reasoning:
      </p>
      <ul>
          <li>Only some operating systems have an overcommit feature.
              <ul>
                  <li>Linux has it enabled by default, but it is configurable.</li>
                  <li>Windows does not overcommit.</li>
                  <li>Embedded systems do not have overcommit.</li>
                  <li>Hobby operating systems may or may not have overcommit.</li>
              </ul>
          </li>
          <li>
              For real-time systems, not only is there no overcommit, but typically the maximum amount
              of memory per application is determined ahead of time.
          </li>
          <li>
              When writing a library, one of the main goals is code reuse. By making code handle
              allocation failure correctly, a library becomes eligible to be reused in
              more contexts.
          </li>
          <li>
              Although some software has grown to depend on overcommit being enabled, its existence
              is the source of countless user experience disasters. When a system with overcommit enabled,
              such as Linux on default settings, comes close to memory exhaustion, the system locks up
              and becomes unusable. At this point, the OOM Killer selects an application to kill
              based on heuristics. This non-deterministic decision often results in an important process
              being killed, and often fails to return the system back to working order.
          </li>
      </ul>
      

      <h3 id="Recursion"><a href="#toc-Recursion">Recursion</a> <a class="hdr" href="#Recursion">§</a></h3>

      <p>
      Recursion is a fundamental tool in modeling software. However it has an often-overlooked problem:
      unbounded memory allocation.
      </p>
      <p>
      Recursion is an area of active experimentation in Zig and so the documentation here is not final.
      You can read a
      <a href="https://ziglang.org/download/0.3.0/release-notes.html#recursion">summary of recursion status in the 0.3.0 release notes</a>.
      </p>
      <p>
      The short summary is that currently recursion works normally as you would expect. Although Zig code
      is not yet protected from stack overflow, it is planned that a future version of Zig will provide
      such protection, with some degree of cooperation from Zig code required.
      </p>
      

      <h3 id="Lifetime-and-Ownership"><a href="#toc-Lifetime-and-Ownership">Lifetime and Ownership</a> <a class="hdr" href="#Lifetime-and-Ownership">§</a></h3>

      <p>
      It is the Zig programmer's responsibility to ensure that a <a href="#Pointers">pointer</a> is not
      accessed when the memory pointed to is no longer available. Note that a <a href="#Slices">slice</a>
      is a form of pointer, in that it references other memory.
      </p>
      <p>
      In order to prevent bugs, there are some helpful conventions to follow when dealing with pointers.
      In general, when a function returns a pointer, the documentation for the function should explain
      who "owns" the pointer. This concept helps the programmer decide when it is appropriate, if ever,
      to free the pointer.
      </p>
      <p>
      For example, the function's documentation may say "caller owns the returned memory", in which case
      the code that calls the function must have a plan for when to free that memory. Probably in this situation,
      the function will accept an <code>Allocator</code> parameter.
      </p>
      <p>
      Sometimes the lifetime of a pointer may be more complicated. For example, the
      <code>std.ArrayList(T).items</code> slice has a lifetime that remains
      valid until the next time the list is resized, such as by appending new elements.
      </p>
      <p>
      The API documentation for functions and data structures should take great care to explain
      the ownership and lifetime semantics of pointers. Ownership determines whose responsibility it
      is to free the memory referenced by the pointer, and lifetime determines the point at which
      the memory becomes inaccessible (lest <a href="#Illegal-Behavior">Illegal Behavior</a> occur).
      </p>
      

      
      <h2 id="Compile-Variables"><a href="#toc-Compile-Variables">Compile Variables</a> <a class="hdr" href="#Compile-Variables">§</a></h2>

      <p>
      Compile variables are accessible by importing the <code><span class="tok-str">&quot;builtin&quot;</span></code> package,
      which the compiler makes available to every Zig source file. It contains
      compile-time constants such as the current target, endianness, and release mode.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">compile_variables.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> separator = <span class="tok-kw">if</span> (builtin.os.tag == .windows) <span class="tok-str">'\\'</span> <span class="tok-kw">else</span> <span class="tok-str">'/'</span>;</code></pre></figure>

      <p>
      Example of what is imported with <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>)</code>:
      </p>
      <figure><figcaption class="zig-cap"><cite>@import("builtin")</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-comment">/// Zig version. When writing code that supports multiple versions of Zig, prefer</span>
<span class="tok-comment">/// feature detection (i.e. with `@hasDecl` or `@hasField`) over version checks.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> zig_version = std.SemanticVersion.parse(zig_version_string) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> zig_version_string = <span class="tok-str">&quot;0.14.0-dev.3451+d8d2aa9af&quot;</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> zig_backend = std.builtin.CompilerBackend.stage2_llvm;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> output_mode: std.builtin.OutputMode = .Exe;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> link_mode: std.builtin.LinkMode = .static;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> unwind_tables: std.builtin.UnwindTables = .@&quot;async&quot;;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> is_test = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> single_threaded = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> abi: std.Target.Abi = .gnu;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> cpu: std.Target.Cpu = .{
    .arch = .x86_64,
    .model = &amp;std.Target.x86.cpu.znver4,
    .features = std.Target.x86.featureSet(&amp;.{
        .@&quot;64bit&quot;,
        .adx,
        .aes,
        .allow_light_256_bit,
        .avx,
        .avx2,
        .avx512bf16,
        .avx512bitalg,
        .avx512bw,
        .avx512cd,
        .avx512dq,
        .avx512f,
        .avx512ifma,
        .avx512vbmi,
        .avx512vbmi2,
        .avx512vl,
        .avx512vnni,
        .avx512vpopcntdq,
        .bmi,
        .bmi2,
        .branchfusion,
        .clflushopt,
        .clwb,
        .clzero,
        .cmov,
        .crc32,
        .cx16,
        .cx8,
        .evex512,
        .f16c,
        .fast_15bytenop,
        .fast_bextr,
        .fast_dpwssd,
        .fast_imm16,
        .fast_lzcnt,
        .fast_movbe,
        .fast_scalar_fsqrt,
        .fast_scalar_shift_masks,
        .fast_variable_perlane_shuffle,
        .fast_vector_fsqrt,
        .fma,
        .fsgsbase,
        .fsrm,
        .fxsr,
        .gfni,
        .idivq_to_divl,
        .invpcid,
        .lzcnt,
        .macrofusion,
        .mmx,
        .movbe,
        .mwaitx,
        .nopl,
        .pclmul,
        .pku,
        .popcnt,
        .prfchw,
        .rdpid,
        .rdpru,
        .rdrnd,
        .rdseed,
        .sahf,
        .sbb_dep_breaking,
        .sha,
        .shstk,
        .slow_shld,
        .smap,
        .smep,
        .sse,
        .sse2,
        .sse3,
        .sse4_1,
        .sse4_2,
        .sse4a,
        .ssse3,
        .vaes,
        .vpclmulqdq,
        .vzeroupper,
        .wbnoinvd,
        .x87,
        .xsave,
        .xsavec,
        .xsaveopt,
        .xsaves,
    }),
};
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> os: std.Target.Os = .{
    .tag = .linux,
    .version_range = .{ .linux = .{
        .range = .{
            .min = .{
                .major = <span class="tok-number">6</span>,
                .minor = <span class="tok-number">13</span>,
                .patch = <span class="tok-number">2</span>,
            },
            .max = .{
                .major = <span class="tok-number">6</span>,
                .minor = <span class="tok-number">13</span>,
                .patch = <span class="tok-number">2</span>,
            },
        },
        .glibc = .{
            .major = <span class="tok-number">2</span>,
            .minor = <span class="tok-number">39</span>,
            .patch = <span class="tok-number">0</span>,
        },
        .android = <span class="tok-number">14</span>,
    }},
};
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> target: std.Target = .{
    .cpu = cpu,
    .os = os,
    .abi = abi,
    .ofmt = object_format,
    .dynamic_linker = .init(<span class="tok-str">&quot;/nix/store/nqb2ns2d1lahnd5ncwmn6k84qfd7vx2k-glibc-2.40-36/lib/ld-linux-x86-64.so.2&quot;</span>),
};
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> object_format: std.Target.ObjectFormat = .elf;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> mode: std.builtin.OptimizeMode = .Debug;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> link_libc = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> link_libcpp = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_error_return_tracing = <span class="tok-null">true</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> valgrind_support = <span class="tok-null">true</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> sanitize_thread = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> fuzz = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> position_independent_code = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> position_independent_executable = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> strip_debug_info = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> code_model: std.builtin.CodeModel = .default;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> omit_frame_pointer = <span class="tok-null">false</span>;</code></pre></figure>
      <p>See also:</p><ul>
<li><a href="#Build-Mode">Build Mode</a></li>
</ul>

      
      <h2 id="Compilation-Model"><a href="#toc-Compilation-Model">Compilation Model</a> <a class="hdr" href="#Compilation-Model">§</a></h2>

      <p>
      A Zig compilation is separated into <em>modules</em>. Each module is a collection of Zig source files,
      one of which is the module's <em>root source file</em>. Each module can <em>depend</em> on any number of
      other modules, forming a directed graph (dependency loops between modules are allowed). If module A
      depends on module B, then any Zig source file in module A can import the <em>root source file</em> of
      module B using <code><span class="tok-builtin">@import</span></code> with the module's name. In essence, a module acts as an
      alias to import a Zig source file (which might exist in a completely separate part of the filesystem).
      </p>
      <p>
      A simple Zig program compiled with <code>zig build-exe</code> has two key modules: the one containing your
      code, known as the "main" or "root" module, and the standard library. Your module <em>depends on</em>
      the standard library module under the name "std", which is what allows you to write
      <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>)</code>! In fact, every single module in a Zig compilation &mdash; including
      the standard library itself &mdash; implicitly depends on the standard library module under the name "std".
      </p>
      <p>
      The "root module" (the one provided by you in the <code>zig build-exe</code> example) has a special
      property. Like the standard library, it is implicitly made available to all modules (including itself),
      this time under the name "root". So, <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>)</code> will always be equivalent to
      <code><span class="tok-builtin">@import</span></code> of your "main" source file (often, but not necessarily, named
      <code>main.zig</code>).
      </p>
      <h3 id="Source-File-Structs"><a href="#toc-Source-File-Structs">Source File Structs</a> <a class="hdr" href="#Source-File-Structs">§</a></h3>

      <p>
      Every Zig source file is implicitly a <code><span class="tok-kw">struct</span></code> declaration; you can imagine that
      the file's contents are literally surrounded by <code><span class="tok-kw">struct</span> { ... }</code>. This means that
      as well as declarations, the top level of a file is permitted to contain fields:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">TopLevelFields.zig</cite></figcaption><pre><code><span class="tok-comment">//! Because this file contains fields, it is a type which is intended to be instantiated, and so</span>
<span class="tok-comment">//! is named in TitleCase instead of snake_case by convention.</span>

foo: <span class="tok-type">u32</span>,
bar: <span class="tok-type">u64</span>,

<span class="tok-comment">/// `@This()` can be used to refer to this struct type. In files with fields, it is quite common to</span>
<span class="tok-comment">/// name the type here, so it can be easily referenced by other declarations in this file.</span>
<span class="tok-kw">const</span> TopLevelFields = <span class="tok-builtin">@This</span>();

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(val: <span class="tok-type">u32</span>) TopLevelFields {
    <span class="tok-kw">return</span> .{
        .foo = val,
        .bar = val * <span class="tok-number">10</span>,
    };
}</code></pre></figure>
      <p>
      Such files can be instantiated just like any other <code><span class="tok-kw">struct</span></code> type. A file's "root
      struct type" can be referred to within that file using <a href="#This">@This</a>.
      </p>
      
      <h3 id="File-and-Declaration-Discovery"><a href="#toc-File-and-Declaration-Discovery">File and Declaration Discovery</a> <a class="hdr" href="#File-and-Declaration-Discovery">§</a></h3>

      <p>
      Zig places importance on the concept of whether any piece of code is <em>semantically analyzed</em>; in
      essence, whether the compiler "looks at" it. What code is analyzed is based on what files and
      declarations are "discovered" from a certain point. This process of "discovery" is based on a simple set
      of recursive rules:
      </p>
      <ul>
        <li>If a call to <code><span class="tok-builtin">@import</span></code> is analyzed, the file being imported is analyzed.</li>
        <li>If a type (including a file) is analyzed, all <code><span class="tok-kw">comptime</span></code>, <code><span class="tok-kw">usingnamespace</span></code>, and <code><span class="tok-kw">export</span></code> declarations within it are analyzed.</li>
        <li>If a type (including a file) is analyzed, and the compilation is for a <a href="#Zig-Test">test</a>, and the module the type is within is the root module of the compilation, then all <code><span class="tok-kw">test</span></code> declarations within it are also analyzed.</li>
        <li>If a reference to a named declaration (i.e. a usage of it) is analyzed, the declaration being referenced is analyzed. Declarations are order-independent, so this reference may be above or below the declaration being referenced, or even in another file entirely.</li>
      </ul>
      <p>
      That's it! Those rules define how Zig files and declarations are discovered. All that remains is to
      understand where this process <em>starts</em>.
      </p>
      <p>
      The answer to that is the root of the standard library: every Zig compilation begins by analyzing the
      file <code>lib/std/std.zig</code>. This file contains a <code><span class="tok-kw">comptime</span></code> declaration
      which imports <code>lib/std/start.zig</code>, and that file in turn uses
      <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>)</code> to reference the "root module"; so, the file you provide as your
      main module's root source file is effectively also a root, because the standard library will always
      reference it.
      </p>
      <p>
      It is often desirable to make sure that certain declarations &mdash; particularly <code><span class="tok-kw">test</span></code>
      or <code><span class="tok-kw">export</span></code> declarations &mdash; are discovered. Based on the above rules, a common
      strategy for this is to use <code><span class="tok-builtin">@import</span></code> within a <code><span class="tok-kw">comptime</span></code> or
      <code><span class="tok-kw">test</span></code> block:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">force_file_discovery.zig</cite></figcaption><pre><code><span class="tok-kw">comptime</span> {
    <span class="tok-comment">// This will ensure that the file 'api.zig' is always discovered (as long as this file is discovered).</span>
    <span class="tok-comment">// It is useful if 'api.zig' contains important exported declarations.</span>
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;api.zig&quot;</span>);

    <span class="tok-comment">// We could also have a file which contains declarations we only want to export depending on a comptime</span>
    <span class="tok-comment">// condition. In that case, we can use an `if` statement here:</span>
    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {
        _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;windows_api.zig&quot;</span>);
    }
}

<span class="tok-kw">test</span> {
    <span class="tok-comment">// This will ensure that the file 'tests.zig' is always discovered (as long as this file is discovered),</span>
    <span class="tok-comment">// if this compilation is a test. It is useful if 'tests.zig' contains tests we want to ensure are run.</span>
    _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;tests.zig&quot;</span>);

    <span class="tok-comment">// We could also have a file which contains tests we only want to run depending on a comptime condition.</span>
    <span class="tok-comment">// In that case, we can use an `if` statement here:</span>
    <span class="tok-kw">if</span> (builtin.os.tag == .windows) {
        _ = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;windows_tests.zig&quot;</span>);
    }
}

<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</code></pre></figure>
      
      <h3 id="Special-Root-Declarations"><a href="#toc-Special-Root-Declarations">Special Root Declarations</a> <a class="hdr" href="#Special-Root-Declarations">§</a></h3>

      <p>
      Because the root module's root source file is always accessible using
      <code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;root&quot;</span>)</code>, is is sometimes used by libraries &mdash; including the Zig Standard
      Library &mdash; as a place for the program to expose some "global" information to that library. The Zig
      Standard Library will look for several declarations in this file.
      </p>
      <h4 id="Entry-Point"><a href="#toc-Entry-Point">Entry Point</a> <a class="hdr" href="#Entry-Point">§</a></h4>

      <p>
      When building an executable, the most important thing to be looked up in this file is the program's
      <em>entry point</em>. Most commonly, this is a function named <code>main</code>, which
      <code>std.start</code> will call just after performing important initialization work.
      </p>
      <p>
      Alternatively, the presence of a declaration named <code>_start</code> (for instance,
      <code><span class="tok-kw">pub</span> <span class="tok-kw">const</span> _start = {};</code>) will disable the default <code>std.start</code>
      logic, allowing your root source file to export a low-level entry point as needed.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">entry_point.zig</cite></figcaption><pre><code><span class="tok-comment">/// `std.start` imports this file using `@import(&quot;root&quot;)`, and uses this declaration as the program's</span>
<span class="tok-comment">/// user-provided entry point. It can return any of the following types:</span>
<span class="tok-comment">/// * `void`</span>
<span class="tok-comment">/// * `E!void`, for any error set `E`</span>
<span class="tok-comment">/// * `u8`</span>
<span class="tok-comment">/// * `E!u8`, for any error set `E`</span>
<span class="tok-comment">/// Returning a `void` value from this function will exit with code 0.</span>
<span class="tok-comment">/// Returning a `u8` value from this function will exit with the given status code.</span>
<span class="tok-comment">/// Returning an error value from this function will print an Error Return Trace and exit with code 1.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    std.debug.print(<span class="tok-str">&quot;Hello, World!\n&quot;</span>, .{});
}

<span class="tok-comment">// If uncommented, this declaration would suppress the usual std.start logic, causing</span>
<span class="tok-comment">// the `main` declaration above to be ignored.</span>
<span class="tok-comment">//pub const _start = {};</span>

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe entry_point.zig</kbd>
$ <kbd>./entry_point</kbd>
Hello, World!
</samp></pre></figure>
      <p>
      If the Zig compilation links libc, the <code>main</code> function can optionally be an
      <code><span class="tok-kw">export</span> <span class="tok-kw">fn</span></code> which matches the signature of the C <code>main</code> function:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">libc_export_entry_point.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>(argc: <span class="tok-type">c_int</span>, argv: [*]<span class="tok-kw">const</span> [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">c_int</span> {
    <span class="tok-kw">const</span> args = argv[<span class="tok-number">0</span>..<span class="tok-builtin">@intCast</span>(argc)];
    std.debug.print(<span class="tok-str">&quot;Hello! argv[0] is '{s}'\n&quot;</span>, .{args[<span class="tok-number">0</span>]});
    <span class="tok-kw">return</span> <span class="tok-number">0</span>;
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe libc_export_entry_point.zig -lc</kbd>
$ <kbd>./libc_export_entry_point</kbd>
Hello! argv[0] is './libc_export_entry_point'
</samp></pre></figure>
      <p>
      <code>std.start</code> may also use other entry point declarations in certain situations, such
      as <code>wWinMain</code> or <code>EfiMain</code>. Refer to the
      <code>lib/std/start.zig</code> logic for details of these declarations.
      </p>
      
      <h4 id="Standard-Library-Options"><a href="#toc-Standard-Library-Options">Standard Library Options</a> <a class="hdr" href="#Standard-Library-Options">§</a></h4>

      <p>
      The standard library also looks for a declaration in the root module's root source file named
      <code>std_options</code>. If present, this declaration is expected to be a struct of type
      <code>std.Options</code>, and allows the program to customize some standard library
      functionality, such as the <code>std.log</code> implementation.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">std_options.zig</cite></figcaption><pre><code><span class="tok-comment">/// The presence of this declaration allows the program to override certain behaviors of the standard library.</span>
<span class="tok-comment">/// For a full list of available options, see the documentation for `std.Options`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> std_options: std.Options = .{
    <span class="tok-comment">// By default, in safe build modes, the standard library will attach a segfault handler to the program to</span>
    <span class="tok-comment">// print a helpful stack trace if a segmentation fault occurs. Here, we can disable this, or even enable</span>
    <span class="tok-comment">// it in unsafe build modes.</span>
    .enable_segfault_handler = <span class="tok-null">true</span>,
    <span class="tok-comment">// This is the logging function used by `std.log`.</span>
    .logFn = myLogFn,
};

<span class="tok-kw">fn</span> <span class="tok-fn">myLogFn</span>(
    <span class="tok-kw">comptime</span> level: std.log.Level,
    <span class="tok-kw">comptime</span> scope: <span class="tok-builtin">@Type</span>(.enum_literal),
    <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    args: <span class="tok-kw">anytype</span>,
) <span class="tok-type">void</span> {
    <span class="tok-comment">// We could do anything we want here!</span>
    <span class="tok-comment">// ...but actually, let's just call the default implementation.</span>
    std.log.defaultLog(level, scope, format, args);
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</code></pre></figure>
      
      <h4 id="Panic-Handler"><a href="#toc-Panic-Handler">Panic Handler</a> <a class="hdr" href="#Panic-Handler">§</a></h4>

      <p>
      The Zig Standard Library looks for a declaration named <code>panic</code> in the root module's
      root source file. If present, it is expected to be a namespace (container type) with declarations
      providing different panic handlers.
      </p>
      <p>
      See <code>std.debug.simple_panic</code> for a basic implementation of this namespace.
      </p>
      <p>
      Overriding how the panic handler actually outputs messages, but keeping the formatted safety panics
      which are enabled by default, can be easily achieved with <code>std.debug.FullPanic</code>:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">panic_handler.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">true</span>);
    <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
    <span class="tok-comment">// Let's overflow this integer!</span>
    x += <span class="tok-number">1</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> panic = std.debug.FullPanic(myPanic);

<span class="tok-kw">fn</span> <span class="tok-fn">myPanic</span>(msg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, first_trace_addr: ?<span class="tok-type">usize</span>) <span class="tok-type">noreturn</span> {
    _ = first_trace_addr;
    std.debug.print(<span class="tok-str">&quot;Panic! {s}\n&quot;</span>, .{msg});
    std.process.exit(<span class="tok-number">1</span>);
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe panic_handler.zig</kbd>
$ <kbd>./panic_handler</kbd>
Panic! integer overflow
</samp></pre></figure>
      
      
      
      <h2 id="Zig-Build-System"><a href="#toc-Zig-Build-System">Zig Build System</a> <a class="hdr" href="#Zig-Build-System">§</a></h2>

      <p>
      The Zig Build System provides a cross-platform, dependency-free way to declare
      the logic required to build a project. With this system, the logic to build
      a project is written in a build.zig file, using the Zig Build System API to
      declare and configure build artifacts and other tasks.
      </p>
      <p>
      Some examples of tasks the build system can help with:
      </p>
      <ul>
        <li>Performing tasks in parallel and caching the results.</li>
        <li>Depending on other projects.</li>
        <li>Providing a package for other projects to depend on.</li>
        <li>Creating build artifacts by executing the Zig compiler. This includes
          building Zig source code as well as C and C++ source code.</li>
        <li>Capturing user-configured options and using those options to configure
          the build.</li>
        <li>Surfacing build configuration as <a href="#comptime">comptime</a> values by providing a
          file that can be <a href="#import">imported</a> by Zig code.</li>
        <li>Caching build artifacts to avoid unnecessarily repeating steps.</li>
        <li>Executing build artifacts or system-installed tools.</li>
        <li>Running tests and verifying the output of executing a build artifact matches
        the expected value.</li>
        <li>Running <code>zig fmt</code> on a codebase or a subset of it.</li>
        <li>Custom tasks.</li>
      </ul>
      <p>
      To use the build system, run <kbd>zig build --help</kbd>
      to see a command-line usage help menu. This will include project-specific
      options that were declared in the build.zig script.
      </p>
      <p>
      For the time being, the build system documentation is hosted externally:
      <a href="https://ziglang.org/learn/build-system/">Build System Documentation</a>
      </p>
      
      <h2 id="C"><a href="#toc-C">C</a> <a class="hdr" href="#C">§</a></h2>

      <p>
      Although Zig is independent of C, and, unlike most other languages, does not depend on libc,
      Zig acknowledges the importance of interacting with existing C code.
      </p>
      <p>
      There are a few ways that Zig facilitates C interop.
      </p>
      <h3 id="C-Type-Primitives"><a href="#toc-C-Type-Primitives">C Type Primitives</a> <a class="hdr" href="#C-Type-Primitives">§</a></h3>

      <p>
      These have guaranteed C ABI compatibility and can be used like any other type.
      </p>
      <ul>
          <li><code><span class="tok-type">c_char</span></code></li>
          <li><code><span class="tok-type">c_short</span></code></li>
          <li><code><span class="tok-type">c_ushort</span></code></li>
          <li><code><span class="tok-type">c_int</span></code></li>
          <li><code><span class="tok-type">c_uint</span></code></li>
          <li><code><span class="tok-type">c_long</span></code></li>
          <li><code><span class="tok-type">c_ulong</span></code></li>
          <li><code><span class="tok-type">c_longlong</span></code></li>
          <li><code><span class="tok-type">c_ulonglong</span></code></li>
          <li><code><span class="tok-type">c_longdouble</span></code></li>
      </ul>
      <p>
      To interop with the C <code><span class="tok-type">void</span></code> type, use <code><span class="tok-type">anyopaque</span></code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Primitive-Types">Primitive Types</a></li>
</ul>

      
      <h3 id="Import-from-C-Header-File"><a href="#toc-Import-from-C-Header-File">Import from C Header File</a> <a class="hdr" href="#Import-from-C-Header-File">§</a></h3>

      <p>
      The <code><span class="tok-builtin">@cImport</span></code> builtin function can be used
      to directly import symbols from <code class="file">.h</code> files:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">cImport_builtin.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> c = <span class="tok-builtin">@cImport</span>({
    <span class="tok-comment">// See https://github.com/ziglang/zig/issues/515</span>
    <span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;_NO_CRT_STDIO_INLINE&quot;</span>, <span class="tok-str">&quot;1&quot;</span>);
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;stdio.h&quot;</span>);
});
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    _ = c.printf(<span class="tok-str">&quot;hello\n&quot;</span>);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe cImport_builtin.zig -lc</kbd>
$ <kbd>./cImport_builtin</kbd>
hello
</samp></pre></figure>

      <p>
      The <code><span class="tok-builtin">@cImport</span></code> function takes an expression as a parameter.
      This expression is evaluated at compile-time and is used to control
      preprocessor directives and include multiple <code class="file">.h</code> files:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">@cImport Expression</cite></figcaption><pre><code><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);

<span class="tok-kw">const</span> c = <span class="tok-builtin">@cImport</span>({
    <span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;NDEBUG&quot;</span>, builtin.mode == .ReleaseFast);
    <span class="tok-kw">if</span> (something) {
        <span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;_GNU_SOURCE&quot;</span>, {});
    }
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;stdlib.h&quot;</span>);
    <span class="tok-kw">if</span> (something) {
        <span class="tok-builtin">@cUndef</span>(<span class="tok-str">&quot;_GNU_SOURCE&quot;</span>);
    }
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;soundio.h&quot;</span>);
});</code></pre></figure>
      <p>See also:</p><ul>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cInclude">@cInclude</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cUndef">@cUndef</a></li>
<li><a href="#import">@import</a></li>
</ul>

      

      <h3 id="C-Translation-CLI"><a href="#toc-C-Translation-CLI">C Translation CLI</a> <a class="hdr" href="#C-Translation-CLI">§</a></h3>

      <p>
      Zig's C translation capability is available as a CLI tool via <kbd>zig translate-c</kbd>.
      It requires a single filename as an argument. It may also take a set of optional flags that are
      forwarded to clang. It writes the translated file to stdout.
      </p>
      <h4 id="Command-line-flags"><a href="#toc-Command-line-flags">Command line flags</a> <a class="hdr" href="#Command-line-flags">§</a></h4>

      <ul>
        <li>
          <kbd>-I</kbd>:
          Specify a search directory for include files. May be used multiple times. Equivalent to
          <a href="https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html#cmdoption-clang-i-dir">
          clang's <kbd>-I</kbd> flag</a>. The current directory is <em>not</em> included by default;
          use <kbd>-I.</kbd> to include it.
        </li>
        <li>
          <kbd>-D</kbd>: Define a preprocessor macro. Equivalent to
          <a href="https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html#cmdoption-clang-d-macro">
          clang's <kbd>-D</kbd> flag</a>.
        </li>
        <li>
          <kbd>-cflags [flags] --</kbd>: Pass arbitrary additional
          <a href="https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html">command line
          flags</a> to clang. Note: the list of flags must end with <kbd>--</kbd>
        </li>
        <li>
          <kbd>-target</kbd>: The <a href="#Targets">target triple</a> for the translated Zig code.
          If no target is specified, the current host target will be used.
        </li>
      </ul>
      
      <h4 id="Using--target-and--cflags"><a href="#toc-Using--target-and--cflags">Using -target and -cflags</a> <a class="hdr" href="#Using--target-and--cflags">§</a></h4>

      <p>
        <strong>Important!</strong> When translating C code with <kbd>zig translate-c</kbd>,
        you <strong>must</strong> use the same <kbd>-target</kbd> triple that you will use when compiling
        the translated code. In addition, you <strong>must</strong> ensure that the <kbd>-cflags</kbd> used,
        if any, match the cflags used by code on the target system. Using the incorrect <kbd>-target</kbd>
        or <kbd>-cflags</kbd> could result in clang or Zig parse failures, or subtle ABI incompatibilities
        when linking with C code.
      </p>
      <figure><figcaption class="c-cap"><cite class="file">varytarget.h</cite></figcaption><pre><code>long FOO = __LONG_MAX__;</code></pre></figure>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig translate-c -target thumb-freestanding-gnueabihf varytarget.h|grep FOO</kbd>
pub export var FOO: c_long = 2147483647;
$ <kbd>zig translate-c -target x86_64-macos-gnu varytarget.h|grep FOO</kbd>
pub export var FOO: c_long = 9223372036854775807;
</samp></pre></figure>
      <figure><figcaption class="c-cap"><cite class="file">varycflags.h</cite></figcaption><pre><code>enum FOO { BAR };
int do_something(enum FOO foo);</code></pre></figure>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig translate-c varycflags.h|grep -B1 do_something</kbd>
pub const enum_FOO = c_uint;
pub extern fn do_something(foo: enum_FOO) c_int;
$ <kbd>zig translate-c -cflags -fshort-enums -- varycflags.h|grep -B1 do_something</kbd>
pub const enum_FOO = u8;
pub extern fn do_something(foo: enum_FOO) c_int;
</samp></pre></figure>
      
      <h4 id="cImport-vs-translate-c"><a href="#toc-cImport-vs-translate-c">@cImport vs translate-c</a> <a class="hdr" href="#cImport-vs-translate-c">§</a></h4>

      <p><code><span class="tok-builtin">@cImport</span></code> and <kbd>zig translate-c</kbd> use the same underlying
      C translation functionality, so on a technical level they are equivalent. In practice,
      <code><span class="tok-builtin">@cImport</span></code> is useful as a way to quickly and easily access numeric constants, typedefs,
      and record types without needing any extra setup. If you need to pass <a href="#Using--target-and--cflags">cflags</a>
      to clang, or if you would like to edit the translated code, it is recommended to use
      <kbd>zig translate-c</kbd> and save the results to a file. Common reasons for editing
      the generated code include: changing <code><span class="tok-kw">anytype</span></code> parameters in function-like macros to more
      specific types; changing <code>[*c]T</code> pointers to <code>[*]T</code> or
      <code>*T</code> pointers for improved type safety; and
      <a href="#setRuntimeSafety">enabling or disabling runtime safety</a> within specific functions.
      </p>
      
      <p>See also:</p><ul>
<li><a href="#Targets">Targets</a></li>
<li><a href="#C-Type-Primitives">C Type Primitives</a></li>
<li><a href="#Pointers">Pointers</a></li>
<li><a href="#C-Pointers">C Pointers</a></li>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cInclude">@cInclude</a></li>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#setRuntimeSafety">@setRuntimeSafety</a></li>
</ul>

      
      <h3 id="C-Translation-Caching"><a href="#toc-C-Translation-Caching">C Translation Caching</a> <a class="hdr" href="#C-Translation-Caching">§</a></h3>

      <p>
        The C translation feature (whether used via <kbd>zig translate-c</kbd> or
        <code><span class="tok-builtin">@cImport</span></code>) integrates with the Zig caching system. Subsequent runs with
        the same source file, target, and cflags will use the cache instead of repeatedly translating
        the same code.
      </p>
      <p>
        To see where the cached files are stored when compiling code that uses <code><span class="tok-builtin">@cImport</span></code>,
        use the <kbd>--verbose-cimport</kbd> flag:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">verbose_cimport_flag.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> c = <span class="tok-builtin">@cImport</span>({
    <span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;_NO_CRT_STDIO_INLINE&quot;</span>, <span class="tok-str">&quot;1&quot;</span>);
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;stdio.h&quot;</span>);
});
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    _ = c;
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe verbose_cimport_flag.zig -lc --verbose-cimport</kbd>
info(compilation): C import source: /home/andy/src/zig/.zig-cache/o/d5beb8c0b08d3a28e44bf4f197b53bae/cimport.h
info(compilation): C import .d file: /home/andy/src/zig/.zig-cache/o/d5beb8c0b08d3a28e44bf4f197b53bae/cimport.h.d
$ <kbd>./verbose_cimport_flag</kbd>
</samp></pre></figure>

      <p>
        <code class="file">cimport.h</code> contains the file to translate (constructed from calls to
        <code><span class="tok-builtin">@cInclude</span></code>, <code><span class="tok-builtin">@cDefine</span></code>, and <code><span class="tok-builtin">@cUndef</span></code>),
        <code class="file">cimport.h.d</code> is the list of file dependencies, and
        <code class="file">cimport.zig</code> contains the translated output.
      </p>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#C-Translation-CLI">C Translation CLI</a></li>
<li><a href="#cInclude">@cInclude</a></li>
<li><a href="#cImport">@cImport</a></li>
</ul>

      
      <h3 id="Translation-failures"><a href="#toc-Translation-failures">Translation failures</a> <a class="hdr" href="#Translation-failures">§</a></h3>

      <p>
        Some C constructs cannot be translated to Zig - for example, <em>goto</em>,
        structs with bitfields, and token-pasting macros. Zig employs <em>demotion</em> to allow translation
        to continue in the face of non-translatable entities.
      </p>
      <p>
        Demotion comes in three varieties - <a href="#opaque">opaque</a>, <em>extern</em>, and
        <code><span class="tok-builtin">@compileError</span></code>.

        C structs and unions that cannot be translated correctly will be translated as <code><span class="tok-kw">opaque</span>{}</code>.
        Functions that contain opaque types or code constructs that cannot be translated will be demoted
        to <code><span class="tok-kw">extern</span></code> declarations.

        Thus, non-translatable types can still be used as pointers, and non-translatable functions
        can be called so long as the linker is aware of the compiled function.
      </p>
      <p>
        <code><span class="tok-builtin">@compileError</span></code> is used when top-level definitions (global variables,
        function prototypes, macros) cannot be translated or demoted. Since Zig uses lazy analysis for
        top-level declarations, untranslatable entities will not cause a compile error in your code unless
        you actually use them.
      </p>
      <p>See also:</p><ul>
<li><a href="#opaque">opaque</a></li>
<li><a href="#extern">extern</a></li>
<li><a href="#compileError">@compileError</a></li>
</ul>

      
      <h3 id="C-Macros"><a href="#toc-C-Macros">C Macros</a> <a class="hdr" href="#C-Macros">§</a></h3>

      <p>
        C Translation makes a best-effort attempt to translate function-like macros into equivalent
        Zig functions. Since C macros operate at the level of lexical tokens, not all C macros
        can be translated to Zig. Macros that cannot be translated will be demoted to
        <code><span class="tok-builtin">@compileError</span></code>. Note that C code which <em>uses</em> macros will be
        translated without any additional issues (since Zig operates on the pre-processed source
        with macros expanded). It is merely the macros themselves which may not be translatable to
        Zig.
      </p>
      <p>Consider the following example:</p>
      <figure><figcaption class="c-cap"><cite class="file">macro.c</cite></figcaption><pre><code>#define MAKELOCAL(NAME, INIT) int NAME = INIT
int foo(void) {
   MAKELOCAL(a, 1);
   MAKELOCAL(b, 2);
   return a + b;
}</code></pre></figure>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig translate-c macro.c &gt; macro.zig</kbd>
</samp></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">macro.zig</cite></figcaption><pre><code><span class="tok-kw">pub</span> <span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">c_int</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">c_int</span> = <span class="tok-number">1</span>;
    _ = &amp;a;
    <span class="tok-kw">var</span> b: <span class="tok-type">c_int</span> = <span class="tok-number">2</span>;
    _ = &amp;b;
    <span class="tok-kw">return</span> a + b;
}
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> MAKELOCAL = <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;unable to translate C expr: unexpected token .Equal&quot;</span>); <span class="tok-comment">// macro.c:1:9</span></code></pre></figure>

      <p>Note that <code>foo</code> was translated correctly despite using a non-translatable
        macro. <code>MAKELOCAL</code> was demoted to <code><span class="tok-builtin">@compileError</span></code> since
        it cannot be expressed as a Zig function; this simply means that you cannot directly use
        <code>MAKELOCAL</code> from Zig.
      </p>
      <p>See also:</p><ul>
<li><a href="#compileError">@compileError</a></li>
</ul>

      

      <h3 id="C-Pointers"><a href="#toc-C-Pointers">C Pointers</a> <a class="hdr" href="#C-Pointers">§</a></h3>

      <p>
      This type is to be avoided whenever possible. The only valid reason for using a C pointer is in
      auto-generated code from translating C code.
      </p>
      <p>
      When importing C header files, it is ambiguous whether pointers should be translated as
      single-item pointers (<code>*T</code>) or many-item pointers (<code>[*]T</code>).
      C pointers are a compromise so that Zig code can utilize translated header files directly.
      </p>
      <p><code>[*c]T</code> - C pointer.</p>
      <ul>
        <li>Supports all the syntax of the other two pointer types (<code>*T</code>) and (<code>[*]T</code>).</li>
        <li>Coerces to other pointer types, as well as <a href="#Optional-Pointers">Optional Pointers</a>.
            When a C pointer is coerced to a non-optional pointer, safety-checked
            <a href="#Illegal-Behavior">Illegal Behavior</a> occurs if the address is 0.
        </li>
        <li>Allows address 0. On non-freestanding targets, dereferencing address 0 is safety-checked
            <a href="#Illegal-Behavior">Illegal Behavior</a>. Optional C pointers introduce another bit to keep track of
            null, just like <code>?<span class="tok-type">usize</span></code>. Note that creating an optional C pointer
            is unnecessary as one can use normal <a href="#Optional-Pointers">Optional Pointers</a>.
        </li>
        <li>Supports <a href="#Type-Coercion">Type Coercion</a> to and from integers.</li>
        <li>Supports comparison with integers.</li>
        <li>Does not support Zig-only pointer attributes such as alignment. Use normal <a href="#Pointers">Pointers</a>
        please!</li>
      </ul>
      <p>When a C pointer is pointing to a single struct (not an array), dereference the C pointer to
        access the struct's fields or member data. That syntax looks like
        this: </p>
        <p><code>ptr_to_struct.*.struct_member</code></p>
        <p>This is comparable to doing <code>-&gt;</code> in C.</p>
        <p> When a C pointer is pointing to an array of structs, the syntax reverts to this:</p>
        <p><code>ptr_to_struct_array[index].struct_member</code></p>
      

      <h3 id="C-Variadic-Functions"><a href="#toc-C-Variadic-Functions">C Variadic Functions</a> <a class="hdr" href="#C-Variadic-Functions">§</a></h3>

      <p>Zig supports extern variadic functions.</p>
      <figure><figcaption class="zig-cap"><cite class="file">test_variadic_function.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> testing = std.testing;

<span class="tok-kw">pub</span> <span class="tok-kw">extern</span> <span class="tok-str">&quot;c&quot;</span> <span class="tok-kw">fn</span> <span class="tok-fn">printf</span>(format: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ...) <span class="tok-type">c_int</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;variadic function&quot;</span> {
    <span class="tok-kw">try</span> testing.expect(printf(<span class="tok-str">&quot;Hello, world!\n&quot;</span>) == <span class="tok-number">14</span>);
    <span class="tok-kw">try</span> testing.expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(printf)).@&quot;fn&quot;.is_var_args);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_variadic_function.zig -lc</kbd>
1/1 test_variadic_function.test.variadic function...OK
All 1 tests passed.
Hello, world!
</samp></pre></figure>

      <p>
        Variadic functions can be implemented using <a href="#cVaStart">@cVaStart</a>, <a href="#cVaEnd">@cVaEnd</a>, <a href="#cVaArg">@cVaArg</a> and <a href="#cVaCopy">@cVaCopy</a>.
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">test_defining_variadic_function.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> testing = std.testing;
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);

<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(count: <span class="tok-type">c_int</span>, ...) <span class="tok-kw">callconv</span>(.C) <span class="tok-type">c_int</span> {
    <span class="tok-kw">var</span> ap = <span class="tok-builtin">@cVaStart</span>();
    <span class="tok-kw">defer</span> <span class="tok-builtin">@cVaEnd</span>(&amp;ap);
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> sum: <span class="tok-type">c_int</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; count) : (i += <span class="tok-number">1</span>) {
        sum += <span class="tok-builtin">@cVaArg</span>(&amp;ap, <span class="tok-type">c_int</span>);
    }
    <span class="tok-kw">return</span> sum;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;defining a variadic function&quot;</span> {
    <span class="tok-kw">if</span> (builtin.cpu.arch == .aarch64 <span class="tok-kw">and</span> builtin.os.tag != .macos) {
        <span class="tok-comment">// https://github.com/ziglang/zig/issues/14096</span>
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }
    <span class="tok-kw">if</span> (builtin.cpu.arch == .x86_64 <span class="tok-kw">and</span> builtin.os.tag == .windows) {
        <span class="tok-comment">// https://github.com/ziglang/zig/issues/16961</span>
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;
    }

    <span class="tok-kw">try</span> std.testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">0</span>), add(<span class="tok-number">0</span>));
    <span class="tok-kw">try</span> std.testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">1</span>), add(<span class="tok-number">1</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">1</span>)));
    <span class="tok-kw">try</span> std.testing.expectEqual(<span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">3</span>), add(<span class="tok-number">2</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">1</span>), <span class="tok-builtin">@as</span>(<span class="tok-type">c_int</span>, <span class="tok-number">2</span>)));
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig test test_defining_variadic_function.zig</kbd>
1/1 test_defining_variadic_function.test.defining a variadic function...OK
All 1 tests passed.
</samp></pre></figure>

      
      <h3 id="Exporting-a-C-Library"><a href="#toc-Exporting-a-C-Library">Exporting a C Library</a> <a class="hdr" href="#Exporting-a-C-Library">§</a></h3>

      <p>
      One of the primary use cases for Zig is exporting a library with the C ABI for other programming languages
      to call into. The <code><span class="tok-kw">export</span></code> keyword in front of functions, variables, and types causes them to
      be part of the library API:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">mathtest.zig</cite></figcaption><pre><code><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a + b;
}</code></pre></figure>

      <p>To make a static library:</p>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-lib mathtest.zig</kbd>
</samp></pre></figure>
      <p>To make a shared library:</p>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-lib mathtest.zig -dynamic</kbd>
</samp></pre></figure>
      <p>Here is an example with the <a href="#Zig-Build-System">Zig Build System</a>:</p>
      <figure><figcaption class="c-cap"><cite class="file">test.c</cite></figcaption><pre><code>// This header is generated by zig from mathtest.zig
#include &quot;mathtest.h&quot;
#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    int32_t result = add(42, 1337);
    printf(&quot;%d\n&quot;, result);
    return 0;
}</code></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">build_c.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *std.Build) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> lib = b.addSharedLibrary(.{
        .name = <span class="tok-str">&quot;mathtest&quot;</span>,
        .root_source_file = b.path(<span class="tok-str">&quot;mathtest.zig&quot;</span>),
        .version = .{ .major = <span class="tok-number">1</span>, .minor = <span class="tok-number">0</span>, .patch = <span class="tok-number">0</span> },
    });
    <span class="tok-kw">const</span> exe = b.addExecutable(.{
        .name = <span class="tok-str">&quot;test&quot;</span>,
    });
    exe.addCSourceFile(.{ .file = b.path(<span class="tok-str">&quot;test.c&quot;</span>), .flags = &amp;.{<span class="tok-str">&quot;-std=c99&quot;</span>} });
    exe.linkLibrary(lib);
    exe.linkSystemLibrary(<span class="tok-str">&quot;c&quot;</span>);

    b.default_step.dependOn(&amp;exe.step);

    <span class="tok-kw">const</span> run_cmd = exe.run();

    <span class="tok-kw">const</span> test_step = b.step(<span class="tok-str">&quot;test&quot;</span>, <span class="tok-str">&quot;Test the program&quot;</span>);
    test_step.dependOn(&amp;run_cmd.step);
}</code></pre></figure>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build test</kbd>
1379
</samp></pre></figure>
      <p>See also:</p><ul>
<li><a href="#export">export</a></li>
</ul>

      
      <h3 id="Mixing-Object-Files"><a href="#toc-Mixing-Object-Files">Mixing Object Files</a> <a class="hdr" href="#Mixing-Object-Files">§</a></h3>

      <p>
      You can mix Zig object files with any other object files that respect the C ABI. Example:
      </p>
      <figure><figcaption class="zig-cap"><cite class="file">base64.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> base64 = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).base64;

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">decode_base_64</span>(
    dest_ptr: [*]<span class="tok-type">u8</span>,
    dest_len: <span class="tok-type">usize</span>,
    source_ptr: [*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    source_len: <span class="tok-type">usize</span>,
) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> src = source_ptr[<span class="tok-number">0</span>..source_len];
    <span class="tok-kw">const</span> dest = dest_ptr[<span class="tok-number">0</span>..dest_len];
    <span class="tok-kw">const</span> base64_decoder = base64.standard.Decoder;
    <span class="tok-kw">const</span> decoded_size = base64_decoder.calcSizeForSlice(src) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    base64_decoder.decode(dest[<span class="tok-number">0</span>..decoded_size], src) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">return</span> decoded_size;
}</code></pre></figure>

      <figure><figcaption class="c-cap"><cite class="file">test.c</cite></figcaption><pre><code>// This header is generated by zig from base64.zig
#include &quot;base64.h&quot;

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    const char *encoded = &quot;YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz&quot;;
    char buf[200];

    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));
    buf[len] = 0;
    puts(buf);

    return 0;
}</code></pre></figure>
      <figure><figcaption class="zig-cap"><cite class="file">build_object.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *std.Build) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> obj = b.addObject(.{
        .name = <span class="tok-str">&quot;base64&quot;</span>,
        .root_source_file = b.path(<span class="tok-str">&quot;base64.zig&quot;</span>),
    });

    <span class="tok-kw">const</span> exe = b.addExecutable(.{
        .name = <span class="tok-str">&quot;test&quot;</span>,
    });
    exe.addCSourceFile(.{ .file = b.path(<span class="tok-str">&quot;test.c&quot;</span>), .flags = &amp;.{<span class="tok-str">&quot;-std=c99&quot;</span>} });
    exe.addObject(obj);
    exe.linkSystemLibrary(<span class="tok-str">&quot;c&quot;</span>);
    b.installArtifact(exe);
}</code></pre></figure>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build</kbd>
$ <kbd>./zig-out/bin/test</kbd>
all your base are belong to us
</samp></pre></figure>
      <p>See also:</p><ul>
<li><a href="#Targets">Targets</a></li>
<li><a href="#Zig-Build-System">Zig Build System</a></li>
</ul>

      
      
      <h2 id="WebAssembly"><a href="#toc-WebAssembly">WebAssembly</a> <a class="hdr" href="#WebAssembly">§</a></h2>

      <p>Zig supports building for WebAssembly out of the box.</p>
      <h3 id="Freestanding"><a href="#toc-Freestanding">Freestanding</a> <a class="hdr" href="#Freestanding">§</a></h3>

      <p>For host environments like the web browser and nodejs, build as an executable using the freestanding
      OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs.</p>
      <figure><figcaption class="zig-cap"><cite class="file">math.zig</cite></figcaption><pre><code><span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(<span class="tok-type">i32</span>) <span class="tok-type">void</span>;

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">void</span> {
    print(a + b);
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe math.zig -target wasm32-freestanding -fno-entry --export=add</kbd>
</samp></pre></figure>

      <figure><figcaption class="javascript-cap"><cite class="file">test.js</cite></figcaption><pre><code>const fs = require('fs');
const source = fs.readFileSync(&quot;./math.wasm&quot;);
const typedArray = new Uint8Array(source);

WebAssembly.instantiate(typedArray, {
  env: {
    print: (result) =&gt; { console.log(`The result is ${result}`); }
  }}).then(result =&gt; {
  const add = result.instance.exports.add;
  add(1, 2);
});</code></pre></figure>
      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>node test.js</kbd>
The result is 3
</samp></pre></figure>
      
      <h3 id="WASI"><a href="#toc-WASI">WASI</a> <a class="hdr" href="#WASI">§</a></h3>

      <p>Zig's support for WebAssembly System Interface (WASI) is under active development.
      Example of using the standard library and reading command line arguments:</p>
      <figure><figcaption class="zig-cap"><cite class="file">wasi_args.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> general_purpose_allocator: std.heap.GeneralPurposeAllocator(.{}) = .init;
    <span class="tok-kw">const</span> gpa = general_purpose_allocator.allocator();
    <span class="tok-kw">const</span> args = <span class="tok-kw">try</span> std.process.argsAlloc(gpa);
    <span class="tok-kw">defer</span> std.process.argsFree(gpa, args);

    <span class="tok-kw">for</span> (args, <span class="tok-number">0</span>..) |arg, i| {
        std.debug.print(<span class="tok-str">&quot;{}: {s}\n&quot;</span>, .{ i, arg });
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe wasi_args.zig -target wasm32-wasi</kbd>
</samp></pre></figure>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>wasmtime wasi_args.wasm 123 hello</kbd>
0: wasi_args.wasm
1: 123
2: hello
</samp></pre></figure>
      <p>A more interesting example would be extracting the list of preopens from the runtime.
      This is now supported in the standard library via <code>std.fs.wasi.Preopens</code>:</p>
      <figure><figcaption class="zig-cap"><cite class="file">wasi_preopens.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> fs = std.fs;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> general_purpose_allocator: std.heap.GeneralPurposeAllocator(.{}) = .init;
    <span class="tok-kw">const</span> gpa = general_purpose_allocator.allocator();

    <span class="tok-kw">var</span> arena_instance = std.heap.ArenaAllocator.init(gpa);
    <span class="tok-kw">defer</span> arena_instance.deinit();
    <span class="tok-kw">const</span> arena = arena_instance.allocator();

    <span class="tok-kw">const</span> preopens = <span class="tok-kw">try</span> fs.wasi.preopensAlloc(arena);

    <span class="tok-kw">for</span> (preopens.names, <span class="tok-number">0</span>..) |preopen, i| {
        std.debug.print(<span class="tok-str">&quot;{}: {s}\n&quot;</span>, .{ i, preopen });
    }
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe wasi_preopens.zig -target wasm32-wasi</kbd>
</samp></pre></figure>

      <figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>wasmtime --dir=. wasi_preopens.wasm</kbd>
0: stdin
1: stdout
2: stderr
3: .
</samp></pre></figure>
      
      
      <h2 id="Targets"><a href="#toc-Targets">Targets</a> <a class="hdr" href="#Targets">§</a></h2>

      <p>
      <strong>Target</strong> refers to the computer that will be used to run an executable.
      It is composed of the CPU architecture, the set of enabled CPU features, operating system,
      minimum and maximum operating system version, ABI, and ABI version.
      </p>
      <p>
      Zig is a general-purpose programming language which means that it is designed to
      generate optimal code for a large set of targets. The command <code>zig targets</code>
      provides information about all of the targets the compiler is aware of.</p>
      <p>When no target option is provided to the compiler, the default choice
      is to target the <strong>host computer</strong>, meaning that the
      resulting executable will be <em>unsuitable for copying to a different
      computer</em>. In order to copy an executable to another computer, the compiler
      needs to know about the target requirements via the <code>-target</code> option.
      </p>
      <p>
      The Zig Standard Library (<code><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>)</code>) has
      cross-platform abstractions, making the same source code viable on many targets.
      Some code is more portable than other code. In general, Zig code is extremely
      portable compared to other programming languages.
      </p>
      <p>
      Each platform requires its own implementations to make Zig's
      cross-platform abstractions work. These implementations are at various
      degrees of completion. Each tagged release of the compiler comes with
      release notes that provide the full support table for each target.
      </p>
      
      <h2 id="Style-Guide"><a href="#toc-Style-Guide">Style Guide</a> <a class="hdr" href="#Style-Guide">§</a></h2>

      <p>
These coding conventions are not enforced by the compiler, but they are shipped in
this documentation along with the compiler in order to provide a point of
reference, should anyone wish to point to an authority on agreed upon Zig
coding style.
      </p>
      <h3 id="Avoid-Redundancy-in-Names"><a href="#toc-Avoid-Redundancy-in-Names">Avoid Redundancy in Names</a> <a class="hdr" href="#Avoid-Redundancy-in-Names">§</a></h3>

      <p>Avoid these words in type names:</p>
      <ul>
        <li>Value</li>
        <li>Data</li>
        <li>Context</li>
        <li>Manager</li>
        <li>utils, misc, or somebody's initials</li>
      </ul>
      <p>Everything is a value, all types are data, everything is context, all logic manages state.
      Nothing is communicated by using a word that applies to all types.</p>
      <p>Temptation to use "utilities", "miscellaneous", or somebody's initials
      is a failure to categorize, or more commonly, overcategorization. Such
      declarations can live at the root of a module that needs them with no
      namespace needed.</p>
      

      <h3 id="Avoid-Redundant-Names-in-Fully-Qualified-Namespaces"><a href="#toc-Avoid-Redundant-Names-in-Fully-Qualified-Namespaces">Avoid Redundant Names in Fully-Qualified Namespaces</a> <a class="hdr" href="#Avoid-Redundant-Names-in-Fully-Qualified-Namespaces">§</a></h3>

      <p>Every declaration is assigned a <strong>fully qualified
      namespace</strong> by the compiler, creating a tree structure. Choose names based
      on the fully-qualified namespace, and avoid redundant name segments.</p>
      <figure><figcaption class="zig-cap"><cite class="file">redundant_fqn.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> json = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> JsonValue = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        number: <span class="tok-type">f64</span>,
        boolean: <span class="tok-type">bool</span>,
        <span class="tok-comment">// ...</span>
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    std.debug.print(<span class="tok-str">&quot;{s}\n&quot;</span>, .{<span class="tok-builtin">@typeName</span>(json.JsonValue)});
}</code></pre></figure><figure><figcaption class="shell-cap">Shell</figcaption><pre><samp>$ <kbd>zig build-exe redundant_fqn.zig</kbd>
$ <kbd>./redundant_fqn</kbd>
redundant_fqn.json.JsonValue
</samp></pre></figure>

      <p>In this example, "json" is repeated in the fully-qualified namespace. The solution
      is to delete <code>Json</code> from <code>JsonValue</code>. In this example we have
      an empty struct named <code>json</code> but remember that files also act
      as part of the fully-qualified namespace.</p>
      <p>This example is an exception to the rule specified in <a href="#Avoid-Redundancy-in-Names">Avoid Redundancy in Names</a>.
      The meaning of the type has been reduced to its core: it is a json value. The name
      cannot be any more specific without being incorrect.</p>
      

      <h3 id="Whitespace"><a href="#toc-Whitespace">Whitespace</a> <a class="hdr" href="#Whitespace">§</a></h3>

      <ul>
        <li>
          4 space indentation
        </li>
        <li>
          Open braces on same line, unless you need to wrap.
        </li>
        <li>If a list of things is longer than 2, put each item on its own line and
          exercise the ability to put an extra comma at the end.
        </li>
        <li>
          Line length: aim for 100; use common sense.
        </li>
      </ul>
      
      <h3 id="Names"><a href="#toc-Names">Names</a> <a class="hdr" href="#Names">§</a></h3>

      <p>
      Roughly speaking: <code>camelCaseFunctionName</code>, <code>TitleCaseTypeName</code>,
              <code>snake_case_variable_name</code>. More precisely:
      </p>
      <ul>
        <li>
            If <code>x</code> is a <code><span class="tok-type">type</span></code>
            then <code>x</code> should be <code>TitleCase</code>, unless it
            is a <code><span class="tok-kw">struct</span></code> with 0 fields and is never meant to be instantiated,
            in which case it is considered to be a "namespace" and uses <code>snake_case</code>.
        </li>
        <li>
            If <code>x</code> is callable, and <code>x</code>'s return type is
            <code><span class="tok-type">type</span></code>, then <code>x</code> should be <code>TitleCase</code>.
        </li>
        <li>
            If <code>x</code> is otherwise callable, then <code>x</code> should
            be <code>camelCase</code>.
        </li>
        <li>
            Otherwise, <code>x</code> should be <code>snake_case</code>.
        </li>
      </ul>
      <p>
      Acronyms, initialisms, proper nouns, or any other word that has capitalization
      rules in written English are subject to naming conventions just like any other
      word. Even acronyms that are only 2 letters long are subject to these
      conventions.
      </p>
      <p>
      File names fall into two categories: types and namespaces. If the file
      (implicitly a struct) has top level fields, it should be named like any
      other struct with fields using <code class="file">TitleCase</code>. Otherwise,
      it should use <code class="file">snake_case</code>. Directory names should be
      <code class="file">snake_case</code>.
      </p>
      <p>
      These are general rules of thumb; if it makes sense to do something different,
      do what makes sense. For example, if there is an established convention such as
      <code>ENOENT</code>, follow the established convention.
      </p>
      
      <h3 id="Examples"><a href="#toc-Examples">Examples</a> <a class="hdr" href="#Examples">§</a></h3>

      <figure><figcaption class="zig-cap"><cite class="file">style_example.zig</cite></figcaption><pre><code><span class="tok-kw">const</span> namespace_name = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dir_name/file_name.zig&quot;</span>);
<span class="tok-kw">const</span> TypeName = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dir_name/TypeName.zig&quot;</span>);
<span class="tok-kw">var</span> global_var: <span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">const</span> const_name = <span class="tok-number">42</span>;
<span class="tok-kw">const</span> primitive_type_alias = <span class="tok-type">f32</span>;
<span class="tok-kw">const</span> string_alias = []<span class="tok-type">u8</span>;

<span class="tok-kw">const</span> StructName = <span class="tok-kw">struct</span> {
    field: <span class="tok-type">i32</span>,
};
<span class="tok-kw">const</span> StructAlias = StructName;

<span class="tok-kw">fn</span> <span class="tok-fn">functionName</span>(param_name: TypeName) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> functionPointer = functionName;
    functionPointer();
    functionPointer = otherFunction;
    functionPointer();
}
<span class="tok-kw">const</span> functionAlias = functionName;

<span class="tok-kw">fn</span> <span class="tok-fn">ListTemplateFunction</span>(<span class="tok-kw">comptime</span> ChildType: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> fixed_size: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> List(ChildType, fixed_size);
}

<span class="tok-kw">fn</span> <span class="tok-fn">ShortList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        field_name: [n]T,
        <span class="tok-kw">fn</span> <span class="tok-fn">methodName</span>() <span class="tok-type">void</span> {}
    };
}

<span class="tok-comment">// The word XML loses its casing when used in Zig identifiers.</span>
<span class="tok-kw">const</span> xml_document =
    <span class="tok-str">\\&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
    <span class="tok-str">\\&lt;document&gt;</span>
    <span class="tok-str">\\&lt;/document&gt;</span>
;
<span class="tok-kw">const</span> XmlParser = <span class="tok-kw">struct</span> {
    field: <span class="tok-type">i32</span>,
};

<span class="tok-comment">// The initials BE (Big Endian) are just another word in Zig identifier names.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">readU32Be</span>() <span class="tok-type">u32</span> {}</code></pre></figure>
      <p>
      See the <a href="#Zig-Standard-Library">Zig Standard Library</a> for more examples.
      </p>
      
      <h3 id="Doc-Comment-Guidance"><a href="#toc-Doc-Comment-Guidance">Doc Comment Guidance</a> <a class="hdr" href="#Doc-Comment-Guidance">§</a></h3>

      <ul>
        <li>Omit any information that is redundant based on the name of the thing being documented.</li>
        <li>Duplicating information onto multiple similar functions is encouraged because it helps IDEs and other tools provide better help text.</li>
        <li>Use the word <strong>assume</strong> to indicate invariants that cause <em>unchecked</em> <a href="#Illegal-Behavior">Illegal Behavior</a> when violated.</li>
        <li>Use the word <strong>assert</strong> to indicate invariants that cause <em>safety-checked</em> <a href="#Illegal-Behavior">Illegal Behavior</a> when violated.</li>
      </ul>
      
      
      <h2 id="Source-Encoding"><a href="#toc-Source-Encoding">Source Encoding</a> <a class="hdr" href="#Source-Encoding">§</a></h2>

      <p>Zig source code is encoded in UTF-8. An invalid UTF-8 byte sequence results in a compile error.</p>
      <p>Throughout all zig source code (including in comments), some code points are never allowed:</p>
      <ul>
        <li>Ascii control characters, except for U+000a (LF), U+000d (CR), and U+0009 (HT): U+0000 - U+0008, U+000b - U+000c, U+000e - U+0001f, U+007f.</li>
        <li>Non-Ascii Unicode line endings: U+0085 (NEL), U+2028 (LS), U+2029 (PS).</li>
      </ul>
      <p>
      LF (byte value 0x0a, code point U+000a, <code><span class="tok-str">'\n'</span></code>) is the line terminator in Zig source code.
      This byte value terminates every line of zig source code except the last line of the file.
      It is recommended that non-empty source files end with an empty line, which means the last byte would be 0x0a (LF).
      </p>
      <p>
      Each LF may be immediately preceded by a single CR (byte value 0x0d, code point U+000d, <code><span class="tok-str">'\r'</span></code>)
      to form a Windows style line ending, but this is discouraged. Note that in multiline strings, CRLF sequences will
      be encoded as LF when compiled into a zig program.
      A CR in any other context is not allowed.
      </p>
      <p>
      HT hard tabs (byte value 0x09, code point U+0009, <code><span class="tok-str">'\t'</span></code>) are interchangeable with
      SP spaces (byte value 0x20, code point U+0020, <code><span class="tok-str">' '</span></code>) as a token separator,
      but use of hard tabs is discouraged. See <a href="#Grammar">Grammar</a>.
      </p>
      <p>
      For compatibility with other tools, the compiler ignores a UTF-8-encoded byte order mark (U+FEFF)
      if it is the first Unicode code point in the source text. A byte order mark is not allowed anywhere else in the source.
      </p>
      <p>
      Note that running <kbd>zig fmt</kbd> on a source file will implement all recommendations mentioned here.
      </p>
      <p>
      Note that a tool reading Zig source code can make assumptions if the source code is assumed to be correct Zig code.
      For example, when identifying the ends of lines, a tool can use a naive search such as <code>/\n/</code>,
      or an <a href="https://msdn.microsoft.com/en-us/library/dd409797.aspx">advanced</a>
      search such as <code>/\r\n?|[\n\u0085\u2028\u2029]/</code>, and in either case line endings will be correctly identified.
      For another example, when identifying the whitespace before the first token on a line,
      a tool can either use a naive search such as <code>/[ \t]/</code>,
      or an <a href="https://tc39.es/ecma262/#sec-characterclassescape">advanced</a> search such as <code>/\s/</code>,
      and in either case whitespace will be correctly identified.
      </p>
      

      <h2 id="Keyword-Reference"><a href="#toc-Keyword-Reference">Keyword Reference</a> <a class="hdr" href="#Keyword-Reference">§</a></h2>

      <div class="table-wrapper">
      <table>
        <thead>
        <tr>
          <th scope="col">Keyword</th>
          <th scope="col">Description</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">addrspace</span></code></pre>
          </th>
          <td>
            The <code><span class="tok-kw">addrspace</span></code> keyword.
            <ul>
              <li>TODO add documentation for addrspace</li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">align</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">align</span></code> can be used to specify the alignment of a pointer.
            It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function.
            <ul>
              <li>See also <a href="#Alignment">Alignment</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">allowzero</span></code></pre>
          </th>
          <td>
            The pointer attribute <code><span class="tok-kw">allowzero</span></code> allows a pointer to have address zero.
            <ul>
              <li>See also <a href="#allowzero">allowzero</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">and</span></code></pre>
          </th>
          <td>
            The boolean operator <code><span class="tok-kw">and</span></code>.
            <ul>
              <li>See also <a href="#Operators">Operators</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">anyframe</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">anyframe</span></code> can be used as a type for variables which hold pointers to function frames.
            <ul>
              <li>See also <a href="#Async-Functions">Async Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">anytype</span></code></pre>
          </th>
          <td>
            Function parameters can be declared with <code><span class="tok-kw">anytype</span></code> in place of the type.
            The type will be inferred where the function is called.
            <ul>
              <li>See also <a href="#Function-Parameter-Type-Inference">Function Parameter Type Inference</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">asm</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">asm</span></code> begins an inline assembly expression. This allows for directly controlling the machine code generated on compilation.
            <ul>
              <li>See also <a href="#Assembly">Assembly</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">async</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">async</span></code> can be used before a function call to get a pointer to the function's frame when it suspends.
            <ul>
              <li>See also <a href="#Async-Functions">Async Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">await</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">await</span></code> can be used to suspend the current function until the frame provided after the <code><span class="tok-kw">await</span></code> completes.
            <code><span class="tok-kw">await</span></code> copies the value returned from the target function's frame to the caller.
            <ul>
              <li>See also <a href="#Async-Functions">Async Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">break</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">break</span></code> can be used with a block label to return a value from the block.
            It can also be used to exit a loop before iteration completes naturally.
            <ul>
              <li>See also <a href="#Blocks">Blocks</a>, <a href="#while">while</a>, <a href="#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">callconv</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">callconv</span></code> can be used to specify the calling convention in a function type.
            <ul>
              <li>See also <a href="#Functions">Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">catch</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">catch</span></code> can be used to evaluate an expression if the expression before it evaluates to an error.
            The expression after the <code><span class="tok-kw">catch</span></code> can optionally capture the error value.
            <ul>
              <li>See also <a href="#catch">catch</a>, <a href="#Operators">Operators</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">comptime</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">comptime</span></code> before a declaration can be used to label variables or function parameters as known at compile time.
            It can also be used to guarantee an expression is run at compile time.
            <ul>
              <li>See also <a href="#comptime">comptime</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">const</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">const</span></code> declares a variable that can not be modified.
            Used as a pointer attribute, it denotes the value referenced by the pointer cannot be modified.
            <ul>
              <li>See also <a href="#Variables">Variables</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">continue</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">continue</span></code> can be used in a loop to jump back to the beginning of the loop.
            <ul>
              <li>See also <a href="#while">while</a>, <a href="#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">defer</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">defer</span></code> will execute an expression when control flow leaves the current block.
            <ul>
              <li>See also <a href="#defer">defer</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">else</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">else</span></code> can be used to provide an alternate branch for <code><span class="tok-kw">if</span></code>, <code><span class="tok-kw">switch</span></code>,
            <code><span class="tok-kw">while</span></code>, and <code><span class="tok-kw">for</span></code> expressions.
            <ul>
              <li>If used after an if expression, the else branch will be executed if the test value returns false, null, or an error.</li>
              <li>If used within a switch expression, the else branch will be executed if the test value matches no other cases.</li>
              <li>If used after a loop expression, the else branch will be executed if the loop finishes without breaking.</li>
              <li>See also <a href="#if">if</a>, <a href="#switch">switch</a>, <a href="#while">while</a>, <a href="#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">enum</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">enum</span></code> defines an enum type.
            <ul>
              <li>See also <a href="#enum">enum</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">errdefer</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">errdefer</span></code> will execute an expression when control flow leaves the current block if the function returns an error, the errdefer expression can capture the unwrapped value.
            <ul>
              <li>See also <a href="#errdefer">errdefer</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">error</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">error</span></code> defines an error type.
            <ul>
              <li>See also <a href="#Errors">Errors</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">export</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">export</span></code> makes a function or variable externally visible in the generated object file.
            Exported functions default to the C calling convention.
            <ul>
              <li>See also <a href="#Functions">Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">extern</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">extern</span></code> can be used to declare a function or variable that will be resolved at link time, when linking statically
            or at runtime, when linking dynamically.
            <ul>
              <li>See also <a href="#Functions">Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">fn</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">fn</span></code> declares a function.
            <ul>
              <li>See also <a href="#Functions">Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">for</span></code></pre>
          </th>
          <td>
            A <code><span class="tok-kw">for</span></code> expression can be used to iterate over the elements of a slice, array, or tuple.
            <ul>
              <li>See also <a href="#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">if</span></code></pre>
          </th>
          <td>
            An <code><span class="tok-kw">if</span></code> expression can test boolean expressions, optional values, or error unions.
            For optional values or error unions, the if expression can capture the unwrapped value.
            <ul>
              <li>See also <a href="#if">if</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">inline</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">inline</span></code> can be used to label a loop expression such that it will be unrolled at compile time.
            It can also be used to force a function to be inlined at all call sites.
            <ul>
              <li>See also <a href="#inline-while">inline while</a>, <a href="#inline-for">inline for</a>, <a href="#Functions">Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">linksection</span></code></pre>
          </th>
          <td>
            The <code><span class="tok-kw">linksection</span></code> keyword can be used to specify what section the function or global variable will be put into (e.g. <code>.text</code>).
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">noalias</span></code></pre>
          </th>
          <td>
            The <code><span class="tok-kw">noalias</span></code> keyword.
            <ul>
              <li>TODO add documentation for noalias</li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">noinline</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">noinline</span></code> disallows function to be inlined in all call sites.
            <ul>
              <li>See also <a href="#Functions">Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">nosuspend</span></code></pre>
          </th>
          <td>
            The <code><span class="tok-kw">nosuspend</span></code> keyword can be used in front of a block, statement or expression, to mark a scope where no suspension points are reached.
            In particular, inside a <code><span class="tok-kw">nosuspend</span></code> scope:
            <ul>
              <li>Using the <code><span class="tok-kw">suspend</span></code> keyword results in a compile error.</li>
              <li>Using <code><span class="tok-kw">await</span></code> on a function frame which hasn't completed yet results in safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>.</li>
              <li>Calling an async function may result in safety-checked <a href="#Illegal-Behavior">Illegal Behavior</a>, because it's equivalent to <code>await async some_async_fn()</code>, which contains an <code><span class="tok-kw">await</span></code>.</li>
            </ul>
            Code inside a <code><span class="tok-kw">nosuspend</span></code> scope does not cause the enclosing function to become an <a href="#Async-Functions">async function</a>.
            <ul>
              <li>See also <a href="#Async-Functions">Async Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">opaque</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">opaque</span></code> defines an opaque type.
            <ul>
              <li>See also <a href="#opaque">opaque</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">or</span></code></pre>
          </th>
          <td>
            The boolean operator <code><span class="tok-kw">or</span></code>.
            <ul>
              <li>See also <a href="#Operators">Operators</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">orelse</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">orelse</span></code> can be used to evaluate an expression if the expression before it evaluates to null.
            <ul>
              <li>See also <a href="#Optionals">Optionals</a>, <a href="#Operators">Operators</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">packed</span></code></pre>
          </th>
          <td>
            The <code><span class="tok-kw">packed</span></code> keyword before a struct definition changes the struct's in-memory layout
            to the guaranteed <code><span class="tok-kw">packed</span></code> layout.
            <ul>
              <li>See also <a href="#packed-struct">packed struct</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">pub</span></code></pre>
          </th>
          <td>
            The <code><span class="tok-kw">pub</span></code> in front of a top level declaration makes the declaration available
            to reference from a different file than the one it is declared in.
            <ul>
              <li>See also <a href="#import">import</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">resume</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">resume</span></code> will continue execution of a function frame after the point the function was suspended.
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">return</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">return</span></code> exits a function with a value.
            <ul>
              <li>See also <a href="#Functions">Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">struct</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">struct</span></code> defines a struct.
            <ul>
              <li>See also <a href="#struct">struct</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">suspend</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">suspend</span></code> will cause control flow to return to the call site or resumer of the function.
            <code><span class="tok-kw">suspend</span></code> can also be used before a block within a function,
            to allow the function access to its frame before control flow returns to the call site.
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">switch</span></code></pre>
          </th>
          <td>
            A <code><span class="tok-kw">switch</span></code> expression can be used to test values of a common type.
            <code><span class="tok-kw">switch</span></code> cases can capture field values of a <a href="#Tagged-union">Tagged union</a>.
            <ul>
              <li>See also <a href="#switch">switch</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">test</span></code></pre>
          </th>
          <td>
            The <code><span class="tok-kw">test</span></code> keyword can be used to denote a top-level block of code
            used to make sure behavior meets expectations.
            <ul>
              <li>See also <a href="#Zig-Test">Zig Test</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">threadlocal</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">threadlocal</span></code> can be used to specify a variable as thread-local.
            <ul>
              <li>See also <a href="#Thread-Local-Variables">Thread Local Variables</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">try</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">try</span></code> evaluates an error union expression.
            If it is an error, it returns from the current function with the same error.
            Otherwise, the expression results in the unwrapped value.
            <ul>
              <li>See also <a href="#try">try</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">union</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">union</span></code> defines a union.
            <ul>
              <li>See also <a href="#union">union</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">unreachable</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">unreachable</span></code> can be used to assert that control flow will never happen upon a particular location.
            Depending on the build mode, <code><span class="tok-kw">unreachable</span></code> may emit a panic.
            <ul>
              <li>Emits a panic in <code>Debug</code> and <code>ReleaseSafe</code> mode, or when using <kbd>zig test</kbd>.</li>
              <li>Does not emit a panic in <code>ReleaseFast</code> and <code>ReleaseSmall</code> mode.</li>
              <li>See also <a href="#unreachable">unreachable</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">usingnamespace</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">usingnamespace</span></code> is a top-level declaration that imports all the public declarations of the operand,
            which must be a struct, union, or enum, into the current scope.
            <ul>
              <li>See also <a href="#usingnamespace">usingnamespace</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">var</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">var</span></code> declares a variable that may be modified.
            <ul>
              <li>See also <a href="#Variables">Variables</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">volatile</span></code></pre>
          </th>
          <td>
            <code><span class="tok-kw">volatile</span></code> can be used to denote loads or stores of a pointer have side effects.
            It can also modify an inline assembly expression to denote it has side effects.
            <ul>
              <li>See also <a href="#volatile">volatile</a>, <a href="#Assembly">Assembly</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <th scope="row">
            <pre><code><span class="tok-kw">while</span></code></pre>
          </th>
          <td>
            A <code><span class="tok-kw">while</span></code> expression can be used to repeatedly test a boolean, optional, or error union expression,
            and cease looping when that expression evaluates to false, null, or an error, respectively.
            <ul>
              <li>See also <a href="#while">while</a></li>
            </ul>
          </td>
        </tr>
        </tbody>
      </table>
      </div>
      

      <h2 id="Appendix"><a href="#toc-Appendix">Appendix</a> <a class="hdr" href="#Appendix">§</a></h2>

      <h3 id="Containers"><a href="#toc-Containers">Containers</a> <a class="hdr" href="#Containers">§</a></h3>

      <p>
      A <em>container</em> in Zig is any syntactical construct that acts as a namespace to hold <a href="#Container-Level-Variables">variable</a> and <a href="#Functions">function</a> declarations.
      Containers are also type definitions which can be instantiated.
      <a href="#struct">Structs</a>, <a href="#enum">enums</a>, <a href="#union">unions</a>, <a href="#opaque">opaques</a>, and even Zig source files themselves are containers.
      </p>
      <p>
      Although containers (except Zig source files) use curly braces to surround their definition, they should not be confused with <a href="#Blocks">blocks</a> or functions.
      Containers do not contain statements.
      </p>
      

      <h3 id="Grammar"><a href="#toc-Grammar">Grammar</a> <a class="hdr" href="#Grammar">§</a></h3>

      <figure><figcaption class="peg-cap"><cite class="file">grammar.y</cite></figcaption><pre><code>Root &lt;- skip container_doc_comment? ContainerMembers eof

# *** Top level ***
ContainerMembers &lt;- ContainerDeclaration* (ContainerField COMMA)* (ContainerField / ContainerDeclaration*)

ContainerDeclaration &lt;- TestDecl / ComptimeDecl / doc_comment? KEYWORD_pub? Decl

TestDecl &lt;- KEYWORD_test (STRINGLITERALSINGLE / IDENTIFIER)? Block

ComptimeDecl &lt;- KEYWORD_comptime Block

Decl
    &lt;- (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE? / KEYWORD_inline / KEYWORD_noinline)? FnProto (SEMICOLON / Block)
     / (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE?)? KEYWORD_threadlocal? GlobalVarDecl
     / KEYWORD_usingnamespace Expr SEMICOLON

FnProto &lt;- KEYWORD_fn IDENTIFIER? LPAREN ParamDeclList RPAREN ByteAlign? AddrSpace? LinkSection? CallConv? EXCLAMATIONMARK? TypeExpr

VarDeclProto &lt;- (KEYWORD_const / KEYWORD_var) IDENTIFIER (COLON TypeExpr)? ByteAlign? AddrSpace? LinkSection?

GlobalVarDecl &lt;- VarDeclProto (EQUAL Expr)? SEMICOLON

ContainerField &lt;- doc_comment? KEYWORD_comptime? !KEYWORD_fn (IDENTIFIER COLON)? TypeExpr ByteAlign? (EQUAL Expr)?

# *** Block Level ***
Statement
    &lt;- KEYWORD_comptime ComptimeStatement
     / KEYWORD_nosuspend BlockExprStatement
     / KEYWORD_suspend BlockExprStatement
     / KEYWORD_defer BlockExprStatement
     / KEYWORD_errdefer Payload? BlockExprStatement
     / IfStatement
     / LabeledStatement
     / SwitchExpr
     / VarDeclExprStatement

ComptimeStatement
    &lt;- BlockExpr
     / VarDeclExprStatement

IfStatement
    &lt;- IfPrefix BlockExpr ( KEYWORD_else Payload? Statement )?
     / IfPrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )

LabeledStatement &lt;- BlockLabel? (Block / LoopStatement)

LoopStatement &lt;- KEYWORD_inline? (ForStatement / WhileStatement)

ForStatement
    &lt;- ForPrefix BlockExpr ( KEYWORD_else Statement )?
     / ForPrefix AssignExpr ( SEMICOLON / KEYWORD_else Statement )

WhileStatement
    &lt;- WhilePrefix BlockExpr ( KEYWORD_else Payload? Statement )?
     / WhilePrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )

BlockExprStatement
    &lt;- BlockExpr
     / AssignExpr SEMICOLON

BlockExpr &lt;- BlockLabel? Block

# An expression, assignment, or any destructure, as a statement.
VarDeclExprStatement
    &lt;- VarDeclProto (COMMA (VarDeclProto / Expr))* EQUAL Expr SEMICOLON
     / Expr (AssignOp Expr / (COMMA (VarDeclProto / Expr))+ EQUAL Expr)? SEMICOLON

# *** Expression Level ***

# An assignment or a destructure whose LHS are all lvalue expressions.
AssignExpr &lt;- Expr (AssignOp Expr / (COMMA Expr)+ EQUAL Expr)?

SingleAssignExpr &lt;- Expr (AssignOp Expr)?

Expr &lt;- BoolOrExpr

BoolOrExpr &lt;- BoolAndExpr (KEYWORD_or BoolAndExpr)*

BoolAndExpr &lt;- CompareExpr (KEYWORD_and CompareExpr)*

CompareExpr &lt;- BitwiseExpr (CompareOp BitwiseExpr)?

BitwiseExpr &lt;- BitShiftExpr (BitwiseOp BitShiftExpr)*

BitShiftExpr &lt;- AdditionExpr (BitShiftOp AdditionExpr)*

AdditionExpr &lt;- MultiplyExpr (AdditionOp MultiplyExpr)*

MultiplyExpr &lt;- PrefixExpr (MultiplyOp PrefixExpr)*

PrefixExpr &lt;- PrefixOp* PrimaryExpr

PrimaryExpr
    &lt;- AsmExpr
     / IfExpr
     / KEYWORD_break BreakLabel? Expr?
     / KEYWORD_comptime Expr
     / KEYWORD_nosuspend Expr
     / KEYWORD_continue BreakLabel?
     / KEYWORD_resume Expr
     / KEYWORD_return Expr?
     / BlockLabel? LoopExpr
     / Block
     / CurlySuffixExpr

IfExpr &lt;- IfPrefix Expr (KEYWORD_else Payload? Expr)?

Block &lt;- LBRACE Statement* RBRACE

LoopExpr &lt;- KEYWORD_inline? (ForExpr / WhileExpr)

ForExpr &lt;- ForPrefix Expr (KEYWORD_else Expr)?

WhileExpr &lt;- WhilePrefix Expr (KEYWORD_else Payload? Expr)?

CurlySuffixExpr &lt;- TypeExpr InitList?

InitList
    &lt;- LBRACE FieldInit (COMMA FieldInit)* COMMA? RBRACE
     / LBRACE Expr (COMMA Expr)* COMMA? RBRACE
     / LBRACE RBRACE

TypeExpr &lt;- PrefixTypeOp* ErrorUnionExpr

ErrorUnionExpr &lt;- SuffixExpr (EXCLAMATIONMARK TypeExpr)?

SuffixExpr
    &lt;- KEYWORD_async PrimaryTypeExpr SuffixOp* FnCallArguments
     / PrimaryTypeExpr (SuffixOp / FnCallArguments)*

PrimaryTypeExpr
    &lt;- BUILTINIDENTIFIER FnCallArguments
     / CHAR_LITERAL
     / ContainerDecl
     / DOT IDENTIFIER
     / DOT InitList
     / ErrorSetDecl
     / FLOAT
     / FnProto
     / GroupedExpr
     / LabeledTypeExpr
     / IDENTIFIER
     / IfTypeExpr
     / INTEGER
     / KEYWORD_comptime TypeExpr
     / KEYWORD_error DOT IDENTIFIER
     / KEYWORD_anyframe
     / KEYWORD_unreachable
     / STRINGLITERAL
     / SwitchExpr

ContainerDecl &lt;- (KEYWORD_extern / KEYWORD_packed)? ContainerDeclAuto

ErrorSetDecl &lt;- KEYWORD_error LBRACE IdentifierList RBRACE

GroupedExpr &lt;- LPAREN Expr RPAREN

IfTypeExpr &lt;- IfPrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?

LabeledTypeExpr
    &lt;- BlockLabel Block
     / BlockLabel? LoopTypeExpr

LoopTypeExpr &lt;- KEYWORD_inline? (ForTypeExpr / WhileTypeExpr)

ForTypeExpr &lt;- ForPrefix TypeExpr (KEYWORD_else TypeExpr)?

WhileTypeExpr &lt;- WhilePrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?

SwitchExpr &lt;- KEYWORD_switch LPAREN Expr RPAREN LBRACE SwitchProngList RBRACE

# *** Assembly ***
AsmExpr &lt;- KEYWORD_asm KEYWORD_volatile? LPAREN Expr AsmOutput? RPAREN

AsmOutput &lt;- COLON AsmOutputList AsmInput?

AsmOutputItem &lt;- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN (MINUSRARROW TypeExpr / IDENTIFIER) RPAREN

AsmInput &lt;- COLON AsmInputList AsmClobbers?

AsmInputItem &lt;- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN Expr RPAREN

AsmClobbers &lt;- COLON StringList

# *** Helper grammar ***
BreakLabel &lt;- COLON IDENTIFIER

BlockLabel &lt;- IDENTIFIER COLON

FieldInit &lt;- DOT IDENTIFIER EQUAL Expr

WhileContinueExpr &lt;- COLON LPAREN AssignExpr RPAREN

LinkSection &lt;- KEYWORD_linksection LPAREN Expr RPAREN

AddrSpace &lt;- KEYWORD_addrspace LPAREN Expr RPAREN

# Fn specific
CallConv &lt;- KEYWORD_callconv LPAREN Expr RPAREN

ParamDecl
    &lt;- doc_comment? (KEYWORD_noalias / KEYWORD_comptime)? (IDENTIFIER COLON)? ParamType
     / DOT3

ParamType
    &lt;- KEYWORD_anytype
     / TypeExpr

# Control flow prefixes
IfPrefix &lt;- KEYWORD_if LPAREN Expr RPAREN PtrPayload?

WhilePrefix &lt;- KEYWORD_while LPAREN Expr RPAREN PtrPayload? WhileContinueExpr?

ForPrefix &lt;- KEYWORD_for LPAREN ForArgumentsList RPAREN PtrListPayload

# Payloads
Payload &lt;- PIPE IDENTIFIER PIPE

PtrPayload &lt;- PIPE ASTERISK? IDENTIFIER PIPE

PtrIndexPayload &lt;- PIPE ASTERISK? IDENTIFIER (COMMA IDENTIFIER)? PIPE

PtrListPayload &lt;- PIPE ASTERISK? IDENTIFIER (COMMA ASTERISK? IDENTIFIER)* COMMA? PIPE

# Switch specific
SwitchProng &lt;- KEYWORD_inline? SwitchCase EQUALRARROW PtrIndexPayload? SingleAssignExpr

SwitchCase
    &lt;- SwitchItem (COMMA SwitchItem)* COMMA?
     / KEYWORD_else

SwitchItem &lt;- Expr (DOT3 Expr)?

# For specific
ForArgumentsList &lt;- ForItem (COMMA ForItem)* COMMA?

ForItem &lt;- Expr (DOT2 Expr?)?

# Operators
AssignOp
    &lt;- ASTERISKEQUAL
     / ASTERISKPIPEEQUAL
     / SLASHEQUAL
     / PERCENTEQUAL
     / PLUSEQUAL
     / PLUSPIPEEQUAL
     / MINUSEQUAL
     / MINUSPIPEEQUAL
     / LARROW2EQUAL
     / LARROW2PIPEEQUAL
     / RARROW2EQUAL
     / AMPERSANDEQUAL
     / CARETEQUAL
     / PIPEEQUAL
     / ASTERISKPERCENTEQUAL
     / PLUSPERCENTEQUAL
     / MINUSPERCENTEQUAL
     / EQUAL

CompareOp
    &lt;- EQUALEQUAL
     / EXCLAMATIONMARKEQUAL
     / LARROW
     / RARROW
     / LARROWEQUAL
     / RARROWEQUAL

BitwiseOp
    &lt;- AMPERSAND
     / CARET
     / PIPE
     / KEYWORD_orelse
     / KEYWORD_catch Payload?

BitShiftOp
    &lt;- LARROW2
     / RARROW2
     / LARROW2PIPE

AdditionOp
    &lt;- PLUS
     / MINUS
     / PLUS2
     / PLUSPERCENT
     / MINUSPERCENT
     / PLUSPIPE
     / MINUSPIPE

MultiplyOp
    &lt;- PIPE2
     / ASTERISK
     / SLASH
     / PERCENT
     / ASTERISK2
     / ASTERISKPERCENT
     / ASTERISKPIPE

PrefixOp
    &lt;- EXCLAMATIONMARK
     / MINUS
     / TILDE
     / MINUSPERCENT
     / AMPERSAND
     / KEYWORD_try
     / KEYWORD_await

PrefixTypeOp
    &lt;- QUESTIONMARK
     / KEYWORD_anyframe MINUSRARROW
     / SliceTypeStart (ByteAlign / AddrSpace / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*
     / PtrTypeStart (AddrSpace / KEYWORD_align LPAREN Expr (COLON Expr COLON Expr)? RPAREN / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*
     / ArrayTypeStart

SuffixOp
    &lt;- LBRACKET Expr (DOT2 (Expr? (COLON Expr)?)?)? RBRACKET
     / DOT IDENTIFIER
     / DOTASTERISK
     / DOTQUESTIONMARK

FnCallArguments &lt;- LPAREN ExprList RPAREN

# Ptr specific
SliceTypeStart &lt;- LBRACKET (COLON Expr)? RBRACKET

PtrTypeStart
    &lt;- ASTERISK
     / ASTERISK2
     / LBRACKET ASTERISK (LETTERC / COLON Expr)? RBRACKET

ArrayTypeStart &lt;- LBRACKET Expr (COLON Expr)? RBRACKET

# ContainerDecl specific
ContainerDeclAuto &lt;- ContainerDeclType LBRACE container_doc_comment? ContainerMembers RBRACE

ContainerDeclType
    &lt;- KEYWORD_struct (LPAREN Expr RPAREN)?
     / KEYWORD_opaque
     / KEYWORD_enum (LPAREN Expr RPAREN)?
     / KEYWORD_union (LPAREN (KEYWORD_enum (LPAREN Expr RPAREN)? / Expr) RPAREN)?

# Alignment
ByteAlign &lt;- KEYWORD_align LPAREN Expr RPAREN

# Lists
IdentifierList &lt;- (doc_comment? IDENTIFIER COMMA)* (doc_comment? IDENTIFIER)?

SwitchProngList &lt;- (SwitchProng COMMA)* SwitchProng?

AsmOutputList &lt;- (AsmOutputItem COMMA)* AsmOutputItem?

AsmInputList &lt;- (AsmInputItem COMMA)* AsmInputItem?

StringList &lt;- (STRINGLITERAL COMMA)* STRINGLITERAL?

ParamDeclList &lt;- (ParamDecl COMMA)* ParamDecl?

ExprList &lt;- (Expr COMMA)* Expr?

# *** Tokens ***
eof &lt;- !.
bin &lt;- [01]
bin_ &lt;- '_'? bin
oct &lt;- [0-7]
oct_ &lt;- '_'? oct
hex &lt;- [0-9a-fA-F]
hex_ &lt;- '_'? hex
dec &lt;- [0-9]
dec_ &lt;- '_'? dec

bin_int &lt;- bin bin_*
oct_int &lt;- oct oct_*
dec_int &lt;- dec dec_*
hex_int &lt;- hex hex_*

ox80_oxBF &lt;- [\200-\277]
oxF4 &lt;- '\364'
ox80_ox8F &lt;- [\200-\217]
oxF1_oxF3 &lt;- [\361-\363]
oxF0 &lt;- '\360'
ox90_0xBF &lt;- [\220-\277]
oxEE_oxEF &lt;- [\356-\357]
oxED &lt;- '\355'
ox80_ox9F &lt;- [\200-\237]
oxE1_oxEC &lt;- [\341-\354]
oxE0 &lt;- '\340'
oxA0_oxBF &lt;- [\240-\277]
oxC2_oxDF &lt;- [\302-\337]

# From https://lemire.me/blog/2018/05/09/how-quickly-can-you-check-that-a-string-is-valid-unicode-utf-8/
# First Byte      Second Byte     Third Byte      Fourth Byte
# [0x00,0x7F]
# [0xC2,0xDF]     [0x80,0xBF]
#    0xE0         [0xA0,0xBF]     [0x80,0xBF]
# [0xE1,0xEC]     [0x80,0xBF]     [0x80,0xBF]
#    0xED         [0x80,0x9F]     [0x80,0xBF]
# [0xEE,0xEF]     [0x80,0xBF]     [0x80,0xBF]
#    0xF0         [0x90,0xBF]     [0x80,0xBF]     [0x80,0xBF]
# [0xF1,0xF3]     [0x80,0xBF]     [0x80,0xBF]     [0x80,0xBF]
#    0xF4         [0x80,0x8F]     [0x80,0xBF]     [0x80,0xBF]

mb_utf8_literal &lt;-
       oxF4      ox80_ox8F ox80_oxBF ox80_oxBF
     / oxF1_oxF3 ox80_oxBF ox80_oxBF ox80_oxBF
     / oxF0      ox90_0xBF ox80_oxBF ox80_oxBF
     / oxEE_oxEF ox80_oxBF ox80_oxBF
     / oxED      ox80_ox9F ox80_oxBF
     / oxE1_oxEC ox80_oxBF ox80_oxBF
     / oxE0      oxA0_oxBF ox80_oxBF
     / oxC2_oxDF ox80_oxBF

ascii_char_not_nl_slash_squote &lt;- [\000-\011\013-\046\050-\133\135-\177]

char_escape
    &lt;- &quot;\\x&quot; hex hex
     / &quot;\\u{&quot; hex+ &quot;}&quot;
     / &quot;\\&quot; [nr\\t'&quot;]
char_char
    &lt;- mb_utf8_literal
     / char_escape
     / ascii_char_not_nl_slash_squote

string_char
    &lt;- char_escape
     / [^\\&quot;\n]

container_doc_comment &lt;- ('//!' [^\n]* [ \n]* skip)+
doc_comment &lt;- ('///' [^\n]* [ \n]* skip)+
line_comment &lt;- '//' ![!/][^\n]* / '////' [^\n]*
line_string &lt;- (&quot;\\\\&quot; [^\n]* [ \n]*)+
skip &lt;- ([ \n] / line_comment)*

CHAR_LITERAL &lt;- &quot;'&quot; char_char &quot;'&quot; skip
FLOAT
    &lt;- &quot;0x&quot; hex_int &quot;.&quot; hex_int ([pP] [-+]? dec_int)? skip
     /      dec_int &quot;.&quot; dec_int ([eE] [-+]? dec_int)? skip
     / &quot;0x&quot; hex_int [pP] [-+]? dec_int skip
     /      dec_int [eE] [-+]? dec_int skip
INTEGER
    &lt;- &quot;0b&quot; bin_int skip
     / &quot;0o&quot; oct_int skip
     / &quot;0x&quot; hex_int skip
     /      dec_int   skip
STRINGLITERALSINGLE &lt;- &quot;\&quot;&quot; string_char* &quot;\&quot;&quot; skip
STRINGLITERAL
    &lt;- STRINGLITERALSINGLE
     / (line_string                 skip)+
IDENTIFIER
    &lt;- !keyword [A-Za-z_] [A-Za-z0-9_]* skip
     / &quot;@&quot; STRINGLITERALSINGLE
BUILTINIDENTIFIER &lt;- &quot;@&quot;[A-Za-z_][A-Za-z0-9_]* skip


AMPERSAND            &lt;- '&amp;'      ![=]      skip
AMPERSANDEQUAL       &lt;- '&amp;='               skip
ASTERISK             &lt;- '*'      ![*%=|]   skip
ASTERISK2            &lt;- '**'               skip
ASTERISKEQUAL        &lt;- '*='               skip
ASTERISKPERCENT      &lt;- '*%'     ![=]      skip
ASTERISKPERCENTEQUAL &lt;- '*%='              skip
ASTERISKPIPE         &lt;- '*|'     ![=]      skip
ASTERISKPIPEEQUAL    &lt;- '*|='              skip
CARET                &lt;- '^'      ![=]      skip
CARETEQUAL           &lt;- '^='               skip
COLON                &lt;- ':'                skip
COMMA                &lt;- ','                skip
DOT                  &lt;- '.'      ![*.?]    skip
DOT2                 &lt;- '..'     ![.]      skip
DOT3                 &lt;- '...'              skip
DOTASTERISK          &lt;- '.*'               skip
DOTQUESTIONMARK      &lt;- '.?'               skip
EQUAL                &lt;- '='      ![&gt;=]     skip
EQUALEQUAL           &lt;- '=='               skip
EQUALRARROW          &lt;- '=&gt;'               skip
EXCLAMATIONMARK      &lt;- '!'      ![=]      skip
EXCLAMATIONMARKEQUAL &lt;- '!='               skip
LARROW               &lt;- '&lt;'      ![&lt;=]     skip
LARROW2              &lt;- '&lt;&lt;'     ![=|]     skip
LARROW2EQUAL         &lt;- '&lt;&lt;='              skip
LARROW2PIPE          &lt;- '&lt;&lt;|'    ![=]      skip
LARROW2PIPEEQUAL     &lt;- '&lt;&lt;|='             skip
LARROWEQUAL          &lt;- '&lt;='               skip
LBRACE               &lt;- '{'                skip
LBRACKET             &lt;- '['                skip
LPAREN               &lt;- '('                skip
MINUS                &lt;- '-'      ![%=&gt;|]   skip
MINUSEQUAL           &lt;- '-='               skip
MINUSPERCENT         &lt;- '-%'     ![=]      skip
MINUSPERCENTEQUAL    &lt;- '-%='              skip
MINUSPIPE            &lt;- '-|'     ![=]      skip
MINUSPIPEEQUAL       &lt;- '-|='              skip
MINUSRARROW          &lt;- '-&gt;'               skip
PERCENT              &lt;- '%'      ![=]      skip
PERCENTEQUAL         &lt;- '%='               skip
PIPE                 &lt;- '|'      ![|=]     skip
PIPE2                &lt;- '||'               skip
PIPEEQUAL            &lt;- '|='               skip
PLUS                 &lt;- '+'      ![%+=|]   skip
PLUS2                &lt;- '++'               skip
PLUSEQUAL            &lt;- '+='               skip
PLUSPERCENT          &lt;- '+%'     ![=]      skip
PLUSPERCENTEQUAL     &lt;- '+%='              skip
PLUSPIPE             &lt;- '+|'     ![=]      skip
PLUSPIPEEQUAL        &lt;- '+|='              skip
LETTERC              &lt;- 'c'                skip
QUESTIONMARK         &lt;- '?'                skip
RARROW               &lt;- '&gt;'      ![&gt;=]     skip
RARROW2              &lt;- '&gt;&gt;'     ![=]      skip
RARROW2EQUAL         &lt;- '&gt;&gt;='              skip
RARROWEQUAL          &lt;- '&gt;='               skip
RBRACE               &lt;- '}'                skip
RBRACKET             &lt;- ']'                skip
RPAREN               &lt;- ')'                skip
SEMICOLON            &lt;- ';'                skip
SLASH                &lt;- '/'      ![=]      skip
SLASHEQUAL           &lt;- '/='               skip
TILDE                &lt;- '~'                skip

end_of_word &lt;- ![a-zA-Z0-9_] skip
KEYWORD_addrspace   &lt;- 'addrspace'   end_of_word
KEYWORD_align       &lt;- 'align'       end_of_word
KEYWORD_allowzero   &lt;- 'allowzero'   end_of_word
KEYWORD_and         &lt;- 'and'         end_of_word
KEYWORD_anyframe    &lt;- 'anyframe'    end_of_word
KEYWORD_anytype     &lt;- 'anytype'     end_of_word
KEYWORD_asm         &lt;- 'asm'         end_of_word
KEYWORD_async       &lt;- 'async'       end_of_word
KEYWORD_await       &lt;- 'await'       end_of_word
KEYWORD_break       &lt;- 'break'       end_of_word
KEYWORD_callconv    &lt;- 'callconv'    end_of_word
KEYWORD_catch       &lt;- 'catch'       end_of_word
KEYWORD_comptime    &lt;- 'comptime'    end_of_word
KEYWORD_const       &lt;- 'const'       end_of_word
KEYWORD_continue    &lt;- 'continue'    end_of_word
KEYWORD_defer       &lt;- 'defer'       end_of_word
KEYWORD_else        &lt;- 'else'        end_of_word
KEYWORD_enum        &lt;- 'enum'        end_of_word
KEYWORD_errdefer    &lt;- 'errdefer'    end_of_word
KEYWORD_error       &lt;- 'error'       end_of_word
KEYWORD_export      &lt;- 'export'      end_of_word
KEYWORD_extern      &lt;- 'extern'      end_of_word
KEYWORD_fn          &lt;- 'fn'          end_of_word
KEYWORD_for         &lt;- 'for'         end_of_word
KEYWORD_if          &lt;- 'if'          end_of_word
KEYWORD_inline      &lt;- 'inline'      end_of_word
KEYWORD_noalias     &lt;- 'noalias'     end_of_word
KEYWORD_nosuspend   &lt;- 'nosuspend'   end_of_word
KEYWORD_noinline    &lt;- 'noinline'    end_of_word
KEYWORD_opaque      &lt;- 'opaque'      end_of_word
KEYWORD_or          &lt;- 'or'          end_of_word
KEYWORD_orelse      &lt;- 'orelse'      end_of_word
KEYWORD_packed      &lt;- 'packed'      end_of_word
KEYWORD_pub         &lt;- 'pub'         end_of_word
KEYWORD_resume      &lt;- 'resume'      end_of_word
KEYWORD_return      &lt;- 'return'      end_of_word
KEYWORD_linksection &lt;- 'linksection' end_of_word
KEYWORD_struct      &lt;- 'struct'      end_of_word
KEYWORD_suspend     &lt;- 'suspend'     end_of_word
KEYWORD_switch      &lt;- 'switch'      end_of_word
KEYWORD_test        &lt;- 'test'        end_of_word
KEYWORD_threadlocal &lt;- 'threadlocal' end_of_word
KEYWORD_try         &lt;- 'try'         end_of_word
KEYWORD_union       &lt;- 'union'       end_of_word
KEYWORD_unreachable &lt;- 'unreachable' end_of_word
KEYWORD_usingnamespace &lt;- 'usingnamespace' end_of_word
KEYWORD_var         &lt;- 'var'         end_of_word
KEYWORD_volatile    &lt;- 'volatile'    end_of_word
KEYWORD_while       &lt;- 'while'       end_of_word

keyword &lt;- KEYWORD_addrspace / KEYWORD_align / KEYWORD_allowzero / KEYWORD_and
         / KEYWORD_anyframe / KEYWORD_anytype / KEYWORD_asm / KEYWORD_async
         / KEYWORD_await / KEYWORD_break / KEYWORD_callconv / KEYWORD_catch
         / KEYWORD_comptime / KEYWORD_const / KEYWORD_continue / KEYWORD_defer
         / KEYWORD_else / KEYWORD_enum / KEYWORD_errdefer / KEYWORD_error / KEYWORD_export
         / KEYWORD_extern / KEYWORD_fn / KEYWORD_for / KEYWORD_if
         / KEYWORD_inline / KEYWORD_noalias / KEYWORD_nosuspend / KEYWORD_noinline
         / KEYWORD_opaque / KEYWORD_or / KEYWORD_orelse / KEYWORD_packed
         / KEYWORD_pub / KEYWORD_resume / KEYWORD_return / KEYWORD_linksection
         / KEYWORD_struct / KEYWORD_suspend / KEYWORD_switch / KEYWORD_test
         / KEYWORD_threadlocal / KEYWORD_try / KEYWORD_union / KEYWORD_unreachable
         / KEYWORD_usingnamespace / KEYWORD_var / KEYWORD_volatile / KEYWORD_while</code></pre></figure>
      
      <h3 id="Zen"><a href="#toc-Zen">Zen</a> <a class="hdr" href="#Zen">§</a></h3>

      <ul>
        <li>Communicate intent precisely.</li>
        <li>Edge cases matter.</li>
        <li>Favor reading code over writing code.</li>
        <li>Only one obvious way to do things.</li>
        <li>Runtime crashes are better than bugs.</li>
        <li>Compile errors are better than runtime crashes.</li>
        <li>Incremental improvements.</li>
        <li>Avoid local maximums.</li>
        <li>Reduce the amount one must remember.</li>
        <li>Focus on code rather than style.</li>
        <li>Resource allocation may fail; resource deallocation must succeed.</li>
        <li>Memory is a resource.</li>
        <li>Together we serve the users.</li>
      </ul>
      
      
      </main></div>
    </div>
  </body>
</html>
