<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>0.12.0 Release Notes âš¡ The Zig Programming Language</title>
    <link rel="icon" href="/favicon.png">
    <link rel="icon" href="/favicon.svg">
    <style>
      :root{
         --nav-width: 24em;
         --nav-margin-l: 1em;
      }
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }
      header {
        padding: 0 1em;
      }
      h1, h2, h3, h4, h5 {
        margin: 0.5em 0 0.5em;
        line-height: 1.2;
        font-weight: bold;
        clear: both;
      }
      h1, h2 { font-size: 2.0em; }
      h3 { font-size: 1.5em; }
      h4 { font-size: 1.25em; }
      h5 { font-size: 1.0em; }
      #contents {
        max-width: 60em;
        margin: auto;
        padding: 0 1em;
      }
      #navigation {
        padding: 0 1em;
      }

      @media screen and (min-width: 1025px) {
        header {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
        header h1 {
          margin: auto;
          max-width: 30em;
        }
        #navigation {
          overflow: auto;
          width: var(--nav-width);
          height: 100vh;
          position: fixed;
          top:0;
          left:0;
          bottom:0;
          padding: unset;
          margin-left: var(--nav-margin-l);
        }
        #navigation nav ul {
          padding-left: 1em;
        }
        #contents-wrapper {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
    }

    a:hover,a:focus {
      background: #fff2a8;
    }
    dt {
      font-weight: bold;
    }
    th, td {
      padding: 0.6em;
    }
    tr:nth-child(even) {
      background: #f2f3f3;
    }
    .t0_1, .t37, .t37_1 {
      font-weight: bold;
    }
    .t2_0 {
      color: #575757;
    }
    .t31_1 {
      color: #b40000;
    }
    .t32_1 {
      color: green;
    }
    .t36_1 {
      color: #005C7A;
    }
    .file {
      font-weight: bold;
      border: unset;
    }
    code {
      background: #f8f8f8;
      border: 1px dotted silver;
      padding-left: 0.3em;
      padding-right: 0.3em;
    }
    pre > code {
      display: block;
      overflow: auto;
      padding: 0.5em;
      border: 1px solid #eee;
      line-height: normal;
    }
    samp {
      background: #fafafa;
    }
    pre > samp {
      display: block;
      overflow: auto;
      padding: 0.5em;
      border: 1px solid #eee;
      line-height: normal;
    }
    kbd {
      font-weight: bold;
    }
    .table-wrapper {
      width: 100%;
      overflow-x: auto;
    }

    .tok-kw {
        color: #333;
        font-weight: bold;
    }
    .tok-str {
        color: #d14;
    }
    .tok-builtin {
        color: #005C7A;
    }
    .tok-comment {
        color: #545454;
        font-style: italic;
    }
    .tok-fn {
        color: #900;
        font-weight: bold;
    }
    .tok-null {
        color: #005C5C;
    }
    .tok-number {
        color: #005C5C;
    }
    .tok-type {
        color: #458;
        font-weight: bold;
    }

    figure {
      margin: auto 0;
    }
    figure pre {
      margin-top: 0;
    }

    figcaption {
      padding-left: 0.5em;
      font-size: small;
      border-top-left-radius: 5px;
      border-top-right-radius: 5px;
    }
    figcaption.zig-cap {
      background: #fcdba5;
    }
    figcaption.c-cap {
      background: #a8b9cc;
      color: #000;
    }
    figcaption.peg-cap {
      background: #fcdba5;
    }
    figcaption.javascript-cap {
      background: #365d95;
      color: #fff;
    }
    figcaption.shell-cap {
      background: #ccc;
      color: #000;
    }

    aside {
      border-left: 0.25em solid #f7a41d;
      padding: 0 1em 0 1em;
    }

    h1 a, h2 a, h3 a, h4 a, h5 a {
      text-decoration: none;
      color: #333;
    }

    a.hdr {
      visibility: hidden;
    }
    h1:hover > a.hdr, h2:hover > a.hdr, h3:hover > a.hdr, h4:hover > a.hdr, h5:hover > a.hdr {
      visibility: visible;
    }

    pre {
      counter-reset: line;
    }
    pre .line:before {
      counter-increment: line;
      content: counter(line);
      display: inline-block;
      padding-right: 1em;
      width: 2em;
      text-align: right;
      color: #999;
    }
    th pre code {
        background: none;
    }
    th .line:before {
        display: none;
    }

    #logo {
      width: 100%;
      height: 7em;
      display: block;
      background-image: url(https://ziglang.org/img/zig-logo-dark.svg);
      background-repeat: no-repeat;
    }

    .diff-red {
      background-color: #ffaeae;
    }
    .diff-green {
      background-color: #bfb;
    }

    @media (prefers-color-scheme: dark) {
      body{
          background:#121212;
          color: #ccc;
      }
      a {
          color: #88f;
      }
      a:hover,a:focus {
          color: #000;
      }
      tr:nth-child(even) {
        background: #1e1e1e;
      }
      .t2_0 {
          color: grey;
      }
      .t31_1 {
          color: red;
      }
      .t32_1 {
          color: #00B800;
      }
      .t36_1 {
          color: #0086b3;
      }
      code {
        background: #222;
        border-color: #444;
      }
      pre > code {
          color: #ccc;
          background: #222;
          border: unset;
      }
      samp {
        background: #000;
        color: #ccc;
      }
      pre > samp {
        border: unset;
      }
      .tok-kw {
          color: #eee;
      }
      .tok-str {
          color: #2e5;
      }
      .tok-builtin {
          color: #ff894c;
      }
      .tok-comment {
          color: #aa7;
      }
      .tok-fn {
          color: #B1A0F8;
      }
      .tok-null {
          color: #ff8080;
      }
      .tok-number {
          color: #ff8080;
      }
      .tok-type {
          color: #68f;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a {
          color: #aaa;
      }
      figcaption.zig-cap {
          background-color: #b27306;
          color: #000;
      }
      figcaption.peg-cap {
          background-color: #b27306;
          color: #000;
      }
      figcaption.shell-cap {
        background: #2a2a2a;
        color: #fff;
      }
      #logo {
        background-image: url(https://ziglang.org/img/zig-logo-light.svg);
      }
      .diff-red {
        background-color: #410000;
      }
      .diff-green {
        background-color: #002d00;
      }
    }
  </style>
  </head>
  <body>
    <div id="contents">
    <a href="https://ziglang.org/"><span id="logo"></span></a>
    <h1>0.12.0 Release Notes</h1>
    <img alt="Zero the Ziguana" src="https://ziglang.org/img/Zero_1.svg" style="height: 18em; float: right">
    <p>
    <a href="https://ziglang.org/download/#release-0.12.0">Download &amp; Documentation</a>
    </p>
    <p>
    Zig is a general-purpose programming language and toolchain for maintaining
    <strong>robust</strong>, <strong>optimal</strong>, and <strong>reusable</strong> software.
    </p>
    <p>Zig development is funded via <a href="/zsf/">Zig Software Foundation</a>,
    a 501(c)(3) non-profit organization. Please consider a recurring donation
    so that we can offer more billable hours to our core team members. This is
    the most straightforward way to accelerate the project along the
    {#link|Roadmap#} to 1.0.</p>
    <p>
    This release features <strong>8 months of work</strong>:
    changes from <strong>268 different contributors</strong>, spread among
    <strong>3688 commits</strong>.</p>
    <p>In the past, these release notes have been extremely long, attempting to
    take note of all enhancements that occurred during the release cycle. In
    the interest of not overwhelming the reader as well as the maintainers
    creating these notes, this document is abridged. Many changes, including
    API breaking changes, are not mentioned here.
    </p>
    {#header_open|Table of Contents#}
    {#nav#}
    {#header_close#}

    {#header_open|Support Table#}
    {#header_open|Tier System#}
    <p>
    A green check mark (âœ…) indicates the target meets all the requirements for the
    support tier. The other icons indicate what is <em>preventing the target from
      reaching the support tier</em>. In other words, the icons are
    <strong>to-do items</strong>. If you find any wrong data here please
    <a href="https://github.com/ziglang/www.ziglang.org">submit a pull request</a>!
    </p>
    {#header_open|Tier 1 Support#}
    <ul>
      <li>Not only can Zig generate machine code for these targets, but the
        {#link|Standard Library#} cross-platform abstractions have implementations
        for these targets.</li>
      <li>The CI server automatically tests these targets on every commit to master
        branch. The ğŸ§ª icon means this target does not yet have CI test coverage.</li>
      <li>The CI server automatically produces pre-built binaries for these targets,
        on every commit to master, and updates
        <a href="https://ziglang.org/download/">the download page</a> with links.
        The ğŸ“¦ icon means the download page is missing this target.
      </li>
      <li>These targets have debug info capabilities and therefore
        produce stack traces on failed assertions.</li>
      <li>libc is available for this target even when cross compiling.</li>
      <li>All the behavior tests and applicable standard library tests pass for this target.
          All language features are known to work correctly. Experimental features do not
          count towards disqualifying an operating system or architecture from Tier 1.
          The ğŸ› icon means there are known {#link|bugs|This Release Contains Bugs#} preventing
          this target from reaching Tier 1.
      </li>
      <li>zig cc, zig c++, and related toolchain commands support
        this target.</li>
      <li>If the Operating System is proprietary then the target is not marked deprecated
        by the vendor. The ğŸ’€ icon means the OS is officially deprecated,
        <a href="https://support.apple.com/en-us/HT208436">such as macos/x86</a>.</li>
    </ul>
    <table>
    <thead>
    <tr>
    <th></th>
    <th>freestanding</th>
    <th>Linux 3.16+</th>
    <th>macOS 11+</th>
    <th>Windows 10+</th>
    <th>WASI</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td>x86_64</td>
    <td>âœ…</td>
    <td>âœ…</td>
    <td>âœ…</td>
    <td>âœ…</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>x86</td>
    <td>âœ…</td>
    <td><a href="https://github.com/ziglang/zig/issues/1929">#1929</a> ğŸ›</td>
    <td>ğŸ’€</td>
    <td><a href="https://github.com/ziglang/zig/issues/537">#537</a> ğŸ›</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>aarch64</td>
    <td>âœ…</td>
    <td><a href="https://github.com/ziglang/zig/issues/2443">#2443</a> ğŸ›</td>
    <td>âœ…</td>
    <td><a href="https://github.com/ziglang/zig/issues/16665">#16665</a> ğŸ›</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>arm</td>
    <td>âœ…</td>
    <td><a href="https://github.com/ziglang/zig/issues/3174">#3174</a> ğŸ›</td>
    <td>ğŸ’€</td>
    <td>ğŸ›ğŸ“¦ğŸ§ª</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>mips</td>
    <td>âœ…</td>
    <td><a href="https://github.com/ziglang/zig/issues/3345">#3345</a> ğŸ›ğŸ“¦</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>riscv64</td>
    <td>âœ…</td>
    <td><a href="https://github.com/ziglang/zig/issues/4456">#4456</a> ğŸ›</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>sparc64</td>
    <td>âœ…</td>
    <td><a href="https://github.com/ziglang/zig/issues/4931">#4931</a> ğŸ›ğŸ“¦ğŸ§ª</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>powerpc64</td>
    <td>âœ…</td>
    <td>ğŸ›</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>powerpc</td>
    <td>âœ…</td>
    <td>ğŸ›</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>wasm32</td>
    <td>âœ…</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>âœ…</td>
    </tr>
    </tbody>
    </table>
    {#header_close#}

    {#header_open|Tier 2 Support#}
    <ul>
    <li>The {#link|Standard Library#} supports this target, but it is possible that some
      APIs will give an "Unsupported OS" compile error. One can link with libc or other
      libraries to fill in the gaps in the standard library. The ğŸ“– icon means the
      standard library is too incomplete to be considered Tier 2 worthy.</li>
    <li>These targets are known to work, but may not be automatically tested, so there
      are occasional regressions. ğŸ” means that nobody has really looked into this target
      so whether or not it works is unknown.</li>
    <li>Some tests may be disabled for these targets as we work toward
      {#link|Tier 1 Support#}.</li>
    </ul>
    <table>
    <thead>
    <tr>
    <th></th>
    <th>free standing</th>
    <th>Linux 3.16+</th>
    <th>macOS 11+</th>
    <th>Windows 10+</th>
    <th>FreeBSD 12.0+</th>
    <th>NetBSD 8.0+</th>
    <th>Dragon FlyBSD 5.8+</th>
    <th>OpenBSD 7.3+</th>
    <th>UEFI</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td>x86_64</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>âœ…</td>
    <td>âœ…</td>
    <td>âœ…</td>
    <td>âœ…</td>
    <td>âœ…</td>
    </tr>
    <tr>
    <td>x86</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>âœ…</td>
    <td>ğŸ’€</td>
    <td>âœ…</td>
    <td>ğŸ”</td>
    <td>ğŸ”</td>
    <td>N/A</td>
    <td>ğŸ”</td>
    <td>âœ…</td>
    </tr>
    <tr>
    <td>aarch64</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>âœ…</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>âœ…</td>
    <td>ğŸ”</td>
    <td>ğŸ”</td>
    <td>N/A</td>
    <td>ğŸ”</td>
    <td>ğŸ”</td>
    </tr>
    <tr>
    <td>arm</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>âœ…</td>
    <td>ğŸ’€</td>
    <td>ğŸ”</td>
    <td>ğŸ”</td>
    <td>ğŸ”</td>
    <td>N/A</td>
    <td>ğŸ”</td>
    <td>ğŸ”</td>
    </tr>
    <tr>
    <td>mips64</td>
    <td>âœ…</td>
    <td>âœ…</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>ğŸ”</td>
    <td>ğŸ”</td>
    <td>N/A</td>
    <td>ğŸ”</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>mips</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>âœ…</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>ğŸ”</td>
    <td>ğŸ”</td>
    <td>N/A</td>
    <td>ğŸ”</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>powerpc64</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>âœ…</td>
    <td>ğŸ’€</td>
    <td>N/A</td>
    <td>ğŸ”</td>
    <td>ğŸ”</td>
    <td>N/A</td>
    <td>ğŸ”</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>powerpc</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>âœ…</td>
    <td>ğŸ’€</td>
    <td>N/A</td>
    <td>ğŸ”</td>
    <td>ğŸ”</td>
    <td>N/A</td>
    <td>ğŸ”</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>riscv64</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>âœ…</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>ğŸ”</td>
    <td>ğŸ”</td>
    <td>N/A</td>
    <td>ğŸ”</td>
    <td>ğŸ”</td>
    </tr>
    <tr>
    <td>sparc64</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>âœ…</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>ğŸ”</td>
    <td>ğŸ”</td>
    <td>N/A</td>
    <td>ğŸ”</td>
    <td>N/A</td>
    </tr>
    </tbody>
    </table>
    {#header_close#}

    {#header_open|Tier 3 Support#}
    <ul>
    <li>The standard library has little to no knowledge of the existence of this
        target.</li>
    <li>If this target is provided by LLVM, LLVM has the target enabled by default.</li>
    <li>These targets are not frequently tested; one will likely need to contribute
      to Zig in order to build for these targets.</li>
    <li>The Zig compiler might need to be updated with a few things such as<ul>
       <li>what sizes are the C integer types</li>
       <li>C ABI calling convention for this target</li>
       <li>start code and default panic handler</li>
      </ul></li>
     <li><code>zig targets</code> is guaranteed to include this target.</li>
    </ul>
    <table>
      <thead>
        <tr>
          <th></th>
          <th>freestanding</th>
          <th>Linux 3.16+</th>
          <th>Windows 10+</th>
          <th>FreeBSD 12.0+</th>
          <th>NetBSD 8.0+</th>
          <th>UEFI</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>x86_64</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
        </tr>
        <tr>
          <td>x86</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
        </tr>
        <tr>
          <td>aarch64</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>âœ…</td>
        </tr>
        <tr>
          <td>arm</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>âœ…</td>
        </tr>
        <tr>
          <td>mips64</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>N/A</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>mips</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>N/A</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>riscv64</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>N/A</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>âœ…</td>
        </tr>
        <tr>
          <td>powerpc32</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>N/A</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>powerpc64</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>N/A</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>bpf</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>hexagon</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>amdgcn</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>sparc</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>s390x</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>lanai</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>csky</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
          <td>âœ…</td>
          <td>âœ…</td>
          <td>N/A</td>
        </tr>
      </tbody>
    </table>
    <table>
      <thead>
        <tr>
          <th></th>
          <th>freestanding</th>
          <th>emscripten</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>wasm32</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>âœ…</td>
        </tr>
      </tbody>
    </table>
    {#header_close#}

    {#header_open|Tier 4 Support#}
    <ul>
      <li>Support for these targets is entirely experimental.</li>
      <li>If this target is provided by LLVM, LLVM may have the target as an
        experimental target, which means that you need to use Zig-provided binaries
        for the target to be available, or build LLVM from source with special configure flags.
        <code>zig targets</code> will display the target if it is available.</li>
      <li>This target may be considered deprecated by an official party, in
        which case this target will remain forever stuck in Tier 4.</li>
      <li>This target may only support <code>-femit-asm</code> and cannot emit
        object files, in which case <code>-fno-emit-bin</code> is enabled by
        default and cannot be overridden.</li>
    </ul>
    <p>Tier 4 targets:</p>
    <ul style="columns: 3">
      <li>avr</li>
      <li>riscv32</li>
      <li>xcore</li>
      <li>nvptx</li>
      <li>msp430</li>
      <li>r600</li>
      <li>arc</li>
      <li>tce</li>
      <li>le</li>
      <li>amdil</li>
      <li>hsail</li>
      <li>spir</li>
      <li>kalimba</li>
      <li>shave</li>
      <li>renderscript</li>
      <li>32-bit x86 macOS, 32-bit ARM macOS, powerpc32 and powerpc64 macOS, because
        <a href="https://support.apple.com/en-us/HT208436">Apple has officially dropped support for them</a>.</li>
    </ul>
    {#header_close#}
    {#header_close#}
    {#header_close#}

    {#header_open|Redesign How Autodoc Works#}
    <img alt="Ziggy the Ziguana" src="https://ziglang.org/img/Ziggy_4.svg" style="height: 13em; float: right">
    <p>This release deletes the previous (experimental) Autodoc implementation and replaces it with a new (not experimental!) one.</p>
<p>The old implementation looked like this:</p>
<pre>   5987 src/Autodoc.zig
   435 src/autodoc/render_source.zig
 10270 lib/docs/commonmark.js
  1245 lib/docs/index.html
  5242 lib/docs/main.js
  2146 lib/docs/ziglexer.js
 25325 total</pre>
    <p>After compilation (sizes are for standard library documentation):</p>
<pre>272K commonmark.js
3.8M data-astNodes.js
360K data-calls.js
767K data-comptimeExprs.js
2.2M data-decls.js
896K data-exprs.js
 13K data-files.js
  45 data-guideSections.js
 129 data-modules.js
  15 data-rootMod.js
 294 data-typeKinds.js
3.2M data-types.js
 38K index.html
158K main.js
 36M src/ (470 .zig.html files)
 78K ziglexer.js</pre>
    <p>Total output size: 47M (5.7M gzipped)</p>
    <p><code>src/Autodoc.zig</code> processed ZIR code, outputting JSON data for a web application to consume. This resulted in a lot of code ineffectively trying to reconstruct the AST from no-longer-available data.</p>
    <p><code>lib/docs/commonmark.js</code> was a third-party markdown implementation that supported <em>too many features</em>; for example I do not want it to be possible to have HTML tags in doc comments, because that would make source code uglier. Only markdown that looks good both as source and rendered should be allowed.</p>
    <p><code>lib/docs/ziglexer.js</code> was an implementation of Zig language tokenization in JavaScript, despite Zig already exposing its own tokenizer in the standard library. When I saw this <a href="https://github.com/ziglang/zig/pull/16306">added to the zig project</a>, <a href="https://github.com/ziglang/zig/issues/16490">a little part of me died inside</a>.</p>
    <p><code>src/autodoc/render_source.zig</code> was a tool that converted .zig files to a syntax-highlighted but non-interactive .zig.html files.</p>
    <p>The new implementation looks like this:</p>
<pre>   942 lib/docs/main.js
   403 lib/docs/index.html
   933 lib/docs/wasm/markdown.zig
   226 lib/docs/wasm/Decl.zig
  1500 lib/docs/wasm/markdown/Parser.zig
   254 lib/docs/wasm/markdown/renderer.zig
   192 lib/docs/wasm/markdown/Document.zig
   941 lib/docs/wasm/main.zig
  1038 lib/docs/wasm/Walk.zig
  6630 total</pre>
    <p>After compilation (sizes are for standard library documentation):</p>
    <pre> 12K index.html
 32K main.js
192K main.wasm
 12M sources.tar</pre>
    <p>Total output size: 12M (2.3M gzipped)</p>
    <p>As you can see, it is both dramatically simpler in terms of implementation as well as build artifacts. Now there are exactly 4 files instead of many, with a 4x reduction in total file size of the generated web app.</p>
    <p>However, not only is it simpler, it is actually more powerful than the old system, because instead of processing ZIR, this system processes the source files directly, meaning it has 100% of the information and never needs to piece anything together backwards.</p>
    <p>This strategy uses a WebAssembly module written in Zig. This allows it to reuse components from the compiler, such as the tokenizer, parser, and other utilities for operating on Zig code.</p>
    <p>The sources.tar file, after being decompressed by the HTTP layer, is fed directly into the wasm module's memory. The tar file is parsed using std.tar and source files are parsed in place, with some additional computations added to hash tables on the side.</p>
    <p>There is room for introducing worker threads to speed up the parsing, although single-threaded it is already so fast that it does not seem necessary.</p>

    {#header_open|Installed Standard Library Documentation#}
    <p>In Zig 0.11.0, a Zig installation comes with a <code>docs/std/</code>
    directory that contains those 47M of output artifacts mentioned above.</p>
    <p>This rewrite removed those artifacts from Zig installations, instead
    offering the <code>zig std</code> command, which hosts std lib autodocs and
    spawns a browser window to view them. When this command is activated,
    <code>lib/compiler/std-docs.zig</code> is compiled from source to perform
    this operation.</p>
    <p>The HTTP server creates the requested files on the fly, including
    rebuilding <code>main.wasm</code> if any of its source files changed, and constructing
    <code>sources.tar</code>, meaning that any source changes to the documented files,
    <em>or to the autodoc system itself</em> are immediately reflected when
    viewing docs. Prefixing the URL with <code>/debug</code> results in a debug
    build of the WebAssembly module.</p>
    <p>This means contributors can test changes to Zig standard library documentation, as well as autodocs functionality, by pressing refresh in their browser window, using a only binary distribution of Zig.</p>
    <p>In total, this reduced the Zig installation size from 317M to 268M (-15%).</p>
    <p>A ReleaseSmall build of the compiler shrinks from 10M to 9.8M (-1%).</p>
    {#header_close#}
    {#header_open|Time to Generate Documentation#}
<p>Autodocs generation is now done properly as part of the pipeline of the compiler rather than tacked on at the end. It also no longer has any dependencies on other parts of the pipeline.</p>
<p>This is how long it now takes to generate standard library documentation:</p>
<pre>Benchmark 1 (3 runs): old/zig test /home/andy/dev/zig/lib/std/std.zig -fno-emit-bin -femit-docs=docs
  measurement          mean Â± Ïƒ            min â€¦ max           outliers         delta
  wall_time          13.3s  Â±  405ms    12.8s  â€¦ 13.6s           0 ( 0%)        0%
  peak_rss           1.08GB Â±  463KB    1.08GB â€¦ 1.08GB          0 ( 0%)        0%
  cpu_cycles         54.8G  Â±  878M     54.3G  â€¦ 55.8G           0 ( 0%)        0%
  instructions        106G  Â±  313K      106G  â€¦  106G           0 ( 0%)        0%
  cache_references   2.11G  Â± 35.4M     2.07G  â€¦ 2.14G           0 ( 0%)        0%
  cache_misses       41.3M  Â±  455K     40.8M  â€¦ 41.7M           0 ( 0%)        0%
  branch_misses       116M  Â± 67.8K      116M  â€¦  116M           0 ( 0%)        0%
Benchmark 2 (197 runs): new/zig build-obj -fno-emit-bin -femit-docs=docs ../lib/std/std.zig
  measurement          mean Â± Ïƒ            min â€¦ max           outliers         delta
  wall_time          24.6ms Â± 1.03ms    22.8ms â€¦ 28.3ms          4 ( 2%)        âš¡- 99.8% Â±  0.3%
  peak_rss           87.3MB Â± 60.6KB    87.2MB â€¦ 87.4MB          0 ( 0%)        âš¡- 91.9% Â±  0.0%
  cpu_cycles         38.4M  Â±  903K     37.4M  â€¦ 46.1M          13 ( 7%)        âš¡- 99.9% Â±  0.2%
  instructions       39.7M  Â± 12.4K     39.7M  â€¦ 39.8M           0 ( 0%)        âš¡-100.0% Â±  0.0%
  cache_references   2.65M  Â± 89.1K     2.54M  â€¦ 3.43M           3 ( 2%)        âš¡- 99.9% Â±  0.2%
  cache_misses        197K  Â± 5.71K      186K  â€¦  209K           0 ( 0%)        âš¡- 99.5% Â±  0.1%
  branch_misses       184K  Â± 1.97K      178K  â€¦  190K           6 ( 3%)        âš¡- 99.8% Â±  0.0%</pre>
    <p>It used to take upwards of 13 seconds. Now it takes 25ms.</p>
    {#header_close#}
    {#header_open|New Autodoc Features#}
    {#header_open|Reliable Linkification#}
    <p>This stems from the fact that with full source files we have all the information, and can write more robust code to look up identifiers from the context they occur in.</p>
    {#header_close#}

    {#header_open|Interactive Source Listings#}
    <p>Press <code>u</code> to go to source code for any declaration:</p>
    <img src="https://ziglang.org/download/0.12.0/release-notes/interactive-source-listings.png" alt="interactive source listings">
    <p>The links take you to the API page for that specific link by changing the location hash.</p>
    {#header_close#}

    {#header_open|Embedded Source Listings#}
    <img src="https://ziglang.org/download/0.12.0/release-notes/embedded-source-listings.png" alt="embedded source listings">
    {#header_close#}

    {#header_open|Search Includes Doc Comments#}
    <img src="https://ziglang.org/download/0.12.0/release-notes/search-including-doc-comments.png" alt="search including doc comments">
    {#header_close#}

    {#header_open|Error Set View#}
    <p>Merged error sets are detected:</p>
    <img src="https://ziglang.org/download/0.12.0/release-notes/merged-error-sets.png" alt="merged error sets">
    <p>Errors that come from other declarations are linked:</p>
    <img src="https://ziglang.org/download/0.12.0/release-notes/other-error-sets.png" alt="other error sets">
    <p>Errors are also shown on function view:</p>
    <img src="https://ziglang.org/download/0.12.0/release-notes/function-view-errors.png" alt="function view errors">
    {#header_close#}

    {#header_open|Correct Type Detection#}
    <img src="https://ziglang.org/download/0.12.0/release-notes/correct-type-detection.png" alt="correct type detection">
    <p>Previous implementation guesses wrong on the type of <code>options</code> as well as <code>DynLib</code>.</p>
    {#header_close#}

    {#header_open|Correct Implementation of Scroll History#}
    <p>The previous implementation implemented scroll history in JavaScript, which is impossible to do
    correctly. The new system makes careful use of the 'popstate' event combined with the history API
    to scroll to the top of the window only when the user navigates to a new link - respecting the browser's
    saved scroll history in all other cases.</p>
    <p>For more details see
    <a href="https://github.com/andrewrk/autodoc/commit/6d96a63430b39c8a08158410b25dd0ecafea28db">the commit diff</a>.</p>
    {#header_close#}
    {#header_close#}
    {#header_close#}

    {#header_open|Language Changes#}
    {#header_open|Unnecessary Use of var#}
    <p>Zig 0.12.0 introduces a new compile error which is emitted when a local variable is declared as
    a {#syntax#}var{#endsyntax#}, but the compiler can infer that {#syntax#}const{#endsyntax#} would suffice.</p>
{#code_begin|test_err|unnecessary_var#}
const expectEqual = @import("std").testing.expectEqual;
test "unnecessary use of var" {
    var x: u32 = 123;
    try expectEqual(123, x);
}
{#code_end#}
    <p>As indicated by the error message, the solution is simple: use {#syntax#}const{#endsyntax#} instead
    where applicable.</p>
    {#header_close#}
    {#header_open|Result Location Semantics#}
    <p>Zig 0.12.0 contains several enhancements to Result Location Semantics (RLS).</p>
    <p>This release implements forwarding of result types through the address-of operator (<code>&</code>). This allows
    syntactic constructs which rely on result types, such as anonymous initializations {#syntax#}.{ ... }{#endsyntax#}
    and casting builtins like {#syntax#}@intCast{#endsyntax#}, to function correctly in the presence of the
    address-of operator:</p>
{#code_begin|test|address_of_rls#}
const S = struct { x: u32 };
const int: u64 = 123;
const val: *const S = &.{ .x = @intCast(int) };
comptime {
    _ = val;
}
{#code_end#}
    <p>In addition, Zig 0.12.0 removes the ability for result <i>locations</i> to propagate through {#syntax#}@as{#endsyntax#}
    and explicitly-typed aggregate initializations {#syntax#}T{ ... }{#endsyntax#}. This restriction is in place to
    simplify the language design: previous releases contained several bugs relating to incorrect casting of result pointers.</p>
    {#header_close#}
    {#header_open|Aggregate Destructuring#}
    <p>Zig 0.12.0 introduces a new syntax to allow destructuring indexable aggregates: that is, tuples, vectors, and arrays.
    Writing a sequence of lvalues or local variable declarations on the left-hand side of the assignment will attempt to
    destructure the value specified on the right-hand side:</p>
{#code_begin|test|destructure#}
const std = @import("std");
const assert = std.debug.assert;
const expectEqual = std.testing.expectEqual;
test "destructure array" {
    var z: u32 = undefined;
    const x, var y, z = [3]u32{ 1, 2, 3 };
    y += 10;
    try expectEqual(1, x);
    try expectEqual(12, y);
    try expectEqual(3, z);
}
test "destructure vector" {
    // Comptime-known values are propagated as you would expect.
    const x, const y = @Vector(2, u32){ 1, 2 };
    comptime assert(x == 1);
    comptime assert(y == 2);
}
test "destructure tuple" {
    var runtime: u32 = undefined;
    runtime = 123;
    const x, const y = .{ 42, runtime };
    // The first tuple field is a `comptime` field, so `x` is comptime-known even
    // though `y` is runtime-known.
    comptime assert(x == 42);
    try expectEqual(123, y);
}
{#code_end#}
    <p>Slices cannot be directly destructured. To destructure values from a slice, convert it to an array by slicing
    with comptime-known bounds, such as {#syntax#}slice[0..3].*{#endsyntax#}.</p>
    {#header_close#}
    {#header_open|Namespace Type Equivalence#}
    <p>In Zig, <code>struct</code>, <code>enum</code>, <code>union</code>, and <code>opaque</code> types are special. They
    do not use structural equivalence, like tuples and arrays do; instead, they create distinct types. These types have
    namespaces, and thus may contain declarations. For this reason, they can be referred to collectively as "namespace
    types".</p>
    <p>In 0.11.0, every time a declaration of such a type was semantically analyzed, a new type was created. Equivalence of
    generic types was handled via memoization of comptime function calls; i.e.
    <code>std.ArrayList(u8) == std.ArrayList(u8)</code> held because the <code>ArrayList</code> function was only called
    once, and its results memoized.</p>
    <p>In 0.12.0, this has changed. Namespace types are now deduplicated based on two factors: their source location, and
    their captures.</p>
    <p>The "captures" of a type refers to the set of comptime-known types and values which it closes over. In other words,
    it is the set of values referenced within the type but declared outside of it. For instance, the
    <code>comptime T: type</code> parameter of <code>std.ArrayList</code> is captured by the type it returns. If two
    namespace types are declared by the same piece of code and have the same captures, they are now considered to be
    precisely the same type.</p>
    <p>Note that the compiler will still memoize comptime calls: that hasn't changed. However, this memoization no longer
    has a meaningful impact on language semantics.</p>
    <p>It is unlikely that this change will cause breakage in existing code. The most likely scenario where it could is
    something like the following:</p>
{#code_begin|syntax|opaque_generator#}
fn MakeOpaque(comptime n: comptime_int) type {
    _ = n;
    return opaque {};
}
const A = MakeOpaque(0);
const B = MakeOpaque(1);
{#code_end#}
    <p>In Zig 0.11.0, this code would create two distinct types, because the calls to <code>MakeOpaque</code> are distinct
    and thus the <code>opaque</code> declaration was analyzed separately for each call. In Zig 0.12.0, these types are
    identical (<code>A == B</code>), because while the function is called twice, the declaration does not capture any
    value.</p>
    <p>This code can be fixed by forcing the type declaration to capture <code>n</code>:</p>
{#code_begin|syntax|opaque_generator#}
fn MakeOpaque(comptime n: comptime_int) type {
    return opaque {
        comptime {
            _ = n;
        }
    };
}
const A = MakeOpaque(0);
const B = MakeOpaque(1);
{#code_end#}
    <p>Since <code>n</code> is referenced within the <code>opaque</code> declaration, this code creates two distinct types.</p>
    {#header_close#}

    {#header_open|Comptime Memory Changes#}
    <p>Zig 0.12.0 overhauls the compiler's internal representation of comptime memory, and more specifically
    comptime-mutable memory (i.e. {#syntax#}comptime var{#endsyntax#}). This overhaul comes with some user-facing
    changes in the form of new restrictions on what you can do with a {#syntax#}comptime var{#endsyntax#}.</p>
    <p>The first, and most significant, new rule is that a pointer to a {#syntax#}comptime var{#endsyntax#} is never
    allowed to become runtime-known. For instance, consider the following snippet:</p>
{#code_begin|test_err|comptime_var_ptr_runtime#}
test "runtime-known comptime var pointer" {
    comptime var x: u32 = 123;
    // `var` makes `ptr` runtime-known
    var ptr: *const u32 = undefined;
    ptr = &x;
    if (ptr.* != 123) return error.TestFailed;
}
{#code_end#}
    <p>In previous versions of Zig, this test passed as you might expect. In Zig 0.12.0, it emits a compile error,
    because the assignment to <code>ptr</code> makes the value <code>&x</code> - which is a pointer to a
    {#syntax#}comptime var{#endsyntax#} - runtime-known.</p>
    <p>Such pointers can also become runtime-known by, for instance, being passed to a function called at runtime:</p>
{#code_begin|test_err|comptime_var_ptr_runtime_arg#}
test "comptime var pointer as runtime argument" {
    comptime var x: u32 = 123;
    if (load(&x) != 123) return error.TestFailed;
}
fn load(ptr: *const u32) u32 {
    return ptr.*;
}
{#code_end#}
    <p>This test also emits a compile error in Zig 0.12.0. The call to <code>load</code> occurs at runtime, and its
    <code>ptr</code> parameter is not marked {#syntax#}comptime{#endsyntax#}, so <code>ptr</code> is runtime-known
    within the body of <code>load</code>. This means the call to <code>load</code> makes the pointer <code>&x</code>
    runtime-known, hence the compile error.</p>
    <p>This restriction was put in place to fix some soundness bugs. When a pointer to a {#syntax#}comptime var{#endsyntax#}
    becomes runtime-known, mutations to it become invalid since the pointed-to data becomes constant, but the type system
    fails to reflect this, leading to the potential for runtime segmentation faults in what appears to be valid code. In
    addition, the value you read from such a pointer at runtime would be its "final" comptime value, which was an
    unintuitive behavior. Thus, these pointers can no longer be runtime-known.</p>
    <p>The second new restriction is that a pointer to a {#syntax#}comptime var{#endsyntax#} is never allowed to be contained
    within the resolved value of a global declaration. For instance, consider the following snippet:</p>
{#code_begin|test_err|comptime_var_ptr_global#}
const ptr: *const u32 = ptr: {
    var x: u32 = 123;
    break :ptr &x;
};
comptime {
    _ = ptr;
}
{#code_end#}
    <p>Here, <code>ptr</code> is a global declaration whose value is a pointer to a {#syntax#}comptime var{#endsyntax#}.
    This declaration was permitted in Zig 0.11.0, but raises a compile error in Zig 0.12.0. The same rule applies in
    more complex cases, such as when the pointer is contained within a struct field:</p>
{#code_begin|test_err|comptime_var_ptr_global_struct#}
const S = struct { ptr: *const u32 };
const val: S = blk: {
    var x: u32 = 123;
    break :blk .{ .ptr = &x };
};
comptime {
    _ = val;
}
{#code_end#}
    <p>This code raises the same compile error as the previous example. This restriction has been put in place primarily to
    aid the implementation of incremental compilation in the Zig compiler, which depends on the fact that analysis of
    global declarations is order-independent, and the dependencies between declarations can be easily modeled.</p>
    <p>The most common way for this to manifest as a compile error in existing code is if a function constructs a slice
    at comptime which is then used at runtime. For instance, consider the following snippet:</p>
{#code_begin|test_err|construct_slice_comptime#}
fn getName() []const u8 {
    comptime var buf: [9]u8 = undefined;
    // In practice there would likely be more complex logic here to populate `buf`.
    @memcpy(&buf, "some name");
    return &buf;
}
test getName {
    try @import("std").testing.expectEqualStrings("some name", getName());
}
{#code_end#}
    <p>A call to <code>getName</code> returns a slice whose <code>ptr</code> field is a pointer to a
    {#syntax#}comptime var{#endsyntax#}. This means the value cannot be used at runtime, nor can it appear in the value
    of a global declaration. This code can be fixed by promoting the computed data to a {#syntax#}const{#endsyntax#}
    after filling the buffer:</p>
{#code_begin|test|construct_slice_comptime#}
fn getName() []const u8 {
    comptime var buf: [9]u8 = undefined;
    // In practice there would likely be more complex logic here to populate `buf`.
    @memcpy(&buf, "some name");
    const final_name = buf;
    return &final_name;
}
test getName {
    try @import("std").testing.expectEqualStrings("some name", getName());
}
{#code_end#}
    <p>Like in previous versions of Zig, comptime-known {#syntax#}const{#endsyntax#}s have infinite lifetime, and the
    restrictions discussed here do not apply to them. Therefore, this code functions as expected.</p>
    <p>Another possible failure mode is in code which used the old semantics to create global mutable comptime state. For
    instance, the following snippet attempts to create a global comptime counter:</p>
{#code_begin|test_err|global_comptime_counter#}
const counter: *u32 = counter: {
    var n: u32 = 0;
    break :counter &n;
};
comptime {
    counter.* += 1;
}
{#code_end#}
    <p>This code emits a compile error in Zig 0.12.0. This use case is not and will not be supported by Zig: any mutable
    comptime state must be represented locally.</p>
    {#header_close#}

    {#header_open|@fieldParentPtr#}
    <p>The first argument is removed in favor of using the {#link|result type|Result Location Semantics#}.</p>
    <p>Migration guide:</p>
    {#syntax_block|zig#}
const parent_ptr = @fieldParentPtr(Parent, "field_name", field_ptr);
    {#end_syntax_block#}
    &downarrow;
    {#syntax_block|zig#}
const parent_ptr: *Parent = @fieldParentPtr("field_name", field_ptr);
    {#end_syntax_block#}
    <p>or</p>
    {#syntax_block|zig#}
const parent_ptr: *Parent = @alignCast(@fieldParentPtr("field_name", field_ptr));
    {#end_syntax_block#}
    <p>depending on what parent pointer alignment the compiler is able to prove.
    The second form is more portable, since it's possible for the
    {#syntax#}@alignCast{#endsyntax#} to be needed for some targets but not others.</p>
    {#header_close#}

    {#header_open|support coercing ref to anonymous array init to many-pointer#}
    <p>Now {#syntax#}&.{ a, b, c }{#endsyntax#} coerces to {#syntax#}[*]const T{#endsyntax#}/{#syntax#}[*:x]const T{#endsyntax#}:</p>
    {#code_begin|test|coerce_many#}
const std = @import("std");
const expectEqual = std.testing.expectEqual;

const Foo = struct { bar: [*]const i32 };

test "ref to anon array init coerced to many-ptr" {
    const foo: Foo = .{ .bar = &.{ 1, -2 } };
    try expectEqual(1, foo.bar[0]);
    try expectEqual(-2, foo.bar[1]);
}

fn checkSentinelManyPtr(values: [*:0]const i32) !void {
    try expectEqual(3, values[0]);
    try expectEqual(-4, values[1]);
    try expectEqual(0, values[2]);
}

test "ref to anon array init coerced to sentinel many-ptr" {
    try checkSentinelManyPtr(&.{ 3, -4 });
}
    {#code_end#}
    {#header_close#}
    {#header_close#}

    {#header_open|Standard Library#}
    {#header_open|Windows Command Line Argument Parsing#}
    <p>On Windows, the command line arguments of a program are a single WTF-16
    encoded string and it's up to the program to split it into an array of
    strings. In C/C++, the entry point of the C runtime takes care of splitting
    the command line and passing argc/argv to the main function.</p>

    <p>Previously, ArgIteratorWindows matched the behavior of
    CommandLineToArgvW, but it turns out that CommandLineToArgvW's behavior
    does not match the behavior of the C runtime post-2008. In 2008, the C
    runtime argv splitting
    <a href="https://daviddeley.com/autohotkey/parameters/parameters.htm#WINCRULESDOC">changed how it handles consecutive double quotes</a>
    within a quoted argument (it's now considered an escaped quote, e.g.
    <code>"foo""bar"</code> post-2008 would get parsed into <code>foo"bar</code>), and the rules around
    argv[0] were also changed.</p>
    <p>This release makes ArgIteratorWindows match the behavior of the
    post-2008 C runtime. The motivation here is roughly the same as when the
    <a href="https://github.com/rust-lang/rust/pull/87580">same change was made in Rust</a>,
    that is (paraphrased):</p>
    <ul>
      <li>Consistent behavior between Zig and modern C/C++ programs</li>
      <li>Allows users to escape double quotes in a way that can be more straightforward</li>
    </ul>
    <p>Additionally, the suggested mitigation for
    <a href="https://flatt.tech/research/posts/batbadbut-you-cant-securely-execute-commands-on-windows/">BatBadBut</a>
    relies on the post-2008 argv splitting behavior for roundtripping of the
    arguments given to cmd.exe.</p>
    <p>The <a href="https://github.com/ziglang/zig/pull/19698">BadBatBut
    mitigation</a> did not make the 0.12.0 release cutoff.</p>
    {#header_close#}

    {#header_open|Bring-Your-Own-OS API Layer Regressed#}
    <p>Previous versions of Zig allowed applications to override the POSIX API layer of the standard library.
    This release intentionally removes this ability, with no migration path offered.</p>
    <p>This was a mistake from day one. This is the wrong abstraction layer to do this in.</p>
    <p>The alternate plan for this is to make all I/O operations require an IO
    interface parameter, similar to how allocations require an Allocator
    interface parameter today.</p>
    <p>Such a plan is not yet implemented, so applications which require this functionality must maintain a
    fork of the standard library until then.</p>
    {#header_close#}

    {#header_open|std.os renamed to std.posix#}
    <p>Migration guide:</p>
    {#syntax_block|zig#}
std.os.abort();
    {#end_syntax_block#}
    &downarrow;
    {#syntax_block|zig#}
std.posix.abort();
    {#end_syntax_block#}
    <p>Generally, one should prefer to use the higher-level cross-platform abstractions rather than reaching
    into the POSIX API layer. For example, {#syntax#}std.process.exit{#endsyntax#} is more portable than
    {#syntax#}std.posix.exit{#endsyntax#}. You should generally expect the API inside <code>std.posix</code>
    to be available on a given OS when the OS implements that corresponding POSIX functionality.</p>
    {#header_close#}

    {#header_open|Ryu Floating-Point Formatting#}
    <p>Zig 0.12.0 replaces the previous errol floating point formatting algorithm with one based on
    <a href="https://github.com/ulfjack/ryu">Ryu</a>, a modern algorithm for
    converting IEEE-754 floating-point numbers to decimal strings.</p>
    <p>The improvements this brings are:</p>
    <ul>
      <li>Ability to format f80 and f128 types</li>
      <li>More accurate f16 and f32 formatting</li>
      <li>Complete round-trip support for every float type</li>
      <li>Generic backend that can be used to print any float of a general number of bits (less than or equal to 128 bits)</li>
    </ul>
    <p>Behavior Differences:</p>
    <ul>
    <li>Exponents are no longer padded with a leading 0 to 2-digits and if positive, the sign is no longer printed:
<pre>errol: 1e+02
ryu:   1e2</pre>
    </li>
    <li>Fractional values of 0 are omitted in full precision mode:
<pre>errol: 2.0e+00
ryu:   2e0</pre>
    </li>
    <li>Full precision output is more accurate in all cases other than f64,
    since we no longer do a cast internally to f64:
<pre># Ryu
3.1234567891011121314151617181920212E0 :f128
3.1234567891011121314E0 :f80
3.1234567891011121314E0 :c_longdouble
3.123456789101112E0 :f64
3.1234567E0 :f32
3.123E0 :f16

## Errol
3.123456789101112e+00 :f128
3.123456789101112e+00 :f80
3.123456789101112e+00 :c_longdouble
3.123456789101112e+00 :f64
3.12345671e+00 :f32
3.123046875e+00 :f16</pre>
    </li>
    <li>Additionally, rounding behaviour in these cases can differ in the fixed
    precision case as the shortest representation will typically differ:
<pre># bits:         141333
# precision:    3
# std_shortest: 1.98049715e-40
# ryu_shortest: 1.9805e-40
# type:         f32
|
| std_dec: 0.000
| ryu_dec: 0.000
|
| std_exp: 1.980e-40
| ryu_exp: 1.981e-40</pre>
    </li>
    </ul>
    <p>Performance: ~2.3x performance improvement</p>
    <p>Code Size: roughly +5KB (2x)</p>
    <p><a href="https://github.com/ziglang/zig/pull/19229">Source for those stats</a></p>
    {#header_close#}

    {#header_open|Reworked HTTP#}
    <p>First, some pretty straightforward changes:</p>
    <ul>
    <li>don't emit Server HTTP header. Let the user add that if they wish to. It's not strictly necessary, and arguably a harmful default.</li>
    <li>correct the error set of <code>finish</code> to not have NotWriteable and MessageTooLong in it</li>
    <li>protect against zero-length chunks in Server</li>
    <li>add missing redirect behavior option to FetchOptions and make it an enum instead of 2 fields</li>
    <li>{#syntax#}error.CompressionNotSupported{#endsyntax#} is renamed to {#syntax#}error.CompressionUnsupported{#endsyntax#}, matching the naming convention from all the other errors in the same set.</li>
    <li>Removed documentation comments that were redundant with field and type names.</li>
    <li>Disabling zstd decompression in the server for now; see #18937.</li>
    <li>Automatically handle expect: 100-continue requests</li>
    </ul>
    <p>Next, <strong>removed the ability to heap-allocate the buffer for headers</strong>. The buffer for HTTP headers is now always provided via a static buffer. As a consequence, <code>OutOfMemory</code> is no longer a member of the <code>read()</code> error set, and the API and implementation of Client and Server are simplified. {#syntax#}error.HttpHeadersExceededSizeLimit{#endsyntax#} is renamed to {#syntax#}error.HttpHeadersOversize{#endsyntax#}.</p>
    <p>Finally, the big changes:</p>

    {#header_open|Removal of std.http.Headers#}
    <p>Instead, some headers are provided via explicit field names populated
    while parsing the HTTP request/response, and some are provided via new
    fields that support passing extra, arbitrary headers. This resulted in
    simplification of logic in many places, as well as elimination of the
    possibility of failure in many places. There is less deinitialization
    code happening now. Furthermore, it made it no longer necessary to clone
    the headers data structure in order to handle redirects.</p>

    <p>http_proxy and https_proxy fields are now pointers since it is common for them to be unpopulated.</p>

    <p><code>loadDefaultProxies</code> is changed into <code>initDefaultProxies</code> to communicate that it does not actually load anything from disk or from the network. The function now is leaky; the API user must pass an already instantiated arena allocator. Removes the need to deinitialize proxies.</p>
    <p>Before, proxies stored arbitrary sets of headers. Now they only store the authorization value.</p>
    <p>Removed the duplicated code between https_proxy and http_proxy. Finally, parsing failures of the environment variables result in errors being emitted rather than silently ignoring the proxy.</p>
    {#header_close#}

    {#header_open|Rework Server Entirely#}
    <p>Mainly, this removes the poorly named <code>wait</code>, <code>send</code>, <code>finish</code> functions, which all operated on the same &quot;Response&quot; object, which was actually being used as the request.</p>
    <p>Now, it looks like this:</p>
    <ol>
    <li><code>std.net.Server.accept()</code> gives you a <code>std.net.Server.Connection</code></li>
    <li><code>std.http.Server.init()</code> with the connection</li>
    <li><code>Server.receiveHead()</code> gives you a Request</li>
    <li><code>Request.reader()</code> gives you a body reader</li>
    <li><code>Request.respond()</code> is a one-shot, or <code>Request.respondStreaming()</code> creates
    a <code>Response</code></li>
    <li><code>Response.writer()</code> gives you a body writer</li>
    <li><code>Response.end()</code> finishes the response; <code>Response.endChunked()</code> allows
    passing response trailers.</li>
    </ol>
    <p>In other words, the type system now guides the API user down the correct path.</p>
    <p><code>receiveHead</code> allows extra bytes to be read into the read buffer, and then will reuse those bytes for the body or the next request upon connection reuse.</p>
    <p><code>respond()</code>, the one-shot function, will send the entire response in one syscall.</p>
    <p>Streaming response bodies no longer wastefully wraps every call to write with a chunk header and trailer; instead it only sends the HTTP chunk wrapper when flushing. This means the user can still control when it happens but it also does not add unnecessary chunks.</p>
    <p>Empirically, the usage code is significantly less noisy, it has less
    error handling while handling errors more correctly, it's more obvious what
    is happening, and it is syscall-optimal.</p>
    {#syntax_block|zig#}
    var read_buffer: [8000]u8 = undefined;
    accept: while (true) {
        const connection = try http_server.accept();
        defer connection.stream.close();

        var server = std.http.Server.init(connection, &read_buffer);
        while (server.state == .ready) {
            var request = server.receiveHead() catch |err| {
                std.debug.print("error: {s}\n", .{@errorName(err)});
                continue :accept;
            };
            try static_http_file_server.serve(&request);
        }
    }
    {#end_syntax_block#}
    {#syntax_block|zig#}
pub fn serve(context: *Context, request: *std.http.Server.Request) ServeError!void {
    // ...
    return request.respond(content, .{
        .status = status,
        .extra_headers = &.{
            .{ .name = "content-type", .value = @tagName(file.mime_type) },
        },
    });
    {#end_syntax_block#}
    <p>Additionally:</p>
    <ul>
    <li>Uncouple <code>std.http.HeadParser</code> from protocol.zig</li>
    <li>Delete <code>std.Server.Connection</code>; use <code>std.net.Server.Connection</code> instead.<ul>
    <li>The API user supplies the read buffer when initializing the
    http.Server, and it is used for the HTTP head as well as a buffer
    for reading the body into.</li>
    </ul>
    </li>
    <li>Replace and document the State enum. No longer is there both &quot;start&quot;
    and &quot;first&quot;.</li>
    </ul>
    <p><code>std.http.Client</code> has not yet been reworked in a similar manner as <code>std.http.Server</code>.</p>
    {#header_close#}
    {#header_close#}

    {#header_open|deflate reimplemented from first principles#}
    <p>In Zig 0.11.0, the deflate implementation was ported from the Go
    standard library, which had a bunch of undesirable properties, such as
    incorrect use of global variables, comments about Go's optimizer in Zig's
    codebase, and the requirement of dynamic memory allocation.</p>
    <p>Zig 0.12.0 has a new implementation that is not a port of an existing codebase.</p>
    <p>The new implementation is roughly 1.2-1.4x faster in decompression and
    1.1-1.2x faster in compression. Compressed sizes are pretty much the same
    in both cases (<a href="https://github.com/ziglang/zig/pull/18923">source</a>).</p>
    <p>The new code uses static allocations for all structures, doesn't require
    allocator. That makes sense especially for deflate where all structures,
    internal buffers are allocated to the full size. Little less for inflate
    where the previous verision used less memory by not preallocating to theoretical
    max size array which are usually not fully used.</p>
    <p>For deflate the new implementaiton allocates 395K while previous
    implementation used 779K. For inflate the new implementation allocates
    74.5K while the old one around 36K.</p>
    <p>Inflate difference is because we here use 64K history instead of 32K previously.</p>
    <p>Migration guide:</p>
    {#syntax_block|zig#}
const std = @import("std");

// To get this file:
// wget -nc -O war_and_peace.txt https://www.gutenberg.org/ebooks/2600.txt.utf-8
const data = @embedFile("war_and_peace.txt");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer std.debug.assert(gpa.deinit() == .ok);
    const allocator = gpa.allocator();

    try oldDeflate(allocator);
    try new(std.compress.flate, allocator);

    try oldZlib(allocator);
    try new(std.compress.zlib, allocator);

    try oldGzip(allocator);
    try new(std.compress.gzip, allocator);
}

pub fn new(comptime pkg: type, allocator: std.mem.Allocator) !void {
    var buf = std.ArrayList(u8).init(allocator);
    defer buf.deinit();

    // Compressor
    var cmp = try pkg.compressor(buf.writer(), .{});
    _ = try cmp.write(data);
    try cmp.finish();

    var fbs = std.io.fixedBufferStream(buf.items);
    // Decompressor
    var dcp = pkg.decompressor(fbs.reader());

    const plain = try dcp.reader().readAllAlloc(allocator, std.math.maxInt(usize));
    defer allocator.free(plain);
    try std.testing.expectEqualSlices(u8, data, plain);
}

pub fn oldDeflate(allocator: std.mem.Allocator) !void {
    const deflate = std.compress.v1.deflate;

    // Compressor
    var buf = std.ArrayList(u8).init(allocator);
    defer buf.deinit();
    // Remove allocator
    // Rename deflate -> flate
    var cmp = try deflate.compressor(allocator, buf.writer(), .{});
    _ = try cmp.write(data);
    try cmp.close(); // Rename to finish
    cmp.deinit(); // Remove

    // Decompressor
    var fbs = std.io.fixedBufferStream(buf.items);
    // Remove allocator and last param
    // Rename deflate -> flate
    // Remove try
    var dcp = try deflate.decompressor(allocator, fbs.reader(), null);
    defer dcp.deinit(); // Remove

    const plain = try dcp.reader().readAllAlloc(allocator, std.math.maxInt(usize));
    defer allocator.free(plain);
    try std.testing.expectEqualSlices(u8, data, plain);
}

pub fn oldZlib(allocator: std.mem.Allocator) !void {
    const zlib = std.compress.v1.zlib;

    var buf = std.ArrayList(u8).init(allocator);
    defer buf.deinit();

    // Compressor
    // Rename compressStream => compressor
    // Remove allocator
    var cmp = try zlib.compressStream(allocator, buf.writer(), .{});
    _ = try cmp.write(data);
    try cmp.finish();
    cmp.deinit(); // Remove

    var fbs = std.io.fixedBufferStream(buf.items);
    // Decompressor
    // decompressStream => decompressor
    // Remove allocator
    // Remove try
    var dcp = try zlib.decompressStream(allocator, fbs.reader());
    defer dcp.deinit(); // Remove

    const plain = try dcp.reader().readAllAlloc(allocator, std.math.maxInt(usize));
    defer allocator.free(plain);
    try std.testing.expectEqualSlices(u8, data, plain);
}

pub fn oldGzip(allocator: std.mem.Allocator) !void {
    const gzip = std.compress.v1.gzip;

    var buf = std.ArrayList(u8).init(allocator);
    defer buf.deinit();

    // Compressor
    // Rename compress => compressor
    // Remove allocator
    var cmp = try gzip.compress(allocator, buf.writer(), .{});
    _ = try cmp.write(data);
    try cmp.close(); // Rename to finisho
    cmp.deinit(); // Remove

    var fbs = std.io.fixedBufferStream(buf.items);
    // Decompressor
    // Rename decompress => decompressor
    // Remove allocator
    // Remove try
    var dcp = try gzip.decompress(allocator, fbs.reader());
    defer dcp.deinit(); // Remove

    const plain = try dcp.reader().readAllAlloc(allocator, std.math.maxInt(usize));
    defer allocator.free(plain);
    try std.testing.expectEqualSlices(u8, data, plain);
}
    {#end_syntax_block#}
    {#header_close#}

    {#header_open|std.posix APIs Gain Type Safety#}
    <p>For example, let's look at <code>std.posix.termios</code>:</p>
    <ul>
    <li>Add missing API bits to termios and the types of its fields for all 12 operating systems</li>
    <li>Correct API bits on Linux (they were wrong for some CPU architectures)</li>
    <li>Consolidate std.c definitions</li>
    <li>Add type safety to all integers</li>
    </ul>
<p>For example previously this is how you would set immediate mode on a tty:</p>
    {#syntax_block|zig#}
const in = std.io.getStdIn();

// copy original settings and restore them once done
const original_termios = try std.posix.tcgetattr(in.handle);
defer std.posix.tcsetattr(in.handle, .FLUSH, original_termios) catch {};

// set immediate input mode
var termios = original_termios;
termios.lflag &= ~@as(std.posix.system.tcflag_t, std.posix.system.ICANON);

// flush changes
try std.posix.tcsetattr(in.handle, .FLUSH, termios);
    {#end_syntax_block#}
<p>Now the middle part looks like this:</p>
    {#syntax_block|zig#}
// set immediate input mode
var termios = original_termios;
termios.lflag.ICANON = false;
    {#end_syntax_block#}
<p>This is thanks to the new definitions based on <code>packed struct</code>. 
Here&#39;s for example the definition of <code>lflag</code> for Linux:</p>
    {#syntax_block|zig#}
pub const tc_lflag_t = switch (native_arch) {
    .powerpc, .powerpcle, .powerpc64, .powerpc64le => packed struct(u32) {
        _0: u1 = 0,
        ECHOE: bool = false,
        ECHOK: bool = false,
        ECHO: bool = false,
        ECHONL: bool = false,
        _5: u2 = 0,
        ISIG: bool = false,
        ICANON: bool = false,
        _9: u1 = 0,
        IEXTEN: bool = false,
        _11: u11 = 0,
        TOSTOP: bool = false,
        _23: u8 = 0,
        NOFLSH: bool = false,
    },
    .mips, .mipsel, .mips64, .mips64el => packed struct(u32) {
        ISIG: bool = false,
        ICANON: bool = false,
        _2: u1 = 0,
        ECHO: bool = false,
        ECHOE: bool = false,
        ECHOK: bool = false,
        ECHONL: bool = false,
        NOFLSH: bool = false,
        IEXTEN: bool = false,
        _9: u6 = 0,
        TOSTOP: bool = false,
        _: u16 = 0,
    },
    else => packed struct(u32) {
        ISIG: bool = false,
        ICANON: bool = false,
        _2: u1 = 0,
        ECHO: bool = false,
        ECHOE: bool = false,
        ECHOK: bool = false,
        ECHONL: bool = false,
        NOFLSH: bool = false,
        TOSTOP: bool = false,
        _9: u6 = 0,
        IEXTEN: bool = false,
        _: u16 = 0,
    },
};
    {#end_syntax_block#}
    <p>Many more {#syntax#}std.posix{#endsyntax#} APIs were adjusted in a
    similar way.</p>
    {#header_close#}

    {#header_open|Global Configuration#}
    <p>Previously, when one wanted to override defaults, such as the logging function used by <code>std.log</code>, they would have to define <code>std_options</code> in their root file, like so:</p>
    {#syntax_block|zig#}
pub const std_options = struct {
    pub const logFn = myLogFn;
};
    {#end_syntax_block#}
    <p>Note how <code>std_options</code> above is a <em>struct type definiton</em>. In this release <code>std_options</code> is now an instance of <code>std.Options</code>, making the process of defining overrides less error-prone.</p>
    <p>The code above would look like this now:</p>
    {#syntax_block|zig#}
pub const std_options: std.Options = .{
    .logFn = myLogFn,
};
    {#end_syntax_block#}
    <p>And this is the definition of <code>std.Options</code> to see what else you can override. </p>
    {#syntax_block|zig#}
pub const Options = struct {
    enable_segfault_handler: bool = debug.default_enable_segfault_handler,

    /// Function used to implement `std.fs.cwd` for WASI.
    wasiCwd: fn () os.wasi.fd_t = fs.defaultWasiCwd,

    /// The current log level.
    log_level: log.Level = log.default_level,

    log_scope_levels: []const log.ScopeLevel = &.{},

    logFn: fn (
        comptime message_level: log.Level,
        comptime scope: @TypeOf(.enum_literal),
        comptime format: []const u8,
        args: anytype,
    ) void = log.defaultLog,

    fmt_max_depth: usize = fmt.default_max_depth,

    cryptoRandomSeed: fn (buffer: []u8) void = @import("crypto/tlcsprng.zig").defaultRandomSeed,

    crypto_always_getrandom: bool = false,

    crypto_fork_safety: bool = true,

    /// By default Zig disables SIGPIPE by setting a "no-op" handler for it.  Set this option
    /// to `true` to prevent that.
    ///
    /// Note that we use a "no-op" handler instead of SIG_IGN because it will not be inherited by
    /// any child process.
    ///
    /// SIGPIPE is triggered when a process attempts to write to a broken pipe. By default, SIGPIPE
    /// will terminate the process instead of exiting.  It doesn't trigger the panic handler so in many
    /// cases it's unclear why the process was terminated.  By capturing SIGPIPE instead, functions that
    /// write to broken pipes will return the EPIPE error (error.BrokenPipe) and the program can handle
    /// it like any other error.
    keep_sigpipe: bool = false,

    /// By default, std.http.Client will support HTTPS connections.  Set this option to `true` to
    /// disable TLS support.
    ///
    /// This will likely reduce the size of the binary, but it will also make it impossible to
    /// make a HTTPS connection.
    http_disable_tls: bool = false,

    side_channels_mitigations: crypto.SideChannelsMitigations = crypto.default_side_channels_mitigations,
};
    {#end_syntax_block#}
    {#header_close#}
    {#header_close#}

    {#header_open|Build System#}

    {#header_open|System Package Mode#}
    <p>Makes the zig build system significantly more friendly to system package maintainers by introducing System Integration Options.</p>
    <p>Let's examine this feature using
    <a href="https://github.com/andrewrk/groovebasin/tree/old-client">groovebasin</a>
    as an example project:</p>
    {#header_open|Ability to Declare Optional System Library Integration#}
    <pre><code><span class="diff-red">--- a/build.zig</span>
<span class="diff-green">+++ b/build.zig</span>
@@ -5,18 +5,8 @@ pub fn build(b: *std.Build) void {
     const optimize = b.standardOptimizeOption(.{
         .preferred_optimize_mode = .ReleaseSafe,
     });
<span class="diff-red">-    const libgroove_optimize_mode = b.option(</span>
<span class="diff-red">-        std.builtin.OptimizeMode,</span>
<span class="diff-red">-        "libgroove-optimize",</span>
<span class="diff-red">-        "override optimization mode of libgroove and its dependencies",</span>
<span class="diff-red">-    );</span>
     const use_llvm = b.option(bool, "use-llvm", "LLVM backend");
 
<span class="diff-red">-    const groove_dep = b.dependency("groove", .{</span>
<span class="diff-red">-        .optimize = libgroove_optimize_mode orelse .ReleaseFast,</span>
<span class="diff-red">-        .target = target,</span>
<span class="diff-red">-    });</span>
<span class="diff-red">-</span>
     b.installDirectory(.{
         .source_dir = .{ .path = "public" },
         .install_dir = .lib,
@@ -31,7 +21,22 @@ pub fn build(b: *std.Build) void {
         .use_llvm = use_llvm,
         .use_lld = use_llvm,
     });
<span class="diff-red">-    server.linkLibrary(groove_dep.artifact("groove"));</span>
<span class="diff-green">+</span>
<span class="diff-green">+    if (b.systemIntegrationOption("groove", .{})) {</span>
<span class="diff-green">+        server.linkSystemLibrary("groove");</span>
<span class="diff-green">+    } else {</span>
<span class="diff-green">+        const libgroove_optimize_mode = b.option(</span>
<span class="diff-green">+            std.builtin.OptimizeMode,</span>
<span class="diff-green">+            "libgroove-optimize",</span>
<span class="diff-green">+            "override optimization mode of libgroove and its dependencies",</span>
<span class="diff-green">+        );</span>
<span class="diff-green">+        const groove_dep = b.dependency("groove", .{</span>
<span class="diff-green">+            .optimize = libgroove_optimize_mode orelse .ReleaseFast,</span>
<span class="diff-green">+            .target = target,</span>
<span class="diff-green">+        });</span>
<span class="diff-green">+        server.linkLibrary(groove_dep.artifact("groove"));</span>
<span class="diff-green">+    }</span>
<span class="diff-green">+</span>
     b.installArtifact(server);
 
     const run_cmd = b.addRunArtifact(server);</code></pre>
    <p>With this diff plus some similar changes in the project's dependency tree...</p>
    {#header_close#}

    {#header_open|System Integration Help Section#}
    <p>There is a new <code>--help</code> section:</p>
    <pre>System Integration Options:
  --system [dir]               System Package Mode. Disable fetching; prefer system libs
  -fsys=[name]                 Enable a system integration
  -fno-sys=[name]              Disable a system integration
  --host-target [triple]       Use the provided target as the host
  --host-cpu [cpu]             Use the provided CPU as the host
  --host-dynamic-linker [path] Use the provided dynamic linker as the host

  Available System Integrations:                Enabled:
    groove                                      no
    z                                           no
    mp3lame                                     no
    vorbis                                      no
    ogg                                         no</pre>
    {#header_close#}

    {#header_open|Using the System Integration Options#}
    {#shell_samp#}
[nix-shell:~/dev/groovebasin]$ zig build -fsys=z

[nix-shell:~/dev/groovebasin]$ ldd zig-out/bin/groovebasin 
    linux-vdso.so.1 (0x00007fff054c7000)
    libz.so.1 => /nix/store/8mw6ssjspf8k1ija88cfldmxlbarl1bb-zlib-1.2.13/lib/libz.so.1 (0x00007fe164675000)
    libm.so.6 => /nix/store/whypqfa83z4bsn43n4byvmw80n4mg3r8-glibc-2.37-45/lib/libm.so.6 (0x00007fe164595000)
    libc.so.6 => /nix/store/whypqfa83z4bsn43n4byvmw80n4mg3r8-glibc-2.37-45/lib/libc.so.6 (0x00007fe1643ae000)
    /nix/store/whypqfa83z4bsn43n4byvmw80n4mg3r8-glibc-2.37-45/lib64/ld-linux-x86-64.so.2 (0x00007fe164696000)
    {#end_shell_samp#}
    <p>Now, re-run the command but removing <code>-fsys=z</code>:</p>
    {#shell_samp#}
[nix-shell:~/dev/groovebasin]$ ~/Downloads/zig/build-release/stage4/bin/zig build

[nix-shell:~/dev/groovebasin]$ ldd zig-out/bin/groovebasin 
    linux-vdso.so.1 (0x00007ffcc23f6000)
    libm.so.6 => /nix/store/whypqfa83z4bsn43n4byvmw80n4mg3r8-glibc-2.37-45/lib/libm.so.6 (0x00007f525feea000)
    libc.so.6 => /nix/store/whypqfa83z4bsn43n4byvmw80n4mg3r8-glibc-2.37-45/lib/libc.so.6 (0x00007f525fd03000)
    /nix/store/whypqfa83z4bsn43n4byvmw80n4mg3r8-glibc-2.37-45/lib64/ld-linux-x86-64.so.2 (0x00007f525ffcc000)
    {#end_shell_samp#}
    {#header_close#}

    {#header_open|New Release Option#}
    <p>System package maintainers can provide the new <code>--release</code> option in order to
    set a system-wide preference for optimization mode, while respecting the application developer's choice.</p>
    <pre>  --release[=mode]             Request release mode, optionally specifying a
                               preferred optimization mode: fast, safe, small</pre>
    {#shell_samp#}
andy@ark ~/d/a/zlib (main)> zig build --release
the project does not declare a preferred optimization mode. choose: --release=fast, --release=safe, or --release=small
error: the following build command failed with exit code 1:
/home/andy/dev/ayb/zlib/zig-cache/o/6f46a03cb0f5f70d2c891f31086fecc9/build /home/andy/Downloads/zig/build-release/stage3/bin/zig /home/andy/dev/ayb/zlib /home/andy/dev/ayb/zlib/zig-cache /home/andy/.cache/zig --seed 0x3e999c60 --release
andy@ark ~/d/a/zlib (main) [1]> zig build --release=safe
andy@ark ~/d/a/zlib (main)> vim build.zig
andy@ark ~/d/a/zlib (main)> git diff
diff --git a/build.zig b/build.zig
index 76bbb01..1bc13e6 100644
--- a/build.zig
+++ b/build.zig
@@ -5,7 +5,9 @@ pub fn build(b: *std.Build) void {
     const lib = b.addStaticLibrary(.{
         .name = "z",
         .target = b.standardTargetOptions(.{}),
-        .optimize = b.standardOptimizeOption(.{}),
+        .optimize = b.standardOptimizeOption(.{
+            .preferred_optimize_mode = .ReleaseFast,
+        }),
     });
     lib.linkLibC();
     lib.addCSourceFiles(.{
andy@ark ~/d/a/zlib (main)> zig build --release
andy@ark ~/d/a/zlib (main)> zig build --release=small
andy@ark ~/d/a/zlib (main)> 
    {#end_shell_samp#}
    <p>This option may be set even if the project's build script does not explicitly expose an optimization
    configuration option.</p>
    {#header_close#}

    {#header_open|Avoid Fetching in System Mode#}
    <p><code>--system</code> prevents Zig from fetching packages. Instead, a directory of packages
    is provided, populated presumably by the system package manager.</p>
    {#shell_samp#}
[nix-shell:~/dev/2Pew]$ zig build --system ~/tmp/p -fno-sys=SDL2
error: lazy dependency package not found: /home/andy/tmp/p/1220c5360c9c71c215baa41b46ec18d0711059b48416a2b1cf96c7c2d87b2e8e4cf6
info: remote package fetching disabled due to --system mode
info: dependencies might be avoidable depending on build configuration

[nix-shell:~/dev/2Pew]$ zig build --system ~/tmp/p 

[nix-shell:~/dev/2Pew]$ mv ~/.cache/zig/p/1220c5360c9c71c215baa41b46ec18d0711059b48416a2b1cf96c7c2d87b2e8e4cf6 ~/tmp/p

[nix-shell:~/dev/2Pew]$ zig build --system ~/tmp/p -fno-sys=SDL2
steps [5/8] zig build-lib SDL2 ReleaseFast native... Compile C Objects [75/128] e_atan2... ^C

[nix-shell:~/dev/2Pew]$ 
    {#end_shell_samp#}
    {#header_close#}

    {#header_close#}

    {#header_open|Lazy Dependencies#}
    <pre><code><span class="diff-red">--- a/build.zig</span>
<span class="diff-green">+++ b/build.zig</span>
<span class="diff-red">-    const groove_dep = b.dependency("groove", .{</span>
<span class="diff-red">-        .optimize = libgroove_optimize_mode orelse .ReleaseFast,</span>
<span class="diff-red">-        .target = target,</span>
<span class="diff-red">-    });</span>
<span class="diff-green">+    if (b.lazyDependency("groove", .{</span>
<span class="diff-green">+        .optimize = libgroove_optimize_mode orelse .ReleaseFast,</span>
<span class="diff-green">+        .target = target,</span>
<span class="diff-green">+    })) |groove_dep| {</span>
<span class="diff-green">+        server.linkLibrary(groove_dep.artifact("groove"));</span>
<span class="diff-green">+    }</span></code></pre>
    <pre><code><span class="diff-red">--- a/build.zig.zon</span>
<span class="diff-green">+++ b/build.zig.zon</span>
@@ -5,6 +5,7 @@
         .groove = .{
             .url = "https://github.com/andrewrk/libgroove/archive/66745eae734e986cd478e7220664f2de902d10a1.tar.gz",
             .hash = "1220285f0f6b2be336519a0e612a11617c655f78b0efe1cac12fc73fc1e50c7b3e14",
<span class="diff-green">+            .lazy = true,</span>
         },
     },
     .paths = .{
    </code></pre>
    <p>This makes the dependency only get fetched if it is actually used. The
    build runner will be rebuilt if any missing lazy dependencies are
    encountered.</p>
    <p>There is an error for using <code>dependency()</code> instead of <code>lazyDependency()</code>:</p>
    {#shell_samp#}
$ zig build -h
thread 2904684 panic: dependency 'groove' is marked as lazy in build.zig.zon which means it must use the lazyDependency function instead
/home/andy/Downloads/zig/lib/std/debug.zig:434:22: 0x11901a9 in panicExtra__anon_18741 (build)
    std.builtin.panic(msg, trace, ret_addr);
                     ^
/home/andy/Downloads/zig/lib/std/debug.zig:409:15: 0x1167399 in panic__anon_18199 (build)
    panicExtra(null, null, format, args);
              ^
/home/andy/Downloads/zig/lib/std/Build.zig:1861:32: 0x1136dca in dependency__anon_16705 (build)
                std.debug.panic("dependency '{s}{s}' is marked as lazy in build.zig.zon which means it must use the lazyDependency function instead", .{ b.dep_prefix, name });
                               ^
/home/andy/dev/groovebasin/build.zig:33:40: 0x10e8865 in build (build)
        const groove_dep = b.dependency("groove", .{
                                       ^
/home/andy/Downloads/zig/lib/std/Build.zig:1982:33: 0x10ca783 in runBuild__anon_8952 (build)
        .Void => build_zig.build(b),
                                ^
/home/andy/Downloads/zig/lib/build_runner.zig:310:29: 0x10c6708 in main (build)
        try builder.runBuild(root);
                            ^
/home/andy/Downloads/zig/lib/std/start.zig:585:37: 0x10af845 in posixCallMainAndExit (build)
            const result = root.main() catch |err| {
                                    ^
/home/andy/Downloads/zig/lib/std/start.zig:253:5: 0x10af331 in _start (build)
    asm volatile (switch (native_arch) {
    ^
???:?:?: 0x8 in ??? (???)
Unwind information for `???:0x8` was not available, trace may be incomplete

error: the following build command crashed:
/home/andy/dev/groovebasin/zig-cache/o/20af710f8e0e96a0ccc68c47688b2d0d/build /home/andy/Downloads/zig/build-release/stage3/bin/zig /home/andy/dev/groovebasin /home/andy/dev/groovebasin/zig-cache /home/andy/.cache/zig --seed 0x513e8ce9 -Z4472a09906216280 -h
    {#end_shell_samp#}
    <p>It's allowed to do the reverse - <code>lazyDependency()</code> when the manifest file does not mark it as lazy.</p>
    <p>It's probably best practice to always use <code>lazyDependency()</code> in build.zig.</p>
    {#header_close#}

    {#header_open|introduce b.path; deprecate LazyPath.relative#}
    <p>This adds the {#syntax#}*std.Build{#endsyntax#} owner to LazyPath so
    that lazy paths returned from a dependency can be used in the application's
    build script without friction or footguns.</p>
    <p>Migration guide:</p>
    <p>Source-Relative LazyPath:</p>
    {#syntax_block|zig#}
.root_source_file = .{ .path = "src/main.zig" },
    {#end_syntax_block#}
    &downarrow;
    {#syntax_block|zig#}
.root_source_file = b.path("src/main.zig"),
    {#end_syntax_block#}

    <p>LazyPath.relative</p>
    {#syntax_block|zig#}
.root_source_file = LazyPath.relative("src/main.zig"),
    {#end_syntax_block#}
    &downarrow;
    {#syntax_block|zig#}
.root_source_file = b.path("src/main.zig"),
    {#end_syntax_block#}

    <p>Test Runner</p>
    {#syntax_block|zig#}
.test_runner = "path/to/test_runner.zig",
    {#end_syntax_block#}
    &downarrow;
    {#syntax_block|zig#}
.test_runner = b.path("path/to/test_runner.zig"),
    {#end_syntax_block#}
    {#header_close#}

    {#header_open|Header Installation#}
    <p>The intent for <code>Compile.installHeader</code> and friends has always been to
    bundle the headers alongside an artifact, have them be installed together
    with the artifact and get automatically added to the include search paths
    of modules that link with the artifact.</p>
    <p>In Zig 0.11.0, however, these functions modified the default
    <code>install</code> top-level step of the builder, lead to a number of
    unexpected results such as installing or not installing the headers
    depending on which top-level build steps are invoked.</p>

    <p>Zig 0.12.0 changes it so that installed headers are added to the compile
    step itself instead of modifying the top-level install step. To handle the
    construction of the include search path for dependent linking modules, an
    intermediary <code>WriteFile</code> step responsible for constructing the appropriate
    include tree is created and set up the first time a module links to an
    artifact.</p>

    <p>Migration guide:</p>

    <p>installHeader now takes a <code>LazyPath</code>:</p>
    {#syntax_block|zig#}
    for (headers) |h| lib.installHeader(h, h);
    {#end_syntax_block#}
    &downarrow;
    {#syntax_block|zig#}
    for (headers) |h| lib.installHeader(b.path(h), h);
    {#end_syntax_block#}

    <p><code>Compile.installConfigHeader</code> has had its second argument removed and now
    uses the value of <code>include_path</code> as its sub path, for parity with
    <code>Module.addConfigHeader</code>. Use
    {#syntax#}artifact.installHeader(config_h.getOutput(), "foo.h"){#endsyntax#}
    if you want to set the sub path to something different.</p>
    {#syntax_block|zig#}
    lib.installConfigHeader(avconfig_h, .{});
    {#end_syntax_block#}
    &downarrow;
    {#syntax_block|zig#}
    lib.installConfigHeader(avconfig_h);
    {#end_syntax_block#}

    <p><code>Compile.installHeadersDirectory</code>/<code>installHeadersDirectoryOptions</code>
    have been consolidated into <code>Compile.installHeadersDirectory</code>, which takes a
    <code>LazyPath</code> and allows exclude/include filters just like <code>InstallDir</code>.</p>
    {#syntax_block|zig#}
    lib.installHeadersDirectoryOptions(.{
        .source_dir = upstream.path(""),
        .install_dir = .header,
        .install_subdir = "",
        .include_extensions = &.{
            "zconf.h",
            "zlib.h",
        },
    });
    {#end_syntax_block#}
    &downarrow;
    {#syntax_block|zig#}
    lib.installHeadersDirectory(upstream.path(""), "", .{
        .include_extensions = &.{
            "zconf.h",
            "zlib.h",
        },
    });
    {#end_syntax_block#}
    <ul>
      <li>[Breaking] <code>b.addInstallHeaderFile</code> now takes a <code>LazyPath</code>.</li>
      <li>[Breaking] As a workaround for
      <a href="https://github.com/ziglang/zig/issues/9698">resurrect emit-h</a>, the generated
      <code>-femit-h</code> header is now never emitted even when the user specifies an
      override for h_dir. If you absolutely need the emitted header, you now
      need to do {#syntax#}install_artifact.emitted_h = artifact.getEmittedH(){#endsyntax#} until
      <code>-femit-h</code> is fixed.</li>
      <li>Added <code>WriteFile.addCopyDirectory</code>, which functions very similar to InstallDir.</li>
      <li><code>InstallArtifact</code> has been updated to install the bundled headers alongide the artifact. The bundled headers are installed to the directory specified by h_dir (which is <code>zig-out/include</code> by default).</li>
    </ul>
    {#header_close#}

    {#header_open|dependencyFromBuildZig#}
    <p>Given a struct that corresponds to the build.zig of a dependency, <code>b.dependencyFromBuildZig</code> returns that same dependency. In other words, if you have already a <code>@import</code>ed a depdency&#39;s build.zig, you can use this function to obtain the corresponding <code>Dependency</code>:</p>
    {#syntax_block|zig#}
// in consumer build.zig
const foo_dep = b.dependencyFromBuildZig(@import("foo"), .{});
    {#end_syntax_block#}
    <p>This function is also important for packages that expose functions from their build.zig files that need to use their corresponding <code>Dependency</code> (for example, for package-relative paths, or for running system commands and returning the output as lazy paths). This would be accomplished through:</p>
    
    {#syntax_block|zig#}
// in dependency build.zig
pub fn getImportantFile(b: *std.Build) std.Build.LazyPath {
    const this_dep = b.dependencyFromBuildZig(@This(), .{});
    return this_dep.path("file.txt");
}

// in consumer build.zig
const file = @import("foo").getImportantFile(b);
    {#end_syntax_block#}
    {#header_close#}
    {#header_close#}

    {#header_open|Compiler#}
    {#header_open|x86_64 Backend#}
    <img alt="Zero the Ziguana" src="https://ziglang.org/img/Zero_2.svg" style="height: 16em; float: right">
    <p>The x86_64 backend is now passing 1765/1828 (97%) of the behavior test suite, compared to the LLVM backend.
    It is far enough along that it is sometimes useful while developing, mainly due to the fact that it
    offers dramatically faster compilation speed:</p>
    <pre>Benchmark 1 (8 runs): zig-0.12.0 build-exe hello.zig
  measurement          mean Â± Ïƒ            min â€¦ max           outliers         delta
  wall_time           667ms Â± 26.7ms     643ms â€¦  729ms          1 (13%)        0%
  peak_rss            175MB Â± 19.3MB     168MB â€¦  223MB          1 (13%)        0%
  cpu_cycles         3.42G  Â±  532M     3.21G  â€¦ 4.74G           1 (13%)        0%
  instructions       6.20G  Â± 1.05G     5.83G  â€¦ 8.79G           1 (13%)        0%
  cache_references    241M  Â± 19.9M      234M  â€¦  291M           1 (13%)        0%
  cache_misses       48.3M  Â± 1.26M     47.7M  â€¦ 51.4M           1 (13%)        0%
  branch_misses      35.3M  Â± 4.07M     33.7M  â€¦ 45.4M           1 (13%)        0%
Benchmark 2 (26 runs): zig-0.12.0 build-exe hello.zig -fno-llvm -fno-lld
  measurement          mean Â± Ïƒ            min â€¦ max           outliers         delta
  wall_time           196ms Â± 5.77ms     187ms â€¦  208ms          0 ( 0%)        âš¡- 70.6% Â±  1.7%
  peak_rss           88.7MB Â±  721KB    87.8MB â€¦ 90.4MB          2 ( 8%)        âš¡- 49.3% Â±  4.3%
  cpu_cycles          842M  Â± 6.01M      836M  â€¦  866M           1 ( 4%)        âš¡- 75.4% Â±  6.0%
  instructions       1.60G  Â± 9.62K     1.60G  â€¦ 1.60G           0 ( 0%)        âš¡- 74.1% Â±  6.5%
  cache_references   56.6M  Â±  378K     56.0M  â€¦ 57.3M           0 ( 0%)        âš¡- 76.6% Â±  3.2%
  cache_misses       8.43M  Â±  104K     8.30M  â€¦ 8.79M           2 ( 8%)        âš¡- 82.5% Â±  1.0%
  branch_misses      7.20M  Â± 30.2K     7.15M  â€¦ 7.28M           2 ( 8%)        âš¡- 79.6% Â±  4.4%</pre>
    <p>This backend can be accessed when compiling for an x86_64 target by passing the CLI options
    <code>-fno-llvm -fno-lld</code>, or by setting the build system
    flags <code>use_llvm</code> and <code>use_lld</code> on
    <code>std.Build.Step.Compile</code> to <code>false</code>. This backend is
    now able to compile many Zig projects, including the compiler itself.</p>
    <p>Remaining tasks until it can be selected by default instead of LLVM for debug builds:</p>
    <ul>
      <li>100% behavior tests passing</li>
      <li>Improved debug info</li>
      <li>Improved runtime performance</li>
    </ul>
    {#header_close#}
    {#header_close#}
 
    {#header_open|Linker#}
    <p>Zig now supports ELF linking for x86_64, aarch64, and partial support for riscv64.</p>
    <p>Dependency on LLD is expected to be dropped during the next release cycle.</p>
    <p>The <code>-fno-lld</code> flag can be used to use Zig's linker where it is not currently the default.</p>
    {#header_close#}

    {#header_open|Cache System#}
    <p>This rather annoying bug is fixed now: <a href="https://github.com/ziglang/zig/issues/16149">error: StreamTooLong when recompiling; duplicate source files in cache manifest</a></p>
    <p>The fix, which deduplicates files listed in the cache manifest, makes cache hits significantly faster.
    Data point: cache hit building hello world with static musl libc</p>
    <pre>Benchmark 1 (61 runs): master/zig build-exe hello.c -target native-native-musl -lc
  measurement          mean Â± Ïƒ            min â€¦ max           outliers         delta
  wall_time          81.4ms Â± 1.76ms    77.7ms â€¦ 87.1ms          1 ( 2%)        0%
  peak_rss           64.6MB Â± 77.7KB    64.4MB â€¦ 64.7MB          0 ( 0%)        0%
  cpu_cycles         97.2M  Â± 1.04M     95.1M  â€¦  101M           1 ( 2%)        0%
  instructions        153M  Â± 11.1K      152M  â€¦  153M           0 ( 0%)        0%
  cache_references   2.21M  Â± 97.1K     2.05M  â€¦ 2.54M           2 ( 3%)        0%
  cache_misses        529K  Â± 24.4K      486K  â€¦  600K           4 ( 7%)        0%
  branch_misses       409K  Â± 6.45K      397K  â€¦  437K           1 ( 2%)        0%
Benchmark 2 (189 runs): cache-dedup/zig build-exe hello.c -target native-native-musl -lc
  measurement          mean Â± Ïƒ            min â€¦ max           outliers         delta
  wall_time          25.8ms Â± 1.26ms    23.9ms â€¦ 30.7ms         11 ( 6%)        âš¡- 68.4% Â±  0.5%
  peak_rss           65.2MB Â± 61.8KB    65.1MB â€¦ 65.4MB          2 ( 1%)        ğŸ’©+  1.0% Â±  0.0%
  cpu_cycles         41.2M  Â±  608K     40.1M  â€¦ 46.3M           4 ( 2%)        âš¡- 57.6% Â±  0.2%
  instructions       64.3M  Â± 12.6K     64.3M  â€¦ 64.4M           2 ( 1%)        âš¡- 57.8% Â±  0.0%
  cache_references   1.28M  Â± 34.5K     1.21M  â€¦ 1.35M           0 ( 0%)        âš¡- 41.9% Â±  0.7%
  cache_misses        348K  Â± 18.6K      297K  â€¦  396K           0 ( 0%)        âš¡- 34.2% Â±  1.1%
  branch_misses       199K  Â± 1.34K      197K  â€¦  206K           6 ( 3%)        âš¡- 51.2% Â±  0.2%</pre>
    {#header_close#}

    {#header_open|Bug Fixes#}
    <p><a href="https://github.com/ziglang/zig/issues?q=is%3Aclosed+is%3Aissue+label%3Abug+milestone%3A0.12.0">Full list of the 502 bug reports closed during this release cycle</a>.</p>
    <p>Many bugs were both introduced and resolved within this release cycle.
    Most bug fixes are omitted from these release notes for the sake of brevity.</p>

    {#header_open|Comptime Pointer Access#}
    <p>Zig has had several long-standing bugs relating to accessing pointers at compile time. When attempting to access
    pointers in a non-trivial way, such as loading a slice of an array or reinterpreting memory, you would at times
    be greeted with a false positive compile error stating that the comptime dereference required a certain type to
    have a well-defined layout.</p>
    <p>The merge of <a href="https://github.com/ziglang/zig/pull/19630">#19630</a> resolves this issue. In Zig 0.12.0,
    the compiler should no longer emit incorrect compile errors when doing complex things with comptime memory.
    This change also includes some fixes to the logic for comptime {#syntax#}@bitCast{#endsyntax#}; in particular,
    bitcasting aggregates containing pointers no longer incorrectly forces the operation to occur at runtime.</p>
    {#header_close#}

    {#header_open|This Release Contains Bugs#}
    <img alt="Zero the Ziguana" src="https://ziglang.org/img/Zero_8.svg" style="height: 13em; float: right">
    <p>
    Zig has
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Abug">known bugs</a>
    and even some
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Amiscompilation">miscompilations</a>.
    </p>
    <p>Zig is immature. Even with Zig 0.12.0, working on a non-trivial project using Zig will
    likely require participating in the development process.</p>
    <p>When Zig reaches 1.0.0, {#link|Tier 1 Support#} will gain a bug policy as an additional
    requirement.</p>
    {#header_close#}
    {#header_close#}

    {#header_open|Toolchain#}
    {#header_open|LLVM 17#}
    <p>This release of Zig upgrades to
    <a href="http://releases.llvm.org/16.0.0/docs/ReleaseNotes.html">LLVM 17.0.6</a>.</p>
    <p>Zig now generates LLVM bitcode module files directly and then passes those to LLVM. This
    means that a Zig compiler built without LLVM libraries can still produce <code>.bc</code> files,
    which can then be passed to clang for compilation.</p>
    {#header_close#}

    {#header_open|musl 1.2.4#}
    <p>Although musl v1.2.5 is now available upstream, this version of Zig
    continues to provide v1.2.4. The next release of Zig is expected to have
    the updated musl.</p>
    {#header_close#}

    {#header_open|glibc 2.38#}
    <p>glibc versions 2.35, 2.36, 2.37, and 2.38 are now available when cross-compiling.</p>
    {#header_close#}

    {#header_open|mingw-w64#}
    <p>Based on a suggestion from <a
    href="https://github.com/sponsors/mstorsjo">Martin StorsjÃ¶</a>, Zig now
    tracks the latest master branch commit of mingw-w64.</p>
    {#header_close#}
    {#header_close#}

    {#header_open|Roadmap#}
    <img alt="Ziggy the Ziguana" src="https://ziglang.org/img/Ziggy_8.svg" style="height: 12em; float: right; transform: scaleX(-1)">

    <p>The major theme of the 0.13.0 release cycle will be <strong>compilation speed</strong>.</p>

    TODO
    {#header_close#}

    {#header_open|Thank You Contributors!#}
    <img alt="Ziggy the Ziguana" src="https://ziglang.org/img/Ziggy_7.svg" style="height: 11em; float: right">
    <p>Here are all the people who landed at least one contribution into this release:</p>
    <ul style="columns: 3">
<li>Andrew Kelley</li>
<li>Jakub Konka</li>
<li>Jacob Young</li>
<li>Matthew Lugg</li>
<li>Robin Voetter</li>
<li>Igor AnicÌ</li>
<li>Ryan Liptak</li>
<li>Veikka Tuominen</li>
<li>antlilja</li>
<li>Carl Ã…stholm</li>
<li>Luuk de Gram</li>
<li>Michael Dusan</li>
<li>Dominic</li>
<li>Krzysztof Wolicki</li>
<li>Casey Banner</li>
<li>Ali Chraghi</li>
<li>Nameless</li>
<li>Ian Johnson</li>
<li>David Rubin</li>
<li>Meghan Denny</li>
<li>Marc Tiehuis</li>
<li>Techatrix</li>
<li>Xavier Bouchoux</li>
<li>Bogdan Romanyuk</li>
<li>Pat Tullmann</li>
<li>Frank Denis</li>
<li>Tristan Ross</li>
<li>Loris Cro</li>
<li>Stephen Gregoratto</li>
<li>xdBronch</li>
<li>Evan Haas</li>
<li>John Schmidt</li>
<li>Ryan Zezeski</li>
<li>expikr</li>
<li>Elaine Gibson</li>
<li>MrDmitry</li>
<li>e4m2</li>
<li>Adam Goertz</li>
<li>Jan Philipp Hafer</li>
<li>Jay Petacat</li>
<li>Jonathan Marler</li>
<li>Travis Staloch</li>
<li>Wooster</li>
<li>XXIV</li>
<li>joadnacer</li>
<li>Jae B</li>
<li>Kai Jellinghaus</li>
<li>Linus Groh</li>
<li>frmdstryr</li>
<li>Garrett Beck</li>
<li>Josh Wolfe</li>
<li>Karl Seguin</li>
<li>Sahnvour</li>
<li>february cozzocrea</li>
<li>fn âŒƒ âŒ¥</li>
<li>Carter Snook</li>
<li>Eric Joldasov</li>
<li>Erik Arvstedt</li>
<li>Gordon Cassie</li>
<li>HydroH</li>
<li>JustinWayland</li>
<li>Lucas Santos</li>
<li>Luis CÃ¡ceres</li>
<li>Motiejus JakÅ¡tys</li>
<li>Nguyá»…n Gia Phong</li>
<li>Paul Berg</li>
<li>Pavel Verigo</li>
<li>Piotr Szlachciak</li>
<li>Prokop RandÃ¡Äek</li>
<li>Ratakor</li>
<li>Stevie Hryciw</li>
<li>SuperAuguste</li>
<li>Zachary Raineri</li>
<li>amp-59</li>
<li>garrisonhh</li>
<li>Alex Kladov</li>
<li>Ben Crist</li>
<li>Eric Eastwood</li>
<li>Jan200101</li>
<li>Jari Vetoniemi</li>
<li>Jeremy Volkman</li>
<li>Kang Seonghoon</li>
<li>Manlio Perillo</li>
<li>Markus F.X.J. Oberhumer</li>
<li>Michael Ortmann</li>
<li>Pascal S. de Kloe</li>
<li>Philipp LÃ¼hmann</li>
<li>Ruben Dimas</li>
<li>Sean</li>
<li>Tobias Simetsreiter</li>
<li>Tom Read Cutting</li>
<li>Tw</li>
<li>Vlad PÄƒnÄƒzan</li>
<li>cipharius</li>
<li>jimying</li>
<li>nikneym</li>
<li>none</li>
<li>ocrap7</li>
<li>riverbl</li>
<li>snoire</li>
<li>tjog</li>
<li>xEgoist</li>
<li>Abhinav Gupta</li>
<li>AdriÃ  Arrufat</li>
<li>Ahmed</li>
<li>Alex</li>
<li>Alexander Heinrich</li>
<li>AlliedEnvy</li>
<li>Ambareesh "Amby" Balaji</li>
<li>Amir Alawi</li>
<li>Andre Herbst</li>
<li>Andre Weissflog</li>
<li>Andreas Herrmann</li>
<li>Anubhab Ghosh</li>
<li>Arnau</li>
<li>Artem Kolichenkov</li>
<li>Aven Bross</li>
<li>Banacial</li>
<li>Becker A</li>
<li>Ben Sinclair</li>
<li>Brandon Black</li>
<li>Brandon Botsch</li>
<li>CPestka</li>
<li>Chadwain Holness</li>
<li>Chris Boesch</li>
<li>Chris Burgess</li>
<li>Christian Flicker</li>
<li>Christiano Haesbaert</li>
<li>Christofer Nolander</li>
<li>Constantin Bilz</li>
<li>Constantin Pestka</li>
<li>Craig O'Connor</li>
<li>Curtis Tate Wilkinson</li>
<li>Daniel A.C. Martin</li>
<li>Daniel Guzman</li>
<li>David Gonzalez Martin</li>
<li>DilithiumNitrate</li>
<li>Dillen Meijboom</li>
<li>DraagrenKirneh</li>
<li>Emil Lerch</li>
<li>Emil Tywoniak</li>
<li>F3real</li>
<li>Federico Stra</li>
<li>Felix Kollmann</li>
<li>Gregory Anders</li>
<li>Gregory Mullen</li>
<li>Guillaume Wenzek</li>
<li>Gustavo C. Viegas</li>
<li>Hashi364</li>
<li>Hong Shick Pak</li>
<li>Ian Kerins</li>
<li>Igor Sadikov</li>
<li>IntegratedQuantum</li>
<li>Jacob G-W</li>
<li>James Chen-Smith</li>
<li>Jan Weidner</li>
<li>Jeremia Dominguez</li>
<li>Jiacai Liu</li>
<li>Jim Calabro</li>
<li>Joachim Schmidt</li>
<li>Joel Gustafson</li>
<li>Johan Jansson</li>
<li>John Benediktsson</li>
<li>Jordyfel</li>
<li>Justus Klausecker</li>
<li>Kamil T</li>
<li>Karl BÃ¶hlmark</li>
<li>Khang Nguyen Duy</li>
<li>Kirk Scheibelhut</li>
<li>Koakuma</li>
<li>Lateef Jackson</li>
<li>Lauri Tirkkonen</li>
<li>Lee Cannon</li>
<li>Leo Emar-Kar</li>
<li>Leonardo Gatti</li>
<li>Lewis Gaul</li>
<li>LinuxUserGD</li>
<li>Littleote</li>
<li>Liviu Dudau</li>
<li>LordMZTE</li>
<li>Luca Ivaldi</li>
<li>Lucas Culverhouse</li>
<li>Maciej 'vesim' KuliÅ„ski</li>
<li>Marcius</li>
<li>Mason Remaley</li>
<li>Matt Knight</li>
<li>Matthew Wozniak</li>
<li>Maximilian</li>
<li>Michael Bradshaw</li>
<li>Michael Lynch</li>
<li>Michael Pfaff</li>
<li>Michael Scott</li>
<li>Michal Ziulek</li>
<li>Mikko Kaihlavirta</li>
<li>Minsoo Choo</li>
<li>Mustafa Uzun</li>
<li>Naboris</li>
<li>Nan Zhong</li>
<li>Niles Salter</li>
<li>Nitin Prakash</li>
<li>OK Ryoko</li>
<li>PanSashko</li>
<li>Paul Jimenez</li>
<li>PauloCampana</li>
<li>Peng He</li>
<li>Phil Richards</li>
<li>Prcuvu</li>
<li>Purrie</li>
<li>Pyry Kovanen</li>
<li>Qusai Hroub</li>
<li>Rafael FernÃ¡ndez LÃ³pez</li>
<li>Rahul Prabhu</li>
<li>Reokodoku</li>
<li>Robinson Collado</li>
<li>Roman FroÅ‚ow</li>
<li>Ryan Barth</li>
<li>Samuel Fiedler</li>
<li>Samuel Nevarez</li>
<li>Scott Schwarz</li>
<li>Sebastien Marie</li>
<li>Simon Brown</li>
<li>Stefan Su</li>
<li>Stephen Gutekanst</li>
<li>Tim Culverhouse</li>
<li>Tobias Simetsreiter</li>
<li>Tomasz Lisowski</li>
<li>Vitalijus Valantiejus</li>
<li>Winter</li>
<li>andrewkraevskii</li>
<li>arbrk1</li>
<li>bfredl</li>
<li>binarycraft007</li>
<li>castholm</li>
<li>cdrmack</li>
<li>cfillion</li>
<li>crayon</li>
<li>cryptocode</li>
<li>danielsan901998</li>
<li>davideger</li>
<li>dbandstra</li>
<li>dhash</li>
<li>dundargoc</li>
<li>emberfade</li>
<li>hdert</li>
<li>iwVerve</li>
<li>jacwil</li>
<li>jaina heartles</li>
<li>jd</li>
<li>leap123</li>
<li>lockbox</li>
<li>loris</li>
<li>mataha</li>
<li>melonedo</li>
<li>mllken</li>
<li>ndbn</li>
<li>notcancername</li>
<li>pancelor</li>
<li>paoda</li>
<li>radar roark</li>
<li>regeliv</li>
<li>salo-dea</li>
<li>sammy j</li>
<li>tinusgraglin</li>
<li>tison</li>
<li>vinnichase</li>
<li>yunsh1</li>
<li>zhylmzr</li>
<li>ĞĞ½Ğ´Ñ€ĞµĞ¹ ĞšÑ€Ğ°ĞµĞ²ÑĞºĞ¸Ğ¹</li>
    </ul>
    {#header_close#}

    {#header_open|Thank You Sponsors!#}
    <img alt="Ziggy the Ziguana" src="https://ziglang.org/img/Ziggy_6.svg" style="height: 18em">
    <p>
    Special thanks to those who <a href="/zsf/">sponsor Zig</a>.
    Because of recurring donations, Zig is driven by the open source community, rather
    than the goal of making profit. In particular, these fine folks sponsor Zig
    for $50/month or more:
    </p>
    <ul style="columns: 3">
      <li><a href="https://github.com/thejoshwolfe" rel="nofollow noopener" target="_blank" class="external-link">Josh
          Wolfe</a></li>
      <li><a href="https://mattnite.net" rel="nofollow noopener" target="_blank" class="external-link">Matt Knight</a>
      </li>
      <li><a href="https://www.hryx.net/" rel="nofollow noopener" target="_blank" class="external-link">Stevie
          Hryciw</a></li>
      <li><a href="https://jethron.id.au" rel="nofollow noopener" target="_blank" class="external-link">Jethro
          Nederhof</a></li>
      <li><a href="https://hachyderm.io/@karrick" rel="nofollow noopener" target="_blank" class="external-link">Karrick
          McDermott</a></li>
      <li><a href="https://www.kapricornmedia.com" rel="nofollow noopener" target="_blank" class="external-link">JosÃ© M
          Rico</a></li>
      <li><a href="https://github.com/drfuchs" rel="nofollow noopener" target="_blank" class="external-link">drfuchs</a>
      </li>
      <li><a href="https://github.com/tigerbeetle/tigerbeetle" rel="nofollow noopener" target="_blank"
          class="external-link">Joran Dirk Greef</a></li>
      <li><a href="https://github.com/rui314" rel="nofollow noopener" target="_blank" class="external-link">Rui
          Ueyama</a></li>
      <li><a href="https://github.com/bfredl" rel="nofollow noopener" target="_blank" class="external-link">bfredl</a>
      </li>
      <li><a href="https://git.sr.ht/~tauoverpi" rel="nofollow noopener" target="_blank" class="external-link">Simon A.
          Nielsen Knights</a></li>
      <li><a href="https://slimsag.com" rel="nofollow noopener" target="_blank" class="external-link">Stephen
          Gutekanst</a></li>
      <li><a href="https://derekcollison.net" rel="nofollow noopener" target="_blank" class="external-link">Derek
          Collison</a></li>
      <li><a href="https://github.com/jmc-88" rel="nofollow noopener" target="_blank" class="external-link">Daniele
          Cocca</a></li>
      <li><a href="https://twitter.com/rbatiati" rel="nofollow noopener" target="_blank" class="external-link">Rafael
          Batiati</a></li>
      <li><a href="https://aras-p.info" rel="nofollow noopener" target="_blank" class="external-link">Aras
          PranckeviÄius</a></li>
      <li><a href="https://terinstock.com" rel="nofollow noopener" target="_blank" class="external-link">Terin Stock</a>
      </li>
      <li><a href="https://kalvad.com" rel="nofollow noopener" target="_blank" class="external-link">LoÃ¯c Tosser</a>
      </li>
      <li><a href="https://scheibo.com" rel="nofollow noopener" target="_blank" class="external-link">Kirk
          Scheibelhut</a></li>
      <li><a href="https://mitchellh.com" rel="nofollow noopener" target="_blank" class="external-link">Mitchell
          Hashimoto</a></li>
      <li><a href="https://github.com/briangold" rel="nofollow noopener" target="_blank" class="external-link">Brian
          Gold</a></li>
      <li><a href="https://github.com/phrrngtn" rel="nofollow noopener" target="_blank" class="external-link">Paul
          Harrington</a></li>
      <li><a href="https://github.com/cgaebel" rel="nofollow noopener" target="_blank" class="external-link">Clark
          Gaebel</a></li>
      <li><a href="https://bun.sh/" rel="nofollow noopener" target="_blank" class="external-link">Bun</a></li>
      <li><a href="https://www.marcus.art/" rel="nofollow noopener" target="_blank" class="external-link">Marcus
          Eagan</a></li>
      <li><a href="https://www.chilton-consulting.com" rel="nofollow noopener" target="_blank" class="external-link">Ken
          Chilton</a></li>
      <li><a href="https://twitter.com/soworston" rel="nofollow noopener" target="_blank"
          class="external-link">Sebastian</a></li>
      <li><a href="https://twitter.com/_willmanning" rel="nofollow noopener" target="_blank" class="external-link">Will
          Manning</a></li>
      <li><a href="https://fulcrum.so" rel="nofollow noopener" target="_blank" class="external-link">Fulcrum Labs</a>
      </li>
      <li><a href="https://mack.work" rel="nofollow noopener" target="_blank" class="external-link">Alex Mackenzie at
          Tapestry VC</a></li>
      <li><a href="http://www.parlikar.com" rel="nofollow noopener" target="_blank" class="external-link">Alok
          Parlikar</a></li>
      <li><a href="https://www.horster.org" rel="nofollow noopener" target="_blank" class="external-link">Viktor
          Tratsevskyy</a></li>
      <li><a href="https://github.com/johnpyp" rel="nofollow noopener" target="_blank" class="external-link">johnpyp</a>
      </li>
      <li><a href="https://huly.io" rel="nofollow noopener" target="_blank" class="external-link">HulyÂ® Platformâ„¢</a>
      </li>
      <li>Reuben Dunnington</li>
      <li>Isaac Yonemoto</li>
      <li>Luuk de Gram</li>
      <li>Auguste Rame</li>
      <li>Jay Petacat</li>
      <li>Dirk de Visser</li>
      <li>Santiago Andaluz</li>
      <li>Andrew Mangogna</li>
      <li>Yaroslav Zhavoronkov</li>
      <li>Christian Wesselhoeft</li>
      <li>Anton Kochkov</li>
      <li>Max Bernstein</li>
      <li>James McGill</li>
      <li>Luke Champine</li>
      <li>AG.ç‹çˆ±å›½</li>
      <li>Wojtek Mach</li>
      <li>Nicola Larosa</li>
      <li>Daniel Hensley</li>
      <li>cryptocode</li>
      <li>Erik MÃ¥llberg</li>
      <li>Collin Kemper</li>
      <li>Fabio Arnold</li>
      <li>Tom Read Cutting</li>
      <li>Ross Rheingans-Yoo</li>
      <li>Emily A. Bellows</li>
      <li>Justin "J.R." Hill</li>
      <li>Mykhailo Tsiuptsiun</li>
      <li>Kiril Mihaylov</li>
      <li>Brett Slatkin</li>
      <li>Sean Carey</li>
      <li>Yurii Rashkovskii</li>
      <li>Benjamin Ebby</li>
      <li>Ralph Brorsen</li>
      <li>OM PropTech GmbH</li>
      <li>Alex Sergeev</li>
      <li>Pierre Curto</li>
      <li>Kemal Akkoyun</li>
      <li>Marco Munizaga</li>
      <li>Josh Ashby</li>
      <li>Chris Baldwin</li>
      <li>Malcolm Still</li>
      <li>Viktor HellstrÃ¶m</li>
      <li>Francis Bouvier</li>
      <li>Fawzi Mohamed</li>
      <li>Alve Larsson</li>
      <li>Nicolas Goy</li>
      <li>Ian Johnson</li>
      <li>Carlos Pizano Uribe</li>
      <li>Rene Schallner</li>
      <li>Linus Groh</li>
      <li>Jinkyu Yi</li>
      <li>jake hemmerle</li>
      <li>Will Pragnell</li>
      <li>Nathan Youngman</li>
      <li>Peter Snelgrove</li>
      <li>Jeff Fowler</li>
      <li>Nate</li>
      <li>Samu</li>
      <li>foxnne</li>
      <li>Christian Gibson</li>
      <li>11sync.net</li>
      <li>impactaky</li>
      <li>Dylan Conway</li>
      <li>Hlib Kanunnikov</li>
      <li>merkleplant</li>
      <li>Omar AlSuwaidi</li>
    </ul>
    {#header_close#}
    </div>
  </body>
</html>
TODO run against tidy
