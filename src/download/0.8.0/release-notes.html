<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>0.8.0 Release Notes ‚ö° The Zig Programming Language</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/favicon.png">
    <link rel="icon" href="/favicon.svg">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        line-height: 1.45;
        margin-left: 0;
        margin-right: 0;
      }
      p {
        margin: 0.8em 0;
      }

      h1, h2, h3, h4, h5 {
        margin: 0.5em 0 0.5em;
        line-height: 1.2;
        font-weight: bold;
        color: #666;
      }

      h1 a, h2 a, h3 a, h4 a, h5 a {
        text-decoration: none;
        color: #666;
      }

      h1 { font-size: 2.0em; }

      h2 { font-size: 1.5em; }

      h3 { font-size: 1.25em; }

      h4 { font-size: 1.0em; }

      a.hdr {
        visibility: hidden;
      }
      h1:hover > a.hdr, h2:hover > a.hdr, h3:hover > a.hdr, h4:hover > a.hdr, h5:hover > a.hdr {
        visibility: visible;
      }

      a {
        color: #2A6286;
      }

      a:not(:hover) {
        text-decoration: none;
      }

      th, td {
        padding: 0.6em;
        text-align: left;
      }

      td {
        font-size: 0.96em;
      }

      th {
        border-bottom: 2px solid #f2f3f3;
      }

      tr:nth-child(even) {
        background: #f2f3f3;
      }

      .t0_1, .t37, .t37_1 {
        font-weight: bold;
      }
      .t2_0 {
        color: grey;
      }
      .t31_1 {
        color: red;
      }
      .t32_1 {
        color: green;
      }
      .t36_1 {
        color: #0086b3;
      }
      .file {
        text-decoration: underline;
      }
      pre,code {
        font-size: 12pt;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        color: #333;
        background: #f8f8f8;
      }
      .table-wrapper {
        width: 100%;
        overflow-y: auto;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      #contents {
        max-width: 60em;
        margin: auto;
        padding: 0 0.2em;
      }

      #logo {
        width: 100%;
        height: 7em;
        display: block;
        background-image: url(https://ziglang.org/img/zig-logo-dark.svg);
        background-repeat: no-repeat;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background-color:#111;
            color: #bbb;
        }
        a {
            color: #88f;
        }
        table, th, td {
            border-color: grey;
        }
        tr:nth-child(even) {
          background: #1e1e1e;
        }
        .t2_0 {
            color: grey;
        }
        .t31_1 {
            color: red;
        }
        .t32_1 {
            color: green;
        }
        .t36_1 {
            color: #0086b3;
        }
        pre > code {
            color: #ccc;
            background: #222;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #e33;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
        h1, h2, h3, h4, h5 {
          color: #aaa;
        }
        h1 a, h2 a, h3 a, h4 a, h5 a {
            color: #aaa;
        }
        #logo {
          background-image: url(https://ziglang.org/img/zig-logo-light.svg);
        }
      }
    </style>
  </head><!--
             .,-:;//;:=,
         . :H@@@MM@M#H/.,+%;,
      ,/X+ +M@@M@MM%=,-%HMMM@X/,
     -+@MM; $M@@MH+-,;XMMMM@MMMM@+-     Now you're thinking
    ;@M@@M- XM@X;. -+XXXXXHHH@M@M#@/.     with Zig
  ,%MM@@MH ,@%=            .-.-=-=:=,.
  -@#@@@MX .,              -%HX$$%%%+;
 =-./@M@M$                  .;@MMMM@MM:
 X@/ -$MM/                    .+MM@@@M$
,@M@H: :@:                    . -X#@@@@-
,@@@MMX, .                     /H- ;@M@M=
.H@@@@M@+,                    %MM+..%#$.
 /MMMM@MMH/.                  XM@MH; -;
  /%+%$XHH@$=              , .H@@@@MX,
   .=--------.           -%H.,@@@@@MX,
   .%MM@@@HHHXX$$$%+- .:$MMX -M@@MM%.
     =XMMM@MM@MM#H;,-+HMM@M+ /MMMX=
       =%@M@M#@$-.=$@MM@@@M; %M%=
         ,:+$+-,/H#MMMMMMM@- -,
               =++%%%%+/:-.
 --><body>
    <div id="contents">
    <a href="https://ziglang.org/"><span id="logo"></span></a>
    <h1>0.8.0 Release Notes</h1>
    <p>
    <a href="https://ziglang.org/download/">Download &amp; Documentation</a>
    </p>
    <p>
    Zig is a general-purpose programming language and toolchain for maintaining
    <strong>robust</strong>, <strong>optimal</strong>, and <strong>reusable</strong> software.
    </p>
    <p>
    Backed by the <a href="/zsf/">Zig Software Foundation</a>,
    the project is <strong>financially sustainable</strong> and offers billable
    hours for core team members:
    </p>
    <ul style="columns: 3">
      <li><a href="https://kristoff.it/">Loris Cro</a></li>
      <li><a href="http://www.jakubkonka.com/">Jakub Konka</a></li>
      <li><a href="https://github.com/Vexu">Veikka Tuominen</a></li>
      <li><a href="https://github.com/SpexGuy">Martin Wickham</a></li>
      <li><a href="https://github.com/alexnask">Alexandros Naskos</a></li>
    </ul>
    <p>
    Please consider <a href="/zsf/">donating to the ZSF</a> to help us pay even more contributors!
    </p>
    <p>
    This release features <strong>7 months of work</strong> and
    changes from <strong>144 different contributors</strong>, spread among
    <strong>2711 commits</strong>.
    </p>
    {#header_open|Table of Contents#}
    {#nav#}
    {#header_close#}

    {#header_open|Support Table#}
    {#header_open|Tier System#}
    <p>
    A green check mark (‚úÖ) indicates the target meets all the requirements for the
    support tier. The other icons indicate what is <em>preventing the target from
      reaching the support tier</em>. In other words, the icons are
    <strong>to-do items</strong>. If you find any wrong data here please
    <a href="https://github.com/ziglang/www.ziglang.org">submit a pull request</a>!
    </p>
    {#header_open|Tier 1 Support#}
    <ul>
      <li>Not only can Zig generate machine code for these targets, but the standard
        library cross-platform abstractions have implementations for these targets.</li>
      <li>üß™ The CI server automatically tests these targets on every commit to master
        branch.</li>
      <li>üì¶ The CI server automatically produces pre-built binaries for these targets,
        on every commit to master, and updates
        <a href="https://ziglang.org/download/">the download page</a> with links.</li>
      <li>These targets have debug info capabilities and therefore produce stack traces
        on failed assertions.</li>
      <li>libc is available for this target even when cross compiling.</li>
      <li>üêõ All the behavior tests and applicable standard library tests pass for this target.
          All language features are known to work correctly. Experimental features do not
          count towards disqualifying an operating system or architecture from Tier 1.</li>
      <li><code>zig cc</code>, <code>zig c++</code> and related toolchain commands support
        this target.</li>
      <li>üíÄ If the Operating System is proprietary then the target is not marked deprecated
        by the vendor,
        <a href="https://support.apple.com/en-us/HT208436">such as macos/x86</a>.</li>
    </ul>
    <table>
    <thead>
    <tr>
    <th></th>
    <th>freestanding</th>
    <th>Linux 3.16+</th>
    <th>macOS 10.13+</th>
    <th>Windows 8.1+</th>
    <th>WASI</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td>x86_64</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>x86</td>
    <td>‚úÖ</td>
    <td><a href="https://github.com/ziglang/zig/issues/1929">#1929</a> üêõüì¶</td>
    <td>üíÄ</td>
    <td><a href="https://github.com/ziglang/zig/issues/537">#537</a> üêõüì¶</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>aarch64</td>
    <td>‚úÖ</td>
    <td><a href="https://github.com/ziglang/zig/issues/2443">#2443</a> üêõ</td>
    <td>‚úÖ</td>
    <td>üêõüì¶üß™</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>arm</td>
    <td>‚úÖ</td>
    <td><a href="https://github.com/ziglang/zig/issues/3174">#3174</a> üêõüì¶</td>
    <td>üíÄ</td>
    <td>üêõüì¶üß™</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>mips</td>
    <td>‚úÖ</td>
    <td><a href="https://github.com/ziglang/zig/issues/3345">#3345</a> üêõüì¶üß™</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>riscv64</td>
    <td>‚úÖ</td>
    <td><a href="https://github.com/ziglang/zig/issues/4456">#4456</a> üêõüì¶</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>sparcv9</td>
    <td>‚úÖ</td>
    <td><a href="https://github.com/ziglang/zig/issues/4931">#4931</a> üêõüì¶üß™</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>wasm32</td>
    <td>‚úÖ</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>‚úÖ</td>
    </tr>
    </tbody>
    </table>
    {#header_close#}

    {#header_open|Tier 2 Support#}
    <ul>
    <li>üìñ The standard library supports this target, but it's possible that some
      APIs will give an "Unsupported OS" compile error. One can link with libc or other
      libraries to fill in the gaps in the standard library.</li>
    <li>üîç These targets are known to work, but may not be automatically tested, so there
      are occasional regressions.</li>
    <li>Some tests may be disabled for these targets as we work toward
      {#link|Tier 1 Support#}.
    </li>
    </ul>
    <table>
    <thead>
    <tr>
    <th></th>
    <th>free standing</th>
    <th>Linux 3.16+</th>
    <th>macOS 10.13+</th>
    <th>Windows 8.1+</th>
    <th>FreeBSD 12.0+</th>
    <th>NetBSD 8.0+</th>
    <th>DragonFlyBSD 5.8+</th>
    <th>UEFI</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td>x86_64</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    </tr>
    <tr>
    <td>x86</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>‚úÖ</td>
    <td>üíÄ</td>
    <td>‚úÖ</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>‚úÖ</td>
    </tr>
    <tr>
    <td>aarch64</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>‚úÖ</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>üîç</td>
    </tr>
    <tr>
    <td>arm</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>‚úÖ</td>
    <td>üíÄ</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>üîç</td>
    </tr>
    <tr>
    <td>mips64</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>mips</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>‚úÖ</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>powerpc64</td>
    <td>‚úÖ</td>
    <td>üìñ</td>
    <td>üíÄ</td>
    <td>N/A</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>powerpc</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    <td>üíÄ</td>
    <td>N/A</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>riscv64</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>‚úÖ</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>üîç</td>
    </tr>
    <tr>
    <td>sparcv9</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>‚úÖ</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    </tbody>
    </table>
    {#header_close#}

    {#header_open|Tier 3 Support#}
    <ul>
    <li>The standard library has little to no knowledge of the existence of this
        target.</li>
    <li>If this target is provided by LLVM, LLVM has the target enabled by default.</li>
    <li>These targets are not frequently tested; one will likely need to contribute
      to Zig in order to build for these targets.</li>
    <li>The Zig compiler might need to be updated with a few things such as<ul>
       <li>what sizes are the C integer types</li>
       <li>C ABI calling convention for this target</li>
       <li>start code and default panic handler</li>
      </ul></li>
     <li><code>zig targets</code> is guaranteed to include this target.</li>
    </ul>
    <table>
      <thead>
        <tr>
          <th></th>
          <th>freestanding</th>
          <th>Linux 3.16+</th>
          <th>Windows 8.1+</th>
          <th>FreeBSD 12.0+</th>
          <th>NetBSD 8.0+</th>
          <th>UEFI</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>x86_64</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
        </tr>
        <tr>
          <td>x86</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
        </tr>
        <tr>
          <td>aarch64</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
        </tr>
        <tr>
          <td>arm</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
        </tr>
        <tr>
          <td>mips64</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>mips</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>riscv64</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
        </tr>
        <tr>
          <td>powerpc32</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>powerpc64</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>‚úÖ</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>bpf</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>hexagon</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>amdgcn</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>sparc</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>s390x</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>lanai</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>csky</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
      </tbody>
    </table>
    <table>
      <thead>
        <tr>
          <th></th>
          <th>freestanding</th>
          <th>emscripten</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>wasm32</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>‚úÖ</td>
        </tr>
      </tbody>
    </table>
    {#header_close#}

    {#header_open|Tier 4 Support#}
    <ul>
      <li>Support for these targets is entirely experimental.</li>
      <li>If this target is provided by LLVM, LLVM may have the target as an
        experimental target, which means that you need to use Zig-provided binaries
        for the target to be available, or build LLVM from source with special configure flags.
        <code>zig targets</code> will display the target if it is available.</li>
      <li>This target may be considered deprecated by an official party,
        <a href="https://support.apple.com/en-us/HT208436">such as macosx/i386</a> in which
        case this target will remain forever stuck in Tier 4.</li>
      <li>This target may only support <code>-femit-asm</code> and cannot emit object files
        (<code>-fno-emit-bin</code> enabled by default and cannot be overridden).</li>
    </ul>
    <p>Tier 4 targets:</p>
    <ul style="columns: 3">
      <li>avr</li>
      <li>riscv32</li>
      <li>xcore</li>
      <li>nvptx</li>
      <li>msp430</li>
      <li>r600</li>
      <li>arc</li>
      <li>tce</li>
      <li>le</li>
      <li>amdil</li>
      <li>hsail</li>
      <li>spir</li>
      <li>kalimba</li>
      <li>shave</li>
      <li>renderscript</li>
      <li>32-bit x86 macOS, 32-bit ARM macOS, powerpc32 and powerpc64 macOS,
        because Apple has officially dropped support for them.</li>
    </ul>
    {#header_close#}
    {#header_close#}

    {#header_open|Windows Support#}
    <p>Improvements to the {#link|Standard Library#}:</p>
    <ul>
      <li>Avoid redundantly providing Windows TLS startup symbols when linking libc
          because they are already provided by libcrt.</li>
      <li>Add <code>timeval</code> extern struct.</li>
      <li>Made sure to handle PATH_NOT_FOUND when deleting files (<a href="https://github.com/ziglang/zig/issues/7879">#7879</a>).</li>
      <li>Made windows.ReadFile allow short reads (<a href="https://github.com/ziglang/zig/issues/7121">#7121</a>).</li>
      <li>Implement chdir and chdirZ for Windows.</li>
      <li>Fixed WindowsDynLib.openW trying to strip the \??\ prefix when it does not exist.</li>
      <li>Only check for evented mode in windows.OpenFile when in async mode.</li>
      <li>Introduced os.windows.QueryObjectName</li>
      <li>os.windows.GetFinalPathNameByHandle: add test</li>
      <li>Define nfds_t for windows.</li>
      <li>os.windows.user32.messageBoxW.</li>
      <li>os/windows/ws2_32: add missing FIONBIO constant.</li>
      <li>Fixed and add os.windows.user32 WM constants.</li>
      <li>Implemented nt path conversion for windows. Fixes <code>.</code> and <code>..</code>
        not working in {#syntax#}std.fs{#endsyntax#} paths.</li>
      <li>Switched to using unicode when parsing the command line on windows (<a href="https://github.com/ziglang/zig/issues/7241">#7241</a>).</li>
    </ul>
    {#header_open|No MSVC Dependency by Default#}
    <p>Since Zig ships with {#link|MinGW-w64|mingw-w64 9.0.0#}, Zig can be used to
    compile C and C++ code on Windows without having MSVC installed.
    However, before this release, it was not obvious how to take advantage of this feature,
    since the default behavior was to integrate with MSVC.
    </p>
    <p>
    In this release, the default behavior is to ignore MSVC and do everything based only
    on the Zig installation. This makes using Zig to compile C and C++ code on
    Windows an "it just works" experience.
    </p>
    <p>
    MSVC integration can be achieved by using <code>-target native-native-msvc</code>.
    Note that mingw-w64 is ABI-compatible with MSVC, so any build artifacts produced by one
    are consumable by the other. However the respective C header files are not always
    API-compatible, which is why there is still a use case for overriding the default.
    </p>
    <p>
    Tracking issue: <a href="https://github.com/ziglang/zig/issues/6565">#6565</a>
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|macOS Support#}
    <p>With the advent of the {#link|Self-Hosted Linker#}, Zig is now able to generate
    well-formed and codesigned binaries on arm64 macOS (aka the Apple Silicon).
    It is also able to cross-compile C, C++, and Zig code to an arm64 and x86_64
    macOS. Additionally, arm64 nightly binaries of Zig are automatically generated
    by our Continuous Integration service, meaning both arm64 and x86_64 macOS are
    now {#link|Tier 1|Tier 1 Support#} targets.
    </p>
    <p>
    To facilitate incremental linking, the self-hosted compiler is now by default generating
    <a href="https://opensource.apple.com/source/lldb/lldb-179.1/www/symbols.html"><code>dSYM</code> bundles</a> which store DWARF debug information and debug symbols on macOS.
    This puts Zig on path of becoming a true replacement for the Xcode development environment.
    </p>
    <p>
    Finally, as a side experiment, Jakub added in {#link|Zig Build System#} integration
    with <a href="https://www.darlinghq.org/">Darling</a> (<a href="https://github.com/ziglang/zig/issues/8760">#8760</a>), a translation layer of macOS
    syscalls to Linux, with the intention of being able to cross test MachO binaries
    and macOS specific tests directly on Linux simply by passing in an additional flag
    <code>-Denable-darling</code> to <code>zig build test</code>.
    </p>
    <p>
    In 0.8.0, Zig provides libc header files for macOS, for both
    <code>x86_64-macos</code> and <code>aarch64-macos</code>, using the experimental
    <a href="https://github.com/ziglang/fetch-them-macos-headers">fetch-them-macos-headers</a>
    project. There is a myth that Apple's C header files have an encumbered license, but that is not
    the case. They are licensed under the
    <a href="https://spdx.org/licenses/APSL-1.1.html">Apple Public Source License</a>
    which is in fact quite permissive.</p>
    <p>Zig 0.8.0 relies on these headers even when compiling natively, as long as there
    are no system dependencies. <strong>This makes Zig able to compile C and C++ code
    on macOS without XCode installed</strong> (<a href="https://github.com/ziglang/zig/issues/6773">#6773</a>).</p>
    <p>Additionally, OS version detection for macOS has been re-implemented.</p>
    {#header_close#}

    {#header_open|WebAssembly Support#}
    <p>The {#link|Self-Hosted Compiler#} gained a work-in-progress
    {#link|WebAssembly Backend#}, which provides the ability for Zig to
    compile to wasm without {#link|LLVM|LLVM 12#}.</p>
    <p>Zig now ships with {#link|WASI libc#} and supports cross-compiling
    C code to WASI. This also makes Zig a tempting alternative to downloading and building
    <a href="https://github.com/webassembly/wasi-libc">WASI libc</a> and/or
    <a href="https://github.com/webassembly/wasi-sdk">WASI SDK</a> manually (<a href="https://github.com/ziglang/zig/issues/8837">#8837</a>).
    </p>
    <p>Additionally:</p>
    <ul>
      <li>Zig now uses the standard <code>.o</code> extension for wasm objects rather
        than <code>.o.wasm</code>.</li>
      <li>Just like every other target, <code>zig build-lib</code> now builds a static
        archive for wasm, unless <code>-dynamic</code> is specified.</li>
    </ul>
    {#header_close#}

    {#header_open|Haiku Support#}
    <p>Al Hoang contributed some initial work to get Zig to run under
    <a href="https://www.haiku-os.org/">Haiku</a>. Some things that are now working:</p>
    <ul>
      <li>{#link|zig cc#} of a barebones C program appears to compile.</li>
      <li><code>zig build-exe</code> can generate an executable binary.</li>
      <li><code>zig run</code> on a zig file works.</li>
      <li>Some basic {#link|Standard Library#} abstractions are implemented for Haiku.</li>
    </ul>
    <p>Getting stack traces to work is still in-progress.</p>
    {#header_close#}

    {#header_open|csky Support#}
    <p>{#link|LLVM 12#} brings in csky support. {#link|glibc|glibc 2.33#}
    already supported csky, but Zig did not ship glibc header files for it since LLVM
    did not have a backend for it. Zig 0.8.0 additionally ships glibc header files
    for csky.</p>
    <p>csky is now a {#link|Tier 3|Tier 3 Support#} target.</p>
    {#header_close#}

    {#header_open|thumb2 Support#}
    <p>LemonBoy contributed the initial bringup for Linux/Thumb2 (<a href="https://github.com/ziglang/zig/issues/8683">#8683</a>).</p>
    <p>Improved support for building {#link|musl|musl 1.2.2#} and {#link|glibc|glibc 2.33#}
    in thumb mode.</p>
    <p>Pass <code>-mthumb</code> when compiling C/C++ code. The Clang driver requires this flag and ignores the target triple.</p>
    {#header_close#}

    {#header_open|bpf Support#}
    <p>Matthew Knight added the <code>c_longdouble</code> mapping for bpf (<a href="https://github.com/ziglang/zig/issues/7504">#7504</a>).</p>
    {#header_close#}

    {#header_open|msp430 Support#}
    <p>Nathan Michaels added the <code>c_longdouble</code> mapping for msp430 (<a href="https://github.com/ziglang/zig/issues/7333">#7333</a>).</p>
    {#header_close#}

    {#header_open|sparc64 Support#}
    <p>sparcv9 gets promoted to {#link|Tier 2|Tier 2 Support#} in this release due to
    various improvements:</p>
    <ul>
      <li>Fixed <code>fork()</code> on Linux/sparc64 and add long double mapping (<a href="https://github.com/ziglang/zig/issues/7237">#7237</a>).</li>
      <li>stage1: set gen_frame_size alignment to work around requirement mismatch.</li>
      <li>Added compiler-rt stub for SPARC CPUs.</li>
      <li>stage1: SPARCv9 f128 enablement (<a href="https://github.com/ziglang/zig/issues/7716">#7716</a>).</li>
      <li>Handle various stack frame related quirks (<a href="https://github.com/ziglang/zig/issues/7946">#7946</a>).</li>
      <li>Fixed backtraces on sparcv9.</li>
      <li>std: Fix stack overflow in SPARC clone() impl</li>
      <li>std: Import correct errno defs for SPARC</li>
      <li>std: Add signal numbers for SPARC</li>
      <li>std: Fix pwrite/pread syscalls on SPARC targets</li>
      <li>Define ENOTSUP for SPARC.</li>
      <li>Fix linux dirent64 buffer align directive.</li>
    </ul>
    <p>Contributors: Koakuma, LemonBoy</p>
    {#header_close#}

    {#header_open|PowerPC Support#}
    <p>32-bit PowerPC gets promoted to {#link|Tier 2|Tier 2 Support#} in this release
    due to various improvements:</p>
    <ul>
    <li>PPC: Correct the generic feature set</li>
    <li>PPC64: Use newfstatat on PPC64.</li>
    <li>PPC64: Use correct clone() stub.</li>
    <li>target: map zig ppc32 ‚Üí llvm ppc (<a href="https://github.com/ziglang/zig/issues/7947">#7947</a>).</li>
    <li>compiler-rt: Don't re-define PPC builtins in test mode</li>
    </ul>

    <p>Zig now has CI test coverage for <code>powerpc-linux-none</code> and
    <code>powerpc-linux-musl</code>. The issue blocking {#link|glibc|glibc 2.33#} support
    is #4927.</p>
    <p>Contributors: LemonBoy, lithdew, Michael Dusan, Benjamin Feng</p>
    {#header_close#}

    {#header_open|32-bit x86 Support#}
    <p>LemonBoy made progress working around #4926, preventing Zig from being able
    to build {#link|glibc|glibc 2.33#} on <code>i386-linux-gnu</code>.
    He got it working, and the tests passing, but it revealed a
    flaw (<a href="https://github.com/ziglang/zig/issues/8930">#8930</a>) in the {#link|Standard Library#} having to do with allocation alignments
    on all 32-bit targets. This issue is not solved in 0.8.0 but is planned to be
    addressed in the 0.8.1 bug fix release. After that, we expect to have test
    coverage for <code>i386-linux-gnu</code>.</p>
    {#header_close#}

    {#header_open|MIPS Support#}
    <p>
    During the 0.8.0 release cycle, Zig's MIPS support was greatly improved, gaining
    full test coverage for little-endian mips, including building {#link|musl|musl 1.2.2#}
    and {#link|glibc|glibc 2.33#}.
    </p>
    <p>
    However, all MIPS targets regressed with the release of {#link|LLVM 12#}, despite having
    <a href="https://bugs.llvm.org/show_bug.cgi?id=49821">an open release blocker bug filed</a>.
    Not only this, but the fix has been in LLVM main branch for a whole month, as of the time
    of this writing, and yet the fix did not make it into 12.0.1-rc1, again despite the
    bug being marked as a 12.0.1 release blocker.
    </p>
    <p>
    As soon as LLVM releases a bug fix version which includes the fix, Zig can re-enable
    MIPS test coverage.
    </p>
    {#header_close#}

    {#header_close#}

    {#header_open|Documentation#}
    <ul>
      <li>std docs: enhance search browser history UX</li>
      <li>The language reference is updated to reflect the changes to the language and
        standard library in this release cycle.</li>
      <li>Fixed {#syntax#}@reduce{#endsyntax#} documentation.</li>
      <li>Fixed operator precedence in the language reference.</li>
      <li>Improved documentation for string slices (<a href="https://github.com/ziglang/zig/issues/7454">#7454</a>).</li>
      <li>Clarify confusing wording regarding <code>%</code> and <code>/</code></li>
      <li>Clarify that {#syntax#}@field{#endsyntax#} can work on declarations.</li>
      <li>Avoid concept of a "Unicode character" in documentation and error messages (<a href="https://github.com/ziglang/zig/issues/8059">#8059</a>).</li>
      <li>Update docs and grammar to allow CRLF line endings (<a href="https://github.com/ziglang/zig/issues/8063">#8063</a>).</li>
      <li>langref: Use "single-item pointer" and "many-item pointer" (<a href="https://github.com/ziglang/zig/issues/8217">#8217</a>).</li>
      <li>docgen: use <code>std.Progress</code> API so that we see a terminal progress
          bar when waiting for the docs to build.</li>
      <li>docs: document the nosuspend keyword (<a href="https://github.com/ziglang/zig/issues/7972">#7972</a>).</li>
      <li>Fix langref.html anchor navigation</li>
      <li>Add doc in `Anonymous Struct Literal` section for special @"0" syntax (<a href="https://github.com/ziglang/zig/issues/8630">#8630</a>).</li>
      <li>Improve documentation for ArrayList, ArrayListUnmanaged, etc. (<a href="https://github.com/ziglang/zig/issues/7624">#7624</a>)</li>
    </ul>
    <p>
    Contributors: Andrew Kelley, Carlos Z√∫√±iga, Dave Gauer, Devin Bayer, Eleanor Bartle, Frank Denis, Jakub Konka, Jay Petacat, Jonas Carpay, Josh Holland, Josh Wolfe, LemonBoy, Martin Wickham, Mathieu Guay-Paquet, Matthew Borkowski, Ryan Liptak, Tadeo Kondrak, Veikka Tuominen, data-man, Jacob G-W, xackus
    </p>
    {#header_close#}

    {#header_open|Language Changes#}
    <p>Compared to other releases, the Zig language saw fewer changes this cycle,
    providing a relatively stable target for the {#link|Self-Hosted Compiler#} implementation.
    Still, there were a few additions and breaking changes.</p>

    {#header_open|No More Extern or Packed Enums#}
    <pre>{#syntax#}const A = extern enum { foo, bar };
const B = packed enum { foo, bar };{#endsyntax#}</pre>
    <pre><code><strong>test.zig:1:11: <span style="color: red">error:</span> enums do not support 'packed' or 'extern'; instead provide an explicit integer tag type</strong>
const A = extern enum { foo, bar };
          ^
<strong>test.zig:2:11: <span style="color: red">error:</span> enums do not support 'packed' or 'extern'; instead provide an explicit integer tag type</strong>
const B = packed enum { foo, bar };
          ^</code></pre>
    <p>This error is caught by the {#link|Self-Hosted Compiler#} (due to {#link|Whole-File AST Lowering#}) but not yet caught by the {#link|Bootstrap Compiler#}. Related proposal: #8970</p>
    {#header_close#}

    {#header_open|Require Block After Suspend#}
    {#code_begin|test_err#}
test "example" {
    suspend;
}
    {#code_end#}
    <p><code>zig fmt</code> automatically fixes it, transforming it into:</p>
    {#code_begin|syntax#}
test "example" {
    suspend {}
}
    {#code_end#}
    <p>Tracking issue: <a href="https://github.com/ziglang/zig/issues/8603">#8603</a></p>
    {#header_close#}

    {#header_open|@extern#}
    <p>New builtin:</p>
    <pre>{#syntax#}@extern(T: type, comptime options: std.builtin.ExternOptions) *T{#endsyntax#}</pre>
    <p>Creates a reference to an external symbol in the output object file.</p>
    {#header_close#}

    {#header_open|Nameless Tests#}
    <p>Nameless tests are exempt from <code>--test-filter</code> parameters, making it
    possible to use <code>--test-filter</code> while still pointing <code>zig test</code>
    at the root source file.</p>
    <p class="file">a.zig</p>
    {#code_begin|syntax#}
test {
    _ = @import("b.zig");
}
    {#code_end#}
    <p class="file">b.zig</p>
    {#code_begin|syntax#}
const std = @import("std");

test "pass" {
    try std.testing.expect(true);
}
test "fail" {
    try std.testing.expect(false);
}
    {#code_end#}
    <pre><code>$ ./zig test a.zig
b.test "fail"... FAIL (TestUnexpectedResult)
<strong>/home/andy/Downloads/zig/lib/std/testing.zig:310:14:</strong> 0x24d54b in std.testing.expect (test)
    if (!ok) return error.TestUnexpectedResult;
             ^
<strong>/home/andy/Downloads/zig/build/b.zig:7:5:</strong> 0x2068b1 in b.test "fail" (test)
    try std.testing.expect(false);
    ^
2 passed; 0 skipped; 1 failed.
error: the following test command failed with exit code 1:
zig-cache/o/577deb476721d8dde8bc782f2c61ed2f/test /home/andy/Downloads/zig/build/zig

$ ./zig test a.zig --test-filter pass
All 2 tests passed.</code></pre>
    {#header_close#}

    {#header_open|@TagType Removed#}
    <p>Old code:</p>
    {#code_begin|test_err#}
const std = @import("std");
const Enum = enum { one, two, three };

test "old code" {
    const T = @TagType(Enum);
    try std.testing.expectEqual(u2, T);
}
    {#code_end#}
    <p>New code:</p>
    {#code_begin|test#}
const std = @import("std");
const Enum = enum { one, two, three };
const TagType = std.meta.TagType;

test "new code" {
    const T = TagType(Enum);
    try std.testing.expectEqual(u2, T);
}
    {#code_end#}
    <p>Contributors: Tadeo Kondrak</p>
    {#header_close#}

    {#header_open|nosuspend#}
    <p>{#syntax#}nosuspend{#endsyntax#} blocks now allow {#syntax#}resume{#endsyntax#}
    inside their scope, because resuming a suspended async function call is actually a
    synchronous operation.</p>
    <p>{#syntax#}nosuspend{#endsyntax#} blocks now allow {#syntax#}async{#endsyntax#}
    function calls inside their scope, because starting an async function call is actually
    a synchronous operation, since the caller is not awaiting on the callee for a return value.</p>
    {#header_close#}

    {#header_open|Add SysV Calling Convention#}
    <p>{#syntax#}std.builtin.CallingConvention{#endsyntax#} now looks like this:</p>
    {#code_begin|syntax#}
pub const CallingConvention = enum {
    Unspecified,
    C,
    Naked,
    Async,
    Inline,
    Interrupt,
    Signal,
    Stdcall,
    Fastcall,
    Vectorcall,
    Thiscall,
    APCS,
    AAPCS,
    AAPCSVFP,
    SysV,
};
    {#code_end#}
    {#header_close#}

    {#header_open|Wrapping Negation on Unsigned Ints at comptime#}
    {#code_begin|test#}
const std = @import("std");
const expect = std.testing.expect;
const maxInt = std.math.maxInt;

test "unsigned negation wrapping" {
    try testUnsignedNegationWrappingEval(1);
    comptime try testUnsignedNegationWrappingEval(1);
}
fn testUnsignedNegationWrappingEval(x: u16) !void {
    try expect(x == 1);
    const neg = -%x;
    try expect(neg == maxInt(u16));
}
    {#code_end#}
    <p>Contributor: LemonBoy</p>
    <p>Tracking issues: <a href="https://github.com/ziglang/zig/issues/7951">#7951</a>, <a href="https://github.com/ziglang/zig/issues/8574">#8574</a></p>
    {#header_close#}

    {#header_open|@import("builtin") no longer re-exports std.builtin#}
    <p>Old code:</p>
    {#code_begin|test_err#}
const std = @import("std");
const builtin = @import("builtin"); // <--- look here

test "old code" {
    const StackTrace = builtin.StackTrace;
}
    {#code_end#}
    <p>New code:</p>
    {#code_begin|test#}
const std = @import("std");
const builtin = std.builtin; // <--- look here

test "new code" {
    const StackTrace = builtin.StackTrace;
}
    {#code_end#}
    <p>Additionally, the following is deprecated:</p>
    {#code_begin|syntax#}
const std = @import("std");
const builtin = std.builtin; // <--- look here

test "deprecated code" {
    const native_arch = builtin.cpu.arch; // deprecated!
}
    {#code_end#}
    <p>Instead, do this:</p>
    {#code_begin|test#}
const std = @import("std");
const builtin = @import("builtin"); // <--- look here

test "new code" {
    const native_arch = builtin.cpu.arch; // OK
}
    {#code_end#}
    {#header_close#}
    {#header_close#}

    {#header_open|Bootstrap Compiler#}
    <p>In the previous release, as well as this release, the main Zig compiler everybody uses
    is the bootstrap compiler, written in C++, also known as "stage1". Despite the main focus
    of this release cycle being the {#link|Self-Hosted Compiler#}, there were some improvements
    to stage1 as well.</p>
    <ul>
        <li>Fix not supporting comments in between multiline string literal lines</li>
        <li>Fix type mapping for c_longdouble</li>
        <li>Print correct error message for vector @intCast</li>
        <li>Fix comparison of unions containing zero-sized types (<a href="https://github.com/ziglang/zig/issues/7047">#7047</a>)</li>
        <li>Avoid resolving type entry in [0]T (fixed #7058)</li>
        <li>Fix crash in comptime struct generation (<a href="https://github.com/ziglang/zig/issues/7027">#7027</a>)</li>
        <li>Disambiguate Wasm imports with same name (<a href="https://github.com/ziglang/zig/issues/7088">#7088</a>)</li>
        <li>Fix generation of pass-by-value args in async fns (<a href="https://github.com/ziglang/zig/issues/7104">#7104</a>)</li>
        <li>Fix asyncCall with non-abi-aligned arguments</li>
        <li>Add architecture-specific clobbers to asm(). We're basically following Clang's
          lead, add the necessary clobbers to minimize the risk of generating wrong code.</li>
        <li>Allow Zig to be built with clang 11 and -Werror</li>
        <li>Reject undefined values when taking union ptr. (<a href="https://github.com/ziglang/zig/issues/7019">#7019</a>)</li>
        <li>Improve error for missing a number type on a runtime var.</li>
        <li>Fix undefined assignment for bitfields. Prevents silent memory corruption. (<a href="https://github.com/ziglang/zig/issues/7055">#7055</a>)</li>
        <li>Emit a compile error instead of falling back to C for unsupported calling convention. (<a href="https://github.com/ziglang/zig/issues/6829">#6829</a>)</li>
        <li>Check calling convention correctly for subsystem detection.</li>
        <li>Resolve usingnamespace decls when calling {#syntax#}@typeInfo{#endsyntax#} (<a href="https://github.com/ziglang/zig/issues/7176">#7176</a>).</li>
        <li>Fix ICE when generating struct fields with padding. (<a href="https://github.com/ziglang/zig/issues/5398">#5398</a>)</li>
        <li>Force union member types to be resolved.</li>
        <li>Fix crash in *[N]T to []T conversion with zst (<a href="https://github.com/ziglang/zig/issues/6951">#6951</a>).</li>
        <li>Add compile error for slice.len incremented beyond bounds (<a href="https://github.com/ziglang/zig/issues/7810">#7810</a>).</li>
        <li>Fix {#syntax#}f128{#endsyntax#} codegen on Big Endian hosts.</li>
        <li>Resolve alignment earlier in {#syntax#}@alignCast{#endsyntax#} (<a href="https://github.com/ziglang/zig/issues/7744">#7744</a>).</li>
        <li>Use correct format specifier for size_t parameters.</li>
        <li>Fix ssize_t definition.</li>
        <li>Remove stray brace in rarely-tested code path (<a href="https://github.com/ziglang/zig/issues/7614">#7614</a>).</li>
        <li>Allow variable capture for multi-prong switch arms, handling the multi-prong
          case as we do with range cases (<a href="https://github.com/ziglang/zig/issues/7188">#7188</a>).</li>
        <li>Let LLVM legalize the overflowing ops on vectors, because it is smart enough to
          produce tight overflow checking sequences.</li>
        <li>Prevent crash with some lazy pointer types (<a href="https://github.com/ziglang/zig/issues/7568">#7568</a>).</li>
        <li>Validate pointer attributes when coercing anon literals.</li>
        <li>Implement type coercion of pointer to anon list to array/struct/union/slice.</li>
        <li>Implement type coercion of anon list to array.</li>
        <li>Create a new declaration scope for union enum types (<a href="https://github.com/ziglang/zig/issues/7532">#7532</a>).</li>
        <li>Add peer type resolution with unsigned ints and larger signed ints.</li>
        <li>Fix bug in generic function monomorphization.</li>
        <li>Apply LLVM ssp attributes globally instead of per-function. Otherwise LLVM asserts with:
          "stack protected callee but caller requested no stack protector"</li>
        <li>Fix crashes (#7426, #7451, #7431).</li>
        <li>Validate the specified cc for lazy fn types (<a href="https://github.com/ziglang/zig/issues/7337">#7337</a>).</li>
        <li>Fix initialization of single-element union tag.</li>
        <li>Fix constant folding of single-element enums.</li>
        <li>Add compile error for pointer arithmetic on ptr-to-array (<a href="https://github.com/ziglang/zig/issues/2018">#2018</a>).</li>
        <li>Fix floating point parsing on BE systems (<a href="https://github.com/ziglang/zig/issues/7256">#7256</a>).</li>
        <li>Fix typeInfo generation for arrays w/o sentinel (<a href="https://github.com/ziglang/zig/issues/7251">#7251</a>).</li>
        <li>Add missing bitcast when rendering var ptr (<a href="https://github.com/ziglang/zig/issues/7250">#7250</a>).</li>
        <li>Small improvement in C ABI support for return types.</li>
        <li>A few small memory usage optimizations.</li>
        <li>Put async frames in the correct LLVM address space.</li>
        <li>Fix for atomicrmw xchg on fp types (<a href="https://github.com/ziglang/zig/issues/4457">#4457</a>).</li>
        <li>Rework tokenizer to match {#link|Self-Hosted Compiler#}. Mainly, this makes the
          stage1 and stage2 logic match each other, making it
          easier to maintain both at the same time. It is also a negligible memory
          usage improvement.</li>
        <li>Store target info in the LLVM module for every function. This is needed to
          let LLVM (or, better, libLTO) produce code using the target options
          specified by the user (<a href="https://github.com/ziglang/zig/issues/8803">#8803</a>).</li>
        <li>Widen non byte-sized atomic loads/stores (<a href="https://github.com/ziglang/zig/issues/7976">#7976</a>).</li>
        <li>Improve message for missing fn return type.</li>
        <li>Fix LLVM error in inline asm invocation (<a href="https://github.com/ziglang/zig/issues/3606">#3606</a>).</li>
        <li>Improve how the async frame alignment is computed.</li>
        <li>More precise serialization of f16 values.</li>
        <li>Fix negation for zero floating point values.</li>
        <li>Resolve builtin types and values via <code>std.builtin</code> rather than via
          {#syntax#}@import("builtin"){#endsyntax#}. This helps avoid the need for
          {#syntax#}usingnamespace{#endsyntax#} used in <code>builtin.zig</code> or in
          <code>std.builtin</code>.</li>
    </ul>
    <p>
    The good news here is that nearly all these fixes come with additional behavior tests, which
    we can use to verify the {#link|Self-Hosted Compiler#} does not regress.
    </p>
    <p>
    One especially noteworthy change here is LemonBoy's fix to ask LLVM to produce compact
    code in -OReleaseSmall mode. Previously, using -OReleaseSmall sometimes resulted in
    larger output binaries than -OReleaseFast! (#7048, #7077)
    </p>
    <p>
    <strong>Big, big thanks to LemonBoy</strong> for solving so many stage1 bugs during this release cycle. This
    is high effort, low-appreciation, huge-impact work that he has been doing. But in reality
    he has been single-handedly keeping us afloat while we work towards finishing the
    {#link|Self-Hosted Compiler#}.
    </p>
    <p>Contributors: LemonBoy, Andrew Kelley, Koakuma, Veikka Tuominen, Tadeo Kondrak, Michael Dusan, Jakub Konka, frmdstryr, Mathieu Guay-Paquet, Sreehari S, Al Hoang, Alexandros Naskos, Isaac Freund, Jay Petacat, Josh Wolfe, Lee Cannon, Matthew Knight, Nathan Michaels, Sizhe Zhao, Timon Kruiper, Woze Parrot, Jacob G-W, lars, pfg, xackus</p>
    {#header_open|LLVM 12#}
    <p>
    This release of Zig upgrades to
    <a href="http://releases.llvm.org/12.0.0/docs/ReleaseNotes.html">LLVM 12</a>.
    </p>
    <p>
    This was a rough release cycle for downstream users of LLVM. During testing of the release
    candidates, we found and reported 7 regressions from LLVM 11. However, despite having
    reproducible regressions reported as release blockers, the LLVM project tagged release
    12.0.0. Not only were there open regressions at this time, but the 12.0.0 tag did not
    even tag the tip of the release/12.x branch - so there were <em>fixes already committed
    into the release branch that did not make it into the tag</em>.
    </p>
    <p>
    At the time of this writing, there are
    <a href="https://bugs.llvm.org/show_bug.cgi?id=release-12.0.1">31 open release blockers for 12.0.1</a>,
    and yet LLVM has already tagged 12.0.1-rc1. As
    <a href="https://lists.llvm.org/pipermail/llvm-dev/2021-May/150800.html">Micha≈Ç G√≥rny puts it</a>:
    </p>
    <blockquote>
I've started testing, hit two bugs I've already reported for 12.0.0 RCs
and figured out I'm wasting my time.  It seems that LLVM reached
the point where releases are pushed through just for the sake of
releases and QA doesn't exist.
    </blockquote>
    <p>
    I hope the LLVM project can step up and take releases and regressions more seriously.
    </p>
    <p>
    Either way, it is starting to become clear that
    <a href="https://kristoff.it/blog/zig-new-relationship-llvm/">transitioning LLVM to an optional dependency</a>,
    and thereby providing an alternative to the LLVM monoculture,
    is becoming more and more of an attractive feature for the Zig project to offer.
    In this release you can see that we have broken ground on this front:
    {#link|x86-64 Backend#},
    {#link|AArch64 Backend#},
    {#link|ARM Backend#},
    {#link|WebAssembly Backend#},
    {#link|RISC-V 64 Backend#},
    {#link|C Backend#},
    {#link|SPIR-V Backend#}
    </p>
    {#header_close#}

    {#header_close#}

    {#header_open|Self-Hosted Compiler#}
    <p>The main focus of this release cycle was the self-hosted compiler (also known
    as "stage2").</p>
    <p>
    Despite the fact that .zig source code by default is still compiled in this
    release using the {#link|Bootstrap Compiler#}, the main driver code is already
    self-hosted, as well as many features, such as {#link|zig cc#}, {#link|C Translation#},
    and {#link|CPU Feature Detection#}. Improvements made to "stage2" in these areas
    do in fact affect the main Zig user experience.
    </p>
    {#header_open|CPU Feature Detection#}
    <p>LemonBoy added a framework for host CPU detection on Linux based on
    parsing <code>/proc/cpuinfo</code>, and implemented the model
    detection for {#link|64-bit SPARC targets|sparc64 Support#} as proof of concept.
    </p>
    <p>
    He also added CPU feature detection for macOS, PowerPC, and ARM/AArch64.
    </p>
    <p>
    The CPU detection code is nearly at feature parity with LLVM. We do support
    detecting the native CPU on Sparc systems and macOS, our ARM/AArch64
    model list is quite comprehensive, and so is our PPC one. The only missing pieces are:</p>
    <ul>
      <li>ARM32 detection on Darwin hosts (it is doubtful anybody is planning on
        running the compiler on a old-ass iPhone)</li>
      <li>s390x detection on Linux hosts. This can be easily added at a later stage.</li>
    </ul>
    <p>As a result of all this work, we dropped LLVM's host CPU detection method
    as a fallback. This is one less dependency that Zig has on LLVM, bringing us
    one step closer to making LLVM an optional extension rather than a required dependency.</p>

    {#header_open|Update CPU Features Tool#}
    <p>Zig's target CPU feature awareness is a superset of LLVM's, which means that for every
    target CPU feature Zig is aware of, it must know whether and how to map that to LLVM's
    target CPU feature.</p>
    <p>For this purpose Andrew created the <a href="https://github.com/ziglang/zig/blob/0.8.0/tools/update_cpu_features.zig">update_cpu_features.zig</a> tool. This tool generates .zig code that
    contains enums and data declarations for all the various CPUs that Zig is aware of.</p>
    <p>This tool is run in response to the following two events:</p>
    <ul>
      <li>When a new LLVM version is released.</li>
      <li>When the Zig project modifies, creates, or deletes target CPU features independently of LLVM.</li>
    </ul>
    <p>Before this release, updating target CPU features in response to LLVM updates was
    a manual process, in which it was too easy to introduce bugs.</p>
    <p>Now, the tool completely automates the process, and there are no longer any manual steps
    involved when LLVM updates, other than re-running the tool.</p>
    <p>
    Additionally, Andrew improved it to parallelize work for each target, making it run
    much faster, despite wading through many megabytes of llvm-tblgen JSON dumps.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|Command-Line Interface#}
    <ul>
      <li>Fixed <code>zig init-lib</code> not accepting <code>-h</code> flag (<a href="https://github.com/ziglang/zig/issues/6798">#6798</a>).</li>
      <li>Infer <code>--name</code> based on first C source file or object.</li>
      <li>Fixed incorrect error message with <code>-cflags</code>.</li>
      <li>Added <code>run</code> and <code>update-and-run</code> command to the <code>--watch</code>
        REPL.</li>
      <li>In the <code>--watch</code> REPL, empty command re-runs previous command. This can be
        especially useful combined with the new <code>update-and-run</code> command.</li>
    </ul>
    {#header_close#}

    {#header_open|Reworked Memory Layout#}
    <p>Andrew writes:</p>
    <p>I have been reading Richard Fabian's book,
    <a href="https://dataorienteddesign.com/dodbook/">Data-Oriented Design</a>,
    and finally things started to "click" for me. I've had these ideas swirling around
    in my head for years, but only recently do I feel like I have an intuitive grasp on
    how modern CPUs work, especially with regards to L1 cache, and the relative latencies
    of uncached memory loads vs computations.</p>
    <p>Compilation speed is a top priority for the design of both the Zig self-hosted
    compiler as well as the language itself. I have been careful to design the language
    in a way as to unlock the potential of an ambitiously fast compiler.</p>
    <p>In this release cycle, I took the time to rework the memory layout of 3 out of 4
    phases of the compiler pipeline:</p>
    <pre>tokenize ‚û°Ô∏è parse ‚û°Ô∏è ast lowering ‚û°Ô∏è semantic analysis ‚û°Ô∏è machine code gen</pre>
    <p>Each arrow in this diagram represents a phase in the compiler pipeline inputting data
    in one form, and outputting data in a different form, for the next phase.</p>
    <ul>
      <li><strong>tokenize</strong> - inputs <strong>.zig source code</strong>,
        outputs <strong>token list</strong></li>
      <li><strong>parse</strong> - inputs <strong>token list</strong>,
        outputs <strong>AST</strong> (Abstract Syntax Tree)</li>
      <li><strong>ast lowering</strong> - inputs <strong>AST</strong>, outputs
        <strong>ZIR</strong> (Zig Intermediate Representation)</li>
      <li><strong>semantic analysis</strong> - inputs <strong>ZIR</strong>, outputs
        <strong>AIR</strong> (Analyzed Intermediate Representation)</li>
      <li><strong>machine code gen</strong> - inputs <strong>AIR</strong>, outputs
        <strong>machine code</strong></li>
    </ul>
    <p>
    I decided to try to reduce the number of heap-allocated bytes of the
    <strong>token list</strong> as well as the <strong>AST</strong>, as a pilot
    test for doing a similar strategy for ZIR and AIR later.
    I had a few key insights here:
    </p>
    <ul>
      <li>Underlying premise: using less memory will make things faster, because
        of fewer allocations and better cache utilization. Also using less
        memory is valuable in and of itself.</li>
      <li>Using a {#link|Struct-Of-Arrays|MultiArrayList#}
        for tokens and AST nodes, saves the bytes of
        padding between the enum tag (which kind of token is it; which kind
        of AST node is it) and the next fields in the struct. It also improves
        cache coherence, since one can peek ahead in the tokens array without
        having to load the source locations of tokens.</li>
      <li>Token memory can be conserved by only having the tag (1 byte) and byte
        offset (4 bytes) for a total of 5 bytes per token. It is not necessary
        to store the token ending byte offset because one can always re-tokenize
        later, but also most tokens the length can be trivially determined from
        the tag alone, and for ones where it doesn't, string literals for
        example, one must parse the string literal again later anyway in
        astgen, making it free to re-tokenize.</li>
      <li>AST nodes do not actually need to store more than 1 token index because
        one can poke left and right in the tokens array very cheaply.</li>
    </ul>
    <p>So far we are left with one big problem though: how can we put AST nodes
    into an array, since different AST nodes are different sizes?</p>
    <p>This is where my key observation comes in: one can have a hash table for
    the extra data for the less common AST nodes! But it gets even better than
    that:</p>
    <p>I defined this data that is always present for every AST Node:</p>
    <ul>
      <li>tag (1 byte)<ul>
          <li>which AST node is it</li>
        </ul>
      </li>
      <li>main_token (4 bytes, index into tokens array)<ul>
          <li>the tag determines which token this points to</li>
        </ul>
      </li>
      <li>{#syntax#}struct{lhs: u32, rhs: u32}{#endsyntax#}<ul>
          <li>enough to store 2 indexes to other AST nodes, the tag determines
            how to interpret this data</li>
        </ul>
      </li>
    </ul>
    <p>You can see how a binary operation, such as <code>a * b</code> would fit into this
    structure perfectly. A unary operation, such as <code>*a</code> would also fit,
    and leave <code>rhs</code> unused. So this is a total of 13 bytes per AST node.
    And again, we don't have to pay for the padding to round up to 16 because
    we store in struct-of-arrays format.</p>

    <p>I made a further observation: the only kind of data AST nodes need to
    store other than the main_token is indexes to sub-expressions. <em>That&#39;s it.</em>
    <strong>The only purpose of an AST is to bring a tree structure to a list of tokens.</strong>
    This observation means all the data that nodes store are only sets of u32
    indexes to other nodes. The other tokens can be found later by the compiler,
    by poking around in the tokens array, which again is super fast because it
    is struct-of-arrays, so you often only need to look at the token tags array,
    which is an array of bytes, very cache friendly.</p>

    <p>So for nearly every kind of AST node, you can store it in 13 bytes. For the
    rarer AST nodes that have 3 or more indexes to other nodes to store, either
    the lhs or the rhs will be repurposed to be an index into an extra_data array
    which contains the extra AST node indexes. In other words, no hash table needed,
    it's just 1 big ArrayList with the extra data for AST Nodes.</p>

    <p>Final observation, no need to have a canonical tag for a given AST. For example:
    The expression <code>foo(bar)</code> is a function call. Function calls can have any
    number of parameters. However in this example, we can encode the function
    call into the AST with a tag called <code>FunctionCallOnlyOneParam</code>, and use lhs
    for the function expr and rhs for the only parameter expr. Meanwhile if the
    code was <code>foo(bar, baz)</code> then the AST node would have to be <code>FunctionCall</code>
    with lhs still being the function expr, but rhs being the index into
    <code>extra_data</code>. Then because the tag is <code>FunctionCall</code> it means
    <code>extra_data[rhs]</code> is the "start" and <code>extra_data[rhs+1]</code> is the "end".
    Now the range <code>extra_data[start..end]</code> describes the list of parameters
    to the function.</p>

    <p>Point being, you only have to pay for the extra bytes if the AST actually
    requires it. The limit to the number of different AST tag encodings is 256, in order to keep
    the tag only 1 byte each.</p>

    <p>Reworking the memory layout of two of the core pipeline phases is no joke.
    After 176 commits, 42 files changed, +20,800/-16,573 lines,
    and help from quite a few contributors, we had all tests passing again in the branch (<a href="https://github.com/ziglang/zig/issues/7920">#7920</a>).
    I observed the following performance improvements of the parser:</p>
    <ul>
      <li>‚úÖ 15% fewer cache-misses</li>
      <li>‚úÖ 28% fewer total instructions executed</li>
      <li>‚úÖ 26% fewer total CPU cycles</li>
      <li>‚úÖ 22% faster wall clock time</li>
    </ul>
    <p>
    Based on this success, I followed up, applying the same principles and strategies
    to <strong>ZIR</strong>.
    </p>
    <p>I'll spare you the details this time, but after 100 commits, 33 files changed,
    +14,719/-11,495 lines, and again some very much appreciated help from various
    contributors, the branch was merge-ready (<a href="https://github.com/ziglang/zig/issues/8266">#8266</a>).</p>
    <p>
    For these changes, it was not possible to come up with a realistic workload for
    a benchmark, since self-hosted semantic analysis was not far enough along, but I was
    able to do this funny one:
    </p>
    <p class="file">print1mil.zig</p>
    <pre>{#syntax#}pub export fn _start() noreturn {
    print(); // repeated 1,000,000 times
    exit();
}

fn print() void {
    asm volatile ("syscall"
        :
        : [number] "{rax}" (1),
          [arg1] "{rdi}" (1),
          [arg2] "{rsi}" (@ptrToInt("Hello, world!\n")),
          [arg3] "{rdx}" (14)
        : "rcx", "r11", "memory"
    );
    return;
}

fn exit() noreturn {
    asm volatile ("syscall"
        :
        : [number] "{rax}" (231),
          [arg1] "{rdi}" (0)
        : "rcx", "r11", "memory"
    );
    unreachable;
}{#endsyntax#}</pre>
    <p>Results:</p>
    <ul>
      <li>‚úÖ Wall Clock Time: 0.93 seconds ‚û°Ô∏è 0.57 seconds (39% reduction)<ul>
          <li>this is 1.8 million lines per second on my laptop üòÄ</li></ul></li>
      <li>‚úÖ Peak Memory Usage: 645 MiB ‚û°Ô∏è 386 MiB (40% reduction)</li>
      <li>‚úÖ Cache Misses (53% reduction)</li>
      <li>‚úÖ Instructions (23% reduction)</li>
      <li>‚úÖ CPU Cycles (41% reduction)</li>
    </ul>
    <p>
    Even with a contrived example like this, it is clear that
    designing the core phases of the compiler pipeline to use compact
    encodings has an obvious and worthwhile benefit in terms of memory usage and speed.
    </p>
    <p>In this release we did <em>not</em> yet apply these principles and strategies to
    <strong>AIR</strong>, the last remaining intermediate representation of the compiler pipeline.
    When we do, it will affect the bottleneck of the compiler - semantic analysis
    and machine code generation - and so I expect to see similar performance
    gains upon finishing that work.</p>
    {#header_close#}

    {#header_open|Whole-File AST Lowering#}
    <p>This was a language modification as well as an implementation strategy.
    It solves #335 and goes a long way towards making the problematic proposal #3028 unneeded.
    The implementation simplified the compiler and yet opened up straightforward
    opportunities for parallelism and caching.</p>
    <p>In stage2 we have a concept of "AstGen" which stands for Abstract Syntax Tree Generation. This is the part where we input an AST and output Zig Intermediate Representation code.</p>
    <p>Before, this was done lazily as-needed per function. This required code to
    orchestrate per-function ZIR code and independently manage memory lifetimes.
    It also meant each function used independent arrays of ZIR tags, instruction lists,
    string tables, and auxiliary lists. When a file was modified, the compiler had to check
    which function source bytes differed, and repeat AstGen for the changed functions to
    generate updated ZIR code.</p>
    <p>One key design strategy is to make ZIR code immutable, typeless, and depend only on AST.
    This ensures that it can be re-used for multiple generic instantiations, comptime
    function calls, and inlined function calls.</p>
    <p>This modification took that design strategy, and observed that it is possible
    to generate ZIR for an entire file indiscriminately, for all functions, depending on
    AST alone and not introducing any type checking. Furthermore, it observes that
    this allows implementing the following compile errors:</p>
    <ul>
      <li>Unused private function</li>
      <li>Unused local variable</li>
      <li>Unused private global variable</li>
      <li>Unreachable code</li>
      <li>Local variable not mutated</li>
    </ul>
    <p>All of these compile errors are possible with AstGen alone, and do not require types. In fact, trying to implement these compile errors with types is problematic because of conditional compilation. But there is no conditional compilation with AstGen. Doing entire files at once would make it possible to have compile errors for unused private functions and globals.</p>
    <p>With the way that ZIR is encoded, lowering all of a file into
    <a href="https://andrewkelley.me/temp/luffy.jpg">one piece</a>
    of ZIR code is less overhead than splitting it by function.
    Less overhead of list capacity is wasted, and more strings in the string
    table will be shared.</p>

    <p>This works great for caching. All source files independently need to be converted
    to ZIR, and once converted to ZIR, the original source, token list, and AST node
    list are all no longer needed. The relevant bytes are stored directly in ZIR.
    So each .zig source file has exactly one corresponding ZIR bytecode.
    The caching strategy for this is dead simple. Consider also that the transformation
    from .zig to ZIR does not depend on the target options, or anything,
    other than the AST. So cached ZIR for std lib files and common used packages
    <strong>can be re-used between unrelated projects</strong>.</p>

    <p>This made the first 3 phases of the compiler pipeline <em>embarassingly parallel</em>.
    Thanks to #2206, the compiler optimistically looks for all .zig source files in a project,
    and parallelizes each tokenize‚û°Ô∏èparse‚û°Ô∏èZIR transformation.
    The caching system notices when .zig source files are unchanged,
    and loads the .ZIR code directly instead of the source, skipping tokenization,
    parsing, and AstGen entirely, on a per-file basis.
    The AST tree only needs to be loaded in order to report compile errors.</p>

    <p>Because of the {#link|Reworked Memory Layout#}, serialization of ZIR
    in binary form is straightforward. It consists only of:</p>
    <ul>
      <li>List of u8 tags for each instruction</li>
      <li>List of u32, u32 data for each instruction</li>
      <li>List of u8 string table</li>
      <li>List of u32 auxiliary data</li>
    </ul>
    <p>Writing/reading this to/from a file is trivial and is performed via a single
    writev/readv syscall, respectively.</p>

    <p>Here is an example of using the new {#link|zig ast-check command#} to print
    how many bytes are used for one of the largest .zig files
    in the {#link|Standard Library#}:</p>
    <pre><code>$ zig ast-check -t std/os.zig | head -n7
# Source bytes:       238 KB
# Tokens:             35023 (171 KB)
# AST Nodes:          17397 (221 KB)
# Total ZIR bytes:    472 KB
# Instructions:       26586 (234 KB)
# String Table Bytes: 15.0 KB
# Extra Data Items:   57179 (223 KB)</code></pre>
    <p>The key thing to remember here is that with "Total ZIR bytes" loaded in memory,
    the "Source bytes" <strong>remain on disk, never loaded into memory</strong>,
    and "Tokens", and "AST Nodes" <strong>are never computed</strong>. They only need
    to be loaded/computed for files which contain compile errors.</p>

    <p>So although the .zig source code is pretty compact, if you add up "Source bytes",
    "Tokens", and "AST Nodes", it comes out to 630 KB, which is 1.3 times the number of
    "Total ZIR bytes". I checked the stats for all the std lib files, and found this 1.3 ratio
    to be extremely consistent.</p>

    <p>This means that not only does whole-file AST lowering allow Zig to skip past 3 compiler
    phases for cached files, Zig ends up loading <em>fewer bytes from disk</em>
    in order to do so!</p>

    <p>
    In this set of changes, I (Andrew) also reworked the incremental compilation
    infrastructure in the frontend, making it work cleanly with
    {#link|Standard Library#} integration. I made this infographic to communicate a sense
    of progress that this set of changes accomplished:
    </p>

    <img src="https://ziglang.org/download/0.8.0/whole-file-astgen.png" alt="Infographic showing a sense of progress" style="max-width: 100%">

    <p>In order to have a proper benchmark to find out how fast the compiler is,
    we would need to have Sema (Semantic Analysis) complete (in the picture above,
    it is marked 40% done). However, we can at least collect a measurement for the first
    three phases of the pipeline and see how Zig is doing so far.</p>

    <p>In summary, it comes out to <strong>8.9 million lines per second</strong> on my
    8-core i9-9980HK NVMe:</p>

    <pre><code>AstGen entire std lib, stage2 debug   cold cache: 0m0.959s
AstGen entire std lib, stage2 debug   warm cache: 0m0.066s
AstGen entire std lib, stage2 release cold cache: 0m0.033s
AstGen entire std lib, stage2 release warm cache: 0m0.018s</code></pre>

    <p>The lines-per-second number is derived by dividing
    how many lines of code are in the {#link|Standard Library#} (292,458) by the
    "release cold cache" number above (33ms)</p>

    <p>There is no way Zig will be this fast when the implementation is completely
    finished. <strong>This number does not include the two final phases of the
      compiler pipeline</strong>. But these are some promising results so far!
    At least there is an upper limit to aim for.</p>

    {#header_open|zig ast-check command#}
    <p>Thanks to this work, there is a new subcommand: <code>zig ast-check</code></p>
    <p>This command quickly reports a subset of compile errors (about 100 different things),
    without needing to know any information about the target or the build.
    This makes it suitable for automatic
    IDE integration, for quick turnaround on compile errors such as:</p>
    <ul>
      <li>Redeclaring the same variable name</li>
      <li>Redundant use of {#syntax#}comptime{#endsyntax#}</li>
      <li>{#syntax#}break{#endsyntax#} expression outside loop</li>
      <li>unused label</li>
      <li>returning from a {#syntax#}defer{#endsyntax#} expression</li>
    </ul>
    <p>
    This command is also useful to Zig developers. It has a <code>-t</code> flag available
    in debug builds of the compiler which renders the ZIR code into a textual format.
    Here is an example:
    </p>
    <p class="file">hello.zig</p>
    {#code_begin|syntax#}
const std = @import("std");

pub fn main() !void {
    try std.io.getStdOut().writeAll("Hello, World!\n");
}
    {#code_end#}
    <pre><code>$ ./zig ast-check -t hello.zig
# Source bytes:       109B
# Tokens:             32 (184B)
# AST Nodes:          16 (328B)
# Total ZIR bytes:    622B
# Instructions:       26 (234B)
# String Table Bytes: 48B
# Extra Data Items:   69 (276B)
%25 = extended(struct_decl(parent, Auto, {
  [53] std line(0) hash(c9cf6ee7a5ad2804a9114568f721d663): %0 = block_inline({
    %1 = import("std") token_offset:1:21
    %2 = break_inline(%0, %1)
  }) node_offset:1:1
  [60] pub main line(2) hash(92a14e8c420ccc95ba5cac0402815cd9): %3 = block_inline({
    %23 = func_inferred([], @Ref.void_type, inferror, {
      %4 = dbg_stmt(1, 4)
      %16 = block({
        %5 = decl_ref("std") token_offset:4:9
        %6 = field_val(%5, "io") node_offset:4:12
        %7 = field_val(%6, "getStdOut") node_offset:4:15
        %8 = call(%7, []) node_offset:4:25
        %9 = field_val(%8, "writeAll") node_offset:4:27
        %10 = param_type(%9, 0)
        %11 = str("Hello, World!\n")
        %12 = as_node(%10, %11) node_offset:4:37
        %13 = call(%9, [%12]) node_offset:4:36
        %14 = is_err(%13) node_offset:4:5
        %15 = condbr(%14, {
          %17 = err_union_code(%13) node_offset:4:5
          %18 = ret_node(%17) node_offset:4:5
        }, {
          %19 = err_union_payload_unsafe(%13) node_offset:4:5
          %20 = break(%16, %19)
        }) node_offset:4:5
      }) node_offset:4:5
      %21 = ensure_result_used(%16) node_offset:4:5
      %22 = ret_coerce(@Ref.void_value) token_offset:5:1
    }) (lbrace=0:20,rbrace=2:0) node_offset:3:5
    %24 = break_inline(%3, %23)
  }) node_offset:3:5
}, {}, {})
Imports:
  std</code></pre>
    {#header_close#}
    {#header_close#}

    {#header_open|LTO#}
    <p>
    LTO stands for <strong>Link Time Optimization</strong>. In summary, it means
    postponing the final stages of compilation and optimization until the very
    end, when all objects are available to examine at the same time.
    </p>
    <p>
    The Command-Line Interface gains <code>-flto</code> and <code>-fno-lto</code> options to
    override the default. However, the cool thing about this is that the defaults
    are great! In general when you use build-exe in release mode, Zig will
    enable LTO if it would work and it would help.
    </p>
    <p>
    {#link|zig cc#} supports detecting and honoring the <code>-flto</code>
    and <code>-fno-lto</code> flags as well.
    </p>
    <p>
    This feature is implemented in a way that allows {#link|LLVM|LLVM 12#} to optimize
    across the Zig and C/C++ code boundary:
    </p>
    <p class="file">main.zig</p>
    <pre>{#syntax#}const std = @import("std");

export fn foo4() void {
    _ = std.c.printf("Hi\n");
}

extern fn foo1() c_int;

pub fn main() u8 {
    return @intCast(u8, foo1());
}{#endsyntax#}</pre>
    <p class="file">a.c</p>
    <pre><code>int foo1(void);
void foo2(void);
void foo4(void);

static signed int i = 0;

void foo2(void) {
  i = -1;
}

static int foo3() {
  foo4();
  return 10;
}

int foo1(void) {
  int data = 0;

  if (i &lt; 0)
    data = foo3();

  data = data + 42;
  return data;
}</code></pre>
    <p>Output:</p>
    <pre><code>$ ./zig build-exe main.zig a.c -OReleaseFast -lc 
$ ./main
$ echo $?
42
$ objdump -d main -Mintel | grep -A7 '&lt;main'
0000000000201530 &lt;main&gt;:
  201530:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  201537:	66 0f 1f 84 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
  20153e:	00 00 
  201540:	48 83 7c c2 08 00    	cmp    QWORD PTR [rdx+rax*8+0x8],0x0
  201546:	48 8d 40 01          	lea    rax,[rax+0x1]
  20154a:	75 f4                	jne    201540 &lt;main+0x10&gt;
  20154c:	48 63 cf             	movsxd rcx,edi
  20154f:	48 89 35 7a 22 00 00 	mov    QWORD PTR [rip+0x227a],rsi        # 2037d0 &lt;argv&gt;
  201556:	48 89 0d 7b 22 00 00 	mov    QWORD PTR [rip+0x227b],rcx        # 2037d8 &lt;argv+0x8&gt;
  20155d:	48 89 15 7c 22 00 00 	mov    QWORD PTR [rip+0x227c],rdx        # 2037e0 &lt;environ.0&gt;
  201564:	48 89 05 7d 22 00 00 	mov    QWORD PTR [rip+0x227d],rax        # 2037e8 &lt;environ.0+0x8&gt;
  20156b:	b8 2a 00 00 00       	mov    eax,0x2a
  201570:	c3                   	ret</code></pre>
    <p>The interesting thing to note here is that there was no LTO explicitly opted into.
    It happened automatically.
    And you can see here that in the main function, there is no call to
    <code>foo1</code> and there is no exported <code>foo4</code>. If we didn't have LTO,
    the call to <code>foo1</code> could not have been inlined. For example, here's what
    happens if we force-disable LTO:
    </p>
    <pre><code>$ ./zig build-exe main.zig a.c -OReleaseFast -lc -fno-lto
$ objdump -d main -Mintel | grep -A7 '&lt;main'
00000000002015d0 &lt;main&gt;:
  2015d0:	50                   	push   rax
  2015d1:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
  2015d8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  2015df:	00 
  2015e0:	48 83 7c c2 08 00    	cmp    QWORD PTR [rdx+rax*8+0x8],0x0
  2015e6:	48 8d 40 01          	lea    rax,[rax+0x1]
  2015ea:	75 f4                	jne    2015e0 &lt;main+0x10&gt;
  2015ec:	48 63 cf             	movsxd rcx,edi
  2015ef:	48 89 35 fa 22 00 00 	mov    QWORD PTR [rip+0x22fa],rsi        # 2038f0 &lt;argv&gt;
  2015f6:	48 89 0d fb 22 00 00 	mov    QWORD PTR [rip+0x22fb],rcx        # 2038f8 &lt;argv+0x8&gt;
  2015fd:	48 89 15 fc 22 00 00 	mov    QWORD PTR [rip+0x22fc],rdx        # 203900 &lt;environ.0&gt;
  201604:	48 89 05 fd 22 00 00 	mov    QWORD PTR [rip+0x22fd],rax        # 203908 &lt;environ.0+0x8&gt;
  20160b:	e8 90 ff ff ff       	call   2015a0 &lt;foo1&gt;
  201610:	0f b6 c0             	movzx  eax,al</code></pre>
    <p>Now you can see Zig is forced to call <code>foo</code> and return its result.</p>
    <p>Tracking issue: <a href="https://github.com/ziglang/zig/issues/2845">#2845</a></p>
    {#header_close#}

    {#header_open|Static PIE#}
    <p>Mainly thanks to LemonBoy, Zig now supports
    <strong>Position Independent Executables</strong>, even
    when compiling statically. Here is an example:</p>
    <pre>$ zig build-exe hello.zig 
$ file hello
hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped
$ zig build-exe hello.zig -fPIE
$ file hello
hello: ELF 64-bit LSB <strong>pie</strong> executable, x86-64, version 1 (SYSV), dynamically linked, with debug_info, not stripped</pre>
    <p>
    The main use case for PIE is
    <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">Address Space Layout Randomization</a>.
    This is a security measure aimed at making exploits more difficult by introducing
    non-determinism into pointer addresses at runtime. Its effectiveness is debatable,
    however, it also has a surprisingly useful property.
    </p>
    <p>
    It is one piece of the puzzle in a
    <a href="https://www.youtube.com/watch?v=pq1XqP4-qOo">truly portable Linux binary that can run on any distribution, including loading graphics drivers</a>.
    A static PIE is capable of executing both statically linked, and then
    re-executing itself dynamically linked once the statically linked code has surveyed
    the system to find the dynamic linker. This is a niche idea, but may
    be worth pursuing for the use case of distributing portable game binaries
    and other GUI applications.
    </p>
    <p>Tracking issues: <a href="https://github.com/ziglang/zig/issues/3960">#3960</a>, <a href="https://github.com/ziglang/zig/issues/4503">#4503</a></p>
    {#header_close#}

    {#header_open|Native libc Integration#}
    <p>Thanks to an improvement by Isaac Freund, Zig will now integrate with system libc
    when targeting the native OS/ABI and linking any system libraries.</p>

    <p>Before, Zig would always try to build its own libc and compile against
    that. This of course makes sense for cross-compilation, but can cause
    problems when targeting the native OS/ABI, when combined with other system libraries.</p>
    
    <p>For example, if the system uses a newer glibc version than zig ships,
    zig will fall back to using the newest version it does ship. However
    this causes linking system libraries to fail as they are built against a
    different glibc version than the zig code is built against.</p>

    <p>On the other hand, if not linking system libraries, using the zig-provided libc
    is more reliable as it does not depend on any quirks of the host system
    or being able to invoke the system C compiler to find include directories.</p>
    {#header_close#}

    {#header_open|Reuse Runtime Libraries in More Cases#}
    <p>
    Previously Zig would need to recompile runtime libraries if you changed the
    values of --strip or -O. Now, unless the <code>debug_compiler_runtime_libs</code>
    flag is set (which is currently not exposed to the CLI), Zig will always
    choose ReleaseFast or ReleaseSmall for compiler runtime libraries.
    </p>
    <p>
    When the main application chooses ReleaseFast or ReleaseSmall, that
    value is propagated to compiler runtime libraries. Otherwise a decision
    is made based on the target, which is currently ReleaseSmall for
    freestanding WebAssembly and ReleaseFast for everything else.
    </p>
    <p>
    Ultimately the purpose of this change is to have Debug and ReleaseSafe
    builds of applications still get optimized builds of, e.g. libcxx and
    libunwind, as well as to spend less time unnecessarily rebuilding compiler
    runtime libraries.
    </p>
    {#header_close#}

    {#header_open|x86-64 Backend#}
    <ul>
      <li>Use ABI size to determine 64-bit operation.</li>
      <li>Implement integer multiplication.</li>
      <li>Encoding helpers to make future contributions easier.</li>
    </ul>
    <p>See <a href="https://github.com/ziglang/zig/blob/0.8.0/test/stage2/test.zig">the set of test cases passing for x86-64</a></p>
    <p>Contributors: gracefu, Joachim Schmidt</p>
    {#header_close#}

    {#header_open|AArch64 Backend#}
    <p>The experimental self-hosted AArch64 (a.k.a. ARM64) backend is new in this version.
    Currently, the self-hosted compiler is able to generate binaries for Linux (ELF) and macOS
    (Mach-O, thanks to Jakub Konka). Currently, only a very small subset of the Zig language
    is supported.</p>
    <p>See <a href="https://github.com/ziglang/zig/blob/0.8.0/test/stage2/aarch64.zig">the set of test cases passing for aarch64</a></p>
    {#header_close#}

    {#header_open|ARM Backend#}
    <p>Bitwise operations on and multiplication of 32-bit integers were introduced.
    Furthermore, conditional branching (including while- and for-loops) is now possible.
    Additionally, the register allocation mechanism was overhauled, allowing for correct
    code generation in situations where registers are spilled.
    </p>
    <p>See <a href="https://github.com/ziglang/zig/blob/0.8.0/test/stage2/arm.zig">the set of test cases passing for ARM</a></p>
    <p>Contributors: Joachim Schmidt</p>
    {#header_close#}

    {#header_open|LLVM Backend#}
    <p>Timon Kruiper broke ground on the stage2 LLVM backend during this release cycle.</p>
    <p>See <a href="https://github.com/ziglang/zig/blob/0.8.0/test/stage2/llvm.zig">the set of test cases passing for the LLVM backend</a></p>
    {#header_close#}

    {#header_open|WebAssembly Backend#}
    <p>This is a work-in-progress backend newly introduced in 0.8.0.</p>
    <p>During the self-hosted compiler meeting of
    <a href="https://github.com/ziglang/zig/wiki/Self-Hosted-Compiler-Meetings#2020-12-10">2020-12-10</a>
    we discussed on how to move forward with the architecture of the backends.
    A proof of concept was done in <a href="https://github.com/ziglang/zig/pull/7321">#7321</a>
    to merge it with the other backends. However, it was found to be counter intuitive and
    ultimately decided upon to keep the wasm backend seperately.
    </p>
    <p>
    Apart from this design decision, progress was made to bring up the wasm backend closer towards feature completeness:
    </p>
    <ul>
        <li>Implement storing and loading of locals (<a href="https://github.com/ziglang/zig/pull/7726">#7726</a>)</li>
        <li>Refactoring the wasm backend to streamline its implementation with the other backends. (<a href="https://github.com/ziglang/zig/pull/7797">#7797</a>)</li>
        <li>Support for control flow such as while loops and if statements. (<a href="https://github.com/ziglang/zig/pull/7895">#7895</a>)</li>
        <li>Importing and calling of extern functions. Allowing to call host functions from within Zig. (<a href="https://github.com/ziglang/zig/pull/7960">#7960</a>)</li>
        <li>Unary operator '!' support. (<a href="https://github.com/ziglang/zig/pull/8339">#8339</a>)</li>
        <li>Opcode builder and multiple binary operands implemented. (<a href="https://github.com/ziglang/zig/pull/8416">#8416</a>)</li>
        <li>"Hello world" support (arrays and pointer to arrays). (<a href="https://github.com/ziglang/zig/pull/8439">#8439</a>)</li>
        <li>Enums (<a href="https://github.com/ziglang/zig/pull/8789">#8789</a>)</li>
        <li>Initial implementation of structs and switches. (<a href="https://github.com/ziglang/zig/pull/8847">#8847</a>)</li>
        <li>Support for error sets and error unions. (<a href="https://github.com/ziglang/zig/pull/8923">#8923</a>)</li>
    </ul>
    <p>See <a href="https://github.com/ziglang/zig/blob/0.8.0/test/stage2/wasm.zig">the set of test cases passing for the WASM backend</a></p>
    <p>Contributors: Luuk de Gram, Isaac Freund, gracefu</p>
    {#header_close#}

    {#header_open|RISC-V 64 Backend#}
    <p>This is a work-in-progress backend newly introduced in 0.8.0.</p>
    <p>See <a href="https://github.com/ziglang/zig/blob/0.8.0/test/stage2/riscv64.zig">the set of test cases passing for the RISC-V 64 backend</a></p>
    <p>Contributors: Joachim Schmidt</p>
    {#header_close#}

    {#header_open|C Backend#}
    <ul>
      <li>Added tests for emit-h functionality.</li>
      <li>Implemented {#syntax#}@breakpoint{#endsyntax#}.</li>
      <li>Improved test harness to support executing generated C code.</li>
      <li>Proper integration with incremental compilation of the frontend.</li>
      <li>condbr, breaks, switchbr, not, bitwise ops, optionals, errors</li>
      <li>Numerous other sweeping changes.</li>
    </ul>
    <p>See <a href="https://github.com/ziglang/zig/blob/0.8.0/test/stage2/cbe.zig">the set of test cases passing for the C backend</a></p>
    <p>Contributors: Andrew Kelley, Veikka Tuominen, Jacob G-W, Noam Preil, Alex Cameron, Tadeo Kondrak</p>
    {#header_close#}

    {#header_open|SPIR-V Backend#}
    <p>Robin Voetter broke ground on the SPIR-V backend during this cycle. It's not yet to the
    point where we can get a
    <a href="https://github.com/andrewrk/zig-vulkan-triangle/">"hello world" vulkan triangle</a>,
    but the skeleton of the backend
    is in place. There are quite a few language issues to overcome. This backend challenges
    the ability for Zig to be true to its "general-purpose" claim, and it is a
    welcome challenge! The existence of this backend will help shape the Zig language specification
    and prevent it from being overfitted to x86-like ISAs.</p>
    {#header_close#}

    {#header_open|SPU Mark II Backend#}
    <p>This backend, related to the <a href="https://ashet.computer/">Ashet Home Computer</a>
    project, was incomplete, and the maintainer stopped working on it. Since it never made it
    to a usable state, this backend is removed in 0.8.0.</p>
    <p>
    The code is still safely stored in the Git history, and anyone is welcome to revive it!
    </p>
    {#header_close#}

    {#header_open|Miscellaneous stage2 Improvements#}
    <ul>
      <li>Default AVR generic cpu to avr2</li>
      <li>parser: Use an operator precedence table</li>
      <li>parser: use shared scratch buffer to avoid allocating and freeing many small lists (<a href="https://github.com/ziglang/zig/issues/8910">#8910</a>).</li>
      <li>Update the official spec to match the self-hosted parser.</li>
      <li>tokenizer: fix crash on multiline string with only 1 backslash (<a href="https://github.com/ziglang/zig/issues/8904">#8904</a>).</li>
      <li>Variable shadowing detection (<a href="https://github.com/ziglang/zig/issues/6969">#6969</a>).</li>
      <li>link: properly implement passthrough mode for LLD child proccess.</li>
      <li>Detect redundant C/C++ source files, preventing a deadlock in the caching system (<a href="https://github.com/ziglang/zig/issues/7308">#7308</a>).</li>
      <li>Print package path on --pkg-begin failure.</li>
      <li>Better error message for root zig source file not found (#6777, #6893).</li>
      <li>Always link -lpthread when using system libc. Required when cross-compiling glibc targets.</li>
      <li>Fix libc components' linking order.</li>
      <li>Add support for <code>-mred-zone</code> and <code>-mno-red-zone</code></li>
      <li>Ability to build stage1 using only a zig tarball.</li>
    </ul>
    <p>Contributors: Andrew Kelley, Jakub Konka, Veikka Tuominen, joachimschmidt557, Evan Haas, Isaac Freund, Jacob G-W, LemonBoy, Timon Kruiper, gracefu, Alex Cameron, xackus, Michael Dusan, Tadeo Kondrak, Alexandros Naskos, Noam Preil, g-w1, xavier, Ersikan, Jay Petacat, Robin Voetter, antlilja, daurnimator, Asherah Connor, Dimenus, Guoxin Yin, Jonathan Marler, Lee Cannon, Luuk de Gram, Josh Holland, Koakuma, Mitchell Kember, Rafael Ristovski, Ryan Liptak, Sizhe Zhao, Sreehari S, lithdew, protty, tgschultz</p>
    {#header_close#}
    {#header_close#}

    {#header_open|Self-Hosted Linker#}
    <p>As you may know from our previous releases, we had immense problems with
    <code>ld64.lld</code> linker on macOS - it is subpar in functionality to other target
    formats (Elf, Coff, etc.) and it does not support the latest arm64-based Macs
    (see #7527 or #3295 for some of the issues we encountered). While there has been
    progress on the new lld's MachO backend dubbed <code>ld64.lld.darwinnew</code>,
    it is still not the default backend as of {#link|LLVM 12#}. Additionally, it is
    doubtful that the new backend will allow for seamless cross-compilation to macOS
    since every macOS binary is required to be a PIE and link dynamically against
    <code>libSystem</code> dylib, which will require the lib's presence on the host
    for the lld to reference and link against.</p>

    <p>These were enough to make
    <a href="https://github.com/ziglang/zig/issues/1535">a case for building our own linker, written entirely in Zig</a>,
    which would initially focus on MachO linking. Since our core team member,
    Jakub, has already been working on the stage2 MachO backend before,
    he decided to try his luck at writing a traditional MachO linker in Zig from scratch
    which he started towards the end of January 2021. Fast forward a couple of months,
    and since May 2021, we are incredibly happy to report it is used as our primary
    linker when targeting macOS and is successfully able to link the stage1 Zig compiler
    as part of the <a href="https://github.com/ziglang/zig-bootstrap">zig-bootstrap</a>
    effort (see
    <a href="https://github.com/ziglang/zig-bootstrap/issues/38">ziglang/zig-bootstrap#38</a> and
    <a href="https://github.com/ziglang/zig-bootstrap/issues/44">ziglang/zig-bootstrap#44</a>).
    </p>

    <p>This means Zig can be used to successfully cross-compile C/C++ (clang) and Zig
    to macOS from anywhere!</p>

    <p>In summary, cross-compiling C/C++ and Zig to macOS is now as trivial as adding
    <code>-target aarch64-macos</code> or <code>-target x86_64-macos</code> to the invocation
    of your chosen Zig tool ({#link|zig cc#}, {#link|zig c++#}, or <code>zig build-exe</code>).
    There are still bits of functionality that are missing such as the ability to create a
    dynamic library or
    <a href="https://github.com/ziglang/zig/issues/8935">linking against text-based definitions (<code>.tbd</code>s)</a>
    but Jakub plans to address these next.</p>

    <p>In celebration of Jakub's recent accomplishments of improving the self-hosted linker
    on Mach-O enough to be able to link LLVM, Clang, LLD, and Zig, we now have the tracking issue
    <a href="https://github.com/ziglang/zig/issues/8726">Completely Eliminate Dependency on LLD</a>
    with the goal of eventually completely relying on our own linker implementation for all
    targets, and entirely stop linking against LLD.
    </p>
    <p>This issue does not block the release of Zig 1.0, however it is a stretch goal, and a
    fun indicator of progress to keep track of along the way.</p>
    <p>Here are all the places we depend on LLD, along with an indicator of how much our
    own linker code can do:</p>
    <ul>
      <li>üü° ELF:<ul>
          <li>üü° x86, x86_64</li>
          <li>üü° arm, aarch64</li>
          <li>üü° riscv</li>
          <li>üî¥ hexagon</li>
          <li>üî¥ mips</li>
          <li>üî¥ ppc, ppc32</li>
          <li>üî¥ sparc</li>
          <li>üî¥ amdgpu</li>
          <li>üî¥ avr</li>
          <li>üî¥ msp430</li>
        </ul></li>
      <li>üü¢ Mach-O<ul>
          <li>üü¢ x86_64</li>
          <li>üü¢ aarch64</li>
        </ul></li>
      <li>üü° COFF/PE<ul>
          <li>üü° x86, x86_64</li>
          <li>üî¥ arm, aarch64</li>
        </ul></li>
      <li>üü° WASM</li>
    </ul>
    <p>Key:</p>
    <ul>
      <li>üü¢ major progress</li>
      <li>üü° some progress</li>
      <li>üî¥ no progress</li>
    </ul>
    <p>
    Another issue to note here is that this release does <em>not</em> include a drop-in
    linker sub-command, e.g. <code>zig ld</code>. At this time Zig is lacking the glue
    code to hook up the Command-Line Interface to the linker implementation.
    If you are interested in this use case, the tracking issue is
    <a href="https://github.com/ziglang/zig/issues/8755">zig ld: a drop-in linker replacement</a>.
    </p>
    {#header_close#}

    {#header_open|C Translation#}
    <p>This is the feature that powers both <code>zig translate-c</code> as well as
    {#syntax#}@cImport{#endsyntax#} syntax. It is implemented in the {#link|Self-Hosted Compiler#},
    using the libclang C++ API.</p>
    <p>
    This release cycle saw a prolific new contributor to this area of the code - Evan Haas.
    Not only did he contribute many improvements to C translation this cycle, but his company,
    <a href="https://www.lagerdata.com/">Lager Data</a>, sponsors Zig. What a guy!
    </p>
    <p>
    Vexu implemented a major simplification of the implementation of translate-c by
    <a href="https://github.com/ziglang/zig/issues/6710">introducing a new pseudo-ast data structure</a>.
    Instead of the code having to manage both AST nodes and tokens at once, in order to render
    the output Zig code, now the C translation code only must create pesudo-AST nodes, which are
    then lowered to tokens at the end. This made the code easier to maintain and contribute to,
    and greatly simplified the {#link|Reworked Memory Layout#} efforts that happened simultaneously
    in the {#link|Self-Hosted-Compiler#}.
    </p>
    <p>Miscellaneous improvements:</p>
    <ul>
      <li>Added support for translating FnDecl's that appear within functions.</li>
      <li>Added support for __cleanup__ attribute, using a {#syntax#}defer{#endsyntax#} statement to implement the C __cleanup__ attribute.</li>
      <li>Demote initialization of opaque types. Fixes a segfault in translate-c that would previously occur when initializing structs with unnamed bitfields.</li>
      <li>Added support for translating global (file scope) assembly.</li>
      <li>Fixed typedefs with multiple names.</li>
      <li>Fixed casting of function pointers.</li>
      <li>Group field access LHS if necessary and LHS of array access if necessary.</li>
      <li>Better handling of int to enum casts (<a href="https://github.com/ziglang/zig/issues/6011">#6011</a>).</li>
      <li>Wrap switch statements in a {#syntax#}while (true){#endsyntax#} loop. This allows {#syntax#}break{#endsyntax#} statements to be directly translated from the original C (<a href="https://github.com/ziglang/zig/issues/8387">#8387</a>).</li>
      <li>Added support for vector expressions, including vector types, __builtin_shufflevector, and __builtin_convertvector.</li>
      <li>Fix calls with no args in macros.</li>
      <li>intcast compound assignment operand if different-sized integer.</li>
      <li>Stop creating unnamed decls for typedefs child types.</li>
      <li>Ensure assignments are within a block when necessary (<a href="https://github.com/ziglang/zig/issues/8159">#8159</a>).</li>
      <li>Preserve zero fractional part in float literals.</li>
      <li>Use {#syntax#}[N:0]{#endsyntax#} arrays when initializer is a string literal (#8264, #8215).</li>
      <li>Demoted usage of un-implemented builtins.</li>
      <li>Implemented generic selection expressions. Enables translation of C code that uses the <code>_Generic</code> keyword.</li>
      <li>Added compound literal support.</li>
      <li>Explicitly cast decayed array to pointer with {#syntax#}@ptrCast{#endsyntax#}. This enables translation of code that uses pointer arithmetic with arrays.</li>
      <li>Support compound assignment of pointer and signed int.</li>
      <li>Translate align attribute for block scoped variables.</li>
      <li>Strip the leading zero from octal literals.</li>
      <li>Enable pointer arithmetic with signed integer operand.</li>
      <li>Added &lt;assert.h&gt; support.</li>
      <li>Added limited OffsetOfExpr support.</li>
      <li>Added typeof support.</li>
      <li>Added support for pointer subtraction (<a href="https://github.com/ziglang/zig/issues/7216">#7216</a>).</li>
      <li>Check for noreturn in switch in more cases.</li>
      <li>Made switch default have an empty block not break.</li>
      <li>Use global scope for typedef/record/enum type translation if needed.</li>
      <li>Correctly add semicolon to if statements.</li>
      <li>Ensure failed macros don't get defined multiple times.</li>
      <li>Improved switch translation.</li>
      <li>Support scoped typedef, enum and record decls (<a href="https://github.com/ziglang/zig/issues/5256">#5256</a>).</li>
      <li>Demote untranslatable declarations to externs.</li>
      <li>Elide some unecessary casts of literals.</li>
      <li>Made comma operator introduce a new scope, preventing inadvertent side-effects when an expression is not evaluated due to boolean short-circuiting (<a href="https://github.com/ziglang/zig/issues/7989">#7989</a>).</li>
      <li>Call {#syntax#}@boolToInt{#endsyntax#} on return value when necessary (<a href="https://github.com/ziglang/zig/issues/6215">#6215</a>).</li>
      <li>Improve function pointer handling (<a href="https://github.com/ziglang/zig/issues/4124">#4124</a>).</li>
      <li>Added wide string literal support.</li>
      <li>Fixed bug when rendering struct initializer with length 1.</li>
      <li>Improved array support (#4831, #7832, #7842).</li>
      <li>Added Wide, UTF-16, and UTF-32 character literals.</li>
      <li>Ensure bools are cast to int when necessary.</li>
      <li>Allow dollar sign $ in identifiers (<a href="https://github.com/ziglang/zig/issues/7585">#7585</a>).</li>
      <li>Static function declarations with no prototype should not be variadic (<a href="https://github.com/ziglang/zig/issues/7594">#7594</a>).</li>
      <li>Demote variadic functions to declarations.</li>
      <li>Correctly cast bool to signed int.</li>
      <li>Improve handling of C compiler intrinsics (<a href="https://github.com/ziglang/zig/issues/6707">#6707</a>).</li>
      <li>Detect parenthesized string literals.</li>
      <li>Support casting enums to all int types.</li>
    </ul>
    <p>
    Here's a fun example, translating one of the many files of DOOM to Zig, and then compiling
    the resulting Zig code into an object:
    </p>
    <pre>andy@ark ~/D/D/linuxdoom-1.10 (master)&gt; zig translate-c -lc m_cheat.c &gt;m_cheat.zig
andy@ark ~/D/D/linuxdoom-1.10 (master)&gt; zig build-obj m_cheat.zig
andy@ark ~/D/D/linuxdoom-1.10 (master)&gt; file m_cheat.o
m_cheat.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), with debug_info, not stripped</pre>
    <p>
    This is one of the smaller C files; I ran into quite a few opportunities
    for more C translation improvements when looking for this example!
    </p>
    <p>Contributors: Evan Haas, Veikka Tuominen (Vexu), xackus, Andrew Kelley, LemonBoy, Isaac Freund, Michael Dusan, Tadeo Kondrak, Timon Kruiper</p>
    {#header_close#}

    {#header_open|Standard Library#}
    <p>The Zig standard library is still unstable and mainly serves as a
    testbed for the language. After the {#link|Self-Hosted Compiler#} is completed,
    the {#link|language|Language Changes#} stabilized, and
    {#link|Package Manager|Package Manager Status#} completed, then it will be time
    to start working on stabilizing the standard library.
    Until then, experimentation and breakage without warning is allowed.</p>
    <p>Miscellaneous Improvements:</p>
    <ul>
    <li>json: option to ignore unknown fields (<a href="https://github.com/ziglang/zig/issues/7906">#7906</a>)</li>
    <li>make writeIntSlice functions work for signed integers</li>
    <li>os: munmap takes a const pointer</li>
    <li>fix Boyer-Moore-Horspool algorithm in indexOfPos and lastIndexOf when element type is larger than a byte</li>
    <li>fix accidental quadratic dependence on haystack length in replace and replacementSize (<a href="https://github.com/ziglang/zig/issues/8859">#8859</a>)</li>
    <li>Const correct GUID parameter of getInfo and setInfo</li>
    <li>os: WSAStartup is now called upon socket creation when needed</li>
    <li>Make atfork handler more robust (<a href="https://github.com/ziglang/zig/issues/8841">#8841</a>).</li>
    <li>Call pthread_atfork only once</li>
    <li>add android __SIZEOF_PTHREAD_MUTEX_T (<a href="https://github.com/ziglang/zig/issues/8384">#8384</a>)</li>
    <li>math.Complex: Change new() to init()</li>
    <li>add missing EBADF error code for openat</li>
    <li>Avoid using white color when printing stacktraces. Use .bold instead of .white, the effect is the same for light-on-dark terminals but greatly improves the readability for dark-on-light ones (<a href="https://github.com/ziglang/zig/issues/8761">#8761</a>).</li>
    <li>dragonfly: fix duplicate definition of sockaddr_storage</li>
    <li>rework math.scalbn (<a href="https://github.com/ziglang/zig/issues/8733">#8733</a>)</li>
    <li>hash_map: use 7 bits of metadata instead of 6</li>
    <li>compiler-rt: Fix signedness mismatch in f128 mul impl</li>
    <li>dragonfly: fix duplicate definition of sockaddr_storage</li>
    <li>fix logic for duplicate comptime fields and avoid freeing comptime fields in parseFree and parseInternal</li>
    <li>fix duplicate_field_behavior UseFirst in json.zig</li>
    <li>json: Fix premature closing brace being considered valid JSON</li>
    <li>fix shrinkAndFree and remove shrinkRetainingCapacity in PriorityQueue and PriorityDequeue</li>
    <li>mem: add sliceTo(), deprecate spanZ(), lenZ()</li>
    <li>bsd: detect os version</li>
    <li>meta.Elem: support all optional types</li>
    <li>Fix offset param splitting for preadv/pwritev</li>
    <li>Harmonize use of off_t between libc and Zig impls</li>
    <li>c: Fix prototypes for bcmp and memcmp</li>
    <li>Prefer 64bit libc functions where possible</li>
    <li>os: add missing sockaddr_storage defs</li>
    <li>os: fix sockaddr_storage padding size</li>
    <li>ArrayList: add clearRetainingCapacity and clearAndFree</li>
    <li>Implement hex float printing</li>
    <li>compiler-rt: Better selection of __clzsi implementation</li>
    <li>Accept unaligned slice in several ArrayListAligned ops. Do not impose the internal alignment requirements to the user-supplied parameters (<a href="https://github.com/ziglang/zig/issues/8647">#8647</a>).</li>
    <li>GeneralPurposeAllocator: print leaked memory addresses. This helps when using it with other tools, such as memory watchpoints.</li>
    <li>handle -frandom-seed in NIX_CFLAGS_COMPILE</li>
    <li>Implement copysign, signbit, isFinite for f128</li>
    <li>rename doc refs to deprecated functions like openC (<a href="https://github.com/ziglang/zig/issues/8467">#8467</a>)</li>
    <li>Improve spinloop hint</li>
    <li>Handle EPERM and ELOOP in os.fstatat()</li>
    <li>remove redundant `comptime const`</li>
    <li>Add a parser for hexadecimal floating point numbers</li>
    <li>Target: bump freebsd known maximum version</li>
    <li>thread: simplify and remove useless return in spawn (<a href="https://github.com/ziglang/zig/issues/8621">#8621</a>)</li>
    <li>Fix for mem.replacementSize adjacent matches bug. (#8454, #8455)</li>
    <li>Fix thread creation with field-less context type (<a href="https://github.com/ziglang/zig/issues/8524">#8524</a>).</li>
    <li>Make meta.alignment work on more types</li>
    <li>compiler-rt: Export __extendhftf2 and __trunctfhf2</li>
    <li>Use stat definition with 32bit *time fields. We're not ready for Y38K yet.</li>
    <li>Split syscall parameters for PowerPC targets</li>
    <li>macho: fix typos in consts defs</li>
    <li>c: Implement fmax and fmaxf</li>
    <li>c: Implement fmin and fminf</li>
    <li>Add process_vm_readv/writev wrappers</li>
    <li>deprecate ensureCapacity, add two other capacity functions</li>
    <li>Add pidfd wrappers</li>
    <li>linux: fix number of arguments for tgkill syscall</li>
    <li>change `@import("builtin")` to `std.builtin`</li>
    <li>compiler-rt: Don't pass f16 around as arguments</li>
    <li>compiler-rt: Implement __trunctfhf2</li>
    <li>compiler-rt: Implement __extendhftf2</li>
    <li>compiler-rt: Fix typo in implementation of fp truncation ops</li>
    <li>os/posix: handle ECONNRESET for write/writev</li>
    <li>Fix sqrt for u0/u1 input types</li>
    <li>dwarf: fix LineNumberProgram check (<a href="https://github.com/ziglang/zig/issues/8421">#8421</a>).</li>
    <li>compiler-rt: Introduce PowerPC-specific f128 helpers</li>
    <li>Fix TLS definitions for 32bit PowerPC targets</li>
    <li>Improve powerpc support.</li>
    <li>netbsd: minor fixes to allow stage1 to build</li>
    <li>os/linux: return error on EALREADY for connect() and getsockoptError()</li>
    <li>os/bits/linux: add IPv6 socket options</li>
    <li>Switch json to use an ordered hashmap</li>
    <li>Add compile error for signed integer math. Output compile errors when signed integer types are used on functions where the answer might've been a complex number but that functionality hasn't been implemented. This applies to sqrt, log, log2, log10 and ln.</li>
    <li>os: handle ECONNRESET for connect() syscall</li>
    <li>base64: cleanups and support url-safe and other non-padded variants</li>
    <li>os.linux: handle ECONNRESET for recv</li>
    <li>UEFI: boot_services: implement locateDevicePath</li>
    <li>Specify type in autoHash error message (<a href="https://github.com/ziglang/zig/issues/7970">#7970</a>).</li>
    <li>Add reset to TokenIterator</li>
    <li>Add syscall7 stub for Linux/MIPS</li>
    <li>Add some enum utilities</li>
    <li>support optional getaddrinfo arguments</li>
    <li>linux: sync io_uring library with liburing</li>
    <li>make c.getErrno() return same type as _errno() aka c_int</li>
    <li>elf: make EM non-exhaustive</li>
    <li>expose machine field in ELF header</li>
    <li>Implement fmtDuration using Formatter (<a href="https://github.com/ziglang/zig/issues/8137">#8137</a>)</li>
    <li>Prevent null pointer deref in mem.len{,Z} (<a href="https://github.com/ziglang/zig/issues/8140">#8140</a>).</li>
    <li>Reject bare +/- input when parsing floats</li>
    <li>add io.Writer.writeStruct</li>
    <li>linux: fix IO_Uring.timeout</li>
    <li>Replace lastIndexOf with lastIndexOfScalar</li>
    <li>Add fs.path.joinZ (<a href="https://github.com/ziglang/zig/issues/7974">#7974</a>)</li>
    <li>add sendmsg</li>
    <li>Swap arguments in Thread.spawn (<a href="https://github.com/ziglang/zig/issues/8082">#8082</a>).</li>
    <li>Target.Abi: add gnuilp32</li>
    <li>ascii: add lessThanIgnoreCase and orderIgnoreCase</li>
    <li>Thread.Semaphore: Fix wrong variable name (<a href="https://github.com/ziglang/zig/issues/8052">#8052</a>).</li>
    <li>fifo.LinearFifo - Expose reader and writer type.</li>
    <li>os.uefi.Guid fixes (<a href="https://github.com/ziglang/zig/issues/8032">#8032</a>)</li>
    <li>fix race condition in linuxWaitFd</li>
    <li>Progress: improve support for "dumb" terminals</li>
    <li>replace ArrayList.shrinkAndFree by ArrayList.shrinkRetainingCapacity</li>
    <li>Add epoll_pwait2 Linux syscall</li>
    <li>remove io.AutoIndentingStream</li>
    <li>fs.net.Stream: add writev and writevAll</li>
    <li>json: large number support</li>
    <li>Don't read more bytes than exist in MsfStream (<a href="https://github.com/ziglang/zig/issues/7839">#7839</a>)</li>
    <li>Fixes for Thread.Condition (<a href="https://github.com/ziglang/zig/issues/7883">#7883</a>)</li>
    <li>math.big.int: normalize after a right shift</li>
    <li>json: support for comptime fields (<a href="https://github.com/ziglang/zig/issues/6231">#6231</a>).</li>
    <li>Remove {#syntax#}@TagType{#endsyntax#}; {#syntax#}meta.TagType{#endsyntax#} to {#syntax#}meta.Tag{#endsyntax#} (<a href="https://github.com/ziglang/zig/issues/7750">#7750</a>).</li>
    <li>GeneralPurposeAllocator: logging improvements</li>
    <li>meta: rename TagPayloadType to TagPayload</li>
    <li>meta: rename TagType to Tag</li>
    <li>Fill out more cases for meta.sizeof</li>
    <li>Fix interger overflow when calling joinZ with empty slices</li>
    <li>macho: add arm64 relocation type enum</li>
    <li>Add MAX_RW_COUNT limit to os.pread() (<a href="https://github.com/ziglang/zig/issues/7805">#7805</a>).</li>
    <li>linux: add fallocate() to io_uring</li>
    <li>Change <code>compareFn</code> to <code>fn (a: T, b: T) math.Order</code></li>
    <li>Add missing cast when calling fcntl w/ constant args</li>
    <li>Fixed pipe2 fallback (<a href="https://github.com/ziglang/zig/issues/7760">#7760</a>)</li>
    <li>Replace <code>shrink</code> with <code>shrinkAndFree</code> and <code>shrinkRetainingCapacity</code></li>
    <li>Add Priority Dequeue</li>
    <li>Organize std lib concurrency primitives and add RwLock</li>
    <li>elf: expose parsing decoupled from fs.File</li>
    <li>os.uefi.protocols.FileProtocol: fix and expose get_position, set_position (<a href="https://github.com/ziglang/zig/issues/7762">#7762</a>)</li>
    <li>Add missing ECONNRESET from getsockoptError</li>
    <li>implement emutls in compiler_rt</li>
    <li>event.Loop: fix race condition when starting the time wheel (<a href="https://github.com/ziglang/zig/issues/7572">#7572</a>).</li>
    <li>Add fmt.formatDuration and fmt.duration (<a href="https://github.com/ziglang/zig/issues/7297">#7297</a>)</li>
    <li>Made reader.skipBytes's num_bytes a u64</li>
    <li>os/bits/linux: add the termios cc bits</li>
    <li>Modify cityhash to work at comptime</li>
    <li>Decouple network streams from fs.File</li>
    <li>Update path.join to recognize any separators that isSep does</li>
    <li>debug: don't fail printLineInfo if the source file is not readable</li>
    <li>builtin: Add zig_version (<a href="https://github.com/ziglang/zig/issues/6466">#6466</a>)</li>
    <li>Fix system library path detection on Linux.</li>
    <li>Add mem.containsAtLeast</li>
    <li>io: <code>FindByteOutStream</code> to <code>FindByteWriter</code> (<a href="https://github.com/ziglang/zig/issues/4917">#4917</a>).</li>
    <li>Add EPERM to os.setsockopt</li>
    <li>Add IP_ constants</li>
    <li>fix LRESULT and LPARAM typedefs</li>
    <li>spinlock: Default SpinLock.state to .Unlocked to allow default struct initialization</li>
    <li>c: add syslog</li>
    <li>freebsd, netbsd, dragonfly: add struct timeval</li>
    <li>Rename ArrayList shrink to shrinkAndFree</li>
    <li>c: add some noalias</li>
    <li>meta.fieldInfo takes an enum rather than a string</li>
    <li>Add meta.FieldEnum</li>
    <li>Show the panicking thread ID</li>
    <li>Add more standard type definitions for FreeBSD (<a href="https://github.com/ziglang/zig/issues/7550">#7550</a>).</li>
    <li>Fix Reader.readUntilDelimiterOrEofAlloc() API</li>
    <li>Uniform polling logic for Windows and Unix.</li>
    <li>Fixed fs.Watch implementation on Linux and Windows</li>
    <li>Fix poll definitions for FreeBSD/Darwin</li>
    <li>Avoid deadlocking in ChildProcess.exec.</li>
    <li>zig test: testing.zig_exe_path is now available. It will be set to the path of the zig executable which is running `zig test`.</li>
    <li>Add c._exit() and use in ChildProcess</li>
    <li>Made hasUniqueRepresentation false for slices; handle unions in autoHash</li>
    <li>Rework ResetEvent, improve std lib Darwin integration</li>
    <li>ResetEvent: use sem_t when linking against pthreads</li>
    <li>Mutex: integrate with pthreads</li>
    <li>Add termios bits for darwin</li>
    <li>c: add fmemopen</li>
    <li>Add sincosf function (<a href="https://github.com/ziglang/zig/issues/7267">#7267</a>)</li>
    <li>Truncate user and group ids for 64 bit Linux systems (<a href="https://github.com/ziglang/zig/issues/7466">#7466</a>)</li>
    <li>Enable segfault handling on FreeBSD.</li>
    <li>Fix Gimli hash on 16n byte inputs</li>
    <li>Add io.counting_reader</li>
    <li>Cast sendto to SendError inside send (<a href="https://github.com/ziglang/zig/issues/7481">#7481</a>)</li>
    <li>Progress: make the API thread-safe</li>
    <li>Add EV_ERROR to FreeBSD bits</li>
    <li>Add Linux baudrate constants</li>
    <li>Add process_madvise to Linux syscalls (<a href="https://github.com/ziglang/zig/issues/7450">#7450</a>)</li>
    <li>Prevent hashing undefined bits for integers of non power of 2 size.</li>
    <li>Create SendToError (<a href="https://github.com/ziglang/zig/issues/7417">#7417</a>)</li>
    <li>non-byte-multiple sized integers and bool have no definite representation (<a href="https://github.com/ziglang/zig/issues/7445">#7445</a>).</li>
    <li>Add missing Linux syscalls.</li>
    <li>Fix formatting of type values (<a href="https://github.com/ziglang/zig/issues/7429">#7429</a>).</li>
    <li>Improve sigaction interface (<a href="https://github.com/ziglang/zig/issues/7411">#7411</a>)</li>
    <li>CrossTarget: add isNativeAbi()</li>
    <li>Make json.unescapeString pub.</li>
    <li>Validate the atomic ordering parameter in atomic.Int</li>
    <li>Prevent instantiation of atomic.Int with non-integral types</li>
    <li>Introduce meta.traits.is{Integral,Float}</li>
    <li>MoveFileEx can return ACCESS_DENIED.</li>
    <li>Add io_uring TIMEOUT and TIMEOUT_REMOVE operations.</li>
    <li>explicitly cast indices to usize. This is needed for platforms where usize=u16, eg. MSP430.</li>
    <li>compiler-rt: Fix compilation of clzsi for armv6 targets</li>
    <li>compiler-rt: Avoid exposing atomic builtins when not supported</li>
    <li>Add testing.expectStringEndsWith</li>
    <li>Fix general purpose allocator incorrectly modifying total_requested_bytes in some cases</li>
    <li>Add AddressFamilyNotSupported to SendError</li>
    <li>c: freeing null is a no-op</li>
    <li>Add a few helpers for matching ascii strings (<a href="https://github.com/ziglang/zig/issues/7300">#7300</a>)</li>
    <li>Make the mutex for GeneralPurposeAllocator configurable (<a href="https://github.com/ziglang/zig/issues/7234">#7234</a>).</li>
    <li>Add readUntilDelimiterOrEofArrayList and readUntilDelimiterOrEofAlloc.</li>
    <li>Make the use of pthread_join POSIX-compliant (<a href="https://github.com/ziglang/zig/issues/7275">#7275</a>)</li>
    <li>Always return loopback address when looking up localhost.</li>
    <li>os: remove unneeded error from accept errorset.</li>
    <li>add os.shutdown function for sockets</li>
    <li>Fix memory leak in BufMap.</li>
    <li>meta: add assumeSentinel</li>
    <li>Avoid deadlock in the signal handler (<a href="https://github.com/ziglang/zig/issues/7247">#7247</a>).</li>
    <li>Add readAllArrayListAligned to Reader which can accept an arbitrary alignment</li>
    <li>Fix file locking logic for BSD targets</li>
    <li>os: fix prctl constants</li>
    <li>use mem.asBytes in Ip4Address.parse so it works at comptime.</li>
    <li>Close dangling fd on error.</li>
    <li>Remove O_NONBLOCK flag after locking. We only need O_NONBLOCK when O_SHLOCK/O_EXLOCK are used and we don't want open() to block, don't let this bit leak to the user fd.</li>
    <li>Fix file locking logic for BSD targets.</li>
    <li>Fix the ELF base calculation.</li>
    <li>Fix logic for detecting _DYNAMIC symbol.</li>
    <li>user32 cleanup, added wrappers and additional functions.</li>
    <li>Add support for ppoll</li>
    <li>os: add time_t and dev_t definitions for x86_64 linux.</li>
    <li>meta.declarations: support {#syntax#}opaque {}{#endsyntax#}</li>
    <li>Add builtin.Signedness, use it instead of is_signed</li>
    <li>getdents: entries with d_ino==0 are now properly skipped</li>
    <li>Change seed for Murmur2_64 from u32 to u64.</li>
    <li>Add atomic.Bool and expose all atomic operations from atomic.Int (<a href="https://github.com/ziglang/zig/issues/7154">#7154</a>).</li>
    <li>Add meta.fieldNames.</li>
    <li>Add fs.openDirAbsolute and fs.accessAbsolute (<a href="https://github.com/ziglang/zig/issues/7082">#7082</a>)</li>
    <li>Move leb128 out of debug and remove trivial *mem functions as discussed in #5588 (<a href="https://github.com/ziglang/zig/issues/6876">#6876</a>)</li>
    <li>linuxWaitFd: make NetworkSubsystemFailed error unreachable. This error from os.poll is Windows-specific, so unreachable on Linux.</li>
    <li>Add more MachO consts and structs.</li>
    <li>mem: make sliceAsBytes, etc. respect volatile</li>
    <li>Add fs.path.extension.</li>
    <li>Improved support for OpenBSD.</li>
    <li>Fix json parser close tracking (<a href="https://github.com/ziglang/zig/issues/6865">#6865</a>).</li>
    <li>Don't prevent compilation on platforms where debug info is unsupported</li>
    <li>Add {#syntax#}mem.timingSafeEql(){#endsyntax#} for constant-time array comparison.</li>
    <li>ArrayList.span is now a compile error. Instead, use the <code>items</code> field directly.</li>
    <li>Add unicode.utf8CountCodepoints and unicode.utf8ValidCodepoint</li>
    <li>start code:: export main with strong linkage. Unmarks `_main` as weak symbol making it global (the entire linked program) in scope.</li>
    <li>start code: increases stack size as appropriate on linux (<a href="https://github.com/ziglang/zig/issues/8708">#8708</a>).</li>
    <li>start code: unconditionally import the root source file</li>
    <li>start code: call wWinMain with root's type.</li>
    <li>start code: make more versatile by always aligning the entry point.</li>
    <li>start code: properly align thread local variables. They were landmines if LLVM decided to optimize any writes to them using vector instructions.</li>
    <li>Make C allocator respect the required alignment. Uses posix_memalign where
    available and the _aligned_{malloc,free} API on Windows (<a href="https://github.com/ziglang/zig/issues/3783">#3783</a>). The new
    heap.raw_c_allocator is available to do what {#syntax#}heap.c_allocator{#endsyntax#}
    previously did. See the new doc comments for more details.</li>
    <li>Made {#syntax#}Version.parse{#endsyntax#} less strict.</li>
    <li>Added {#syntax#}LinearFifo(...).pump(src_reader, dest_writer){#endsyntax#}</li>
    </ul>
<p>Contributors: Andrew Kelley, LemonBoy, Isaac Freund, Jakub Konka, lithdew, daurnimator, Frank Denis, Veikka Tuominen, S√©bastien Marie, xackus, Michael Dusan, Matthew Borkowski, Jonathan Marler, Zander Khan, Asherah Connor, Koakuma, Vincent Rischmann, Alexandros Naskos, Rohlem, Al Hoang, Tadeo Kondrak, Vexu, Evan Haas, Lee Cannon, Martin Wickham, Jacob G-W, Felix (xq) Quei√üner, Kenta Iwasaki, Robin Voetter, Benjamin Feng, Jay Petacat, Joran Dirk Greef, Luuk de Gram, data-man, Alex Cameron, Hubert Jasudowicz, Julius Putra Tanu Setiaji, Loris Cro, Rocknest, Timon Kruiper, Aransentin, Bill Nagel, Jonathan Knezek, Lewis Gaul, antlilja, rgreenblatt, viri, Asherah Connor, Cameron Conn, Dmitry Atamanov, Isaac Yonemoto, Jens Goldberg, Josh Holland, Lewis Gaul, Ryan Liptak, Sage Hane, Shachaf Ben-Kiki, Sobeston, Sreehari S, Tau, frmdstryr, luna, root, ryuukk, tgschultz, Adam Goertz, Aiz672, Anders Conbere, Andreas Karlsson, Andreas Linz, Benjamin Graf, BinaryWarlock, Bxil, Carlos Z√∫√±iga, Daniele Cocca, Devin Bayer, Edward Dean, Ethan Gruffudd, Guillaume Ballet, Hadron67, Hannu Hartikainen, J.C. Moyer, Joris Hartog, Josh Wolfe, Julian Maingot, Kenta Iwasaki, Lewis Gaul, Luna, Maciej Walczak, Mahdi Khanalizadeh, Manuel Floru√ü, Mathieu Guay-Paquet, Matt Knight, Matt Sicker, Meghan Denny, Michael Freundorfer, Michael Holmes, Miles Alan, Nathana√´l Courant, Nuno Leiria, Rageoholic, Ryan Greenblatt, Sahnvour, Travis, Yorhel, ZapAnton, aiz, breakin, christian-stephen, cryptocode, ducdetronquito, fancl20, gracefu, heidezomp, johnLate, jumpnbrownweasel, mason1920, protty, viri, ≈Ωiga ≈Ωeljko</p>

    {#header_open|Formatted Printing#}
    <ul>
      <li>Added 'u' specifier.</li>
      <li>Implemented named arguments and runtime width/precision.</li>
      <li>Reworked the whole parser.</li>
      <li>Removed z/Z format specifiers. Instead, use std.zig.fmtId.</li>
      <li>Fixed the `*` specifier for more types, print an error message if we
        can't show the value address.</li>
      <li>Disable the special casing of {} for u8 slices/arrays.
        Unless {s} is specified the contents won't be treated as a string.</li>
      <li>Improved error messages in std.fmt (<a href="https://github.com/ziglang/zig/issues/7898">#7898</a>)</li>
      <li>Introduce {'} to indicate escape for a single-quoted string,
        and {} to indicate escape for a double quoted string.</li>
      <li>Removed 'x'/'X'/'e'/'E' special cases for u8 slices. Instead use
      fmt.fmtSliceHexLower and fmtSliceHexUpper.</li>
      <li>Removed the B and Bi format specifiers. Instead use fmt.fmtIntSizeDec
      and fmtIntSizeBin.</li>
    </ul>
    {#header_close#}

    {#header_open|fs.path.dirname: return null when input path is root#}
    {#code_begin|test|dirname#}
const std = @import("std");
test "dirname on root path" {
    try std.testing.expect(std.fs.path.dirname("/") == null);
}
    {#code_end#}
    <p>This intentionally diverges from the unix dirname command, as well as
    Python and Node.js standard libraries, which all have this edge case
    return the input path, unmodified. This is a footgun, and nobody should
    have ever done it this way.</p>

    <p>Even the man page contradicts the behavior. It says:
    "strip last component from file name". Now consider, if you
    remove the last item from an array of length 1, then you
    have now an array of length 0. After you strip the last component, there
    should be no components remaining. Clearly, returning the input parameter
    unmodified in this case does not match the documented behavior. This is
    my justification for taking a stand on this API design.</p>

    <p>Fixes #6746, #6727, #6584, #6592, #6602</p>
    {#header_close#}

    {#header_open|Thread-Local CSPRNG for General Use#}
    <p>{#syntax#}std.crypto.random{#endsyntax#} is now available. It is an implementation
    of the {#syntax#}std.rand.Random{#endsyntax#} interface (<a href="https://github.com/ziglang/zig/issues/6704">#6704</a>):</p>
    {#code_begin|exe#}
const std = @import("std");

pub fn main() !void {
    var bytes: [10]u8 = undefined;
    std.crypto.random.bytes(&bytes);

    const boolean = std.crypto.random.boolean();
    const int = std.crypto.random.uintLessThan(u8, 100);

    std.debug.print("bytes: {x}\nboolean: {}\nint: {d}\n", .{
        std.fmt.fmtSliceHexLower(&bytes), boolean, int,
    });
}
    {#code_end#}
    <p>{#syntax#}std.crypto.randomBytes{#endsyntax#} is
    removed in favor of {#syntax#}std.crypto.random.bytes{#endsyntax#}.</p>
    <p>Some details about this implementation:</p>
    <ul>
      <li>It is cross platform, even freestanding.</li>
      <li>It cannot fail. On initialization for some systems requires calling
        {#syntax#}os.getrandom(){#endsyntax#}, in which case there are rare but
        theoretically possible errors. The code panics in these cases, however the
        application may choose to override the default seed function and then
        handle the failure another way.</li>
      <li>It is thread-safe.</li>
      <li>The randomness is cryptographically secure.</li>
      <li>It calls arc4random on systems that support it.</li>
      <li>On Linux, AT_RANDOM is ignored and <em>not</em> used to seed it.</li>
      <li>On Linux, MADV_WIPEONFORK is used to provide fork safety.</li>
      <li>On pthread systems, `pthread_atfork` is used to provide fork safety.</li>
      <li>For systems that do not have the capability to provide fork safety,
        the implementation falls back to calling getrandom() every time.</li>
      <li>If madvise is unavailable or returns an error, or pthread_atfork
       fails for whatever reason, it falls back to calling getrandom() every
       time.</li>
      <li>Applications may choose to opt-out of fork safety.</li>
      <li>Applications may choose to opt-in to unconditionally calling
        getrandom() for every call to std.crypto.random.fillFn.</li>
    </ul>
    <p>Thanks to LemonBoy for finding and fixing a flaw in the use of madvise (<a href="https://github.com/ziglang/zig/issues/7609">#7609</a>).</p>
    {#header_close#}

    {#header_open|Crypto#}

    {#header_open|Legacy Keccak hash functions#}
    <p>The legacy Keccak hash functions have been added (<code>hash.sha3.Keccak_256, hash.sha3.Keccak_512</code>). They only differ from the standard SHA-3 functions by their domain separation byte.

    <p>These functions are not recommended as they are slow and non-standard. However, popular blockchains such as Ethereum still require them.
    {#header_close#}

    {#header_open|AES-OCB#}
    <p>This release adds <a href="https://competitions.cr.yp.to/round3/ocbv11.pdf">AES-OCB</a>, which has been around for a long time. It's simpler, faster and has better nonce-reuse resistance than AES-GCM.

    <p>RFC 7253 was published in 2014. OCB also won the CAESAR competition along with AEGIS that we already had.

    <p>So, why isn't everybody using it instead of GCM? And why didn't we have it in Zig before?

    <p>The sad reason for this was patents. GCM was invented only to work around these patents, and for all this time, OCB was that nice thing that everybody knew existed but that couldn't be freely used.

    <p><a href="https://mailarchive.ietf.org/arch/msg/cfrg/qLTveWOdTJcLn4HP3ev-vrj05Vg/">That just changed in February 2021</a>. The OCB patents have been abandoned, and OCB is now public domain.
    {#header_close#}

    {#header_open|ISAP#}
    <p>We already had ciphers optimized for performance, for compatibility, for size and for specific CPUs.</p>

    <p>However we used to lack a class of ciphers that is becoming increasingly important, as Zig is being used for embedded systems, but also as hardware-level side channels keep being discovered.</p>

    <p>Please welcome <a href="https://isap.iaik.tugraz.at/files/isapv20.pdf">ISAPv2</a> (ISAP-A-128a), a cipher specifically designed for resilience against leakage and fault attacks.</p>

    <p>ISAPv2 is not fast, but can be an option for highly sensitive data, when the runtime environment cannot be trusted.</p>
    {#header_close#}

    {#header_open|Hash-To-Curve#}
    <p>Is there a way to map an arbitrary string into an elliptic curve point, so that the discrete log is not known?</p>

    <p>While more and more protocols require such a function, there was no standard way to do it until the <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/">hash-to-curve</a> specification came out.</p>

    <p>This release adds <code>crypto.ecc.Edwards25519.fromString()</code>, implementing the suites defined in the specification for the Edwards25519 curve.</p>
    {#header_close#}

    {#header_open|Double-Base Scalar Multiplication#}
    <p>Signatures systems over elliptic curves frequently require computing Px+Qy, with P and Q being different points on the same curve.</p>

    <p>And a specialized function can be much faster than computing both multiplications separately.</p>

    <p>Incidentally, this is exactly what the new <code>Edwards25519.mulDoubleBasePublic()</code> and <code>P256.mulDoubleBasePublic()</code> functions do.</p>
    {#header_close#}

    {#header_open|P-256#}
    <p>They were invented by a US government agency. They are prone to side channels. Secure or not, implementations tend to be slow. Renowned cryptographers <a href="https://safecurves.cr.yp.to">don't trust them much</a>. And Zig already includes better alternatives such as Ristretto255.</p>

    <p>But the NIST curves are deployed everywhere. Far more than any other curves. For compliance reasons or simply because most protocols don't support anything else, we need them.</p>

    <p>Zig 0.8.0 adds support for the NIST P-256 curve. Other prime-order curves will follow shortly.</p>

    <p>Since they don't use "nice" primes, safely implementing finite field arithmetic for these curves is tricky, and many implementations got hit by carry propagation bugs.</p>

    <p>We took the approach of contributing a Zig backend to <a href="https://github.com/mit-plv/fiat-crypto">fiat-crypto</a>, a project to generate arithmetic that has been formally proven for correctness.</p>

    <p>The output of that tool is the core of our P-256 implementation,
    <strong>making Zig the first general-purpose language with formally verified cryptography
      right in the standard library</strong>. Support for other curves will be done the same way.</p>

    <p>Please note however, that verification stops at source-level, and doesn't protect
    against possible {#link|compiler bugs|This Release Contains Bugs#}.</p>
    {#header_close#}

    {#header_open|Constant-Time Comparisons#}
    <p>A new function was added to compare (not just for equality) byte strings: <code>crypto.utils.timingSafeCompare()</code>.</p>

    <p>It is useful to compare arbitrary-large nonces, counters or serialized field elements.</p>
    {#header_close#}

    {#header_open|Round-Reduced ChaCha20#}
    <p>Round-reduced versions (8 and 12 rounds) of the ChaCha20-based ciphers have been added. This includes the ChaCha20 stream cipher itself, as well as the ChaCha20-Poly1305 construction.</p>

    <p>8 rounds ChaCha20 provides a 2.5x speedup over the standard 20 rounds version, <a href="https://eprint.iacr.org/2019/1492.pdf">and is still believed to have a safe security margin</a>.</p>
    {#header_close#}

    {#header_open|Breaking Changes#}
    <ul>
      <li>Edwards25519: <code>neutralElement</code> was deprecated. New code should use <code>identityElement</code> instead.</li>
      <li>Errors have been made more consistent across <code>std.crypto</code> functions. They now all share the same <code>std.crypto.Error</code> errors set.</li>
    </ul>
    {#header_close#}

    {#header_open|Performance Improvements#}
    <ul>
      <li>Ed25519 signature verification is about 60% faster than in Zig 0.7.1.</li>
    </ul>
    {#header_close#}

    {#header_open|Crypto Bug Fixes#}
    <ul>
      <li>AES: <code>{encrypt,decrypt}Wide()</code> functions performed more rounds than necessary. This has been fixed.</li>
      <li>BLAKE2: properly handle output sizes that are not a multiple of 8.</li>
      <li>Salsa20: the vectorized implementation didn't use the correct position for the internal counter.</li>
    </ul>
    {#header_close#}

    <p>Contributors: Frank Denis, Andrew Kelley, LemonBoy, Al Hoang, Guillaume Ballet, Isaac Freund, Jay Petacat, Matt Sicker, Rocknest, Tadeo Kondrak, Veikka Tuominen</p>
    {#header_close#}

    {#header_open|MultiArrayList#}
    <p>One pattern commonly observed in Data-Oriented Design is
    <a href="https://en.wikipedia.org/wiki/AoS_and_SoA">Struct of Arrays (SOA)</a>.
    This can be useful when {#link|reworking memory layout|Reworked Memory Layout#}
    to be more CPU-cache-friendly.</p>
    <p>Some programming languages have experimented with support for SoA at the language level.
    In Zig, this abstraction is now provided in the standard library; no language modifications
    needed.</p>
    <p>The purpose of this data structure is to provide a similar API to
    {#syntax#}ArrayList{#endsyntax#} but instead of the element type being a struct,
    the fields of the struct are in N different arrays, all with the same length and capacity.</p>
    <p>Having this abstraction means we can put them in the same allocation,
    avoiding overhead with the allocator. It also saves a tiny bit of
    overhead from the redundant capacity and length fields, since each
    struct element shares the same value.</p>

    <p>Here is an example of using this data structure:</p>
    {#code_begin|exe|multi_array_list#}
const std = @import("std");
const Allocator = std.mem.Allocator;
const MultiArrayList = std.MultiArrayList;
const ArrayList = std.ArrayListUnmanaged;

const MyData = struct {
    tag: enum { one, two },
    pointer: *i32,
};

pub fn main() !void {
    {
        var gpa: std.heap.GeneralPurposeAllocator(.{
            .enable_memory_limit = true,
        }) = .{};
        defer _ = gpa.deinit();

        var list: ArrayList(MyData) = .{};
        defer list.deinit(&gpa.allocator);

        try addSomeItems(&gpa.allocator, &list);
        std.debug.print("ArrayList: {}\n", .{
            std.fmt.fmtIntSizeBin(gpa.total_requested_bytes),
        });
    }
    {
        var gpa: std.heap.GeneralPurposeAllocator(.{
            .enable_memory_limit = true,
        }) = .{};
        defer _ = gpa.deinit();

        var list: MultiArrayList(MyData) = .{};
        defer list.deinit(&gpa.allocator);

        try addSomeItems(&gpa.allocator, &list);
        std.debug.print("MultiArrayList: {}\n", .{
            std.fmt.fmtIntSizeBin(gpa.total_requested_bytes),
        });
    }
}

var derp: i32 = 0;

fn addSomeItems(gpa: *Allocator, list: anytype) !void {
    var i: usize = 0;
    while (i < 10000) : (i += 1) {
        try list.append(gpa, .{
            .pointer = &derp,
            .tag = if (i % 1 == 0) .one else .two,
        });
    }
}
    {#code_end#}
    <p>Here is illustrated the same struct added ten thousand times to an ArrayList,
    and also to a MultiArrayList, and observe that the MultiArrayList uses only 57% of the
    memory as the ArrayList, due to not wasting the padding bytes between the 1-byte enum
    field and the pointer field.</p>
    <p>On modern hardware, this can make a big difference due to lower L1 cache pressure
    on the CPU.</p>
    <p>This abstraction was immediately useful, unlocking both
    {#link|Reworked Memory Layout#} in the {#link|Self-Hosted Compiler#} as well as
    {#link|hash map improvements|Hash Maps#} in this release cycle.</p>
    {#header_close#}

    {#header_open|Hash Maps#}
    <p>Martin Wickham made
    <a href="https://github.com/ziglang/zig/pull/8975">sweeping changes</a>
    to <code>HashMap</code> and <code>ArrayHashMap</code> APIs as part of 0.8.0, resolving
    the following issues:</p>
    <ul>
      <li>{#link|Hash Context Types#} (<a href="https://github.com/ziglang/zig/issues/8528">#8528</a>).</li>
      <li>{#link|Adapting Contexts#} (<a href="https://github.com/ziglang/zig/issues/8619">#8619</a>).</li>
      <li>New {#syntax#}getPtr(){#endsyntax#} function returns a pointer to value (<a href="https://github.com/ziglang/zig/issues/7489">#7489</a>).</li>
      <li>{#link|Separated Key/Value Storage#} (<a href="https://github.com/ziglang/zig/issues/8363">#8363</a>).</li>
      <li>BufSet/BufMap functions renamed to match other set/map types (<a href="https://github.com/ziglang/zig/issues/8971">#8971</a>).</li>
    </ul>
    <p>Preexisting code that uses these APIs will need to update.</p>
    <p>Additionally, the following miscellaneous improvements were made:</p>
    <ul>
    <li>Fixed HashMap.putAssumeCapacity and HashMap.clearRetainingCapacity (<a href="https://github.com/ziglang/zig/issues/7061">#7061</a>).</li>
    <li>Fixed AutoArrayHashMap's store_hash logic.</li>
    <li>ArrayHashMap: ensureUnusedCapacity and ensureTotalCapacity.</li>
    <li>Removed empty init from HashMapUnmanaged.</li>
    <li>ArrayHashMap: decrement entries slice len after popping from entries in pop() to prevent OOB.</li>
    <li>ArrayHashMap: add "AssertDiscard" function variants.</li>
    <li>Support equivalent ArrayList operations in ArrayHashMap.</li>
    </ul>
    {#header_open|Hash Context Types#}
    <p>Hash map types which accept a hash and eql function have been refactored to instead
    require a Context type.  Context types must have member functions <code>hash</code>
    and <code>eql</code> which will perform the hash.  Example context for strings:</p>
    {#code_begin|syntax#}
pub const StringContext = struct {
    pub fn hash(self: @This(), s: []const u8) u64 {
        return hashString(s);
    }
    pub fn eql(self: @This(), a: []const u8, b: []const u8) bool {
        return eqlString(a, b);
    }
};
    {#code_end#}
    <p>Note that, like before, ArrayHashMap requires 32-bit hashes and HashMap requires
    64-bit hashes.</p>
    <p>Context types may also have fields.</p>
    {#code_begin|syntax#}
pub const StringPoolContext = struct {
    pool: StringPool,
    pub fn hash(self: @This(), s: StringPool.ID) u64 {
        return self.pool.getStringHash(s);
    }
    pub fn eql(self: @This(), a: StringPool.ID, b: StringPool.ID) bool {
        return a == b;
    }
};
    {#code_end#}
    <p>When using a nonempty context with a Managed hash map type, the context instance
    is stored within the managed instance.  The instance must be created with
    <code>initContext</code> instead of the usual <code>init</code> function.</p>

    <p>For Unmanaged hash map types, you must now call Context variants of the
    hash map functions to pass in a context instance:</p>
    <ul>
      <li><code>map.put(k, v)</code> =&gt; <code>map.putContext(k, v, ctx)</code></li>
      <li><code>map.get(k)</code> =&gt; <code>map.getContext(k, ctx)</code></li>
      <li><code>map.remove(k)</code> =&gt; <code>map.removeContext(k, ctx)</code></li>
      <li>etc.</li>
    </ul>
    <p>However, the old functions still exist, and will work as long as the context
    is zero sized.</p>
    {#header_close#}

    {#header_open|Adapting Contexts#}
    <p>In addition to Contexts, you can now create Adapting Contexts, which allow you to
    use specialized keys with the map. For example:</p>
    {#code_begin|syntax#}
pub const StringPoolAdaptingContext = struct {
    pool: StringPool,
    pub fn hash(self: @This(), k: []const u8) u64 {
        return hashString(k);
    }
    pub fn eql(self: @This(), new_key: []const u8, stored_key: StringPool.ID) bool {
        return eqlString(new_key, self.pool.getString(stored_key));
    }
};
    {#code_end#}
    <p>This adapting context can be used to query a map which uses the
    <code>StringPoolContext</code> from the previous section. The adapter allows queries
    to be performed using keys which may or may not actually be in the string pool.
    To enable this, it provides hashing for the adapted key, and a comparison function
    between the adapted key and a stored key.</p>
    <p>New functions with names ending in <code>Adapted</code> allow these adapting contexts
    to be passed in.</p>
    {#header_close#}

    {#header_open|Separated Key/Value Storage#}
    <p>Before 0.8.0, keys and values were stored in an array of structs of
    <code>Entry{K, V}</code>.  This storage wastes a lot of memory if keys and values
    have differing alignment, and for <code>ArrayHashMap</code> incurs performance
    penalties when iterating over only keys or only values.
    With this change, hash maps now store two separated arrays of
    keys and values.</p>

    <p>This means that existing APIs which return {#syntax#}*Entry{#endsyntax#} can no longer be supported.
    The following breaking changes have been made:</p>
    <ul>
    <li><code>Entry</code> has been changed from {#syntax#}struct { key: K, value: V }{#endsyntax#} to {#syntax#}struct { key_ptr: *K, value_ptr: *V }{#endsyntax#}.</li>
    <li>A new struct <code>KV</code> is <code>struct { key: K, value: V }</code>.</li>
    <li>APIs which used to return <code>*Entry</code> now return <code>Entry</code>.</li>
    <li>APIs which used to return <code>Entry</code> now return <code>KV</code>.</li>
    </ul>
    <p>Here are some examples for updating code to use the new API:</p>
    <p>Example 1:</p>
    <pre>{#syntax#}// old
var it = hash_map.iterator();
while (it.next()) |entry| {
    const k = entry.key;
    const v = entry.value;
}

// new
var it = hash_map.iterator();
while (it.next()) |entry| {
    const k = entry.key_ptr.*;
    const v = entry.value_ptr.*;
}{#endsyntax#}</pre>
    <p>Example 2:</p>
    <pre>{#syntax#}// old
for (array_hash_map.entries.items) |entry| {
    free(entry.key);
    free(entry.value);
}

// new
for (array_hash_map.keys()) |key| {
    free(key);
}
for (array_hash_map.values()) |value| {
    free(value);
}{#endsyntax#}</pre>
    <p>Example 3:</p>
    <pre>{#syntax#}// old
for (array_hash_map.entries.items) |entry| {
    useBoth(entry.key, entry.value);
}

// new
var it = array_hash_map.iterator()
while (it.next()) |entry| {
    useBoth(entry.key_ptr.*, entry.value_ptr.*);
}

// After accepted proposal https://github.com/ziglang/zig/issues/7257 is implemented:
for (array_hash_map.keys(), array_hash_map.values()) |key, value| {
    useBoth(key, value);
}{#endsyntax#}</pre>
    <p>Example 4:</p>
    <pre>{#syntax#}// old
const result = try map.getOrPut(key);
if (!result.found_existing) {
    result.entry.value = new_value;
}

// new
const result = try map.getOrPut(key);
if (!result.found_existing) {
    result.value_ptr.* = new_value;
}{#endsyntax#}</pre>
    {#header_close#}

    {#header_open|Renamed Functions#}
    <p>In addition to the above changes, several functions have been renamed to better
    reflect their operation and to improve consistency. These changes also affect the
    <code>BufMap</code> and <code>BufSet</code> APIs.</p>
    <ul>
      <li><code>ensureCapacity</code> has been split into <code>ensureTotalCapacity</code> and <code>ensureAdditionalCapacity</code></li>
      <li><code>HashMap.remove</code> now returns {#syntax#}bool{#endsyntax#}, a new function <code>fetchRemove</code> returns <code>?KV</code></li>
      <li><code>removeAssertDiscard</code> has been deleted, use <code>assert(map.remove(key))</code> instead.</li>
      <li><code>ArrayHashMap.remove</code> has been split into six variants (not including adapted/context variants)<ul>
          <li>{#syntax#}orderedRemove(K) bool{#endsyntax#}</li>
          <li>{#syntax#}orderedRemoveAt(usize) bool{#endsyntax#}</li>
          <li>{#syntax#}fetchOrderedRemove(K) ?KV{#endsyntax#}</li>
          <li>{#syntax#}swapRemove(K) bool{#endsyntax#}</li>
          <li>{#syntax#}swapRemoveAt(usize) bool{#endsyntax#}</li>
          <li>{#syntax#}fetchSwapRemove(K) ?KV{#endsyntax#}</li>
        </ul>
      </li>
      <li><code>BufSet.put</code> is now <code>BufSet.insert</code></li>
      <li><code>BufSet.exists</code> is now <code>BufSet.contains</code></li>
      <li><code>BufSet.delete</code> is now <code>BufSet.remove</code></li>
      <li><code>BufSet.iterator</code> now iterates over key values only</li>
      <li><code>BufMap.set</code> is now <code>BufMap.put</code></li>
      <li><code>BufMap.setMove</code> is now <code>BufMap.putMove</code></li>
      <li><code>BufMap.delete</code> is now <code>BufMap.remove</code></li>
    </ul>
    {#header_close#}
    {#header_close#}

    {#header_open|Progress#}
    <p>This is the API that provides a progress bar for terminal applications.
    You've probably seen it since the Zig compiler itself uses it.</p>
    <p>There is now better handling of line-wrapping:</p>
    <p>In order to update the printed progress string the code tried to move
    the cursor N cells to the left, where N is the number of written bytes,
    and then clear the remaining part of the line.
    This strategy has two main issues:</p>
    <ul>
      <li>Is only valid if the number of characters is equal to the number of
        written bytes.</li>
      <li>Is only valid if the line doesn't get too long.</li>
    </ul>
    <p>The second point is the main motivation for this change, when the line
    becomes too long the terminal wraps it to a new physical line. This
    means that moving the cursor to the left won't be enough anymore as once
    the left border is reached it cannot move anymore.</p>

    <p>The wrapped line is still stored by the terminal as a single line,
    despite now taking more than a single one when displayed. If you try to
    resize the terminal you'll notice how the contents are reflowed and are
    essentially illegible.</p>

    <p>Querying the cursor position on non-Windows systems (plot twist,
    Microsoft suggests using VT escape sequences on newer systems) is
    extremely cumbersome so the new implementation does something different.</p>

    <p>Before printing anything it saves the cursor position and clears the
    screen below the cursor, this way we ensure there's absolutely no trace
    of stale data on screen, and after the message is printed we simply
    restore it.</p>

    <p>There are still some major flaws with the way the code is implemented
    to interact with terminals, and contributions are welcome to improve it.</p>
    {#header_close#}

    {#header_open|Testing#}
    <p><code>std.testing</code> now uses errors to fail tests. Callsites
    will have to adjust to use {#syntax#}try{#endsyntax#}:</p>
    <p>Old:</p>
    {#code_begin|test_err#}
const std = @import("std");
const testing = std.testing;

test "old" {
    std.testing.expect(true);
}
    {#code_end#}
    <p>New:</p>
    {#code_begin|test#}
const std = @import("std");
const testing = std.testing;

test "new" {
    try std.testing.expect(true);
}
    {#code_end#}
    <p>The default test runner is modified so that when a test returns an error,
    the test is marked as failure, however subsequent tests are still run.
    At the end is reported the failures and successes,
    and the final exit code of zig test will be 0 if and only if all tests succeeded with
    no memory leaks.</p>
    <p>A --fail-fast flag is planned to be added to <code>zig test</code> to get the
    old behavior back, but it is not yet implemented.</p>
    {#header_close#}

    {#header_open|Orphanage#}
    <p>The
    <a href="https://github.com/ziglang/std-lib-orphanage">Zig Standard Library Orphanage</a>
    has started adopting.</p>
    <p>This is code that used to be in the standard library, but there wasn't any reason to keep
    maintaining it there when it could function just fine as a third party package.</p>
    <p>Feel free to start your own source code repository and take over the duties of maintaining
    any of this code. You can send PRs to the README to link to your project.</p>
    <p>The following APIs are up for adoption:</p>
    <ul>
      <li>SegmentedList (<a href="https://github.com/ziglang/zig/issues/7190">#7190</a>)</li>
      <li>Serialization</li>
      <li>ArrayListSentineled</li>
      <li>BloomFilter</li>
      <li>HttpHeaders</li>
      <li>RedBlackTree</li>
    </ul>
    {#header_close#}
    {#header_close#}

    {#header_open|Zig Build System#}
    <p>
    The Zig Build System is invoked via the <code>zig build</code> command, which executes
    a declarative <code>build.zig</code> script to collect options and describe the graph
    of steps, and then provides options to execute those steps.
    </p>
    <p>
    Although it is already essential to nearly every Zig project, the Zig Build System is
    still experimental and unstable. As a build system, stability is especially important,
    but stabilization cannot occur until the language stabilizes. Language stability is the
    next area of focus on the {#link|Roadmap#}.
    </p>

    <p>The first thing you will immediately notice in this release is that the
    default install prefix is now <code>zig-out</code> in the build root, rather than
    <code>zig-cache</code> in the current working directory (<a href="https://github.com/ziglang/zig/issues/8659">#8659</a>). The <code>-p</code>
    flag can be used to choose a different install prefix.</p>

    <p>
    In addition, there are the following improvements:
    </p>

    <ul>
      <li>Support specifying rpaths explicitly (<a href="https://github.com/ziglang/zig/issues/8912">#8912</a>).</li>
      <li><code>installDirectory</code> supports a <code>blank_extensions</code> option
        to blank out files instead of omitting them. This is utilized by Zig's build script
        so that the installation does not include many megabytes of test files, but
        also {#syntax#}@import{#endsyntax#} on them does not cause a compile error.</li>
      <li>Added experimental Darling support for cross testing macOS.</li>
      <li>Fixed wrong glibc dir passed to qemu for i386.</li>
      <li>If using a RunStep, show the command run on verbose (<a href="https://github.com/ziglang/zig/issues/8571">#8571</a>).</li>
      <li>Added LibExeObjStep.linker_allow_shlib_undefined field to set --allow-shlib-undefined</li>
      <li>std.build: make Builder.install_prefix non optional
        This is useful for build.zig files to check in some cases, for example
        to adhere to the convention of installing config to /etc instead of
        /usr/etc on linux when using the /usr prefix. Perhaps std.build will
        handle such common cases eventually, but that is not yet the case.</li>
      <li>Added support for LTO configuration.</li>
      <li>Added support for passing write file args as build options (<a href="https://github.com/ziglang/zig/issues/7909">#7909</a>).
        Makes it easier to generate Zig code in a build.zig script.</li>
      <li>Dupe strings on all public api points for std.build.</li>
      <li>Propagate env_map for child processes.</li>
      <li>Assert that install paths are relative. If absolute paths are passed they
        will work unless $DESTDIR is set, which causes subtly broken build.zig's.</li>
      <li>Made build errors followed by two newlines.</li>
      <li>Added {#syntax#}sanitize_thread{#endsyntax#} option.</li>
      <li>Added option to override default stack size in build system.</li>
      <li>{#syntax#}addBuildOption{#endsyntax#} gains support for more types: {#syntax#}SemanticVersion{#endsyntax#}, floats, {#syntax#}?[:0]const u8{#endsyntax#}</li>
      <li>Dynamic library artifacts are now passed as positionals.</li>
      <li>COFF linking: fix incorrectly passing .dll instead of .lib</li>
    </ul>
<p>Contributors: Andrew Kelley, Asherah Connor, Daniele Cocca, Frank Denis, Hubert Jasudowicz, Isaac Freund, Jakub Konka, Jay Petacat, Jonathan Marler, Josh Holland, Lee Cannon, LemonBoy, Martin Wickham, Michael Dusan, Michael Holmes, Ryan Greenblatt, Veikka Tuominen, Vexu, Vincent Rischmann, antlilja, daurnimator, frmdstryr, Jacob G-W, lithdew, rgreenblatt</p>
    {#header_close#}

    {#header_open|Toolchain#}
    {#header_open|Thread Sanitizer#}
    <p>The <code>-fsanitize-thread</code> option is now available to detect data races.
    This is based on
    <a href="https://clang.llvm.org/docs/ThreadSanitizer.html">Clang's ThreadSanitizer</a>.
    </p>
    {#header_close#}

    {#header_open|musl 1.2.2#}
    <p>
    Zig ships with the source code to <a href="https://www.musl-libc.org/">musl</a>.
    When the musl C ABI is selected, Zig builds musl from source for the selected target.
    </p>
    <p>
    This release updates the bundled musl source code to
    <a href="https://musl.libc.org/releases.html">v1.2.2</a>.
    </p>
    <p>Additionally, Isaac Freund contributed the ability to target dynamically linked
    musl (<a href="https://github.com/ziglang/zig/issues/7406">#7406</a>). This greatly improves the behavior of Zig on Linux distributions that use
    musl as their libc, such as Alpine Linux.</p>
    {#header_close#}

    {#header_open|glibc 2.33#}
    <p>
    Zig gains the ability to target
    <a href="https://sourceware.org/pipermail/libc-alpha/2021-February/122207.html">glibc 2.33</a>
    in addition to the other 43 glibc versions.
    </p>
    {#header_close#}

    {#header_open|mingw-w64 9.0.0#}
    <p>
    Zig ships with the source code to <a href="https://mingw-w64.org/">mingw-w64</a>.
    When targeting *-windows-gnu and linking against libc, Zig builds mingw-w64 from source
    for the selected target.
    </p>
    <p>
    This release updates the bundled mingw-w64 source code to
    <a href="https://sourceforge.net/p/mingw-w64/mailman/message/37287751/">v9.0.0</a>.
    </p>
    {#header_close#}

    {#header_open|WASI libc#}
    <p>Zig now ships with {#link|WASI libc#} and supports cross-compiling
    C code to WASI. See also {#link|WebAssembly Support#}.</p> 
    {#header_close#}

    {#header_open|zig ar#}
    <p>New subcommand: <code>zig ar</code> which is a drop-in replacement for <code>ar</code>.</p>
    {#header_close#}

    {#header_open|zig cc#}
    <p>
    Zig now automatically uses a thread pool to compile C objects in parallel. For users
    with multiple CPU cores this will make a huge difference in how long it takes to
    compile C and C++ objects.
    </p>
    <p>
    <code>zig cc</code> is covered by the Bug Stability Program. This means that, even
    prior to Zig 1.0, we will not tag a release with any known regressions in <code>zig cc</code>.
    Some caveats: this applies to only the Zig codebase; we cannot promise that
    {#link|Clang|LLVM 12#} will not regress.
    </p>
    <p>
    Also please be aware that there are
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3A%22zig+cc%22">open zig cc issues</a>,
    but these are things that never worked in the first place, making them
    <em>bugs</em> and <em>enhancements</em>, not regressions.
    </p>
    <p>
    Apart from parallelization, mainly the improvements in this release are polish
    and bug fixes, bringing us materially closer to the "it just works" user experience:
    </p>
    <ul>
      <li>Made <code>zig cc</code> print more info from Clang itself and from our own linker
      invocation. This is needed for CMake to properly discover all the include directories
      and library search paths (#7110, #7166).</li>
      <li>Made SONAME off by default when using <code>zig cc</code> to match C compilers.
        <code>zig build-lib -dynamic</code> still defaults SONAME to on.</li>
      <li>Default to a.exe on Windows, matching Clang.</li>
      <li>Support both ubsan and tsan at the same time.</li>
      <li>Support reading input from stdin, fixing use of <code>zig cc</code> with meson (#6271.</li>
      <li>Recognize more coff linker options (<a href="https://github.com/ziglang/zig/issues/7874">#7874</a>).</li>
      <li>Recognize the <code>-s</code> flag to be "strip".</li>
      <li>Fixed handling of <code>-MM</code> flag, as well as <code>-MG</code>,
        <code>-MM</code>, and <code>-MMD</code> aliases.</li>
      <li>Copy .pdb files from zig-cache/ when appropriate (<a href="https://github.com/ziglang/zig/issues/8407">#8407</a>).</li>
      <li>Properly pass -mcpu option when assembling.</li>
      <li>Expose header files when linking libunwind.</li>
      <li>Implicitly enable <code>--eh_frame_hdr</code> when compiling C/C++ files. Matches what Clang/GCC driver do (<a href="https://github.com/ziglang/zig/issues/7711">#7711</a>).</li>
    </ul>

    {#header_open|Environment Variable Alternatives to CLI Options#}
    <p>This release adds:</p>
    <ul>
      <li><code>ZIG_LOCAL_CACHE_DIR</code> corresponding to <code>--cache-dir</code></li>
      <li><code>ZIG_GLOBAL_CACHE_DIR</code> corresponding to <code>--global-cache-dir</code></li>
      <li><code>ZIG_LIB_DIR</code> corresponding to <code>--override-lib-dir</code></li>
      <li><code>ZIG_VERBOSE_LINK</code> corresponding to <code>--verbose-link</code></li>
      <li><code>ZIG_VERBOSE_CC</code> corresponding to <code>--verbose-cc</code></li>
    </ul>
    <p>
    Generally the CLI options that Zig provides are preferable to using environment variables,
    however, when using <code>zig cc</code>, we are bound by Clang's CLI options and
    therefore need alternate channels to pass these configuration options.
    </p>
    {#header_close#}

    {#header_open|Improved Local Cache Directory Logic#}
    <p>
    Previously, when choosing the local cache directory, if there was no
    root source file, an explicitly chosen path, or other clues, zig would
    choose cwd + zig-cache/ as the local cache directory.
    </p>
    <p>
    This can be problematic if Zig is invoked with the CWD set to a
    read-only directory, or a directory unrelated to the actual source files
    being compiled. In the real world, we see this when using <code>zig cc</code> with
    CGo, which for some reason changes the current working directory to the
    read-only go standard library path before running the C compiler.
    </p>
    <p>
    This change conservatively chooses to use the global cache directory
    as the local cache directory when there is no other reasonable choice,
    and no longer will rely on the cwd path to choose a local cache directory.
    </p>
    <p>
    As a reminder, the <code>--cache-dir</code> CLI flag and <code>ZIG_LOCAL_CACHE_DIR</code>
    environment variable are available for overriding the decision. For the
    zig build system, it will always choose the directory that build.zig is + zig-cache/.
    </p>
    <p>
    With this, plus a commit that landed in Go 1.17,
    <a href="https://dev.to/kristoff/zig-makes-go-cross-compilation-just-work-29ho">Zig Makes Go Cross Compilation Just Work</a>.
    </p>
    <p>
    Another user saw this and noticed that additionally,
    <a href="https://actually.fyi/posts/zig-makes-rust-cross-compilation-just-work/">Zig Makes Rust Cross-compilation Just Work</a>.
    </p>
    {#header_close#}
    <p>
    Contributors: Andrew Kelley, Jakub Konka, LemonBoy, Rafael Ristovski, Jacob G-W
    </p>
    {#header_close#}

    {#header_open|zig c++#}
    <p>
    <code>zig c++</code> is equivalent to {#link|zig cc#} with an added <code>-lc++</code>
    parameter, but I made a separate heading here because I realized that some people are
    not aware that Zig supports compiling C++ code and providing libc++ too!
    </p>
    <pre><code>#include &lt;iostream&gt;
int main() {
    std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl;
    return 0;
}</code></pre>
    <pre>$ zig c++ -o hello hello.cpp
$ ./hello
Hello World!</pre>
    <p>Cross-compiling too, of course:</p>
    <pre>$ zig c++ -o hello hello.cpp -target riscv64-linux
$ qemu-riscv64 ./hello
Hello World!</pre>
    <p>
    One thing that trips people up when they use this feature is that the
    <strong>C++ ABI is not stable across compilers</strong>, so always remember the rule:
    You must use the same C++ compiler to compile <em>all</em> your objects and static libraries.
    This is an unfortunate limitation of C++ which Zig can never fix.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|Bug Fixes#}
    <p>
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aclosed+is%3Aissue+label%3Abug+milestone%3A0.8.0+">Full list of the 106 bug reports closed during this release cycle</a>.
    </p>
    <p>
    Note: many bugs were both introduced and resolved within this release cycle.
    </p>
    {#header_open|This Release Contains Bugs#}
    <p>
    Zig has
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Abug">known bugs</a>
    and even some
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Amiscompilation">miscompilations</a>.
    </p>
    <p>Zig is immature. Even with Zig 0.8.0, working on a non-trivial project using Zig will
    likely require participating in the development process.</p>
    <p>When Zig reaches 1.0.0, a new requirement for {#link|Tier 1 Support#} will be
    0 known bugs for that target.</p>
    <p>
    A <a href="https://github.com/ziglang/zig/milestone/12">0.8.1 release</a> is planned.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|News#}

    {#header_open|Frank Denis joins the Core Zig Team#}
    <p>Frank has completely organized, modernized, fixed, and fleshed out
    {#link|Standard Library#} {#link|Crypto#}, as well as other parts of the standard library.
    He also delivered a
    <a href="https://www.youtube.com/watch?v=G-4_cNAq1uQ">Zig Showtime talk on 25519</a>.
    <p>Frank has shown continued dedication and discipline in contributions
to the Zig programming language project. The quality of his work
speaks for itself.</p>
    <p>In addition, Frank has proven to be a steadfast community leader,
    setting an example for how to treat others with kindness and respect.</p>
    {#header_close#}

    {#header_open|kprotty joins the Core Zig Team#}
    <p>I am pleased to announce our newest Zig team member, kprotty. If you've 
    interacted with him, you know that he has an insatiable appetite for 
    concurrency-related performance, based on a deep understanding that only 
    comes from dedication and experimentation.</p>

    <p>Check out his related Showtime talks:</p>

    <ul>
      <li><a href="https://www.youtube.com/watch?v=jMqKaKg_gvw">Build-A-Barging Lock</a></li>
      <li><a href="https://www.youtube.com/watch?v=WRsXxtHGv90">Schedulers and Stuff</a></li>
    </ul>
    <p>kprotty's contributions to the Zig standard library are core to the 
    success of the project.</p>
    <p>In addition, kprotty has proven to be a steadfast community leader,
    setting an example for how to treat others with kindness and respect.</p>
    {#header_close#}

    {#header_open|LemonBoy Gains LLVM Write Access#}
    <p>If you read even a little bit of these release notes, you probably noticed that
    LemonBoy did an incredible amount of work for Zig.</p>
    <p>But this mad man did not only that, but also submitted patches to LLVM upstream to
    fix Zig-related issues that came up. So much so, recently, that he was granted write
    access to the LLVM repository.</p>
    <p>Congrats to LemonBoy and thank you for your contributions.</p>
    {#header_close#}

    {#header_open|Loris Cro Gets a Raise#}
    <p>Loris was the first person hired by the Zig Software Foundation. At the time,
    Andrew's plan was to pay him out of his personal savings account. However, within just two
    weeks of work, Loris already paid for himself and more, by helping to get more donations.</p>
    <p>Until now his hourly rate has been 40 USD/hour, but now it is 50 USD/hour, same as
    the other contractors. So, Loris: please start billing ZSF at this higher rate!</p>
    {#header_close#}

    {#header_open|License Tweak#}
    <p>In celebration of this 0.8.0 release, Andrew made a small tweak to the LICENSE file
    of the main Zig repository:</p>
    <pre><code>--- a/LICENSE
+++ b/LICENSE
@@ -1,6 +1,6 @@
 The MIT License (Expat)
 
<span style="color: red">-Copyright (c) 2015 Andrew Kelley</span>
<span style="color: green">+Copyright (c) 2015-2021, Zig contributors</span>
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal</code></pre>
    <p>
    Thank you everyone for your amazing contributions over the past years! ‚ù§Ô∏è
    </p>
    {#header_close#}

    {#header_close#}

    {#header_open|Roadmap#}
    <p>The major theme of the 0.9.0 release cycle will be <strong>stabilizing the language</strong>,
    <strong>creating a first draft of the language specification</strong>, and
    <strong>self-hosting the compiler</strong>.
    </p>
    <p>I am now confident that we can ship the {#link|Self-Hosted Compiler#} with the 0.9.0 release
    of Zig.</p>

    {#header_open|Package Manager Status#}
    <p>
    Having a package manager built into the Zig compiler is a
    <a href="https://github.com/ziglang/zig/issues/943">long-anticipated feature</a>.
    Zig 0.8.0 does not have this feature.
    </p>
    <p>
    If the package manager works well, people will use it, which means building Zig projects
    will involve compiling more lines of Zig code, which means the Zig compiler must get faster,
    better at incremental compilation, and better at resource management.
    </p>
    <p>
    Therefore, the package manager depends on finishing the
    {#link|Self-Hosted Compiler#}, since it is planned to have these
    improved performance characteristics, while the {#link|Bootstrap Compiler#}
    is not planned to have them.</p>
    {#header_close#}

    {#header_open|Accepted Proposals#}
    <p>
    If you want more of a sense of the direction Zig is heading, you can look at
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Aaccepted">the set of accepted proposals</a>.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|Thank You LavaTech#}
    <p>Special thanks to Ave and Luna of <a href="https://lavatech.top/">LavaTech</a>, who are
    hosting an instance of <a href="https://sourcehut.org/">SourceHut</a> for our Continuous Integration
    pipeline, but with more RAM than the main sr.ht service allows. Thanks to this, FreeBSD now has
    significantly more test coverage, most notably all the standard library tests.</p>
    {#header_close#}

    {#header_open|Thank You Sponsors!#}
    <p>
    Special thanks to those who <a href="/zsf/">sponsor Zig</a>.
    Because of you, Zig is driven by the open source community, rather than the goal of making profit.
    In particular, these fine folks sponsor Zig for $50/month or more:
    </p>
    <ul style="columns: 3">
<li><a href="https://pex.com">Pex</a></li>
<li><a href="https://github.com/drfuchs">drfuchs</a></li>
<li><a href="https://lagerdata.com ">Lager Data</a></li>
<li><a href="https://www.hryx.net/">Stevie Hryciw</a></li>
<li><a href="https://github.com/karrick">Karrick McDermott</a></li>
<li><a href="https://github.com/jorangreef">Joran Dirk Greef</a></li>
<li><a href="https://github.com/tauoverpi">Simon A. Nielsen Knights</a></li>
<li><a href="https://slimsag.com">Stephen Gutekanst</a></li>
<li><a href="https://www.synadia.com/">ConnectEverything</a></li>
<li><a href="http://derekcollison.net/">Derek Collison</a></li>
<li><a href="https://github.com/Vulfox">Dustin Taylor</a></li>
<li><a href="https://github.com/thejoshwolfe">Josh Wolfe</a></li>
<li><a href="https://github.com/mattnite">Matthew Knight</a></li>
<li><a href="https://github.com/ryanworl">ryanworl</a></li>
<li><a href="https://jethron.id.au">Jethro Nederhof</a></li>
<li><a href="https://github.com/bfredl">Bj√∂rn Linse</a></li>
<li><a href="https://github.com/wilsonk">wilsonk</a></li>
<li><a href="https://github.com/david-vanderson">David Vanderson</a></li>
<li><a href="https://skunkwerks.at/">SkunkWerks GmbH</a></li>
<li><a href="https://github.com/tawawhite">tawawhite</a></li>
<li><a href="https://github.com/dimenus">Ryan Saunderson</a></li>
<li>Isaac Yonemoto</li>
<li>Felix Quei√üner</li>
<li>devzero</li>
<li>Luuk de Gram</li>
<li>Jamie Brandon</li>
<li>Auguste Rame</li>
<li>Jay Petacat</li>
<li>Michal Ziulek</li>
<li>Vincent Rischmann</li>
<li>seadragon-droid</li>
<li>Asherah Connor</li>
<li>meraymond2</li>
<li>Dirk de Visser</li>
<li>Santiago Andaluz</li>
<li>Martin Wickham</li>
<li>Jos√© M Rico</li>
<li>Steve Powers</li>
<li>Yaroslav Zhavoronkov</li>
<li>Agam Dua</li>
<li>Rui Ueyama</li>
<li>mbarkhau</li>
<li>Clay Kuppinger</li>
<li>Charlie Cheever</li>
<li>Anton Kochkov</li>
<li>Martin Schwaighofer</li>
<li>Jesus Alvarez</li>
<li>Max Bernstein</li>
<li>Rand Fitzpatrick</li>
<li>Timothy Ham</li>
<li>Robert Hencke</li>
<li>Max De Marzi</li>
<li>Christopher Kennedy</li>
<li>Jordan Orelli</li>
<li>Keith Devens</li>
<li>jamesmcgill</li>
<li>Luke Champine</li>
<li>Neil Wang</li>
<li>Mitchell Kember</li>
<li>Christopher David Shirk</li>
<li>Mamadou S Diallo</li>
<li>Matyas Tamas</li>
<li>Daniel Hensley</li>
<li>cryptocode</li>
<li>Andrew Gallant</li>
<li>Erik Lundin</li>
<li>Christopher Dolan</li>
<li>Tom Maenan Read Cutting</li>
<li>Robert Krahn</li>
    </ul>
    {#header_close#}
    </div>
  </body>
</html>
