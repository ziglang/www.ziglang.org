<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>0.8.0 Release Notes ‚ö° The Zig Programming Language</title>
    <link rel="icon" href="https://ziglang.org/favicon.png">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        line-height: 1.45;
        margin-left: 0;
        margin-right: 0;
      }
      p {
        margin: 0.8em 0;
      }

      h1, h2, h3, h4, h5 {
        margin: 0.5em 0 0.5em;
        line-height: 1.2;
        font-weight: bold;
        color: #666;
      }

      h1 a, h2 a, h3 a, h4 a, h5 a {
        text-decoration: none;
        color: #666;
      }

      h1 { font-size: 2.0em; }

      h2 { font-size: 1.5em; }

      h3 { font-size: 1.25em; }

      h4 { font-size: 1.0em; }

      a.hdr {
        visibility: hidden;
      }
      h1:hover > a.hdr, h2:hover > a.hdr, h3:hover > a.hdr, h4:hover > a.hdr, h5:hover > a.hdr {
        visibility: visible;
      }

      a {
        color: #2A6286;
      }

      a:not(:hover) {
        text-decoration: none;
      }

      th, td {
        padding: 0.6em;
        text-align: left;
      }

      td {
        font-size: 0.96em;
      }

      th {
        border-bottom: 2px solid #f2f3f3;
      }

      tr:nth-child(even) {
        background: #f2f3f3;
      }

      .t0_1, .t37, .t37_1 {
        font-weight: bold;
      }
      .t2_0 {
        color: grey;
      }
      .t31_1 {
        color: red;
      }
      .t32_1 {
        color: green;
      }
      .t36_1 {
        color: #0086b3;
      }
      .file {
        text-decoration: underline;
      }
      pre,code {
        font-size: 12pt;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        color: #333;
        background: #f8f8f8;
      }
      .table-wrapper {
        width: 100%;
        overflow-y: auto;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      #contents {
        max-width: 60em;
        margin: auto;
        padding: 0 0.2em;
      }

      #logo {
        width: 100%;
        height: 7em;
        display: block;
        background-image: url(https://ziglang.org/img/zig-logo-dark.svg);
        background-repeat: no-repeat;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background-color:#111;
            color: #bbb;
        }
        a {
            color: #88f;
        }
        table, th, td {
            border-color: grey;
        }
        tr:nth-child(even) {
          background: #1e1e1e;
        }
        .t2_0 {
            color: grey;
        }
        .t31_1 {
            color: red;
        }
        .t32_1 {
            color: green;
        }
        .t36_1 {
            color: #0086b3;
        }
        pre > code {
            color: #ccc;
            background: #222;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #e33;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
        h1, h2, h3, h4, h5 {
          color: #aaa;
        }
        h1 a, h2 a, h3 a, h4 a, h5 a {
            color: #aaa;
        }
        #logo {
          background-image: url(https://ziglang.org/img/zig-logo-light.svg);
        }
      }
    </style>
  </head><!--
             .,-:;//;:=,
         . :H@@@MM@M#H/.,+%;,
      ,/X+ +M@@M@MM%=,-%HMMM@X/,
     -+@MM; $M@@MH+-,;XMMMM@MMMM@+-     Now you're thinking
    ;@M@@M- XM@X;. -+XXXXXHHH@M@M#@/.     with Zig
  ,%MM@@MH ,@%=            .-.-=-=:=,.
  -@#@@@MX .,              -%HX$$%%%+;
 =-./@M@M$                  .;@MMMM@MM:
 X@/ -$MM/                    .+MM@@@M$
,@M@H: :@:                    . -X#@@@@-
,@@@MMX, .                     /H- ;@M@M=
.H@@@@M@+,                    %MM+..%#$.
 /MMMM@MMH/.                  XM@MH; -;
  /%+%$XHH@$=              , .H@@@@MX,
   .=--------.           -%H.,@@@@@MX,
   .%MM@@@HHHXX$$$%+- .:$MMX -M@@MM%.
     =XMMM@MM@MM#H;,-+HMM@M+ /MMMX=
       =%@M@M#@$-.=$@MM@@@M; %M%=
         ,:+$+-,/H#MMMMMMM@- -,
               =++%%%%+/:-.
 --><body>
    <div id="contents">
    <a href="https://ziglang.org/"><span id="logo"></span></a>
    <h1>0.8.0 Release Notes</h1>
    <p>
    <a href="https://ziglang.org/download/">Download &amp; Documentation</a>
    </p>
    <p>
    Zig is a general-purpose programming language and toolchain for maintaining
    <strong>robust</strong>, <strong>optimal</strong>, and <strong>reusable</strong> software.
    </p>
    <p>
    Backed by the <a href="/zsf/">Zig Software Foundation</a>,
    the project is <strong>financially sustainable</strong> and offers billable
    hours for core team members:
    </p>
    <ul style="columns: 3">
      <li><a href="https://kristoff.it/">Loris Cro</a></li>
      <li><a href="http://www.jakubkonka.com/">Jakub Konka</a></li>
      <li><a href="https://vexu.eu/">Veikka Tuominen</a></li>
      <li><a href="https://github.com/SpexGuy">Martin Wickham</a></li>
      <li><a href="https://github.com/alexnask">Alexandros Naskos</a></li>
    </ul>
    <p>
    Please consider <a href="/zsf/">donating to the ZSF</a> to help us pay even more contributors!
    </p>
    <p>
    This release features <strong>7 months of work</strong> and
    changes from <strong>144 different contributors</strong>, spread among
    <strong>2711 commits</strong>.
    </p>
    {#header_open|Table of Contents#}
    {#nav#}
    {#header_close#}

    {#header_open|Support Table#}
    {#header_open|Tier System#}
    <p>
    A green check mark (‚úÖ) indicates the target meets all the requirements for the
    support tier. The other icons indicate what is <em>preventing the target from
      reaching the support tier</em>. In other words, the icons are
    <strong>to-do items</strong>. If you find any wrong data here please
    <a href="https://github.com/ziglang/www.ziglang.org">submit a pull request</a>!
    </p>
    {#header_open|Tier 1 Support#}
    <ul>
      <li>Not only can Zig generate machine code for these targets, but the standard
        library cross-platform abstractions have implementations for these targets.</li>
      <li>üß™ The CI server automatically tests these targets on every commit to master
        branch.</li>
      <li>üì¶ The CI server automatically produces pre-built binaries for these targets,
        on every commit to master, and updates
        <a href="https://ziglang.org/download/">the download page</a> with links.</li>
      <li>These targets have debug info capabilities and therefore produce stack traces
        on failed assertions.</li>
      <li>libc is available for this target even when cross compiling.</li>
      <li>üêõ All the behavior tests and applicable standard library tests pass for this target.
          All language features are known to work correctly. Experimental features do not
          count towards disqualifying an operating system or architecture from Tier 1.</li>
      <li><code>zig cc</code>, <code>zig c++</code> and related toolchain commands support
        this target.</li>
      <li>üíÄ If the Operating System is proprietary then the target is not marked deprecated
        by the vendor,
        <a href="https://support.apple.com/en-us/HT208436">such as macos/x86</a>.</li>
    </ul>
    <table>
    <thead>
    <tr>
    <th></th>
    <th>freestanding</th>
    <th>Linux 3.16+</th>
    <th>macOS 10.13+</th>
    <th>Windows 8.1+</th>
    <th>WASI</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td>x86_64</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>x86</td>
    <td>‚úÖ</td>
    <td>#1929 üêõüì¶</td>
    <td>üíÄ</td>
    <td>#537 üêõüì¶</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>aarch64</td>
    <td>‚úÖ</td>
    <td>#2443 üêõ</td>
    <td>‚úÖ</td>
    <td>üêõüì¶üß™</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>arm</td>
    <td>‚úÖ</td>
    <td>#3174 üêõüì¶</td>
    <td>N/A</td>
    <td>üêõüì¶üß™</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>mips</td>
    <td>‚úÖ</td>
    <td>#3345 üêõüì¶üß™</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>riscv64</td>
    <td>‚úÖ</td>
    <td>#4456 üêõüì¶</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>sparcv9</td>
    <td>‚úÖ</td>
    <td>#4931 üêõüì¶üß™</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>wasm32</td>
    <td>‚úÖ</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>‚úÖ</td>
    </tr>
    </tbody>
    </table>
    {#header_close#}

    {#header_open|Tier 2 Support#}
    <ul>
    <li>üìñ The standard library supports this target, but it's possible that some
      APIs will give an "Unsupported OS" compile error. One can link with libc or other
      libraries to fill in the gaps in the standard library.</li>
    <li>üîç These targets are known to work, but may not be automatically tested, so there
      are occasional regressions.</li>
    <li>Some tests may be disabled for these targets as we work toward
      {#link|Tier 1 Support#}.
    </li>
    </ul>
    <table>
    <thead>
    <tr>
    <th></th>
    <th>free standing</th>
    <th>Linux 3.16+</th>
    <th>macOS 10.13+</th>
    <th>Windows 8.1+</th>
    <th>FreeBSD 12.0+</th>
    <th>NetBSD 8.0+</th>
    <th>DragonFlyBSD 5.8+</th>
    <th>UEFI</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td>x86_64</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    </tr>
    <tr>
    <td>x86</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>‚úÖ</td>
    <td>üíÄ</td>
    <td>‚úÖ</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>‚úÖ</td>
    </tr>
    <tr>
    <td>aarch64</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>‚úÖ</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>üîç</td>
    </tr>
    <tr>
    <td>arm</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>‚úÖ</td>
    <td>N/A</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>üîç</td>
    </tr>
    <tr>
    <td>mips64</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>mips</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>‚úÖ</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>powerpc64</td>
    <td>‚úÖ</td>
    <td>üìñ</td>
    <td>üíÄ</td>
    <td>N/A</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>powerpc</td>
    <td>‚úÖ</td>
    <td>‚úÖ</td>
    <td>üíÄ</td>
    <td>N/A</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    <tr>
    <td>riscv64</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>‚úÖ</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>üîç</td>
    </tr>
    <tr>
    <td>sparcv9</td>
    <td>{#link|Tier 1|Tier 1 Support#}</td>
    <td>‚úÖ</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>üîç</td>
    <td>üîç</td>
    <td>N/A</td>
    <td>N/A</td>
    </tr>
    </tbody>
    </table>
    {#header_close#}

    {#header_open|Tier 3 Support#}
    <ul>
    <li>The standard library has little to no knowledge of the existence of this
        target.</li>
    <li>If this target is provided by LLVM, LLVM has the target enabled by default.</li>
    <li>These targets are not frequently tested; one will likely need to contribute
      to Zig in order to build for these targets.</li>
    <li>The Zig compiler might need to be updated with a few things such as<ul>
       <li>what sizes are the C integer types</li>
       <li>C ABI calling convention for this target</li>
       <li>start code and default panic handler</li>
     </ul>
     <li><code>zig targets</code> is guaranteed to include this target.</li>
    </ul>
    <table>
      <thead>
        <tr>
          <th></th>
          <th>freestanding</th>
          <th>Linux 3.16+</th>
          <th>Windows 8.1+</th>
          <th>FreeBSD 12.0+</th>
          <th>NetBSD 8.0+</th>
          <th>UEFI</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>x86_64</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
        </tr>
        <tr>
          <td>x86</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
        </tr>
        <tr>
          <td>aarch64</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
        </tr>
        <tr>
          <td>arm</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
        </tr>
        <tr>
          <td>mips64</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>mips</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>riscv64</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
        </tr>
        <tr>
          <td>powerpc32</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>powerpc64</td>
          <td>{#link|Tier 2|Tier 2 Support#}</td>
          <td>‚úÖ</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>bpf</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>hexagon</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>amdgcn</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>sparc</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>s390x</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
        <tr>
          <td>lanai</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
          <td>N/A</td>
        </tr>
      </tbody>
    </table>
    <table>
      <thead>
        <tr>
          <th></th>
          <th>freestanding</th>
          <th>emscripten</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>wasm32</td>
          <td>{#link|Tier 1|Tier 1 Support#}</td>
          <td>‚úÖ</td>
        </tr>
      </tbody>
    </table>
    {#header_close#}

    {#header_open|Tier 4 Support#}
    <ul>
      <li>Support for these targets is entirely experimental.</li>
      <li>If this target is provided by LLVM, LLVM may have the target as an
        experimental target, which means that you need to use Zig-provided binaries
        for the target to be available, or build LLVM from source with special configure flags.
        <code>zig targets</code> will display the target if it is available.</li>
      <li>This target may be considered deprecated by an official party,
        <a href="https://support.apple.com/en-us/HT208436">such as macosx/i386</a> in which
        case this target will remain forever stuck in Tier 4.</li>
      <li>This target may only support <code>-femit-asm</code> and cannot emit object files
        (<code>-fno-emit-bin</code> enabled by default and cannot be overridden).</li>
    </ul>
    <p>Tier 4 targets:</p>
    <ul style="columns: 3">
      <li>avr</li>
      <li>riscv32</li>
      <li>xcore</li>
      <li>nvptx</li>
      <li>msp430</li>
      <li>r600</li>
      <li>arc</li>
      <li>tce</li>
      <li>le</li>
      <li>amdil</li>
      <li>hsail</li>
      <li>spir</li>
      <li>kalimba</li>
      <li>shave</li>
      <li>renderscript</li>
      <li>32-bit x86 macOS, as well as powerpc32 and powerpc64 macOS, because Apple has
          officially dropped support for them.</li>
    </ul>
    {#header_close#}
    {#header_close#}

    {#header_open|Windows Support#}
    Windows TLS startup symbols are already provided by libcrt when linking against libc

    make "gnu" (mingw-w64) the default C ABI on Windows Closes #6565

Contributors: Alexandros Naskos, Andrew Kelley
    {#header_close#}

    {#header_open|macOS Support#}
    <p>With the advent of the {#link|Self-Hosted Linker#}, Zig is now able to generate
    well-formed and codesigned binaries on arm64 macOS (aka the Apple Silicon).
    It is also able to cross-compile C, C++, and Zig code to an arm64 and x86_64
    macOS. Additionally, arm64 nightly binaries of Zig are automatically generated
    by our Continuous Integration service, meaning both arm64 and x86_64 macOS are
    now {#link|Tier 1|Tier 1 Support#} targets.
    </p>
    <p>
    To facilitate incremental linking, the self-hosted compiler is now by default generating
    <a href="https://opensource.apple.com/source/lldb/lldb-179.1/www/symbols.html"><code>dSYM</code> bundles</a> which store DWARF debug information and debug symbols on macOS.
    This puts Zig on path of becoming a true replacement for the Xcode development environment.
    </p>
    <p>
    Finally, as a side experiment, Jakub added in {#link|Zig Build System#} integration
    with <a href="https://www.darlinghq.org/">Darling</a> (#8760), a translation layer of macOS
    syscalls to Linux, with the intention of being able to cross test MachO binaries
    and macOS specific tests directly on Linux simply by passing in an additional flag
    <code>-Denable-darling</code> to <code>zig build test</code>.
    </p>

    <p>TODO</p>
SYSTEM_LINKER_HACK
    macos: avoid --export-dynamic when using system linker

 * fetch-them-macos-headers #7035
   - headers now available for x86_64-macos-gnu and aarch64-macos-gnu
   - depend on bundled headers even for native. #6773
   - jakub & andrew
    {#header_close#}

    {#header_open|WebAssembly Support#}
    <p>The {#link|Self-Hosted Compiler#} gained a work-in-progress
    {#link|WebAssembly Backend#}, which provides the ability for Zig to
    compile to wasm without {#link|LLVM|LLVM 12#}.</p>
    <p>Zig now ships with {#link|WASI libc#} and supports cross-compiling
    C code to WASI with Zig. This also makes Zig a tempting alternative to downloading and
    building
    <a href="https://github.com/webassembly/wasi-libc">WASI libc</a> and/or
    <a href="https://github.com/webassembly/wasi-sdk">WASI SDK</a> manually (#8837).
    </p>

    TODO
* wasm: fix object extension to standard .o from .o.wasm
* wasm: build static archive unless -dynamic specified
    {#header_close#}

    {#header_open|Haiku Support#}
    TODO
    {#header_close#}

    {#header_open|csky Support#}
    TODO (glibc supported it but now llvm does too)
    {#header_close#}

    {#header_open|thumb2 Support#}
    TODO
    {#header_close#}

    {#header_open|bpf Support#}
    TODO Matthew Knight Add c_longdouble mapping for bpf (#7504)
    {#header_close#}

    {#header_open|msp430 Support#}
    TODO Nathan Michaels: Implement msp430 mapping for c_longdouble. (#7333)
    {#header_close#}

    {#header_open|sparc64 Support#}
    Fix fork() on Linux/sparc64 and add long double mapping (#7237)
    TODO stage1: set gen_frame_size alignment to work around requirement mismatch
    Add compiler-rt stub for SPARC CPUs
    stage1: SPARCv9 f128 enablement (#7716)
    std.debug.StackIterator: account for SPARC %fp quirk
    SPARCv9: Handle various stack frame related quirks (#7946).

    tier 2

    std: Fix backtraces on sparcv9

    std: Fix stack overflow in SPARC clone() impl
    std: Import correct errno defs for SPARC
    std: Add signal numbers for SPARC
    std: Fix pwrite/pread syscalls on SPARC targets
    Define ENOTSUP for SPARC

    Add missing f128 compiler-rt shim
    Fix linux dirent64 buffer align directive

    Koakuma, LemonBoy
    {#header_close#}
    {#header_close#}

    {#header_open|Documentation#}
    <ul>
      <li>std docs: enhance search browser history UX</li>
      <li>The language reference is updated to reflect the changes to the language and
        standard library in this release cycle.</li>
      <li>Fixed {#syntax#}@reduce{#endsyntax#} documentation.</li>
      <li>Fixed operator precedence in the language reference.</li>
      <li>Improved documentation for string slices (#7454).</li>
      <li>Clarify confusing wording regarding <code>%</code> and <code>/</code></li>
      <li>Clarify that {#syntax#}@field{#endsyntax#} can work on declarations.</li>
      <li>Avoid concept of a "Unicode character" in documentation and error messages (#8059).</li>
      <li>Update docs and grammar to allow CRLF line endings (#8063).</li>
      <li>langref: Use "single-item pointer" and "many-item pointer" (#8217).</li>
      <li>docgen: use <code>std.Progress</code> API so that we see a terminal progress
          bar when waiting for the docs to build.</li>
      <li>docs: document the nosuspend keyword (#7972).</li>
      <li>Fix langref.html anchor navigation</li>
      <li>Add doc in `Anonymous Struct Literal` section for special @"0" syntax (#8630).</li>
      <li>Improve documentation for ArrayList, ArrayListUnmanaged, etc. (#7624)</li>
    </ul>
    <p>
    Contributors: Andrew Kelley, Carlos Z√∫√±iga, Dave Gauer, Devin Bayer, Eleanor Bartle, Frank Denis, Jakub Konka, Jay Petacat, Jonas Carpay, Josh Holland, Josh Wolfe, LemonBoy, Martin Wickham, Mathieu Guay-Paquet, Matthew Borkowski, Ryan Liptak, Tadeo Kondrak, Veikka Tuominen, data-man, Jacob G-W, xackus
    </p>
    {#header_close#}

    {#header_open|Language Changes#}
    TODO language
  - delete packed enums from the language
    stage1: Require a block after suspend Closes #8603
  - Add {#syntax#}@extern{#endsyntax#}.

  - `zig test` no longer filters based on empty labels / nameless test blocks

  - remove @TagType
    - Tadeo Kondrak

  - Allow resume in nosuspend scope. Resuming a suspended async function call
    is actually a synchronous operation.

  - Allow async in nosuspend scope. Starting an async function call is actually
    a synchronous operation, since the caller is not awaiting on the callee for a return value.

  - add SysV calling convention

  - stage1: Allow wrapping negation on unsigned ints at comptime Closes #7951 Closes #8574

  - std.builtin re-arranging
    {#header_close#}

    {#header_open|Bootstrap Compiler#}
    <p>In the previous release, as well as this release, the main Zig compiler everybody uses
    is the bootstrap compiler, written in C++, also known as "stage1". Despite the main focus
    of this release cycle being the {#link|Self-Hosted Compiler#}, there were some improvements
    to stage1 as well.</p>
    <ul>
        <li>Fix not supporting comments in between multiline string literal lines</li>
        <li>Fix type mapping for c_longdouble</li>
        <li>Print correct error message for vector @intCast</li>
        <li>Fix comparison of unions containing zero-sized types (#7047)</li>
        <li>Avoid resolving type entry in [0]T (fixed #7058)</li>
        <li>Fix crash in comptime struct generation (#7027)</li>
        <li>Disambiguate Wasm imports with same name (#7088)</li>
        <li>Fix generation of pass-by-value args in async fns (#7104)</li>
        <li>Fix asyncCall with non-abi-aligned arguments</li>
        <li>Add architecture-specific clobbers to asm(). We're basically following Clang's
          lead, add the necessary clobbers to minimize the risk of generating wrong code.</li>
        <li>Allow Zig to be built with clang 11 and -Werror</li>
        <li>Reject undefined values when taking union ptr. (#7019)</li>
        <li>Improve error for missing a number type on a runtime var.</li>
        <li>Fix undefined assignment for bitfields. Prevents silent memory corruption. (#7055)</li>
        <li>Emit a compile error instead of falling back to C for unsupported calling convention. (#6829)</li>
        <li>Check calling convention correctly for subsystem detection.</li>
        <li>Resolve usingnamespace decls when calling {#syntax#}@typeInfo{#endsyntax#} (#7176).</li>
        <li>Fix ICE when generating struct fields with padding. (#5398)</li>
        <li>Force union member types to be resolved.</li>
        <li>Fix crash in *[N]T to []T conversion with zst (#6951).</li>
        <li>Add compile error for slice.len incremented beyond bounds (#7810).</li>
        <li>Fix {#syntax#}f128{#endsyntax#} codegen on Big Endian hosts.</li>
        <li>Resolve alignment earlier in {#syntax#}@alignCast{#endsyntax#} (#7744).</li>
        <li>Use correct format specifier for size_t parameters.</li>
        <li>Fix ssize_t definition.</li>
        <li>Remove stray brace in rarely-tested code path (#7614).</li>
        <li>Allow variable capture for multi-prong switch arms, handling the multi-prong
          case as we do with range cases (#7188).</li>
        <li>Let LLVM legalize the overflowing ops on vectors, because it is smart enough to
          produce tight overflow checking sequences.</li>
        <li>Prevent crash with some lazy pointer types (#7568).</li>
        <li>Validate pointer attributes when coercing anon literals.</li>
        <li>Implement type coercion of pointer to anon list to array/struct/union/slice.</li>
        <li>Implement type coercion of anon list to array.</li>
        <li>Create a new declaration scope for union enum types (#7532).</li>
        <li>Add peer type resolution with unsigned ints and larger signed ints.</li>
        <li>Fix bug in generic function monomorphization.</li>
        <li>Apply LLVM ssp attributes globally instead of per-function. Otherwise LLVM asserts with:
          "stack protected callee but caller requested no stack protector"</li>
        <li>Fix crashes (#7426, #7451, #7431).</li>
        <li>Validate the specified cc for lazy fn types (#7337).</li>
        <li>Fix initialization of single-element union tag.</li>
        <li>Fix constant folding of single-element enums.</li>
        <li>Add compile error for pointer arithmetic on ptr-to-array (#2018).</li>
        <li>Fix floating point parsing on BE systems (#7256).</li>
        <li>Fix typeInfo generation for arrays w/o sentinel (#7251).</li>
        <li>Add missing bitcast when rendering var ptr (#7250).</li>
        <li>Small improvement in C ABI support for return types.</li>
        <li>A few small memory usage optimizations.</li>
        <li>Put async frames in the correct LLVM address space.</li>
        <li>Fix for atomicrmw xchg on fp types (#4457).</li>
        <li>Rework tokenizer to match {#link|Self-Hosted Compiler#}. Mainly, this makes the
          stage1 and stage2 logic match each other, making it
          easier to maintain both at the same time. It is also a negligible memory
          usage improvement.</li>
        <li>Store target info in the LLVM module for every function. This is needed to
          let LLVM (or, better, libLTO) produce code using the target options
          specified by the user (#8803).</li>
        <li>Widen non byte-sized atomic loads/stores (#7976).</li>
        <li>Improve message for missing fn return type.</li>
        <li>Fix LLVM error in inline asm invocation (#3606).</li>
        <li>Improve how the async frame alignment is computed.</li>
        <li>More precise serialization of f16 values.</li>
        <li>Fix negation for zero floating point values.</li>
        <li>Resolve builtin types and values via <code>std.builtin</code> rather than via
          {#syntax#}@import("builtin"){#endsyntax#}. This helps avoid the need for
          {#syntax#}usingnamespace{#endsyntax#} used in <code>builtin.zig</code> or in
          <code>std.builtin</code>.</li>
    </ul>
    <p>
    The good news here is that nearly all these fixes come with additional behavior tests, which
    we can use to verify the {#link|Self-Hosted Compiler#} does not regress.
    </p>
    <p>
    One especially noteworthy change here is LemonBoy's fix to ask LLVM to produce compact
    code in -OReleaseSmall mode. Previously, using -OReleaseSmall sometimes resulted in
    larger output binaries than -OReleaseFast! (#7048, #7077)
    </p>
    <p>
    <strong>Big, big thanks to LemonBoy</strong> for solving so many stage1 bugs during this release cycle. This
    is high effort, low-appreciation, huge-impact work that he has been doing. But in reality
    he has been single-handedly keeping us afloat while we work towards finishing the
    {#link|Self-Hosted Compiler#}.
    </p>
    <p>Contributors: LemonBoy, Andrew Kelley, Koakuma, Veikka Tuominen, Tadeo Kondrak, Michael Dusan, Jakub Konka, frmdstryr, Mathieu Guay-Paquet, Sreehari S, Al Hoang, Alexandros Naskos, Isaac Freund, Jay Petacat, Josh Wolfe, Lee Cannon, Matthew Knight, Nathan Michaels, Sizhe Zhao, Timon Kruiper, Woze Parrot, Jacob G-W, lars, pfg, xackus</p>
    {#header_open|LLVM 12#}
    <p>
    This release of Zig upgrades to
    <a href="http://releases.llvm.org/12.0.0/docs/ReleaseNotes.html">LLVM 12</a>.
    </p>
    <p>
    This was a rough release cycle for downstream users of LLVM. During testing of the release
    candidates, we found and reported 7 regressions from LLVM 11. However, despite having
    reproducible regressions reported as release blockers, the LLVM project tagged release
    12.0.0. Not only were there open regressions at this time, but the 12.0.0 tag did not
    even tag the tip of the release/12.x branch - so there were <em>fixes already committed
    into the release branch that did not make it into the tag</em>.
    </p>
    <p>
    At the time of this writing, there are
    <a href="https://bugs.llvm.org/show_bug.cgi?id=release-12.0.1">31 open release blockers for 12.0.1</a>,
    and yet LLVM has already tagged 12.0.1-rc1. As
    <a href="https://lists.llvm.org/pipermail/llvm-dev/2021-May/150800.html">Micha≈Ç G√≥rny puts it</a>:
    </p>
    <blockquote>
I've started testing, hit two bugs I've already reported for 12.0.0 RCs
and figured out I'm wasting my time.  It seems that LLVM reached
the point where releases are pushed through just for the sake of
releases and QA doesn't exist.
    </blockquote>
    <p>
    I hope the LLVM project can step up and take releases and regressions more seriously.
    </p>
    <p>
    Either way, it is starting to become clear that
    <a href="https://kristoff.it/blog/zig-new-relationship-llvm/">transitioning LLVM to an optional dependency</a>,
    and thereby providing an alternative to the LLVM monoculture,
    is becoming more and more of an attractive feature for the Zig project to offer.
    In this release you can see that we have broken ground on this front:
    {#link|x86-64 Backend#},
    {#link|AArch64 Backend#},
    {#link|ARM Backend#},
    {#link|WebAssembly Backend#},
    {#link|RISC-V 64 Backend#},
    {#link|C Backend#},
    {#link|SPIR-V Backend#}
    </p>
    {#header_close#}

    {#header_close#}

    {#header_open|Self-Hosted Compiler#}
    <p>The main focus of this release cycle was the self-hosted compiler (also known
    as "stage2").</p>
    <p>
    Despite the fact that .zig source code by default is still compiled in this
    release using the {#link|Bootstrap Compiler#}, the main driver code is already
    self-hosted, as well as many features, such as {#link|zig cc#}, {#link|C Translation#},
    and {#link|CPU Feature Detection#}. So improvements made to "stage2" in these areas
    do in fact affect the main Zig user experience.
    </p>
    TODO Show passing test cases that self-hosted is now capable of
    TODO Performance demo
    TODO Mention the architecture of the stage2 compiler and note the
      main contributors who have stepped up to work on the various parts of it.
    TODO Explain the bootstrapping plan

    <p>Miscellaneous:</p>
    <ul>
      <li>Default AVR generic cpu to avr2</li>
      <li>parser: Use an operator precedence table</li>
      <li>parser: use shared scratch buffer to avoid allocating and freeing many small lists (#8910).</li>
      <li>Update the official spec to match the self-hosted parser.</li>
      <li>tokenizer: fix crash on multiline string with only 1 backslash (#8904).</li>
      <li>Variable shadowing detection (#6969).</li>
      <li>link: properly implement passthrough mode for LLD child proccess.</li>
      <li>Detect redundant C/C++ source files, preventing a deadlock in the caching system (#7308).</li>
      <li>Print package path on --pkg-begin failure.</li>
      <li>Better error message for root zig source file not found (#6777, #6893).</li>
      <li>Always link -lpthread when using system libc. Required when cross-compiling glibc targets.</li>
      <li>Allow building musl/glibc in thumb mode.</li>
      <li>Fix libc components' linking order.</li>
    </ul>
    {#header_open|CPU Feature Detection#}
    TODO
    stage2: Add framework for host CPU detection on Linux

    Add a generic framework to parse /proc/cpuinfo and implement the model
    detection for 64bit SPARC targets as proof of concept.

    stage2: Add CPU feature detection for macos

    This is mostly meant to detect the current and future AArch64 core types
    as the x86 part is already taken care of with OS-independent machinery.


    stage2: Drop LLVM's host CPU detection method as fallback

    The CPU detection code is nearly at feature parity, we do support
    detecting the native CPU on Sparc systems and macos, our ARM/AArch64
    model list is quite comprehensive and so is our PPC one.

    The only missing pieces are:
    - ARM32 detection on Darwin hosts (I don't think anybody is planning on
      running the compiler on a old-ass iPhone)
    - s390x detection on Linux hosts, this can be easily added at a later
      stage.


    stage1: Implement CPU host detection for PowerPC targets

    Untested but should work well on both 32 and 64 bit systems.

    stage2: Implement CPU host detection for ARM/AArch64 targets

    LemonBoy

    TODO mention CPU features tool improvement
    {#header_close#}

    {#header_open|Command-Line Interface#}
    TODO

    fix issue #6798: zig init-lib doesn't accept -h flag

Contributors: Guoxin Yin


    {#header_close#}

    {#header_open|Reworked Memory Layout#}
    TODO
tokenizer memory layout
ast memory layout
zir memory layout
  - thanks to the contributors who helped out
    {#header_close#}

    {#header_open|Whole-File AST Lowering#}
    TODO

commit b750e074c621b8679e14e53f9ecd2faa4432eff9
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Sat May 22 17:20:30 2021 -0700

    stage2: rework astgen command into `zig ast-check`
    
    This addresses the use case of quickly reporting AstGen compile errors
    for a file, for use with an IDE for example.
    
     * Rename from `zig asgen` to `zig ast-check`
     * It is now a command always available; not only in debug builds.
     * Give it usage text and proper CLI parsing.
     * Support reading from stdin when no positional arg is provided.
     * `-t` flag makes it print textual ZIR. Without this flag, it only
       provides compile errors.
     * Support `--color` parameter to override the tty detection
    
    closes #8871

 src/main.zig | 158 +++++++++++++++++++++++++++++++++++++++++++----------------
 1 file changed, 117 insertions(+), 41 deletions(-)

    {#header_close#}

    {#header_open|Static PIE#}
    <p>Mainly thanks to LemonBoy, Zig now supports
    <strong>Position Independent Executables</strong>, even
    when compiling statically. Here is an example:</p>
    <pre>$ zig build-exe hello.zig 
$ file hello
hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped
$ zig build-exe hello.zig -fPIE
$ file hello
hello: ELF 64-bit LSB <strong>pie</strong> executable, x86-64, version 1 (SYSV), dynamically linked, with debug_info, not stripped</pre>
    <p>
    The main use case for PIE is
    <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">Address Space Layout Randomization</a>.
    This is a security measure aimed at making exploits more difficult by introducing
    non-determinism into pointer addresses at runtime. Its effectiveness is debatable,
    however, it also has a surprisingly useful property.
    </p>
    <p>
    It is one piece of the puzzle in a
    <a href="https://www.youtube.com/watch?v=pq1XqP4-qOo">truly portable Linux binary that can run on any distribution, including loading graphics drivers</a>.
    A static PIE is capable of executing both statically linked, and then
    re-executing itself dynamically linked once the statically linked code has surveyed
    the system to find the dynamic linker. This is a niche idea, but may
    be worth pursuing for the use case of distributing portable game binaries
    and other GUI applications.
    </p>
    <p>Tracking issues: #3960, #4503</p>
    {#header_close#}

    {#header_open|Reuse Runtime Libraries in More Cases#}
    <p>
    Previously Zig would need to recompile runtime libraries if you changed the
    values of --strip or -O. Now, unless the <code>debug_compiler_runtime_libs</code>
    flag is set (which is currently not exposed to the CLI), Zig will always
    choose ReleaseFast or ReleaseSmall for compiler runtime libraries.
    </p>
    <p>
    When the main application chooses ReleaseFast or ReleaseSmall, that
    value is propagated to compiler runtime libraries. Otherwise a decision
    is made based on the target, which is currently ReleaseSmall for
    freestanding WebAssembly and ReleaseFast for everything else.
    </p>
    <p>
    Ultimately the purpose of this change is to have Debug and ReleaseSafe
    builds of applications still get optimized builds of, e.g. libcxx and
    libunwind, as well as to spend less time unnecessarily rebuilding compiler
    runtime libraries.
    </p>
    {#header_close#}


    {#header_open|x86-64 Backend#}
    TODO
    {#header_close#}

    {#header_open|AArch64 Backend#}
<p>The experimental self-hosted AArch64 (a.k.a. ARM64) backend is new in this version.
Currently, the self-hosted compiler is able to generate binaries for Linux (ELF) and macOS
(Mach-O, thanks to Jakub Konka). Currently, only a very small subset of the Zig language
is supported.</p>
    {#header_close#}

    {#header_open|ARM Backend#}
    <p>
Bitwise operations on and multiplication of 32-bit integers were introduced. Furthermore, conditional branching (including while- and for-loops) is now possible. Additionally, the register allocation mechanism was overhauled, allowing for correct code generation in situations where registers are spilled.
    </p>
    {#header_close#}

    {#header_open|LLVM Backend#}
    TODO
    {#header_close#}

    {#header_open|WebAssembly Backend#}
    <p>A lot of progress has been made with regards to the WebAssembly backend, both
    architecturally and in terms of feature completeness.</p>

    <p>During the self-hosted compiler meeting of
    <a href="https://github.com/ziglang/zig/wiki/Self-Hosted-Compiler-Meetings#2020-12-10">2020-12-10</a>
    we discussed on how to move forward with the architecture of the backends.
    A proof of concept was done in <a href="https://github.com/ziglang/zig/pull/7321">#7321</a>
    to merge it with the other backends. However, it was found to be counter intuitive and
    ultimately decided upon to keep the wasm backend seperately.
    </p>
    <p>
    Apart from this design decision, progress was made to bring up the wasm backend closer towards feature completeness:
    </p>
    <ul>
        <li>Implement storing and loading of locals (<a href="https://github.com/ziglang/zig/pull/7726">#7726</a>)</li>
        <li>Refactoring the wasm backend to streamline its implementation with the other backends. (<a href="https://github.com/ziglang/zig/pull/7797">#7797</a>)</li>
        <li>Support for control flow such as while loops and if statements. (<a href="https://github.com/ziglang/zig/pull/7895">#7895</a>)</li>
        <li>Importing and calling of extern functions. Allowing to call host functions from within Zig. (<a href="https://github.com/ziglang/zig/pull/7960">#7960</a>)</li>
        <li>Unary operator '!' support. (<a href="https://github.com/ziglang/zig/pull/8339">#8339</a>)</li>
        <li>Opcode builder and multiple binary operands implemented. (<a href="https://github.com/ziglang/zig/pull/8416">#8416</a>)</li>
        <li>"Hello world" support (arrays and pointer to arrays). (<a href="https://github.com/ziglang/zig/pull/8439">#8439</a>)</li>
        <li>Enums (<a href="https://github.com/ziglang/zig/pull/8789">#8789</a>)</li>
        <li>Initial implementation of structs and switches. (<a href="https://github.com/ziglang/zig/pull/8847">#8847</a>)</li>
        <li>Support for error sets and error unions. (<a href="https://github.com/ziglang/zig/pull/8923">#8923</a>)</li>
    </ul>
    <p>Contributors: Gracefuu, Isaac Freund, Luuk de Gram</p>

    {#header_close#}

    {#header_open|RISC-V 64 Backend#}
    TODO
    {#header_close#}

    {#header_open|C Backend#}
    TODO
    {#header_close#}

    {#header_open|SPIR-V Backend#}
    TODO
    {#header_close#}

    {#header_open|SPU Mark II Backend#}
    <p>This backend, related to the <a href="https://ashet.computer/">Ashet Home Computer</a>
    project, was incomplete, and the maintainer stopped working on it. Since it never made it
    to a usable state, this backend is removed in 0.8.0.</p>
    <p>
    The code is still safely stored in the Git history, and anyone is welcome to revive it!
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|Self-Hosted Linker#}
    <p>As you may know from our previous releases, we had immense problems with
    <code>ld64.lld</code> linker on macOS - it is subpar in functionality to other target
    formats (Elf, Coff, etc.) and it does not support the latest arm64-based Macs
    (see #7527 or #3295 for some of the issues we encountered). While there has been
    progress on the new lld's MachO backend dubbed <code>ld64.lld.darwinnew</code>,
    it is still not the default backend as of {#link|LLVM 12#}. Additionally, it is
    doubtful that the new backend will allow for seamless cross-compilation to macOS
    since every macOS binary is required to be a PIE and link dynamically against
    <code>libSystem</code> dylib, which will require the lib's presence on the host
    for the lld to reference and link against.</p>

    <p>These were enough to make
    <a href="https://github.com/ziglang/zig/issues/1535">a case for building our own linker, written entirely in Zig</a>,
    which would initially focus on MachO linking. Since our core team member,
    Jakub, has already been working on the stage2 MachO backend before,
    he decided to try his luck at writing a traditional MachO linker in Zig from scratch
    which he started towards the end of January 2021. Fast forward a couple of months,
    and since May 2021, we are incredibly happy to report it is used as our primary
    linker when targeting macOS and is successfully able to link the stage1 Zig compiler
    as part of the <a href="https://github.com/ziglang/zig-bootstrap">zig-bootstrap</a>
    effort (see
    <a href="https://github.com/ziglang/zig-bootstrap/issues/38">ziglang/zig-bootstrap#38</a> and
    <a href="https://github.com/ziglang/zig-bootstrap/issues/44">ziglang/zig-bootstrap#44</a>).
    </p>

    <p>This means Zig can be used to successfully cross-compile C/C++ (clang) and Zig
    to macOS from anywhere!</p>

    <p>In summary, cross-compiling C/C++ and Zig to macOS is now as trivial as adding
    <code>-target aarch64-macos</code> or <code>-target x86_64-macos</code> to the invocation
    of your chosen Zig tool ({#link|zig cc#}, {#link|zig c++#}, or <code>zig build-exe</code>).
    There are still bits of functionality that are missing such as the ability to create a
    dynamic library or
    <a href="https://github.com/ziglang/zig/issues/8935">linking against text-based definitions (<code>.tbd</code>s)</a>
    but Jakub plans to address these next.</p>

    <p>In celebration of Jakub's recent accomplishments of improving the self-hosted linker
    on Mach-O enough to be able to link LLVM, Clang, LLD, and Zig, we now have the tracking issue
    <a href="https://github.com/ziglang/zig/issues/8726">Completely Eliminate Dependency on LLD</a>
    with the goal of eventually completely relying on our own linker implementation for all
    targets, and entirely stop linking against LLD.
    </p>
    <p>This issue does not block the release of Zig 1.0, however it is a stretch goal, and a
    fun indicator of progress to keep track of along the way.</p>
    <p>Here are all the places we depend on LLD, along with an indicator of how much our
    own linker code can do:</p>
    <ul>
      <li>üü° ELF:<ul>
          <li>üü° x86, x86_64</li>
          <li>üü° arm, aarch64</li>
          <li>üü° riscv</li>
          <li>üî¥ hexagon</li>
          <li>üî¥ mips</li>
          <li>üî¥ ppc, ppc32</li>
          <li>üî¥ sparc</li>
          <li>üî¥ amdgpu</li>
          <li>üî¥ avr</li>
          <li>üî¥ msp430</li>
        </ul></li>
      <li>üü¢ Mach-O<ul>
          <li>üü¢ x86_64</li>
          <li>üü¢ aarch64</li>
        </ul></li>
      <li>üü° COFF/PE<ul>
          <li>üü° x86, x86_64</li>
          <li>üî¥ arm, aarch64</li>
        </ul></li>
      <li>üü° WASM</li>
    </ul>
    <p>Key:</p>
    <ul>
      <li>üü¢ major progress</li>
      <li>üü° some progress</li>
      <li>üî¥ no progress</li>
    </ul>
    <p>
    Another issue to note here is that this release does <em>not</em> include a drop-in
    linker sub-command, e.g. <code>zig ld</code>. At this time Zig is lacking the glue
    code to hook up the Command-Line Interface to the linker implementation.
    If you are interested in this use case, the tracking issue is
    <a href="https://github.com/ziglang/zig/issues/8755">zig ld: a drop-in linker replacement</a>.
    </p>
    {#header_close#}

    {#header_open|C Translation#}
    <p>This is the feature that powers both <code>zig translate-c</code> as well as
    {#syntax#}@cImport{#endsyntax#} syntax. It is implemented in the {#link|Self-Hosted Compiler#},
    using the libclang C++ API.</p>
    <p>
    This release cycle saw a prolific new contributor to this area of the code - Evan Haas.
    Not only did he contribute many improvements to C translation this cycle, but his company,
    <a href="https://www.lagerdata.com/">Lager Data</a>, sponsors Zig. What a guy!
    </p>
    <p>
    Vexu implemented a major simplification of the implementation of translate-c by
    <a href="https://github.com/ziglang/zig/issues/6710">introducing a new pseudo-ast data structure</a>.
    Instead of the code having to manage both AST nodes and tokens at once, in order to render
    the output Zig code, now the C translation code only must create pesudo-AST nodes, which are
    then lowered to tokens at the end. This made the code easier to maintain and contribute to,
    and greatly simplified the {#link|Reworked Memory Layout#} efforts that happened simultaneously
    in the {#link|Self-Hosted-Compiler#}.
    </p>
    <p>Miscellaneous improvements:</p>
    <ul>
      <li>Added support for translating FnDecl's that appear within functions.</li>
      <li>Added support for __cleanup__ attribute, using a {#syntax#}defer{#endsyntax#} statement to implement the C __cleanup__ attribute.</li>
      <li>Demote initialization of opaque types. Fixes a segfault in translate-c that would previously occur when initializing structs with unnamed bitfields.</li>
      <li>Added support for translating global (file scope) assembly.</li>
      <li>Fixed typedefs with multiple names.</li>
      <li>Fixed casting of function pointers.</li>
      <li>Group field access LHS if necessary and LHS of array access if necessary.</li>
      <li>Better handling of int to enum casts (#6011).</li>
      <li>Wrap switch statements in a {#syntax#}while (true){#endsyntax#} loop. This allows {#syntax#}break{#endsyntax#} statements to be directly translated from the original C (#8387).</li>
      <li>Added support for vector expressions, including vector types, __builtin_shufflevector, and __builtin_convertvector.</li>
      <li>Fix calls with no args in macros.</li>
      <li>intcast compound assignment operand if different-sized integer.</li>
      <li>Stop creating unnamed decls for typedefs child types.</li>
      <li>Ensure assignments are within a block when necessary (#8159).</li>
      <li>Preserve zero fractional part in float literals.</li>
      <li>Use {#syntax#}[N:0]{#endsyntax#} arrays when initializer is a string literal (#8264, #8215).</li>
      <li>Demoted usage of un-implemented builtins.</li>
      <li>Implemented generic selection expressions. Enables translation of C code that uses the <code>_Generic</code> keyword.</li>
      <li>Added compound literal support.</li>
      <li>Explicitly cast decayed array to pointer with {#syntax#}@ptrCast{#endsyntax#}. This enables translation of code that uses pointer arithmetic with arrays.</li>
      <li>Support compound assignment of pointer and signed int.</li>
      <li>Translate align attribute for block scoped variables.</li>
      <li>Strip the leading zero from octal literals.</li>
      <li>Enable pointer arithmetic with signed integer operand.</li>
      <li>Added &lt;assert.h&gt; support.</li>
      <li>Added limited OffsetOfExpr support.</li>
      <li>Added typeof support.</li>
      <li>Added support for pointer subtraction (#7216).</li>
      <li>Check for noreturn in switch in more cases.</li>
      <li>Made switch default have an empty block not break.</li>
      <li>Use global scope for typedef/record/enum type translation if needed.</li>
      <li>Correctly add semicolon to if statements.</li>
      <li>Ensure failed macros don't get defined multiple times.</li>
      <li>Improved switch translation.</li>
      <li>Support scoped typedef, enum and record decls (#5256).</li>
      <li>Demote untranslatable declarations to externs.</li>
      <li>Elide some unecessary casts of literals.</li>
      <li>Made comma operator introduce a new scope, preventing inadvertent side-effects when an expression is not evaluated due to boolean short-circuiting (#7989).</li>
      <li>Call {#syntax#}@boolToInt{#endsyntax#} on return value when necessary (#6215).</li>
      <li>Improve function pointer handling (#4124).</li>
      <li>Added wide string literal support.</li>
      <li>Fixed bug when rendering struct initializer with length 1.</li>
      <li>Improved array support (#4831, #7832, #7842).</li>
      <li>Added Wide, UTF-16, and UTF-32 character literals.</li>
      <li>Ensure bools are cast to int when necessary.</li>
      <li>Allow dollar sign $ in identifiers (#7585).</li>
      <li>Static function declarations with no prototype should not be variadic (#7594).</li>
      <li>Demote variadic functions to declarations.</li>
      <li>Correctly cast bool to signed int.</li>
      <li>Improve handling of C compiler intrinsics (#6707).</li>
      <li>Detect parenthesized string literals.</li>
      <li>Support casting enums to all int types.</li>
    </ul>
    <p>
    Here's a fun example, translating one of the many files of DOOM to Zig, and then compiling
    the resulting Zig code into an object:
    </p>
    <pre>andy@ark ~/D/D/linuxdoom-1.10 (master)&gt; zig translate-c -lc m_cheat.c &gt;m_cheat.zig
andy@ark ~/D/D/linuxdoom-1.10 (master)&gt; zig build-obj m_cheat.zig
andy@ark ~/D/D/linuxdoom-1.10 (master)&gt; file m_cheat.o
m_cheat.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), with debug_info, not stripped</pre>
    <p>
    This is one of the smaller C files; I ran into quite a few opportunities
    for more C translation improvements when looking for this example!
    </p>
    <p>Contributors: Evan Haas, Veikka Tuominen (Vexu), xackus, Andrew Kelley, LemonBoy, Isaac Freund, Michael Dusan, Tadeo Kondrak, Timon Kruiper</p>
    {#header_close#}

    {#header_open|Standard Library#}
    <p>The Zig standard library is still unstable and mainly serves as a
    testbed for the language. After the {#link|Self-Hosted Compiler#} is completed,
    the {#link|language|Language Changes#} stabilized, and
    {#link|Package Manager|Package Manager Status#} completed, then it will be time
    to start working on stabilizing the standard library.
    Until then, experimentation and breakage without warning is allowed.</p>
    <p>Miscellaneous Improvements:</p>
    <ul>
    <li>json: option to ignore unknown fields (#7906)</li>
    <li>make writeIntSlice functions work for signed integers</li>
    <li>os: munmap takes a const pointer</li>
    <li>fix Boyer-Moore-Horspool algorithm in indexOfPos and lastIndexOf when element type is larger than a byte</li>
    <li>fix accidental quadratic dependence on haystack length in replace and replacementSize (#8859)</li>
    <li>Const correct GUID parameter of getInfo and setInfo</li>
    <li>implement nt path conversion for windows</li>
    <li>os: WSAStartup is now called upon socket creation when needed</li>
    <li>Make atfork handler more robust (#8841).</li>
    <li>Call pthread_atfork only once</li>
    <li>add android __SIZEOF_PTHREAD_MUTEX_T (#8384)</li>
    <li>math.Complex: Change new() to init()</li>
    <li>add missing EBADF error code for openat</li>
    <li>Avoid using white color when printing stacktraces. Use .bold instead of .white, the effect is the same for light-on-dark terminals but greatly improves the readability for dark-on-light ones (#8761).</li>
    <li>dragonfly: fix duplicate definition of sockaddr_storage</li>
    <li>fix & add os.windows.user32 WM constants</li>
    <li>rework math.scalbn (#8733)</li>
    <li>hash_map: use 7 bits of metadata instead of 6</li>
    <li>compiler-rt: Fix signedness mismatch in f128 mul impl</li>
    <li>dragonfly: fix duplicate definition of sockaddr_storage</li>
    <li>fix logic for duplicate comptime fields and avoid freeing comptime fields in parseFree and parseInternal</li>
    <li>fix duplicate_field_behavior UseFirst in json.zig</li>
    <li>json: Fix premature closing brace being considered valid JSON</li>
    <li>fix shrinkAndFree and remove shrinkRetainingCapacity in PriorityQueue and PriorityDequeue</li>
    <li>mem: add sliceTo(), deprecate spanZ(), lenZ()</li>
    <li>bsd: detect os version</li>
    <li>meta.Elem: support all optional types</li>
    <li>Fix offset param splitting for preadv/pwritev</li>
    <li>fix AutoArrayHashMap's store_hash logic</li>
    <li>Harmonize use of off_t between libc and Zig impls</li>
    <li>c: Fix prototypes for bcmp and memcmp</li>
    <li>Prefer 64bit libc functions where possible</li>
    <li>os: add missing sockaddr_storage defs</li>
    <li>os: fix sockaddr_storage padding size</li>
    <li>os/windows/ws2_32: add missing FIONBIO constant</li>
    <li>ArrayHashMap: ensureUnusedCapacity and ensureTotalCapacity</li>
    <li>ArrayList: add clearRetainingCapacity and clearAndFree</li>
    <li>Implement hex float printing</li>
    <li>compiler-rt: Better selection of __clzsi implementation</li>
    <li>Accept unaligned slice in several ArrayListAligned ops. Do not impose the internal alignment requirements to the user-supplied parameters (#8647).</li>
    <li>os/bits/windows: add `timeval` extern struct</li>
    <li>GeneralPurposeAllocator: print leaked memory addresses. This helps when using it with other tools, such as memory watchpoints.</li>
    <li>handle -frandom-seed in NIX_CFLAGS_COMPILE</li>
    <li>Implement copysign, signbit, isFinite for f128</li>
    <li>rename doc refs to deprecated functions like openC (#8467)</li>
    <li>Improve spinloop hint</li>
    <li>Handle EPERM and ELOOP in os.fstatat()</li>
    <li>remove redundant `comptime const`</li>
    <li>Add a parser for hexadecimal floating point numbers</li>
    <li>Target: bump freebsd known maximum version</li>
    <li>thread: simplify and remove useless return in spawn (#8621)</li>
    <li>Fix for mem.replacementSize adjacent matches bug. (#8454, #8455)</li>
    <li>Fix thread creation with field-less context type (#8524).</li>
    <li>Make meta.alignment work on more types</li>
    <li>compiler-rt: Export __extendhftf2 and __trunctfhf2</li>
    <li>compiler-rt: Don't re-define PPC builtins in test mode</li>
    <li>Use stat definition with 32bit *time fields. We're not ready for Y38K yet.</li>
    <li>Split syscall parameters for PowerPC targets</li>
    <li>macho: fix typos in consts defs</li>
    <li>c: Implement fmax and fmaxf</li>
    <li>c: Implement fmin and fminf</li>
    <li>Add process_vm_readv/writev wrappers</li>
    <li>deprecate ensureCapacity, add two other capacity functions</li>
    <li>Add pidfd wrappers</li>
    <li>os.windows.user32.messageBoxW</li>
    <li>linux: fix number of arguments for tgkill syscall</li>
    <li>change `@import("builtin")` to `std.builtin`</li>
    <li>compiler-rt: Don't pass f16 around as arguments</li>
    <li>compiler-rt: Implement __trunctfhf2</li>
    <li>compiler-rt: Implement __extendhftf2</li>
    <li>compiler-rt: Fix typo in implementation of fp truncation ops</li>
    <li>os/posix: handle ECONNRESET for write/writev</li>
    <li>Fix sqrt for u0/u1 input types</li>
    <li>dwarf: fix LineNumberProgram check (#8421).</li>
    <li>compiler-rt: Introduce PowerPC-specific f128 helpers</li>
    <li>Fix TLS definitions for 32bit PowerPC targets</li>
    <li>Improve powerpc support.</li>
    <li>Removed empty init from HashMapUnmanaged</li>
    <li>netbsd: minor fixes to allow stage1 to build</li>
    <li>os/linux: return error on EALREADY for connect() and getsockoptError()</li>
    <li>os/bits/linux: add IPv6 socket options</li>
    <li>Switch json to use an ordered hashmap</li>
    <li>Add compile error for signed integer math. Output compile errors when signed integer types are used on functions where the answer might've been a complex number but that functionality hasn't been implemented. This applies to sqrt, log, log2, log10 and ln.</li>
    <li>os: handle ECONNRESET for connect() syscall</li>
    <li>base64: cleanups and support url-safe and other non-padded variants</li>
    <li>ArrayHashMap: decrement entries slice len after popping from entries in pop() to prevent oob</li>
    <li>os.linux: handle ECONNRESET for recv</li>
    <li>UEFI: boot_services: implement locateDevicePath</li>
    <li>Specify type in autoHash error message (#7970).</li>
    <li>Add reset to TokenIterator</li>
    <li>Add syscall7 stub for Linux/MIPS</li>
    <li>Add some enum utilities</li>
    <li>support optional getaddrinfo arguments</li>
    <li>linux: sync io_uring library with liburing</li>
    <li>make c.getErrno() return same type as _errno() aka c_int</li>
    <li>elf: make EM non-exhaustive</li>
    <li>expose machine field in ELF header</li>
    <li>Implement fmtDuration using Formatter (#8137)</li>
    <li>Prevent null pointer deref in mem.len{,Z} (#8140).</li>
    <li>Reject bare +/- input when parsing floats</li>
    <li>add io.Writer.writeStruct</li>
    <li>linux: fix IO_Uring.timeout</li>
    <li>Replace lastIndexOf with lastIndexOfScalar</li>
    <li>Add fs.path.joinZ (#7974)</li>
    <li>add sendmsg</li>
    <li>Swap arguments in Thread.spawn (#8082).</li>
    <li>Target.Abi: add gnuilp32</li>
    <li>ascii: add lessThanIgnoreCase and orderIgnoreCase</li>
    <li>Thread.Semaphore: Fix wrong variable name (#8052).</li>
    <li>fifo.LinearFifo - Expose reader and writer type.</li>
    <li>os.uefi.Guid fixes (#8032)</li>
    <li>fix race condition in linuxWaitFd</li>
    <li>Progress: improve support for "dumb" terminals</li>
    <li>replace ArrayList.shrinkAndFree by ArrayList.shrinkRetainingCapacity</li>
    <li>Add epoll_pwait2 Linux syscall</li>
    <li>remove io.AutoIndentingStream</li>
    <li>fs.net.Stream: add writev and writevAll</li>
    <li>target: map zig ppc32 ‚Üí llvm ppc (#7947).</li>
    <li>json: large number support</li>
    <li>Don't read more bytes than exist in MsfStream (#7839)</li>
    <li>Fixes for Thread.Condition (#7883)</li>
    <li>math.big.int: normalize after a right shift</li>
    <li>json: support for comptime fields (#6231).</li>
    <li>Remove {#syntax#}@TagType{#endsyntax#}; {#syntax#}meta.TagType{#endsyntax#} to {#syntax#}meta.Tag{#endsyntax#} (#7750).</li>
    <li>GeneralPurposeAllocator: logging improvements</li>
    <li>meta: rename TagPayloadType to TagPayload</li>
    <li>meta: rename TagType to Tag</li>
    <li>Fill out more cases for meta.sizeof</li>
    <li>Fix interger overflow when calling joinZ with empty slices</li>
    <li>macho: add arm64 relocation type enum</li>
    <li>Add MAX_RW_COUNT limit to os.pread() (#7805).</li>
    <li>linux: add fallocate() to io_uring</li>
    <li>windows: make sure to handle PATH_NOT_FOUND when deleting files (#7879).</li>
    <li>Change <code>compareFn</code> to <code>fn (a: T, b: T) math.Order</code></li>
    <li>Add missing cast when calling fcntl w/ constant args</li>
    <li>Fixed pipe2 fallback (#7760)</li>
    <li>Replace <code>shrink</code> with <code>shrinkAndFree</code> and <code>shrinkRetainingCapacity</code></li>
    <li>ArrayHashMap: add "AssertDiscard" function variants.</li>
    <li>Add Priority Dequeue</li>
    <li>Organize std lib concurrency primitives and add RwLock</li>
    <li>elf: expose parsing decoupled from fs.File</li>
    <li>os.uefi.protocols.FileProtocol: fix and expose get_position, set_position (#7762)</li>
    <li>Add missing ECONNRESET from getsockoptError</li>
    <li>define nfds_t for windows</li>
    <li>implement emutls in compiler_rt</li>
    <li>event.Loop: fix race condition when starting the time wheel (#7572).</li>
    <li>macos: reimplement OS version detection</li>
    <li>introduce os.windows.QueryObjectName</li>
    <li>os.windows.GetFinalPathNameByHandle: add test</li>
    <li>Add fmt.formatDuration and fmt.duration (#7297)</li>
    <li>Made reader.skipBytes's num_bytes a u64</li>
    <li>os/bits/linux: add the termios cc bits</li>
    <li>Modify cityhash to work at comptime</li>
    <li>Decouple network streams from fs.File</li>
    <li>Update path.join to recognize any separators that isSep does</li>
    <li>debug: don't fail printLineInfo if the source file is not readable</li>
    <li>builtin: Add zig_version (#6466)</li>
    <li>Fix system library path detection on Linux.</li>
    <li>Add mem.containsAtLeast</li>
    <li>io: <code>FindByteOutStream</code> to <code>FindByteWriter</code> (#4917).</li>
    <li>Add EPERM to os.setsockopt</li>
    <li>Add IP_ constants</li>
    <li>fix LRESULT and LPARAM typedefs</li>
    <li>spinlock: Default SpinLock.state to .Unlocked to allow default struct initialization</li>
    <li>c: add syslog</li>
    <li>freebsd, netbsd, dragonfly: add struct timeval</li>
    <li>Support equivalent ArrayList operations in ArrayHashMap</li>
    <li>Rename ArrayList shrink => shrinkAndFree</li>
    <li>c: add some noalias</li>
    <li>meta.fieldInfo takes an enum rather than a string</li>
    <li>Add meta.FieldEnum</li>
    <li>Show the panicking thread ID</li>
    <li>Add more standard type definitions for FreeBSD (#7550).</li>
    <li>Fix Reader.readUntilDelimiterOrEofAlloc() API</li>
    <li>Uniform polling logic for Windows and Unix.</li>
    <li>Fix poll definitions for FreeBSD/Darwin</li>
    <li>Avoid deadlocking in ChildProcess.exec.</li>
    <li>zig test: testing.zig_exe_path is now available. It will be set to the path of the zig executable which is running `zig test`.</li>
    <li>Add c._exit() and use in ChildProcess</li>
    <li>Made hasUniqueRepresentation false for slices; handle unions in autoHash</li>
    <li>Rework ResetEvent, improve std lib Darwin integration</li>
    <li>ResetEvent: use sem_t when linking against pthreads</li>
    <li>Mutex: integrate with pthreads</li>
    <li>Add termios bits for darwin</li>
    <li>c: add fmemopen</li>
    <li>Add sincosf function (#7267)</li>
    <li>Truncate user and group ids for 64 bit Linux systems (#7466)</li>
    <li>Enable segfault handling on FreeBSD.</li>
    <li>Fix Gimli hash on 16n byte inputs</li>
    <li>Add io.counting_reader</li>
    <li>Cast sendto to SendError inside send (#7481)</li>
    <li>Progress: make the API thread-safe</li>
    <li>Add EV_ERROR to FreeBSD bits</li>
    <li>Add Linux baudrate constants</li>
    <li>Add process_madvise to Linux syscalls (#7450)</li>
    <li>Prevent hashing undefined bits for integers of non power of 2 size.</li>
    <li>Only check for evented mode in windows.OpenFile when in async mode</li>
    <li>Create SendToError (#7417)</li>
    <li>non-byte-multiple sized integers and bool have no definite representation (#7445).</li>
    <li>Fixed fs.Watch implementation on Linux and Windows</li>
    <li>Add missing Linux syscalls.</li>
    <li>Fix formatting of type values (#7429).</li>
    <li>Improve sigaction interface (#7411)</li>
    <li>CrossTarget: add isNativeAbi()</li>
    <li>Make json.unescapeString pub.</li>
    <li>Validate the atomic ordering parameter in atomic.Int</li>
    <li>Prevent instantiation of atomic.Int with non-integral types</li>
    <li>Introduce meta.traits.is{Integral,Float}</li>
    <li>MoveFileEx can return ACCESS_DENIED.</li>
    <li>Add io_uring TIMEOUT and TIMEOUT_REMOVE operations.</li>
    <li>explicitly cast indices to usize. This is needed for platforms where usize=u16, eg. MSP430.</li>
    <li>compiler-rt: Fix compilation of clzsi for armv6 targets</li>
    <li>compiler-rt: Avoid exposing atomic builtins when not supported</li>
    <li>Add testing.expectStringEndsWith</li>
    <li>Fix general purpose allocator incorrectly modifying total_requested_bytes in some cases</li>
    <li>Add AddressFamilyNotSupported to SendError</li>
    <li>c: freeing null is a no-op</li>
    <li>Add a few helpers for matching ascii strings (#7300)</li>
    <li>Make the mutex for GeneralPurposeAllocator configurable (#7234).</li>
    <li>Add readUntilDelimiterOrEofArrayList and readUntilDelimiterOrEofAlloc.</li>
    <li>Make the use of pthread_join POSIX-compliant (#7275)</li>
    <li>Always return loopback address when looking up localhost.</li>
    <li>os: remove unneeded error from accept errorset.</li>
    <li>add os.shutdown function for sockets</li>
    <li>Fix WindowsDynLib.openW trying to strip the \??\ prefix when it does not exist</li>
    <li>Switch to using unicode when parsing the command line on windows (#7241)</li>
    <li>Fix memory leak in BufMap.</li>
    <li>meta: add assumeSentinel</li>
    <li>Avoid deadlock in the signal handler (#7247).</li>
    <li>Add readAllArrayListAligned to Reader which can accept an arbitrary alignment</li>
    <li>Fix file locking logic for BSD targets</li>
    <li>os: fix prctl constants</li>
    <li>use mem.asBytes in Ip4Address.parse so it works at comptime.</li>
    <li>Close dangling fd on error.</li>
    <li>Remove O_NONBLOCK flag after locking. We only need O_NONBLOCK when O_SHLOCK/O_EXLOCK are used and we don't want open() to block, don't let this bit leak to the user fd.</li>
    <li>Fix file locking logic for BSD targets.</li>
    <li>Fix the ELF base calculation.</li>
    <li>Fix logic for detecting _DYNAMIC symbol.</li>
    <li>user32 cleanup, added wrappers and additional functions.</li>
    <li>Add support for ppoll</li>
    <li>os: add time_t and dev_t definitions for x86_64 linux.</li>
    <li>PPC: Correct the generic feature set</li>
    <li>PPC64: Use newfstatat on PPC64.</li>
    <li>PPC64: Use correct clone() stub.</li>
    <li>meta.declarations: support {#syntax#}opaque {}{#endsyntax#}</li>
    <li>Add builtin.Signedness, use it instead of is_signed</li>
    <li>getdents: entries with d_ino==0 are now properly skipped</li>
    <li>Change seed for Murmur2_64 from u32 to u64.</li>
    <li>Implement chdir and chdirZ for Windows.</li>
    <li>Add atomic.Bool and expose all atomic operations from atomic.Int (#7154).</li>
    <li>Add meta.fieldNames.</li>
    <li>Add fs.openDirAbsolute and fs.accessAbsolute (#7082)</li>
    <li>Move leb128 out of debug and remove trivial *mem functions as discussed in #5588 (#6876)</li>
    <li>linuxWaitFd: make NetworkSubsystemFailed error unreachable. This error from os.poll is Windows-specific, so unreachable on Linux.</li>
    <li>Add more MachO consts and structs.</li>
    <li>Made windows.ReadFile allow short reads (#7121).</li>
    <li>mem: make sliceAsBytes, etc. respect volatile</li>
    <li>Add fs.path.extension.</li>
    <li>Fix HashMap.putAssumeCapacity and HashMap.clearRetainingCapacity (#7061).</li>
    <li>Improved support for OpenBSD.</li>
    <li>Fix json parser close tracking (#6865).</li>
    <li>Don't prevent compilation on platforms where debug info is unsupported</li>
    <li>Add {#syntax#}mem.timingSafeEql(){#endsyntax#} for constant-time array comparison.</li>
    <li>ArrayList.span is now a compile error. Instead, use the <code>items</code> field directly.</li>
    <li>Add unicode.utf8CountCodepoints and unicode.utf8ValidCodepoint</li>
    <li>start code:: export main with strong linkage. Unmarks `_main` as weak symbol making it global (the entire linked program) in scope.</li>
    <li>start code: increases stack size as appropriate on linux (#8708).</li>
    <li>start code: unconditionally import the root source file</li>
    <li>start code: call wWinMain with root's type.</li>
    <li>start code: make more versatile by always aligning the entry point.</li>
    <li>start code: properly align thread local variables. They were landmines if LLVM decided to optimize any writes to them using vector instructions.</li>
    <li>Make C allocator respect the required alignment. Uses posix_memalign where
    available and the _aligned_{malloc,free} API on Windows (#3783). The new
    heap.raw_c_allocator is available to do what {#syntax#}heap.c_allocator{#endsyntax#}
    previously did. See the new doc comments for more details.</li>
    <li>Made {#syntax#}Version.parse{#endsyntax#} less strict.</li>
    <li>Added {#syntax#}LinearFifo(...).pump(src_reader, dest_writer){#endsyntax#}</li>
    <li>Support for static PIE executables.</li>
    </ul>

<p>Contributors: Adam Goertz, Aiz672, Al Hoang, Alex Cameron, Alexandros Naskos, Anders Conbere, Andreas Karlsson, Andreas Linz, Andrew Kelley, Aransentin, Asherah Connor, Benjamin Feng, Benjamin Graf, Bill Nagel, BinaryWarlock, Bxil, Cameron Conn, Carlos Z√∫√±iga, Daniele Cocca, Devin Bayer, Dmitry Atamanov, Edward Dean, Ethan Gruffudd, Evan Haas, Felix (xq) Quei√üner, Frank Denis, Guillaume Ballet, Hadron67, Hannu Hartikainen, Hubert Jasudowicz, Isaac Freund, Isaac Yonemoto, J.C. Moyer, Jakub Konka, Jay Petacat, Jens Goldberg, Jonathan Knezek, Jonathan Marler, Joran Dirk Greef, Joris Hartog, Josh Holland, Josh Wolfe, Julian Maingot, Julius Putra Tanu Setiaji, Kenta Iwasaki, Koakuma, Lee Cannon, LemonBoy, Lewis Gaul, Loris Cro, Luna, Luuk de Gram, Maciej Walczak, Mahdi Khanalizadeh, Manuel Floru√ü, Martin Wickham, Mathieu Guay-Paquet, Matt Knight, Matt Sicker, Matthew Borkowski, Meghan, Meghan Denny, Michael Dusan, Michael Freundorfer, Michael Holmes, Miles Alan, Nathana√´l Courant, Nuno Leiria, Rageoholic, Robin Voetter, Rocknest, Rohlem, Ryan Greenblatt, Ryan Liptak, Sage Hane, Sahnvour, Shachaf Ben-Kiki, Sobeston, Sreehari S, S√©bastien Marie, Tadeo Kondrak, Tau, Timon Kruiper, Travis, Veikka Tuominen, Vincent Rischmann, Yorhel, Zander Khan, ZapAnton, aiz, antlilja, breakin, christian-stephen, cryptocode, data-man, daurnimator, ducdetronquito, fancl20, frmdstryr, Jacob G-W, gracefu, heidezomp, johnLate, jumpnbrownweasel, lithdew, luna, mason1920, rgreenblatt, root, ryuukk, tgschultz, viri, xackus, ≈Ωiga ≈Ωeljko</p>

    {#header_open|Formatted Printing#}
    TODO

    Made formatBuf UTF-8 aware.
    Add 'u' specifier to format
    std: Implement named arguments & runtime width/precision
    LemonBoy reworked the whole parser

    remove z/Z format specifiers. Zig's format system is flexible enough to add custom formatters.  This PR removes the new z/Z format specifiers that were added for printing Zig identifiers and replaces them with custom formatters.

    Also fix the `*` specifier for more types, print an error message if we
    can't show the value address.

    std: Disable the special casing of {} for u8 slices/arrays
    Unless {s} is specified the contents won't be treated as a string.

    Improve error messages in std.fmt (#7898)


    std.zig.fmt escaped string formatting recognizes single quote style

    This introduces {'} to indicate escape for a single-quoted string,
    and {} to indicate escape for a double quoted string.

    Without this, there would be unnecessary \' inside double quoted
    strings, and unnecessary \" inside single quoted strings.

    Motivated by the llvm12 branch, in the new tool I am writing for
    updating target CPU features.

    std: Deprecate 'x'/'X'/'e'/'E' special cases for u8 slices

    Let's follow the road paved by the removal of 'z'/'Z', the Formatter
    pattern is nice enough to let us remove the remaining four special cases
    and declare u8 slices free from any special casing!

    std: Deprecate the B and Bi format specifiers

    Following #8007 and #8137 let's get rid of the last weird format.


    {#header_close#}

    {#header_open|fs.path.dirname: return null when input path is root#}
    {#code_begin|test|dirname#}
const std = @import("std");
test "dirname on root path" {
    try std.testing.expect(std.fs.path.dirname("/") == null);
}
    {#code_end#}
    <p>This intentionally diverges from the unix dirname command, as well as
    Python and Node.js standard libraries, which all have this edge case
    return the input path, unmodified. This is a footgun, and nobody should
    have ever done it this way.</p>

    <p>Even the man page contradicts the behavior. It says:
    "strip last component from file name". Now consider, if you
    remove the last item from an array of length 1, then you
    have now an array of length 0. After you strip the last component, there
    should be no components remaining. Clearly, returning the input parameter
    unmodified in this case does not match the documented behavior. This is
    my justification for taking a stand on this API design.</p>

    <p>Fixes #6746, #6727, #6584, #6592, #6602</p>
    {#header_close#}

    {#header_open|Thread-Local CSPRNG for General Use#}
commit 013efaf13987acfa6b41d40f07900c1ea77f5bda
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Thu Dec 17 20:03:41 2020 -0700

    std: introduce a thread-local CSPRNG for general use (#6704)

    std.crypto.random

    * cross platform, even freestanding
    * can't fail. on initialization for some systems requires calling
      os.getrandom(), in which case there are rare but theoretically
      possible errors. The code panics in these cases, however the
      application may choose to override the default seed function and then
      handle the failure another way.
    * thread-safe
    * supports the full Random interface
    * cryptographically secure
    * no syscall required to initialize on Linux (AT_RANDOM)
    * calls arc4random on systems that support it

    `std.crypto.randomBytes` is removed in favor of `std.crypto.random.bytes`.

    I moved some of the Random implementations into their own files in the
    interest of organization.

    stage2 no longer requires passing a RNG; instead it uses this API.

commit 53987c932c9d62cc9cdae3d523fb62756ce83ca9
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Fri Dec 18 15:38:38 2020 -0700

    std.crypto.random: introduce fork safety

    Everybody gets what they want!

     * AT_RANDOM is completely ignored.
     * On Linux, MADV_WIPEONFORK is used to provide fork safety.
     * On pthread systems, `pthread_atfork` is used to provide fork safety.
     * For systems that do not have the capability to provide fork safety,
       the implementation falls back to calling getrandom() every time.
     * If madvise is unavailable or returns an error, or pthread_atfork
       fails for whatever reason, it falls back to calling getrandom() every
       time.
     * Applications may choose to opt-out of fork safety.
     * Applications may choose to opt-in to unconditionally calling
       getrandom() for every call to std.crypto.random.fillFn.
     * Added `std.meta.globalOption`.
     * Added `std.os.madvise` and related bits.
     * Bumped up the size of the main thread TLS buffer. See the comment
       there for justification.
     * Simpler hot path in TLS initialization.
    {#header_close#}

    {#header_open|Crypto#}

    {#header_open|Legacy Keccak hash functions#}
    <p>The legacy Keccak hash functions have been added (<code>hash.sha3.Keccak_256, hash.sha3.Keccak_512</code>). They only differ from the standard SHA-3 functions by their domain separation byte.

    <p>These functions are not recommended as they are slow and non-standard. However, popular blockchains such as Ethereum still require them.
    {#header_close#}

    {#header_open|AES-OCB#}
    <p>This release adds <a href="https://competitions.cr.yp.to/round3/ocbv11.pdf">AES-OCB</a>a, which has been around for a long time. It's simpler, faster and has better nonce-reuse resistance than AES-GCM.

    <p>RFC 7253 was published in 2014. OCB also won the CAESAR competition along with AEGIS that we already had.

    <p>So, why isn't everybody using it instead of GCM? And why didn't we have it in Zig before?

    <p>The sad reason for this was patents. GCM was invented only to work around these patents, and for all this time, OCB was that nice thing that everybody knew existed but that couldn't be freely used.

    <p><a href="https://mailarchive.ietf.org/arch/msg/cfrg/qLTveWOdTJcLn4HP3ev-vrj05Vg/">That just changed in February 2021</a>. The OCB patents have been abandoned, and OCB is now public domain.
    {#header_close#}

    {#header_open|ISAP#}
    <p>We already had ciphers optimized for performance, for compatibility, for size and for specific CPUs.</p>

    <p>However we used to lack a class of ciphers that is becoming increasingly important, as Zig is being used for embedded systems, but also as hardware-level side channels keep being discovered.</p>

    <p>Please welcome <a href="https://isap.iaik.tugraz.at/files/isapv20.pdf">ISAPv2</a> (ISAP-A-128a), a cipher specifically designed for resilience against leakage and fault attacks.</p>

    <p>ISAPv2 is not fast, but can be an option for highly sensitive data, when the runtime environment cannot be trusted.</p>
    {#header_close#}

    {#header_open|Hash-To-Curve#}
    <p>Is there a way to map an arbitrary string into an elliptic curve point, so that the discrete log is not known?</p>

    <p>While more and more protocols require such a function, there was no standard way to do it until the <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/">hash-to-curve</a> specification came out.</p>

    <p>This release adds <code>crypto.ecc.Edwards25519.fromString()</code>, implementing the suites defined in the specification for the Edwards25519 curve.</p>
    {#header_close#}

    {#header_open|Double-Base Scalar Multiplication#}
    <p>Signatures systems over elliptic curves frequently require computing Px+Qy, with P and Q being different points on the same curve.</p>

    <p>And a specialized function can be much faster than computing both multiplications separately.</p>

    <p>Incidentally, this is exactly what the new <code>Edwards25519.mulDoubleBasePublic()</code> and <code>P256.mulDoubleBasePublic()</code> functions do.</p>
    {#header_close#}

    {#header_open|P-256#}
    <p>They were invented by a US government agency. They are prone to side channels. Secure or not, implementations tend to be slow. Renowned cryptographers <a href="https://safecurves.cr.yp.to">don't trust them much</a>. And Zig already includes better alternatives such as Ristretto255.</p>

    <p>But the NIST curves are deployed everywhere. Far more than any other curves. For compliance reasons or simply because most protocols don't support anything else, we need them.</p>

    <p>Zig 0.8.0 adds support for the NIST P-256 curve. Other prime-order curves will follow shortly.</p>

    <p>Since they don't use "nice" primes, safely implementing finite field arithmetic for these curves is tricky, and many implementations got hit by carry propagation bugs.</p>

    <p>We took the approach of contributing a Zig backend to <a href="https://github.com/mit-plv/fiat-crypto">fiat-crypto</a>, a project to generate arithmetic that has been formally proven for correctness.</p>

    <p>The output of that tool is the core of our P-256 implementation,
    <strong>making Zig the first general-purpose language with formally verified cryptography
      right in the standard library</strong>. Support for other curves will be done the same way.</p>

    <p>Please note however, that verification stops at source-level, and doesn't protect
    against possible {#link|compiler bugs|This Release Contains Bugs#}.</p>
    {#header_close#}

    {#header_open|Constant-Time Comparisons#}
    <p>A new function was added to compare (not just for equality) byte strings: <code>crypto.utils.timingSafeCompare()</code>.</p>

    <p>It is useful to compare arbitrary-large nonces, counters or serialized field elements.</p>
    {#header_close#}

    {#header_open|Round-Reduced ChaCha20#}
    <p>Round-reduced versions (8 and 12 rounds) of the ChaCha20-based ciphers have been added. This includes the ChaCha20 stream cipher itself, as well as the ChaCha20-Poly1305 construction.</p>

    <p>8 rounds ChaCha20 provides a 2.5x speedup over the standard 20 rounds version, <a href="https://eprint.iacr.org/2019/1492.pdf">and is still believed to have a safe security margin</a>.</p>
    {#header_close#}

    {#header_open|Breaking Changes#}
    <ul>
      <li>Edwards25519: <code>neutralElement</code> was deprecated. New code should use <code>identityElement</code> instead.</li>
      <li>Errors have been made more consistent across <code>std.crypto</code> functions. They now all share the same <code>std.crypto.Error</code> errors set.</li>
    </ul>
    {#header_close#}

    {#header_open|Performance Improvements#}
    <ul>
      <li>Ed25519 signature verification is about 60% faster than in Zig 0.7.1.</li>
    </ul>
    {#header_close#}

    {#header_open|Crypto Bug Fixes#}
    <ul>
      <li>AES: <code>{encrypt,decrypt}Wide()</code> functions performed more rounds than necessary. This has been fixed.</li>
      <li>BLAKE2: properly handle output sizes that are not a multiple of 8.</li>
      <li>Salsa20: the vectorized implementation didn't use the correct position for the internal counter.</li>
    </ul>
    {#header_close#}

    <p>Contributors: Frank Denis, Andrew Kelley, LemonBoy, Al Hoang, Guillaume Ballet, Isaac Freund, Jay Petacat, Matt Sicker, Rocknest, Tadeo Kondrak, Veikka Tuominen</p>
    {#header_close#}

    {#header_open|MultiArrayList#}
    TODO
    Also known as "Struct-Of-Arrays" or "SOA". The purpose of this data
    structure is to provide a similar API to ArrayList but instead of
    the element type being a struct, the fields of the struct are in N
    different arrays, all with the same length and capacity.

    Having this abstraction means we can put them in the same allocation,
    avoiding overhead with the allocator. It also saves a tiny bit of
    overhead from the redundant capacity and length fields, since each
    struct element shares the same value.

    This is an alternate implementation to #7854.
    {#header_close#}

    {#header_open|Progress#}
    TODO

    std: Better handling of line-wrapping in Progress

    In order to update the printed progress string the code tried to move
    the cursor N cells to the left, where N is the number of written bytes,
    and then clear the remaining part of the line.
    This strategy has two main issues:
     - Is only valid if the number of characters is equal to the number of
       written bytes,
     - Is only valid if the line doesn't get too long.

    The second point is the main motivation for this change, when the line
    becomes too long the terminal wraps it to a new physical line. This
    means that moving the cursor to the left won't be enough anymore as once
    the left border is reached it cannot move anymore.

    The wrapped line is still stored by the terminal as a single line,
    despite now taking more than a single one when displayed. If you try to
    resize the terminal you'll notice how the contents are reflowed and are
    essentially illegible.

    Querying the cursor position on non-Windows systems (plot twist,
    Microsoft suggests using VT escape sequences on newer systems) is
    extremely cumbersome so let's do something different.

    Before printing anything let's save the cursor position and clear the
    screen below the cursor, this way we ensure there's absolutely no trace
    of stale data on screen, and after the message is printed we simply
    restore it.
    {#header_close#}

    {#header_open|Orphanage#}
    TODO
    move std.SegmentedList to the std-lib-orphanage

    I spent a long time working on this data structure, and I still think
    it's a neat idea, but it has no business being in the std lib.

    I'm aware of the few remaining references to SegmentedList that exist in
    the std lib, but they are dead code, and so I'm leaving the dead
    references as a clue that the code is dead. Cleaning up dead code will
    be a separate effort that involves code coverage tools to make sure we
    find it all.

    std-lib-orphanage commit: 2c36a7894c689ecbaf63d5f489bb0c68773410c4

    closes #7190

    std: move serialization to the std lib orphanage

    std-lib-orphanage commit 633792839f6f838fa864cde6af015413ee713404

    move ArrayListSentineled to std lib orphanage

    {#header_close#}

    {#header_close#}

    {#header_open|Zig Build System#}
    <p>
    The Zig Build System is invoked via the <code>zig build</code> command, which executes
    a declarative <code>build.zig</code> script to collect options and describe the graph
    of steps, and then provides options to execute those steps.
    </p>
    <p>
    Although it is already essential to nearly every Zig project, the Zig Build System is
    still experimental and unstable. As a build system, stability is especially important,
    but stabilization cannot occur until the language stabilizes. Language stability is the
    next area of focus on the {#link|Roadmap#}.
    </p>

    <p>The first thing you will immediately notice in this release is that the
    default install prefix is now <code>zig-out</code> in the build root, rather than
    <code>zig-cache</code> in the current working directory (#8659). The <code>-p</code>
    flag can be used to choose a different install prefix.</p>

    <p>
    In addition, there are the following improvements:
    </p>

    <ul>
      <li>Support specifying rpaths explicitly (#8912).</li>
      <li><code>installDirectory</code> supports a <code>blank_extensions</code> option
        to blank out files instead of omitting them. This is utilized by Zig's build script
        so that the installation does not include many megabytes of test files, but
        also {#syntax#}@import{#endsyntax#} on them does not cause a compile error.</li>
      <li>Added experimental Darling support for cross testing macOS.</li>
      <li>Fixed wrong glibc dir passed to qemu for i386.</li>
      <li>If using a RunStep, show the command run on verbose (#8571).</li>
      <li>Added LibExeObjStep.linker_allow_shlib_undefined field to set --allow-shlib-undefined</li>
      <li>std.build: make Builder.install_prefix non optional
        This is useful for build.zig files to check in some cases, for example
        to adhere to the convention of installing config to /etc instead of
        /usr/etc on linux when using the /usr prefix. Perhaps std.build will
        handle such common cases eventually, but that is not yet the case.</li>
      <li>Added support for LTO configuration.</li>
      <li>Added support for passing write file args as build options (#7909).
        Makes it easier to generate Zig code in a build.zig script.</li>
      <li>Dupe strings on all public api points for std.build.</li>
      <li>Propagate env_map for child processes.</li>
      <li>Assert that install paths are relative. If absolute paths are passed they
        will work unless $DESTDIR is set, which causes subtly broken build.zig's.</li>
      <li>Made build errors followed by two newlines.</li>
      <li>Added {#syntax#}sanitize_thread{#endsyntax#} option.</li>
      <li>Added option to override default stack size in build system.</li>
      <li>{#syntax#}addBuildOption{#endsyntax#} gains support for more types: {#syntax#}SemanticVersion{#endsyntax#}, floats, {#syntax#}?[:0]const u8{#endsyntax#}</li>
      <li>Dynamic library artifacts are now passed as positionals.</li>
      <li>COFF linking: fix incorrectly passing .dll instead of .lib</li>
    </ul>


<p>Contributors: Andrew Kelley, Asherah Connor, Daniele Cocca, Frank Denis, Hubert Jasudowicz, Isaac Freund, Jakub Konka, Jay Petacat, Jonathan Marler, Josh Holland, Lee Cannon, LemonBoy, Martin Wickham, Michael Dusan, Michael Holmes, Ryan Greenblatt, Veikka Tuominen, Vexu, Vincent Rischmann, antlilja, daurnimator, frmdstryr, Jacob G-W, lithdew, rgreenblatt</p>
    {#header_close#}

    {#header_open|Toolchain#}
TODO tooling:

    ability to build stage1 using only a zig tarball 5a65caa2a3686e12e4dfcfd599ed02f8a09c6017

    tsan /  -fsanitize-thread

    -mno-red-zone

    LTO support, across zig and c/c++. #2845

    make "gnu" (mingw-w64) the default C ABI on Windows Closes #6565

    {#header_open|musl 1.2.2#}
    <p>
    Zig ships with the source code to <a href="https://www.musl-libc.org/">musl</a>.
    When the musl C ABI is selected, Zig builds musl from source for the selected target.
    </p>
    <p>
    This release updates the bundled musl source code to
    <a href="https://musl.libc.org/releases.html">v1.2.2</a>.
    </p>
    TODO ifreund made it support dynamic musl (#7406)
    {#header_close#}

    {#header_open|glibc 2.33#}
    <p>
    Zig gains the ability to target
    <a href="https://sourceware.org/pipermail/libc-alpha/2021-February/122207.html">glibc 2.33</a>
    in addition to the other 43 glibc versions.
    </p>
    TODO -lcrypt

    {#header_close#}

    {#header_open|mingw-w64 9.0.0#}
    <p>
    Zig ships with the source code to <a href="https://mingw-w64.org/">mingw-w64</a>.
    When targeting *-windows-gnu and linking against libc, Zig builds mingw-w64 from source
    for the selected target.
    </p>
    <p>
    This release updates the bundled mingw-w64 source code to
    <a href="https://sourceforge.net/p/mingw-w64/mailman/message/37287751/">v9.0.0</a>.
    </p>
    {#header_close#}

    {#header_open|WASI libc#}
    TODO
    {#header_close#}

    {#header_open|zig ar#}
    TODO
    {#header_close#}

    {#header_open|zig cc#}
    <p>
    Zig now automatically uses a thread pool to compile C objects in parallel. For users
    with multiple CPU cores this will make a huge difference in how long it takes to
    compile C and C++ objects.
    </p>
    <p>
    <code>zig cc</code> is covered by the Bug Stability Program. This means that, even
    prior to Zig 1.0, we will not tag a release with any known regressions in <code>zig cc</code>.
    Some caveats: this applies to only the Zig codebase; we cannot promise that
    {#link|Clang|LLVM 12#} will not regress.
    </p>
    <p>
    Also please be aware that there are
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3A%22zig+cc%22">open zig cc issues</a>,
    but these are things that never worked in the first place, making them
    <em>bugs</em> and <em>enhancements</em>, not regressions.
    </p>
    <p>
    Apart from parallelization, mainly the improvements in this release are polish
    and bug fixes, bringing us materially closer to the "it just works" user experience:
    </p>
    <ul>
      <li>Made <code>zig cc</code> print more info from Clang itself and from our own linker
      invocation. This is needed for CMake to properly discover all the include directories
      and library search paths (#7110, #7166).</li>
      <li>Made SONAME off by default when using <code>zig cc</code> to match C compilers.
        <code>zig build-lib -dynamic</code> still defaults SONAME to on.</li>
      <li>Default to a.exe on Windows, matching Clang.</li>
      <li>Support both ubsan and tsan at the same time.</li>
      <li>Support reading input from stdin, fixing use of <code>zig cc</code> with meson (#6271.</li>
      <li>Recognize more coff linker options (#7874).</li>
      <li>Recognize the <code>-s</code> flag to be "strip".</li>
      <li>Fixed handling of <code>-MM</code> flag, as well as <code>-MG</code>,
        <code>-MM</code>, and <code>-MMD</code> aliases.</li>
      <li>Copy .pdb files from zig-cache/ when appropriate (#8407).</li>
      <li>Properly pass -mcpu option when assembling.</li>
      <li>Expose header files when linking libunwind.</li>
      <li>Implicitly enable <code>--eh_frame_hdr</code> when compiling C/C++ files. Matches what Clang/GCC driver do (#7711).</li>
      <li>Pass -mthumb when compiling C/C++ code. The Clang driver requires this flag and ignores the target triple.</li>
    </ul>

    {#header_open|Environment Variable Alternatives to CLI Options#}
    <p>This release adds:</p>
    <ul>
      <li><code>ZIG_LOCAL_CACHE_DIR</code> corresponding to <code>--cache-dir</code></li>
      <li><code>ZIG_GLOBAL_CACHE_DIR</code> corresponding to <code>--global-cache-dir</code></li>
      <li><code>ZIG_LIB_DIR</code> corresponding to <code>--override-lib-dir</code></li>
      <li><code>ZIG_VERBOSE_LINK</code> corresponding to <code>--verbose-link</code></li>
      <li><code>ZIG_VERBOSE_CC</code> corresponding to <code>--verbose-cc</code></li>
    </ul>
    <p>
    Generally the CLI options that Zig provides are preferable to using environment variables,
    however, when using <code>zig cc</code>, we are bound by Clang's CLI options and
    therefore need alternate channels to pass these configuration options.
    </p>
    {#header_close#}

    {#header_open|Improved Local Cache Directory Logic#}
    <p>
    Previously, when choosing the local cache directory, if there was no
    root source file, an explicitly chosen path, or other clues, zig would
    choose cwd + zig-cache/ as the local cache directory.
    </p>
    <p>
    This can be problematic if Zig is invoked with the CWD set to a
    read-only directory, or a directory unrelated to the actual source files
    being compiled. In the real world, we see this when using <code>zig cc</code> with
    CGo, which for some reason changes the current working directory to the
    read-only go standard library path before running the C compiler.
    </p>
    <p>
    This change conservatively chooses to use the global cache directory
    as the local cache directory when there is no other reasonable choice,
    and no longer will rely on the cwd path to choose a local cache directory.
    </p>
    <p>
    As a reminder, the <code>--cache-dir</code> CLI flag and <code>ZIG_LOCAL_CACHE_DIR</code>
    environment variable are available for overriding the decision. For the
    zig build system, it will always choose the directory that build.zig is + zig-cache/.
    </p>
    <p>
    With this, plus a commit that landed in Go 1.17,
    <a href="https://dev.to/kristoff/zig-makes-go-cross-compilation-just-work-29ho">Zig Makes Go Cross Compilation Just Work</a>.
    </p>
    <p>
    Another user saw this and noticed that additionally,
    <a href="https://actually.fyi/posts/zig-makes-rust-cross-compilation-just-work/">Zig Makes Rust Cross-compilation Just Work</a>.
    </p>
    {#header_close#}
    <p>
    Contributors: Andrew Kelley, Jakub Konka, LemonBoy, Rafael Ristovski, Jacob G-W
    </p>
    {#header_close#}

    {#header_open|zig c++#}
    <p>
    <code>zig c++</code> is equivalent to {#link|zig cc#} with an added <code>-lc++</code>
    parameter, but I made a separate heading here because I realized that some people are
    not aware that Zig supports compiling C++ code and providing libc++ too!
    </p>
    <pre><code>#include &lt;iostream&gt;
int main() {
    std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl;
    return 0;
}</code></pre>
    <pre>$ zig c++ -o hello hello.cpp
$ ./hello
Hello World!</pre>
    <p>Cross-compiling too, of course:</p>
    <pre>$ zig c++ -o hello hello.cpp -target riscv64-linux
$ qemu-riscv64 ./hello
Hello World!</pre>
    <p>
    One thing that trips people up when they use this feature is that the
    <strong>C++ ABI is not stable across compilers</strong>, so always remember the rule:
    You must use the same C++ compiler to compile <em>all</em> your objects and static libraries.
    This is an unfortunate limitation of C++ which Zig can never fix.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|Bug Fixes#}
    <p>
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aclosed+is%3Aissue+label%3Abug+milestone%3A0.8.0+">Full list of the 106 bug reports closed during this release cycle</a>.
    </p>
    <p>
    Note: many bugs were both introduced and resolved within this release cycle.
    </p>
    {#header_open|This Release Contains Bugs#}
    <p>
    Zig has
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Abug">known bugs</a>
    and even some
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Amiscompilation">miscompilations</a>.
    </p>
    <p>Zig is immature. Even with Zig 0.8.0, working on a non-trivial project using Zig will
    likely require participating in the development process.</p>
    <p>When Zig reaches 1.0.0, a new requirement for {#link|Tier 1 Support#} will be
    0 known bugs for that target.</p>
    <p>
    A <a href="https://github.com/ziglang/zig/milestone/12">0.8.1 release</a> is planned.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|News#}

    {#header_open|Please Welcome Frank Denis to the Core Zig Team#}
    <p>TODO</p>
    {#header_close#}

    {#header_open|Please Welcome kprotty to the Core Zig Team#}
    <p>TODO</p>
    {#header_close#}

    {#header_open|LemonBoy Gains LLVM Write Access#}
    <p>TODO</p>
    {#header_close#}

    {#header_close#}

    {#header_open|Roadmap#}
    <p>
    According to the
    <a href="https://ziglang.org/download/0.7.0/release-notes.html#Roadmap">0.7.0 Roadmap</a>,
    the major theme of the 0.8.0 release was supposed to be <strong>stabilizing the language</strong>,
    <strong>creating a first draft of the language specification</strong>, and
    <strong>self-hosting the compiler</strong>.
    </p>
    <p>TODO</p>
    <p>
    The major goal of the 0.9.0 release cycle is to finish the self-hosted compiler and ship it,
    deleting the C++ implementation of Zig. If you are concerned about bootstrapping, see this
    issue:
    <a href="https://github.com/ziglang/zig/issues/6378">#6378: Allow the feature of O(1) bootstrapping to temporarily regress</a>
    </p>

    {#header_open|Package Manager Status#}
    <p>
    Having a package manager built into the Zig compiler is a
    <a href="https://github.com/ziglang/zig/issues/943">long-anticipated feature</a>.
    Zig 0.8.0 does not have this feature.
    </p>
    <p>
    If the package manager works well, people will use it, which means building Zig projects
    will involve compiling more lines of Zig code, which means the Zig compiler must get faster,
    better at incremental compilation, and better at resource management.
    </p>
    <p>
    Therefore, the package manager depends on finishing the
    {#link|Self-Hosted Compiler#}, since it is planned to have these
    improved performance characteristics, while stage1 is not planned to have them.
    </p>
    {#header_close#}

    {#header_open|Accepted Proposals#}
    <p>
    If you want more of a sense of the direction Zig is heading, you can look at
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Aaccepted">the set of accepted proposals</a>.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|Thank You LavaTech#}
    <p>Special thanks to Ave and Luna of <a href="https://lavatech.top/">LavaTech</a>, who are
    hosting an instance of <a href="https://sourcehut.org/">SourceHut</a> for our Continuous Integration
    pipeline, but with more RAM than the main sr.ht service allows. Thanks to this, FreeBSD now has
    significantly more test coverage, most notably all the standard library tests.</p>
    {#header_close#}

    {#header_open|Thank You Sponsors!#}
    <p>
    Special thanks to those who <a href="https://github.com/sponsors/ziglang/">sponsor Zig</a>.
    Because of you, Zig is driven by the open source community, rather than the goal of making profit.
    In particular, these fine folks sponsor Zig for $50/month or more:
    </p>
    <ul style="columns: 3">
      TODO
    </ul>
    {#header_close#}
    </div>
  </body>
</html>


 TODO mention the license tweak


 TODO do a diff on the test matrix

 TODO allow tests to fail


commit 0d4b6ac7417d1094ac972981b0241444ce2380ba
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Fri Jan 22 23:36:30 2021 -0700

    add LTO support
    
    The CLI gains -flto and -fno-lto options to override the default.
    However, the cool thing about this is that the defaults are great! In
    general when you use build-exe in release mode, Zig will enable LTO if
    it would work and it would help.
    
    zig cc supports detecting and honoring the -flto and -fno-lto flags as
    well. The linkWithLld functions are improved to all be the same with
    regards to copying the artifact instead of trying to pass single objects
    through LLD with -r. There is possibly a future improvement here as
    well; see the respective TODOs.
    
    stage1 is updated to support outputting LLVM bitcode instead of machine
    code when lto is enabled. This allows LLVM to optimize across the Zig and
    C/C++ code boundary.
    
    closes #2845


commit 5ac91794cce8bd53916a378815be01e4365d53d9
Author: Isaac Freund <ifreund@ifreund.xyz>
Date:   Mon May 10 21:29:20 2021 +0200

    stage2: use system libc when targeting the native OS/ABI
    
    Currently zig will always try to build its own libc and compile against
    that. This of course makes sense for cross-compilation, but can cause
    problems when targeting the native OS/ABI.
    
    For example, if the system uses a newer glibc version than zig ships
    zig will fall back to using the newest version it does ship. However
    this causes linking system libraries to fail as they are built against a
    different glibc version than the zig code is built against.
    
    To remedy this, simply default to linking the system libc when targeting
    the native OS/ABI.

 src/Compilation.zig | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

commit 1d6c804b29fed146aafda0f56cae7a4853b6abf9
Author: Isaac Freund <ifreund@ifreund.xyz>
Date:   Tue May 18 23:09:28 2021 +0200

    stage2: only default to linking system libc if linking system libs
    
    We do need to link the system libc if linking system libraries as
    they may potentially be compiled against e.g. a newer glibc version
    than zig can provide. However if not linking system libraries, using
    the zig provided libc is more reliable as it does not depend on any
    quirks of the host system or being able to invoke the system cc to
    find include dirs.

 src/Compilation.zig | 16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)

