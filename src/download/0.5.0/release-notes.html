<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>0.5.0 Release Notes &middot; The Zig Programming Language</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/favicon.png">
    <link rel="icon" href="/favicon.svg">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        line-height: 1.45;
        margin-left: 0;
        margin-right: 0;
      }
      p {
        margin: 0.8em 0;
      }

      h1, h2, h3, h4, h5 {
        margin: 0.5em 0 0.5em;
        line-height: 1.2;
        font-weight: bold;
        color: #666;
      }

      h1 a, h2 a, h3 a, h4 a, h5 a {
        text-decoration: none;
        color: #666;
      }

      h1 { font-size: 2.0em; }
      
      h2 { font-size: 1.5em; }
      
      h3 { font-size: 1.25em; }

      h4 { font-size: 1.0em; }

      a.hdr {
        visibility: hidden;
      }
      h1:hover > a.hdr, h2:hover > a.hdr, h3:hover > a.hdr, h4:hover > a.hdr, h5:hover > a.hdr {
        visibility: visible;
      }

      a {
        color: #2A6286;
      }
      
      a:not(:hover) {
        text-decoration: none;
      }

      th, td {
        padding: 0.6em;
        text-align: left;
      }
      
      td {
        font-size: 0.96em;
      }
      
      th {
        border-bottom: 2px solid #f2f3f3;
      }
      
      tr:nth-child(even) {
        background: #f2f3f3;
      }
      
      .t0_1, .t37, .t37_1 {
        font-weight: bold;
      }
      .t2_0 {
        color: grey;
      }
      .t31_1 {
        color: red;
      }
      .t32_1 {
        color: green;
      }
      .t36_1 {
        color: #0086b3;
      }
      .file {
        text-decoration: underline;
      }
      pre,code {
        font-size: 12pt;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        color: #333;
        background: #f8f8f8;
      }
      .table-wrapper {
        width: 100%;
        overflow-y: auto;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      #contents {
        max-width: 60em;
        margin: auto;
        padding: 0 0.2em;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background-color:#111;
            color: #bbb;
        }
        a {
            color: #88f;
        }
        table, th, td {
            border-color: grey;
        }
        tr:nth-child(even) {
          background: #1e1e1e;
        }
        .t2_0 {
            color: grey;
        }
        .t31_1 {
            color: red;
        }
        .t32_1 {
            color: green;
        }
        .t36_1 {
            color: #0086b3;
        }
        pre > code {
            color: #ccc;
            background: #222;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #e33;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
        h1, h2, h3, h4, h5 {
          color: #aaa;
        }
        h1 a, h2 a, h3 a, h4 a, h5 a {
            color: #aaa;
        }
      }
    </style>
  </head>
  <!--
                          oooo$$$$$$$$$$$$oooo
                      oo$$$$$$$$$$$$$$$$$$$$$$$$o
                   oo$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o         o$   $$ o$
   o $ oo        o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o       $$ $$ $$o$
oo $ $ "$      o$$$$$$$$$    $$$$$$$$$$$$$    $$$$$$$$$o       $$$o$$o$
"$$$$$$o$     o$$$$$$$$$      $$$$$$$$$$$      $$$$$$$$$$o    $$$$$$$$
  $$$$$$$    $$$$$$$$$$$      $$$$$$$$$$$      $$$$$$$$$$$$$$$$$$$$$$$
  $$$$$$$$$$$$$$$$$$$$$$$    $$$$$$$$$$$$$    $$$$$$$$$$$$$$  """$$$
   "$$$""""$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     "$$$
    $$$   o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     "$$$o
   o$$"   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$       $$$o
   $$$    $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$" "$$$$$$ooooo$$$$o
  o$$$oooo$$$$$  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$   o$$$$$$$$$$$$$$$$$
  $$$$$$$$"$$$$   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     $$$$""""""""
 """"       $$$$    "$$$$$$$$$$$$$$$$$$$$$$$$$$$$"      o$$$
            "$$$o     """$$$$$$$$$$$$$$$$$$"$$"         $$$
              $$$o          "$$""$$$$$$""""           o$$$
               $$$$o                 oo             o$$$"
                "$$$$o      o$$$$$$o"$$$$o        o$$$$
                  "$$$$$oo     ""$$$$o$$$$$o   o$$$$""  
                     ""$$$$$oooo  "$$$o$$$$$$$$$"""
                        ""$$$$$$$oo $$$$$$$$$$       
                                """"$$$$$$$$$$$        
                                    $$$$$$$$$$$$       
                                     $$$$$$$$$$"      
                                      "$$$""""
  -->
  <body>
    <div id="contents">
    <a href="/"><img alt="zig" src="../../zig-logo.svg"></a>
    <h1>0.5.0 Release Notes</h1>
    <p>
    <a href="/download">Download &amp; Documentation</a>
    </p>
    <p>
    Zig is a general-purpose programming language designed for <strong>robustness</strong>,
    <strong>optimality</strong>, and <strong>maintainability</strong>.
    Zig is aggressively pursuing its goal of overthrowing C as the de facto language for system programming.
    Zig intends to be so practical that people find themselves using it, because it "just works".
    </p>
    <p>
    This release features <strong>6 months of work</strong> and
    changes from <strong>67 different contributors</strong>, spread among
    <strong>1541 commits</strong>.
    </p>
    <p>
    Special thanks to my
    <a href="https://github.com/users/andrewrk/sponsorship">sponsors who provide financial support</a>.
    You're making Zig sustainable.
    </p>

    {#header_open|Table of Contents#}
    {#nav#}
    {#header_close#}

    {#header_open|LLVM 9#}
    <p>
    This release of Zig upgrades to
    <a href="http://releases.llvm.org/9.0.0/docs/ReleaseNotes.html">LLVM 9</a>.
    Zig operates in lockstep with LLVM; Zig 0.5.0 is not compatible with LLVM 8.
    </p>
    <p>
    Notably this means that Zig now has {#link|RISC-V Support#}.
    </p>
    <p>
    Zig also gains <a href="https://emscripten.org/">emscripten</a> as a target OS.
    <a href="https://github.com/emscripten-core/emscripten/issues/6432">emscripten cannot self-host yet</a>,
    but when it can, it will be interesting to explore this as an option for a Zig-in-the-browser sandbox,
    using {#link|WebAssembly|WebAssembly Support#}.
    </p>
    {#header_close#}

    {#header_open|Support Table#}
    <p>
    A <a href="../../#Support-Table">support table for master branch</a> can be found on the home page.
    Here the support table for 0.5.0 is reproduced:
    </p>
<table>
<thead>
<tr>
<th></th>
<th>free standing</th>
<th>Linux 3.16+</th>
<th>macOS 10.13+</th>
<th>Windows 7+</th>
<th>FreeBSD 12.0+</th>
<th>NetBSD 8.0+</th>
<th>UEFI</th>
<th>WASI</th>
<th>Android</th>
</tr>
</thead>
<tbody>
<tr>
<td>x86_64</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td style="white-space: nowrap">{#link|Tier 2|Tier 2 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
</tr>
<tr>
<td>wasm32</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>arm64</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
</tr>
<tr>
<td>arm32</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
</tr>
<tr>
<td>mips32 LE</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>i386</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
</tr>
<tr>
<td>bpf</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>hexagon</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>mips32 BE</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>mips64</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>amdgcn</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>sparc</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>s390x</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>lanai</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>powerpc32</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>powerpc64</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>wasm64</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>avr</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>riscv32</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>riscv64</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>xcore</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>nvptx</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>msp430</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>r600</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>arc</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>tce</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>le</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>amdil</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>hsail</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>spir</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>kalimba</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>shave</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>renderscript</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
</tbody>
</table>
    {#header_open|Tier System#}

    {#header_open|Tier 1 Support#}
    <ul>
      <li>Not only can Zig generate machine code for these targets, but the standard
   library cross-platform abstractions have implementations for these targets.
   Thus it is practical to write a pure Zig application with no dependency on
   libc.</li>
      <li>The CI server automatically tests these targets on every commit to master
      branch, and updates <a href="/download">the download page</a> with links to pre-built binaries.</li>
      <li>These targets have debug info capabilities and therefore produce stack traces on failed assertions.
      </li>
      <li>libc is available for this target even when cross compiling.</li>
    </ul>
    {#header_close#}

    {#header_open|Tier 2 Support#}
    <ul>
    <li>There may be some standard library implementations, but many abstractions
      will give an "Unsupported OS" compile error. One can link with libc or other
      libraries to fill in the gaps in the standard library.</li>
    <li>These targets are known to work, but are not automatically tested, so there
      are occasional regressions.</li>
    <li>Some tests may be disabled for these targets as we work toward Tier 1
      support.</li>
    </ul>
    {#header_close#}

    {#header_open|Tier 3 Support#}
    <ul>
    <li>The standard library has little to no knowledge of the existence of this
        target.</li>
    <li>Because Zig is based on LLVM, it has the capability to build for these
      targets, and LLVM has the target enabled by default.</li>
    <li>These targets are not frequently tested; one will likely need to contribute
      to Zig in order to build for these targets.</li>
    <li>The Zig compiler might need to be updated with a few things such as<ul>
       <li>what sizes are the C integer types</li>
       <li>C ABI calling convention for this target</li>
       <li>bootstrap code and default panic handler</li>
     </ul>
     <li><code>zig targets</code> is guaranteed to include this target.</li>
    </ul>
    {#header_close#}

    {#header_open|Tier 4 Support#}
    <ul>
      <li>Support for these targets is entirely experimental.</li>
      <li>LLVM may have the target as an experimental target, which means that you
   need to use Zig-provided binaries for the target to be available, or
   build LLVM from source with special configure flags. <code>zig targets</code> will
   display the target if it is available.</li>
   <li>This target may be considered deprecated by an official party,
     <a href="https://support.apple.com/en-us/HT208436">such as macosx/i386</a> in which
     case this target will remain forever stuck in Tier 4.</li>
   <li>This target may only support <code>--emit asm</code> and cannot emit object files.</li>
    </ul>
    {#header_close#}
    {#header_close#}

    {#header_open|RISC-V Support#}
    <p>
    This release updates to {#link|LLVM 9#}, {#link|musl 1.1.23#} with patches, and
    {#link|glibc 2.30#}. This plus updates to the {#link|Standard Library#} means
    that Zig's (64-bit) RISC-V support has gone from {#link|Tier 4 Support#} to
    {#link|Tier 3 Support#} in this release.
    </p>
    <ul>
      <li>daurnimator updated riscv64 syscalls in the std lib.</li>
      <li>LemonBoy updated thread-local storage startup code to take into account DTP bias
          according to the RISCV ABI. He also corrected some of the bits in the std lib.
          Thanks to this the {#link|compiler-rt#} tests are passing for RISC-V.
      </li>
    </ul>
    <p>
    RISC-V is a very flexible target, with features such as atomics, and even integer multiplication
    being optional. Since Zig does not yet have
    <a href="https://github.com/ziglang/zig/issues/2883">ability to specify target CPU features</a>,
    the default set of cross-compilation features are <code>"+a,+c,+d,+f,+m,+relax"</code>,
    which matches Clang.
    </p>
    <p>
    The RISC-V target does not yet pass Zig's test suite:
    </p>
    <ul>
      <li><a href="https://github.com/ziglang/zig/issues/3338">LLVM ERROR: Named registers not implemented for this target</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/3338">LLVM unable to perform f16 widening</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/3339">LLD silent failure linking behavior tests</a></li>
    </ul>
    <p>
    The next step for all these issues is to create test case reductions and then
    file upstream bug reports.
    </p>
    <p>
    However, I did work with <a href="https://github.com/users/richfelker/sponsorship">Rich Felker</a>
    to get musl building with Clang for the RISC-V target, which means that we can do this:
    </p>
    <p class="file">hello.c</p>
    <pre><code>#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    printf("Hello world\n");
    return 0;
}</code></pre>
<pre><code class="shell">$ zig build-exe --c-source hello.c -lc -target riscv64-linux-musl
$ qemu-riscv64 ./hello
Hello world</code></pre>
    <p>
    Zig 0.5.0 carries a few patches to musl which makes this work. A new musl release is expected soon which
    contains these patches.
    </p>
    <p>
    To be clear - the above simple example also works in Zig - it's just that all the language features
    such as {#syntax#}f16{#endsyntax#} are not working, and there is no automated {#link|Test Coverage#}
    for this target.
    </p>
    {#code_begin|exe|hello#}
    {#target_linux_riscv64#}
const std = @import("std");

pub fn main() void {
    std.debug.warn("Hello from zig\n");
}
    {#code_end#}
<pre><code>$ qemu-riscv64 ./hello
Hello from zig</code></pre>
    <p>
    Although {#link|glibc 2.30#} gained RISC-V support, Zig is not able to build
    glibc for this target yet. See <a href="https://github.com/ziglang/zig/issues/3340">#3340</a> for more details. Looks like it could be
    as simple as importing a couple more .h files from the glibc source tree.
    </p>
    {#header_close#}

    {#header_open|64-bit ARM Support#}
    <p>LemonBoy worked on {#link|Standard Library#} support for aarch64 during this release cycle:</p>
    <ul>
      <li>Several improvements to {#link|Thread Local Storage#}.</li>
      <li>Fixed the definition of <code>epoll_*</code> struct on non x86_64 arches.</li>
      <li>Fixed some syscalls and flag definitions.</li>
    </ul>
    <p>
    After this work, and improvements made to {#link|Test Coverage#}, the following targets are now
    covered by the Zig test suite:
    </p>
    <ul>
      <li><strong>aarch64v8_5a-linux-none</strong> (no libc)</li>
      <li><strong>aarch64v8_5a-linux-musl</strong> (building {#link|musl 1.1.23#} from source,
        statically linking against it, and using it for OS APIs)</li>
      <li><strong>aarch64v8_5a-linux-gnu</strong> (building {#link|glibc 2.30#} from source,
        dynamically linking against it, and using it for OS APIs)</li>
    </ul>
    <p>
    This test coverage led to the following bug fixes:
    </p>
    <ul>
      <li>LemonBoy fixed a test on ARM due to the use of {#syntax#}undefined{#endsyntax#} ptr. </li>
      <li>Fixed Linux stat struct on aarch64. The ABI was incorrect.</li>
      <li>Fixed {#link|glibc 2.30#} builds on aarch64-linux-gnu. There was a missing include path in the
        compilation line, leading to incorrect fstat ABI. <a href="https://github.com/ziglang/zig/issues/3291">#3291</a></li>
    </ul>
    <p>
    However, due to
    <a href="https://github.com/ziglang/zig/issues/3271">LLVM miscompiling trivial switch for AArch64</a>,
    some failing tests are disabled, which means 64-bit ARM remains a {#link|Tier 2 Support#} target.
    The good news is we filed an <a href="https://bugs.llvm.org/show_bug.cgi?id=43383">LLVM bug report</a>,
    and it has already been solved in LLVM trunk, scheduled to be included in LLVM 9.0.1.
    </p>
    <p>
    After that, the only remaining issues standing in the way of
    <a href="https://github.com/ziglang/zig/issues/2443">Tier 1 Support for ARM 64-bit (aarch64) Linux</a>
    are:
    </p>
    <ul>
      <li><a href="https://github.com/ziglang/zig/issues/3282">When targeting AArch64, unable to widen cast f16 to f128</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/2934">fn return struct - aarch64 stack alignment exception</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/3268">@newStackCall() generates invalid machine code</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/1481">More C ABI support for this target</a></li>
      <li>Add {#link|Test Coverage#} for {#link|Debug Info and Stack Traces#} for this target.</li>
      <li>Come up with a way for the Continuous Integration service to create 64-bit ARM binaries
        for the <a href="/download">download page</a>.</li>
    </ul>
    <p class="file">arm64-test.zig</p>
    <pre>{#syntax#}
const builtin = @import("builtin");
const std = @import("std");
const assert = std.debug.assert;

test "cross compiled unit test" {
    assert(builtin.arch == .aarch64);
}
    {#endsyntax#}</pre>
<pre><code class="shell">$ zig test arm64-test.zig -target aarch64v8-linux --test-cmd qemu-aarch64 --test-cmd-bin
1/1 test "cross compiled unit test"...OK
All tests passed.</code></pre>
    {#header_close#}

    {#header_open|32-bit ARM Support#}
    <p>
    Thanks to {#link|compiler-rt#} improvements by vegecode and LemonBoy, Zig's
    32-bit ARM support is much stronger in version 0.5.0.
    </p>
    <p>
    Alongside these efforts, LemonBoy improved the {#link|Standard Library#} by making
    I/O offsets and sizes {#syntax#}u64{#endsyntax#} instead of {#syntax#}usize{#endsyntax#},
    decoupling the concepts of address-space size and file size. This solved many compile errors
    when trying to target 32-bit ARM, as well as any other 32-bit architecture. <a href="https://github.com/ziglang/zig/issues/637">#637</a>
    </p>
    <p>He also made several improvements to {#link|Thread Local Storage#} for 32-bit ARM.</p>
    <p>Robin Voetter joined the Zig community during this release cycle, and hammered away
    at the {#link|Standard Library#}:</p>
    <ul>
      <li>Added arm32 linux bits definitions and syscall conventions.</li>
      <li>TLS initialization, clone definition and _start functionality.</li>
      <li>Made {#syntax#}std.os.linux.mmap{#endsyntax#} use <code>SYS_mmap2</code> if it exists.</li>
      <li>Used <code>sys_*stat*64</code> instead of <code>sys_*stat*</code> where appropriate.</li>
      <li>Fixed overflow when calculating atime, ctime and mtime on File.stat().</li>
      <li>Fixed compilation error casting getEndPos to usize.</li>
      <li>Fixed preadv, preadv2, pwritev and pwritev2.</li>
      <li>Fixed seteuid and setegid.</li>
      <li>Replaced legacy 16-bit syscalls with 32-bit versions when appropriate.</li>
      <li>Added missing clobbers on arm-eabi and arm64 syscall conventions.</li>
    </ul>
    <p>
    After all these improvements, 32-bit ARM support is leveled-up to {#link|Tier 2 Support#}.
    Along with improvements made to {#link|Test Coverage#}, the following targets are
    now covered by the Zig test suite:
    </p>
    <ul>
      <li><strong>armv8_5a-linux-none</strong> (no libc)</li>
      <li><strong>armv8_5a-linux-musl</strong> (building {#link|musl 1.1.23#} from source,
        statically linking against it, and using it for OS APIs)</li>
      <li><a href="https://github.com/ziglang/zig/issues/3287">armv8_5a-linux-gnu test coverage is not passing yet</a></li>
    </ul>
    <p class="file">arm32-test.zig</p>
    <pre>{#syntax#}
const builtin = @import("builtin");
const std = @import("std");
const assert = std.debug.assert;

test "cross compiled unit test" {
    assert(builtin.arch == .arm);
}
    {#endsyntax#}</pre>
<pre><code class="shell">$ zig test arm32-test.zig -target armv8-linux --test-cmd qemu-arm --test-cmd-bin
1/1 test "cross compiled unit test"...OK
All tests passed.</code></pre>
    <p>
    After updating to {#link|musl 1.1.23#}, Zig's <code>clone</code> on arm32 is updated to
    latest musl implementation.
    </p>
    <p>
    Remaining issues to solve in order to achieve
    <a href="https://github.com/ziglang/zig/issues/3174">Tier 1 Support for ARM 32-bit Linux</a>:
    </p>
    <ul>
      <li><a href="https://github.com/ziglang/zig/issues/3322">armv7 __aeabi_uidivmod produces undefined instruction exception</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/3289">std lib tests failing on arm 32-bit</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/3287">unable to build glibc for target armv8-linux-gnueabihf </a></li>
      <li><a href="https://github.com/ziglang/zig/issues/2767">Constant packed struct instantiations can generate incorrect unaligned loads on armv4t/armv5</a></li>
      <li>Add {#link|Test Coverage#} for {#link|Debug Info and Stack Traces#} for this target.</li>
      <li>Come up with a way for the Continuous Integration service to create 32-bit ARM binaries
        for the <a href="/download">download page</a>.</li>
    </ul>
    {#header_close#}

    {#header_open|MSYS2 Support#}
    <p>
    Although Zig does not officially support <a href="https://www.msys2.org/">MSYS2</a>
    as a host target, <a href="https://github.com/emekoi">emekoi</a> has dutifully maintained
    unofficial support. Thanks to emekoi's efforts, one can build and run the stage1 C++ compiler
    of Zig in an MSYS2 environment.
    </p>
    <p>
    Note: sometimes "MinGW" is used as a shorthand to mean "MSYS2". However, it is not
    to be confused with {#link|mingw-w64|Zig ships with mingw-w64#},
    or with the unrelated project, <a href="http://mingw.org/">MinGW</a>. MinGW-w64 is
    a fork of MinGW, which adds support for more architectures (such as 64-bit Windows)
    and more system APIs. When someone says "MinGW", it's almost certain they either
    mean "MSYS2" (which is based on MinGW-w64) or "MinGW-w64" instead.
    </p>
    <p>
    Here is the list of things emekoi did to maintain unofficial support for MSYS2:
    </p>
    <ul>
      <li>fixed linking of system libraries on msys2</li>
      <li>added code for linking libc on msys2</li>
      <li>made lld flags on windows consistent</li>
      <li>renamed add_gnu_link_args</li>
      <li>fixed stack protector issues</li>
      <li>added static_crt_dir to libc file</li>
      <li>fixed visibility of zig_libc_cc_print_file_name</li>
      <li>supress warnings for format strings on msys64</li>
      <li>make string literal const on windows</li>
      <li>increase stack size for msys2</li>
      <li>fixed compilation on mingw-w64</li>
      <li>fixed static linking on mingw-w64</li>
      <li>fixed size of ZigClangAPValue on mingw-w64</li>
      <li>improved CMake file for msys2</li>
      <li>fixed backtraces when linking libc on msys2</li>
      <li>avoid passing -static to msvc when static linking</li>
    </ul>
    {#header_close#}

    {#header_open|FreeBSD Support#}
    <p>
    stratact made the following changes:
    </p>
    <ul>
      <li>Added missing <code>&lt;stdint.h&gt;</code> include for <code>uint8_t</code> type declaration.</li>
      <li>Added needed FreeBSD check to link to libpthread.</li>
      <li>Added missing C <code>dl_iterate_phdr</code> function for FreeBSD.</li>
    </ul>
    <p>
    This combined with disabling some of the
    <a href="https://github.com/ziglang/zig/issues/3251">failing standard library tests for FreeBSD</a>,
    stratact was able to enable more {#link|Test Coverage#} for FreeBSD. Now the Continuous Integration
    server runs 7 additional kinds of tests from the test suite, instead of only the behavior tests.
    </p>
    <p>
    stratact reports all tests passing locally, however, we have run into memory limits of
    <a href="https://sourcehut.org/">SourceHut</a>, which is the service used to run FreeBSD tests.
    Drew DeVault has understandably denied our request for more RAM, and so we are left with
    disabled test coverage until Zig can finish self-hosting, or improve the memory usage of
    the C++ stage1 compiler.
    </p>
    <p>
    The set of remaining issues until
    <a href="https://github.com/ziglang/zig/issues/1759">Tier 1 FreeBSD Support for x86_64</a> is now:
    </p>
    <ul>
      <li><a href="https://github.com/ziglang/zig/issues/3251">The event tests hang on FreeBSD</a>.
        Event-based code is still pending a rewrite now that {#link|Async Functions#} have been redesigned.</li>
      <li><a href="https://github.com/ziglang/zig/issues/3210">FreeBSD CI tests disabled due to using more memory than sr.ht provides</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/2876">add FreeBSD libc as a cross compilation target</a>.
        This is the task to do for FreeBSD what Zig already does for {#link|musl|musl 1.1.23#}, {#link|glibc|glibc 2.30#}, and {#link|mingw-w64|Zig ships with mingw-w64#}.</li>
    </ul>
    {#header_close#}

    {#header_open|WebAssembly Support#}
    <p>
    During the 0.5.0 release cycle, Shritesh Bhattarai joined the Zig community and made significant
    contributions to Zig's <a href="https://webassembly.org/">WebAssembly</a> and
    <a href="https://wasi.dev/">WASI (Web Assembly System Interface)</a> support.
    </p>
    <p>
    He got {#link|compiler-rt#} working and tweaked the target settings such as:
    </p>
    <ul>
      <li>disabling error return traces</li>
      <li>forcing single-threaded mode</li>
      <li>making the executable file extension ".wasm"</li>
    </ul>
    <p>
    Thanks to this as well as Shritesh adding basic standard library support for the WASI target, as well as
    improving the linker settings that Zig uses, WebAssembly and WASI are now {#link|Tier 2 Support#}
    targets!
    </p>
    <p>
    As a demo, Shritesh created <a href="https://shritesh.github.io/zigfmt-web/">zigfmt-web</a>, which
    is a web page that will run <code>zig fmt</code> on a block of code, using the <em>same
    implementation as official zig fmt</em>.
    </p>
    <p>
    Shritesh created a basic allocator intended to be used on the WebAssembly target,
    <code>std.heap.wasm_allocator</code>. This uses the WebAssembly intrinsics to request memory
    from the host, and is not capable of freeing memory. The standard library does not yet have
    an allocator for WebAssembly that can reclaim freed memory. See
    <a href="https://github.com/fengb/zee_alloc/">zee_alloc</a> for a community project
    attempting to solve this use case.
    </p>
    <p>
    Shritesh also created a <a href="https://shritesh.github.io/zig-wasm-dom/">demo of Zig interacting with the DOM via JS</a> (<a href="https://github.com/shritesh/zig-wasm-dom">source</a>).
    </p>
    <p>Other miscellaneous improvements to WebAssembly:</p>
    <ul>
      <li>update <code>std.os.page_size</code> for WebAssembly</li>
      <li>Benjamin Feng switched wasm export-all to only values marked exports, so that unused
        symbols get properly garbage collected, resulting in smaller wasm binaries.</li>
      <li>LemonBoy implemented {#link|compiler-rt#} builtins for WebAssembly.</li>
      <li>Benjamin Feng updated the library prefix to be empty for WebAssembly rather than "lib".</li>
    </ul>
    <p>
    Zig now provides a {#link|Freestanding libc#}, which is available when linking libc
    for the WebAssembly target. It is not yet fully complete, but you can get a sense of the
    use case for it with this demo project:
    <a href="https://github.com/andrewrk/lua-in-the-browser">lua-in-the-browser</a>
    </p>
    <p>This use case led to several improvements to Zig's WebAssembly support:</p>
    <ul>
      <li><code>build-exe</code> is for executables which have a <code>main()</code>.
        <code>build-lib</code> is for building libraries of functions to use from,
        for example, a web browser environment.</li>
      <li>For now pass <code>--export-all</code> for libraries when there are any
         C objects because we have no way to detect the list of exports
         when compiling C code.</li>
      <li>Zig no longer passes <code>--no-entry</code> to the linker for executables.
        If you want <code>--no-entry</code> then use <code>build-lib</code>.</li>
      <li>Made the "musl" ABI the default ABI for wasm32-freestanding.</li>
      <li><code>build-exe</code> does include the startup code that supplies <code>_start</code> for the
        <code>wasm32-freestanding</code> target. Previously this did not occur because
        of logic excluding "freestanding".</li>
      <li><code>build-lib</code> for <code>wasm32-freestanding</code> target gets
        linked by LLD. To avoid infinite recursion, {#link|compiler-rt#} and
        {#link|Freestanding libc#} are built as objects rather than libraries.</li>
      <li>"lib" prefix and ".wasm" extension instead of ".a". Rather than
        <code>build-lib foo.zig</code> producing "libfoo.a", now it produces "foo.wasm".</li>
      <li>{#link|Freestanding libc#} only provides <code>_start</code> symbol for wasm when linking libc.</li>
    </ul>
    <p>
    Zig is particularly well suited to creating reasonably small &amp; fast WebAssembly
    binaries. Here are some demos of WebAssembly projects from Zig community members:
    </p>
    <ul>
      <li><a href="https://dbandstra.github.io/oxid/">Oxid</a> - an arcade-style game where you fight waves of monsters in a fixed-screen maze.</li>
      <li><a href="https://fengb.github.io/fundude/">FUNâœœDUDE</a> - gameboy emulator.</li>
      <li><a href="https://raulgrell.github.io/tetris/">Tetris</a> - WebGL tetris.</li>
    </ul>
    {#header_close#}

    {#header_open|UEFI Support#}
    <p>
    Nick Erdmann has been reading the
    <a href="https://uefi.org/sites/default/files/resources/UEFI_Spec_2_8_final.pdf">UEFI specification</a>
    and improving Zig support for this target.
    </p>
    <p>Zig's {#link|Standard Library#} now integrates more cleanly with UEFI, and other things
    now "just work" such as PDB files and 0x0 addresses.</p>
    <p>
    Many of the UEFI protocol definitions are now available in {#syntax#}std.os.uefi.protocols{#endsyntax#}.
    </p>
    <p>
    Nick has clean and well-organized demo projects which serve as resources to help others
    learn how to do UEFI programming:
    </p>
    <ul>
      <li><a href="https://github.com/nrdmn/uefi-examples">uefi-examples</a> - tutorials</li>
      <li><a href="https://github.com/nrdmn/uefi-paint">uefi-paint</a> - UEFI-bootable touch paint app</li>
      <li><a href="https://github.com/nrdmn/uefi-freetype">uefi-freetype</a> -
        <a href="https://twitter.com/andy_kelley/status/1176561072398098432">changing the system BIOS to use Comic SansðŸ¤¡</a></li>
    </ul>
    {#header_close#}

    {#header_open|iOS Support#}
    <p>
    Matthew Iannucci added initial support for iOS targets (<a href="https://github.com/ziglang/zig/issues/2237">#2237</a>).
    </p>
    <p>
    However iOS remains a {#link|Tier 3 Support#} target. There are no known
    active Zig projects targeting iOS.
    </p>
    {#header_close#}

    {#header_open|MIPS Support#}
    <p>
    LemonBoy implemented {#link|Thread Local Storage#} for architectures that
    have thread pointer offsets, such as mipsel. He updated the {#link|Standard Library#}
    with the Linux system bits for the mipsel architecture, and worked with {#link|musl|musl 1.1.23#}
    upstream to get it
    <a href="https://www.openwall.com/lists/musl/2019/09/27/1/2">patched</a>
    enough to be able to successfully build with Clang for this target. Zig carries this patch in 0.5.0.
    </p>
    <p>
    After these changes, MIPS now has {#link|Tier 2 Support#}!
    LemonBoy reports running a Zig binary on his router:
    </p>
    <pre>18:59 &lt;TheLemonMan&gt; just got a Zig binary running on my mips32 router, yay</pre>
    <p>
    These targets are now covered by the Zig test suite:
    </p>
    <ul>
      <li><strong>mipsel-linux-none</strong> (no libc)</li>
      <li><strong>mipsel-linux-musl</strong> (building {#link|musl 1.1.23#} from source,
        statically linking against it, and using it for OS APIs)</li>
      <li><a href="https://github.com/ziglang/zig/issues/2058">mipsel-linux-gnu remains to be investigated</a></li>
    </ul>
    <p>
    Aside from investigating <code>mipsel-linux-gnu</code>, the only remaining issues standing in the way of
    <a href="https://github.com/ziglang/zig/issues/3345">Tier 1 Support for MIPS Little-Endian Linux (mipsel-linux)</a>
    are:
    </p>
    <ul>
      <li><a href="https://github.com/ziglang/zig/issues/3317">LLVM miscompiles some vector instructions</a> - we still need to file the upstream bug report</li>
      <li>Add {#link|Test Coverage#} for {#link|Debug Info and Stack Traces#} for this target.</li>
      <li>Come up with a way for the Continuous Integration service to create binaries for
        the <a href="/download">download page</a>.</li>
    </ul>
    <p class="file">mips-test.zig</p>
    <pre>{#syntax#}
const builtin = @import("builtin");
const std = @import("std");
const assert = std.debug.assert;

test "cross compiled unit test" {
    assert(builtin.arch == .mipsel);
}
    {#endsyntax#}</pre>
<pre><code class="shell">$ zig test mips-test.zig -target mipsel-linux --test-cmd qemu-mipsel --test-cmd-bin
1/1 test "cross compiled unit test"...OK
All tests passed.</code></pre>
    {#header_close#}

    {#header_open|Android Support#}
    <p><a href="https://github.com/meme">meme</a> joined the Zig community and contributed improvements
    to the target <code>aarch64-linux-android</code>. Thanks to their efforts, Zig now has
    {#link|Tier 2 Support#} for Android.
    </p>
    <p>
    Here's an example of building an Android executable with Zig:
    </p>
    <p class="file">hello_android.zig</p>
    <pre>{#syntax#}
const std = @import("std");

pub fn main() void {
    std.debug.warn("Hello, Android!");
}
    {#endsyntax#}</pre>
<pre><code class="shell">$ zig build-exe hello_android.zig -target aarch64-linux-android
$ file ./hello_android
./hello_android: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, with debug_info, not stripped</code></pre>
    <p>In this example, there is no {#link|libc#} dependency. However, Zig does know how to integrate
    with Android's libc. The first step is to create a libc text file describing where various paths
    are. One can obtain a template for this file by executing <code>zig libc</code>. In this example,
    I've taken the template and populated it based on the path to the Android NDK in my downloads
    folder:</p>
    <p class="file">android_libc.txt</p>
    <pre><code># The directory that contains `stdlib.h`.
# On POSIX-like systems, include directories be found with: `cc -E -Wp,-v -xc /dev/null`
include_dir=/home/andy/Downloads/android-ndk-r20/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include

# The system-specific include directory. May be the same as `include_dir`.
# On Windows it's the directory that includes `vcruntime.h`.
# On POSIX it's the directory that includes `sys/errno.h`.
sys_include_dir=/home/andy/Downloads/android-ndk-r20/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include

# The directory that contains `crt1.o` or `crt2.o`.
# On POSIX, can be found with `cc -print-file-name=crt1.o`.
# Not needed when targeting MacOS.
crt_dir=/home/andy/Downloads/android-ndk-r20/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/lib/aarch64-linux-android/21

# The directory that contains `crtbegin.o`.
# On POSIX, can be found with `cc -print-file-name=crtbegin.o`.
# Not needed when targeting MacOS.
static_crt_dir=/home/andy/Downloads/android-ndk-r20/toolchains/llvm/prebuilt/linux-x86_64/lib/gcc/aarch64-linux-android/4.9.x

# The directory that contains `vcruntime.lib`.
# Only needed when targeting MSVC on Windows.
msvc_lib_dir=

# The directory that contains `kernel32.lib`.
# Only needed when targeting MSVC on Windows.
kernel32_lib_dir=</code></pre>
    <p class="file">hello_libc.zig</p>
    <pre>{#syntax#}
const std = @import("std");

extern fn printf(msg: [*]const u8, ...) c_int;

pub fn main() void {
    _ = printf(c"hello android libc\n");
}
    {#endsyntax#}</pre>
<pre><code class="shell">$ zig build-exe hello_libc.zig -target aarch64-linux-android -lc --libc android_libc.txt
$ file ./hello_libc
./hello_libc: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /system/bin/linker64, with debug_info, not stripped</code></pre>
    {#header_close#}
    {#header_close#}

    {#header_open|Language Changes#}
    <ul>
      <li>Slice types no longer have field access.
        Instead, use {#syntax#}@typeInfo(Slice).Pointer.child{#endsyntax#}.</li>
      <li>Enum literals now implicit cast to tagged unions.</li>
      <li>Allow implicit casting optional pointer to optional {#syntax#}c_void{#endsyntax#} pointer.</li>
      <li>Sam Tebbs added implicit cast for {#syntax#}*[N]T{#endsyntax#} to {#syntax#}[*c]T{#endsyntax#}.</li>
      <li>Stevie Hryciw made {#syntax#}anyerror{#endsyntax#} no longer a keyword. <a href="https://github.com/ziglang/zig/issues/2835">#2835</a></li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#cmpxchgStrong">@cmpxchgStrong</a> and <a href="https://ziglang.org/documentation/0.5.0/#cmpxchgWeak">@cmpxchgWeak</a> now support 128-bit integers on x86_64.</li>
      <li>{#syntax#}comptime_int{#endsyntax#} now implicit casts to {#syntax#}comptime_float{#endsyntax#}.</li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#typeOf">@typeOf</a> now guarantees no runtime side effects.</li>
      <li>Timon Kruiper added implicit casting from enum literal to optional enum and implicit casting to
        payload of error union.</li>
      <li>LemonBoy added the {#syntax#}noinline{#endsyntax#} keyword for function declarations.</li>
      <li>Comparison between union tag and enum literal is now allowed thanks to LemonBoy. <a href="https://github.com/ziglang/zig/issues/2810">#2810</a></li>
      <li>LemonBoy made Single-element {#syntax#}enum{#endsyntax#} default to {#syntax#}u0{#endsyntax#}.
        However, {#syntax#}comptime_int{#endsyntax#} is still allowed as an explicit enum tag type. <a href="https://github.com/ziglang/zig/issues/2997">#2997</a></li>
    </ul>

    {#header_open|usingnamespace#}
      <p>
      {#syntax#}usingnamespace{#endsyntax#} is a top level declaration that imports all the public declarations of
      the operand, which must be a {#syntax#}struct{#endsyntax#}, {#syntax#}union{#endsyntax#}, or
      {#syntax#}enum{#endsyntax#}, into the current scope:
      </p>
      {#code_begin|test|usingnamespace#}
usingnamespace @import("std");

test "using std namespace" {
    debug.assert(true);
}
      {#code_end#}
      <p>
      Instead of the above pattern, it is generally recommended to explicitly alias individual declarations.
      However, {#syntax#}usingnamespace{#endsyntax#} has an important use case when organizing the public
      API of a file or package. For example, one might have <code>c.zig</code> with all of the
      <a href="https://ziglang.org/documentation/0.5.0/#Import-from-C-Header-File">C imports</a>:
      </p>
      <pre>{#syntax#}
pub usingnamespace @cImport({
    @cInclude("epoxy/gl.h");
    @cInclude("GLFW/glfw3.h");
    @cDefine("STBI_ONLY_PNG", "");
    @cDefine("STBI_NO_STDIO", "");
    @cInclude("stb_image.h");
});
      {#endsyntax#}</pre>
      <p>
      The above example demonstrates using {#syntax#}pub{#endsyntax#} to qualify the
      {#syntax#}usingnamespace{#endsyntax#} additionally makes the imported declarations
      {#syntax#}pub{#endsyntax#}. This can be used to forward declarations, giving precise control
      over what declarations a given file exposes.
      </p>
      <p>
      In Zig 0.4.0, this feature existed as <code>use</code>, but it only worked at the top-level
      scope, and only for structs. The feature was also considered unstable.
      </p>
      <p>Thank you LemonBoy for fixing {#syntax#}usingnamespace{#endsyntax#} outside the top-level scope, and
      making it work with arbitrary structs.</p>
      <p>
      In Zig 0.5.0, both <code>use</code> and {#syntax#}usingnamespace{#endsyntax#} are accepted, and
      {#link|zig fmt#} automatically converts to the canonical syntax. The next release of Zig after this
      one will remove the old syntax.
      </p>
      <p>
      This feature is now stable and planned to be included in
      <a href="https://github.com/ziglang/zig/issues/75">the language specification</a>.
      </p>
    {#header_close#}

    {#header_open|External Thread Local Variables#}
    <p>
    Zig now always respects {#syntax#}threadlocal{#endsyntax#} for variables with external linkage.
    </p>
    <p>
    Previously, if you had, for example:
    </p>
    <pre>{#syntax#}extern "c" threadlocal var errno: c_int;{#endsyntax#}</pre>
    <p>
    This would turn {#syntax#}errno{#endsyntax#} into a normal variable for <code>--single-threaded</code>
    builds. However for variables with external linkage, there is an ABI
    to uphold.
    </p>
    <p>
    This is needed to make errno work for DragonFly BSD. See <a href="https://github.com/ziglang/zig/issues/2381">#2381</a>.
    </p>
    {#header_close#}

    {#header_open|@hasField and @hasDecl#}
    <pre>{#syntax#}@hasField(comptime Container: type, comptime name: []const u8) bool{#endsyntax#}</pre>
    <pre>{#syntax#}@hasDecl(comptime Container: type, comptime name: []const u8) bool{#endsyntax#}</pre>
    <p>
    The new builtin function <a href="https://ziglang.org/documentation/0.5.0/#hasField">@hasField</a> returns whether the field name of a struct, union, or enum exists.
    The result is a compile time boolean. It does not include functions, variables, or constants.
    </p>
    <p>
    The new builtin function <a href="https://ziglang.org/documentation/0.5.0/#hasDecl">@hasDecl</a> returns whether or not a struct, enum, or union has a declaration.
    </p>
    {#code_begin|test|has_builtins#}
const std = @import("std");
const assert = std.debug.assert;

const Foo = struct {
    nope: i32,

    pub var blah = "xxx";
    const hi = 1;
};

test "@hasDecl and @hasField" {
    assert(@hasDecl(Foo, "blah"));

    // Even though `hi` is private, @hasDecl returns true because this test is
    // in the same file scope as Foo. It would return false if Foo was declared
    // in a different file.
    assert(@hasDecl(Foo, "hi"));

    // @hasDecl is for declarations; not fields.
    assert(!@hasDecl(Foo, "nope"));
    assert(!@hasDecl(Foo, "nope1234"));

    assert(@hasField(Foo, "nope"));
}
    {#code_end#}
    <p>
    Thanks to Shawn Landden for initial implementation and documentation of <a href="https://ziglang.org/documentation/0.5.0/#hasField">@hasField</a>.
    </p>
    {#header_close#}

    {#header_open|C Pointers Support Optional Syntax#}
    <p>
    When {#link|translating C code|C Translation#}, Zig does not know whether pointer types
    should be translated to <code>*</code> or <code>[*]</code> pointers. Instead, they
    are translated to <a href="https://ziglang.org/documentation/0.5.0/#C-Pointers">C Pointers</a>.
    </p>
    <p>
    As the documentation notes, this type is to be avoided whenever possible. The only valid reason
    for using a C pointer is in auto-generated code from translating C code. 
    </p>
    <p>
    Interfacing with C pointer types happens due to direct interop with translated .h files. It's always
    a future possibility to rewrite the .h file in .zig to gain better type-safety. Previously,
    optional syntax, such as {#syntax#}if{#endsyntax#}, {#syntax#}orelse{#endsyntax#}, {#syntax#}null{#endsyntax#},
    and {#syntax#}.?{#endsyntax#} did not work for C pointers. This would cause compile errors if
    the type signature of the external function prototypes were improved to have the real pointer types
    rather than C pointers.
    </p>
    <p>
    Now, this syntax works, and so there is no penalty for starting out with auto-translated headers, and then
    later "upgrading" to better typed bindings.
    </p>
    {#code_begin|test|getenv#}
    {#link_libc#}
const getenv = @cImport(@cInclude("stdlib.h")).getenv;

// note: this is just a demo of C pointers with optional syntax.
// std.process has better API for getenv.

test "C pointers with optional syntax" {
    const ptr1 = getenv(c"HOME").?; // don't do this ðŸ’¥
    const ptr2 = getenv(c"HOME") orelse return error.Homeless; // OK

    if (getenv(c"HOME")) |ptr3| {
        // also OK
    }

    const ptr4 = getenv(c"HOME");
    if (ptr4 == null) {
        // also works
    }
}
    {#code_end#}
    <p>
    The auto-translated <code>getenv</code> prototype looks like this:
    </p>
    <pre>{#syntax#}
pub extern fn getenv(__name: [*c]const u8) [*c]u8;
    {#endsyntax#}</pre>
    <p>
    If we were to improve this prototype with correct pointer types, the test will still pass:
    </p>
    {#code_begin|test|getenv2#}
    {#link_libc#}
pub extern fn getenv(name: [*]const u8) ?[*]u8;

// note: this is just a demo of C pointers with optional syntax.
// std.process has better API for getenv.

test "C pointers with optional syntax" {
    const ptr1 = getenv(c"HOME").?; // don't do this ðŸ’¥
    const ptr2 = getenv(c"HOME") orelse return error.Homeless; // OK

    if (getenv(c"HOME")) |ptr3| {
        // also OK
    }

    const ptr4 = getenv(c"HOME");
    if (ptr4 == null) {
        // also works
    }
}
    {#code_end#}
    {#header_close#}

    {#header_open|Switching on Error Sets#}
    <p>
    Using {#syntax#}switch{#endsyntax#} on an
    <a href="https://ziglang.org/documentation/0.5.0/#Error-Set-Type">error set</a> now provides a way
    to capture an error value with a subset type:
    </p>
    {#code_begin|exe|switch_err_set_1#}
const std = @import("std");
const os = std.os;

const Error = error{
    AccessDenied,
    FileTooBig,
    IsDir,
    SymLinkLoop,
    ProcessFdQuotaExceeded,
    NameTooLong,
    SystemFdQuotaExceeded,
    NoDevice,
    FileNotFound,
    SystemResources,
    NoSpaceLeft,
    NotDir,
    PathAlreadyExists,
    DeviceBusy,
    InputOutput,
    OperationAborted,
    BrokenPipe,
    Unexpected,
};

pub fn main() Error!void {
    // open a normal, blocking file descriptor.
    const fd = try os.open("/dev/urandom", os.O_RDONLY, 0);
    defer os.close(fd);

    // we did *not* use O_NONBLOCK, so the OS will not give us
    // EWOULDBLOCK.
    var buf: [100]u8 = undefined;
    const nbytes = try readBlocking(fd, &buf);
}

/// Asserts that fd was opened in a blocking fashion.
fn readBlocking(fd: os.fd_t, buffer: []u8) !usize {
    return std.os.read(fd, buffer) catch |err| switch (err) {
        error.WouldBlock => unreachable, // Remove this to observe compile error
        else => |e| return e,
    };
}
    {#code_end#}
    <p>
    Here you can see that the program compiled just fine, even though {#syntax#}error.WouldBlock{#endsyntax#}
    is not found in the error set. This is because the function {#syntax#}readBlocking{#endsyntax#}
    switched on the error set, and handled the {#syntax#}error.WouldBlock{#endsyntax#} case. This means
    the error set type of value captured by the {#syntax#}else{#endsyntax#} does not include the value
    {#syntax#}error.WouldBlock{#endsyntax#}.
    </p>
    <p>
    In addition to this, Zig allows capturing the payload from multiple error set values:
    </p>
    {#code_begin|exe|switch_err_set_2#}
const std = @import("std");
const os = std.os;

const Error = error{
    AccessDenied,
    FileTooBig,
    IsDir,
    SymLinkLoop,
    ProcessFdQuotaExceeded,
    NameTooLong,
    SystemFdQuotaExceeded,
    NoDevice,
    FileNotFound,
    SystemResources,
    NoSpaceLeft,
    NotDir,
    PathAlreadyExists,
    DeviceBusy,
    OperationAborted,
    BrokenPipe,
    Unexpected,
};

pub fn main() Error!void {
    // open a normal, blocking file descriptor.
    const fd = try os.open("/dev/urandom", os.O_RDONLY, 0);
    defer os.close(fd);

    // we did *not* use O_NONBLOCK, so the OS will not give us
    // EWOULDBLOCK.
    var buf: [100]u8 = undefined;
    const nbytes = try readBlocking(fd, &buf);
}

/// Asserts that fd was opened in a blocking fashion.
fn readBlocking(fd: os.fd_t, buffer: []u8) !usize {
    return std.os.read(fd, buffer) catch |err| switch (err) {
        error.WouldBlock, error.InputOutput => |e| {
            std.debug.panic("unexpected: {}\n", e);
        },
        else => |e| return e,
    };
}
    {#code_end#}
    <p>
    In this example, {#syntax#}error.InputOutput{#endsyntax#} was lifted out of {#syntax#}Error{#endsyntax#}
    since it is handled inside {#syntax#}readBlocking{#endsyntax#}. The {#syntax#}e{#endsyntax#} capture value
    has type {#syntax#}error{WouldBlock,InputOutput}{#endsyntax#}.
    </p>
    {#header_close#}

    {#header_open|Bit Manipulation Builtin Functions#}
    <p>Shawn Landden improved the consistency of the names and parameters of bit manipulation intrinsics.</p>
    <ul>
      <li>Rename <code>@bitreverse</code> to <a href="https://ziglang.org/documentation/0.5.0/#bitReverse">@bitReverse</a> to adhere to
        <a href="https://ziglang.org/documentation/0.5.0/#Style-Guide">naming conventions</a>.</li>
      <li>Rename <code>@bswap</code> to <a href="https://ziglang.org/documentation/0.5.0/#byteSwap">@byteSwap</a>.</li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#clz">@clz</a>, <a href="https://ziglang.org/documentation/0.5.0/#ctz">@ctz</a>, <a href="https://ziglang.org/documentation/0.5.0/#popCount">@popCount</a>, <a href="https://ziglang.org/documentation/0.5.0/#byteSwap">@byteSwap</a>, and <a href="https://ziglang.org/documentation/0.5.0/#bitReverse">@bitReverse</a> now have an explicit type parameter.</li>
    </ul>
    <pre>{#syntax#}@bitReverse(comptime T: type, integer: T) T{#endsyntax#}</pre>
    <pre>{#syntax#}@byteSwap(comptime T: type, operand: T) T{#endsyntax#}</pre>
    <pre>{#syntax#}@clz(comptime T: type, integer: T){#endsyntax#}</pre>
    <pre>{#syntax#}@ctz(comptime T: type, integer: T){#endsyntax#}</pre>
    <pre>{#syntax#}@popCount(comptime T: type, integer: T){#endsyntax#}</pre>
    <p>
    <a href="https://github.com/ziglang/zig/issues/2119">#2119</a> <a href="https://github.com/ziglang/zig/issues/2120">#2120</a>
    </p>
    {#header_close#}

    {#header_open|Undeclared Identifiers in Compile-Time Dead Branches#}
    <p>
    Zig no longer validates whether identifiers exist in dead {#syntax#}comptime{#endsyntax#} branches:
    </p>
    {#code_begin|test|dead_comptime_branch#}
test "dead comptime branch" {
    if (false) {
        does_not_exist = thisFunctionAlsoDoesNotExist();
    }
}
    {#code_end#}
    <p>
    This is counter-intuitive, but consider that the set of available identifiers may depend on
    {#syntax#}comptime{#endsyntax#} parameters, such as the target OS:
    </p>
    <pre>{#syntax#}
const builtin = @import("builtin");

usingnamespace switch (builtin.os) {
    .windows => @import("windows_stuff.zig"),
    else => @import("posix_stuff.zig"),
};

test "example" {
    if (builtin.os == .windows) {
        ExitProcess(0);
    } else {
        exit(0);
    }
}
    {#endsyntax#}</pre>
    <p>
    In practice, this has resulted in various code cleanups throughout the standard library.
    </p>
    <p>
    Zig's lazy analysis, while convenient, surfaces the inherent problems of conditional compilation.
    See the related proposal:
    <a href="https://github.com/ziglang/zig/issues/3028">"multibuilds" - a plan to harmonize conditional compilation with compile errors, documentation, and IDEs</a>
    </p>
    {#header_close#}

    {#header_open|Default Struct Field Values#}
    <p>
    Each struct field may now have an expression indicating the default field value. Such expressions
    are executed at {#syntax#}comptime{#endsyntax#}, and allow the field to be omitted in a struct
    literal expression:
    </p>
    {#code_begin|test|default_fields#}
const Foo = struct {
    a: i32 = 1234,
    b: i32,
};

test "default struct field values" {
    const x = Foo{
        .b = 5,
    };
    if (x.a + x.b != 1239) {
        @compileError("it's even comptime known!");
    }
}
    {#code_end#}
    {#header_close#}

    {#header_open|Array Literal Syntax#}
    <p>
    The array literal syntax has changed, when inferring the size.
    </p>
    <p>Old syntax:</p>
    <pre><code>[]i32{1, 2, 3}</code></pre>
    <p>New syntax:</p>
    <pre>{#syntax#}[_]i32{1, 2, 3}{#endsyntax#}</pre>
    <p>
    The previous syntax used to look too much like instantiating a slice. This caused all kinds
    of confusion. Now it's pretty clear that the type is an array.
    </p>
    <a href="https://github.com/ziglang/zig/issues/1797">#1797</a>
    {#header_close#}

    {#header_open|@import("root")#}
    <p>
    The <a href="https://ziglang.org/documentation/0.5.0/#Root-Source-File">Root Source File</a>
    (in the case of <code>build-exe</code>, the file with {#syntax#}pub fn main{#endsyntax#})
    is now available to import anywhere, using {#syntax#}@import("root"){#endsyntax#}.
    Combined with {#link|@hasDecl|@hasField and @hasDecl#},
    this allows library code to support global configuration settings based on declarations in the
    root source file.
    </p>
    <p>
    The {#link|Standard Library#} takes advantage of this for several use cases. One example is
    the {#link|Default Segfault Handler#}. It works like this (from <code>std.debug</code>):
    </p>
    <pre>{#syntax#}
const root = @import("root");

/// Whether or not the current target can print useful debug information when a segfault occurs.
pub const have_segfault_handling_support = builtin.os == .windows or
    (builtin.arch == builtin.Arch.x86_64 and builtin.os == .linux);

pub const enable_segfault_handler: bool = if (@hasDecl(root, "enable_segfault_handler"))
    root.enable_segfault_handler
else
    runtime_safety and have_segfault_handling_support;

pub fn maybeEnableSegfaultHandler() void {
    if (enable_segfault_handler) {
        std.debug.attachSegfaultHandler();
    }
}
    {#endsyntax#}</pre>
    <p>
    And then Zig's startup code calls {#syntax#}std.debug.maybeEnableSegfaultHandler(){#endsyntax#} just before
    calling {#syntax#}main(){#endsyntax#}.
    </p>
    <p>
    Another place this is used in the standard library is to decide a global "I/O mode", which is
    related to {#link|Async Functions#}.
    </p>
    <p>
    This feature has the capability to be abused, and should be used with care. Any root source file
    declarations that can affect a library's behavior should be well-documented. When Zig gains
    <a href="https://github.com/ziglang/zig/issues/21">documentation generation</a>, the auto-generated
    docs will have the capability to enumerate all the places that depend on a root source file declaration.
    </p>
    <p>Thank you emekoi for the initial implementation of this.</p>
    {#header_close#}

    {#header_open|@mulAdd#}
    <p>
    Zig now has <a href="https://ziglang.org/documentation/0.5.0/#mulAdd">@mulAdd</a>, otherwise known as "fused-multiply-add". 
    </p>
    <pre>{#syntax#}@mulAdd(comptime T: type, a: T, b: T, c: T) T{#endsyntax#}</pre>
    <p>
    Performs {#syntax#}(a * b) + c{#endsyntax#}, except only rounds once, and is thus more accurate.
    Additionally, some targets have a hardware instruction for this, making it potentially faster than
    a userland implementation.
    </p>
    {#code_begin|test|mul_add#}
const std = @import("std");

test "@mulAdd" {
    // In this example we use numbers small enough to avoid rounding errors that would occur
    // without @mulAdd.
    std.testing.expect(@mulAdd(f32, 2.0, 3.0, 4.0) == (2.0 * 3.0) + 4.0);
}
    {#code_end#}
    <p>
    Currently this instruction only works for floating point types, as well as
    {#link|vectors of floating point types|SIMD#}. However, there is
    <a href="https://github.com/ziglang/zig/issues/3321">an open proposal</a>
    to make this work for any types that support {#syntax#}*{#endsyntax#} and {#syntax#}+{#endsyntax#}
    operators, such as integers. The proposal also suggests to remove the explicit type parameter requirement.
    </p>
    <p>Thank you Shawn Landden for the initial implementation of this.</p>
    {#header_close#}

    {#header_open|Builtins for Math Functions#}
    <p>
    Shawn Landden added:
    </p>
    <ul style="columns: 3">
      <li><a href="https://ziglang.org/documentation/0.5.0/#sin">@sin</a></li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#cos">@cos</a></li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#exp">@exp</a></li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#exp2">@exp2</a></li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#ln">@ln</a></li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#log2">@log2</a></li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#log10">@log10</a></li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#fabs">@fabs</a></li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#floor">@floor</a></li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#ceil">@ceil</a></li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#trunc">@trunc</a></li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#round">@round</a></li>
    </ul>
    <pre>{#syntax#}@sin(comptime T: type, value: T) T{#endsyntax#}</pre>
    <pre>{#syntax#}@cos(comptime T: type, value: T) T{#endsyntax#}</pre>
    <pre>{#syntax#}@exp(comptime T: type, value: T) T{#endsyntax#}</pre>
    <pre>{#syntax#}@exp2(comptime T: type, value: T) T{#endsyntax#}</pre>
    <pre>{#syntax#}@ln(comptime T: type, value: T) T{#endsyntax#}</pre>
    <pre>{#syntax#}@log2(comptime T: type, value: T) T{#endsyntax#}</pre>
    <pre>{#syntax#}@log10(comptime T: type, value: T) T{#endsyntax#}</pre>
    <pre>{#syntax#}@fabs(comptime T: type, value: T) T{#endsyntax#}</pre>
    <pre>{#syntax#}@floor(comptime T: type, value: T) T{#endsyntax#}</pre>
    <pre>{#syntax#}@ceil(comptime T: type, value: T) T{#endsyntax#}</pre>
    <pre>{#syntax#}@trunc(comptime T: type, value: T) T{#endsyntax#}</pre>
    <pre>{#syntax#}@round(comptime T: type, value: T) T{#endsyntax#}</pre>
    <p>
    These are builtin functions because some architectures have hardware instructions for these.
    Furthermore, because these functions are well-defined, the optimizer may sometimes be able to
    convert calls to these builtins into better forms.
    </p>
    <p>
    It's planned for Zig to provide <code>libmvec</code> in the future, and these functions will become
    {#link|SIMD#}-capable.
    </p>
    {#header_close#}

    {#header_open|Result Location Semantics#}
    <p>
    What I'm calling <strong>Result Location Semantics</strong> was a large branch of Zig that
    fundamentally changed the way that expressions are semantically analyzed. This was the
    third attempt, which finally succeeded. I abandoned the
    <a href="https://github.com/ziglang/zig/pull/1652">first attempt</a> after
    1 week. The <a href="https://github.com/ziglang/zig/pull/1682">second attempt</a>, which took
    place during the <a href="/download/0.4.0/release-notes.html">0.4.0 release cycle</a>,
    lasted 2 months, but again was regretfully abandoned. However, there were significant parts of the
    second attempt that landed in the eventual implementation.
    </p>
    <p>
    During my work on this branch, the Zig community stepped up and continued to improve master branch
    all the while. You can observe this by seeing how many names are mentioned in these release
    notes. I am proud and grateful of the Zig community for this.
    </p>
    <p>
    Although the implementation was difficult, the user-facing differences of
    <strong>Result Location Semantics</strong> are nearly impossible to detect. The main purpose
    was to pave the way for the redesign of {#link|Async Functions#}.
    </p>
    <p>
    The main thing that this change does is semantically guarantee that no copying happens
    in expressions. As an example:
    </p>
    {#code_begin|test|result_loc#}
const std = @import("std");

const Object = struct {
    tag: i32,
    pt: [2]Point,
};

const Point = struct {
    x: i32,
    y: i32,
};

test "result location semantics" {
    const result = if (condition()) foo(10) else bar();
    std.testing.expect(result.tag == 10);
    std.testing.expect(result.pt[0].x == 69);
    std.testing.expect(result.pt[1].y == 420);
}

fn condition() bool {
    return true;
}

fn foo(arg: i32) Object {
    return baz(arg);
}

fn bar() Object {
    return Object{
        .tag = 1,
        .pt = undefined,
    };
}

fn baz(arg: i32) Object {
    return Object{
        .tag = arg,
        .pt = [_]Point{ nice(), blazet() },
    };
}

fn nice() Point {
    return Point{
        .x = 69,
        .y = 69,
    };
}

fn blazet() Point {
    return Point{
        .x = 420,
        .y = 420,
    };
}
    {#code_end#}
    <p>
    The important thing to note here is that the functions {#syntax#}nice(){#endsyntax#} and
    {#syntax#}blazet(){#endsyntax#} <em>write directly to <strong>result</strong></em> in the
    main test function. There are no intermediate copies, and this is semantically guaranteed
    by the language.
    </p>
    <p>
    With Zig's current semantics, it is actually not possible to observe the difference between
    0.4.0 and 0.5.0 (except with {#link|async function calls|Async Functions#}). However, with
    future proposals to the language it would matter a great deal:
    </p>
    <ul>
      <li><a href="https://github.com/ziglang/zig/issues/2765">result location: ability to refer to the return result location before the `return` statement</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/2761">result locations: unwrap optional and error unions so that the payload can be non-copied</a></li>
    </ul>
    <p>
    The point here is that initialization functions would be able to set up pointer references relative to
    the return value, and have the value be guaranteed to be valid.
    </p>
    <p>
    Before moving on to the next section I want to say a huge thank you to <strong>Michael Dusan</strong>.
    This branch was a dizzying amount of effort, and towards the end of it, Michael
    started contributing. He created test case reductions and even solved some of the regressions,
    such as vector to array conversion not being aligned correctly. This was both unexpected and 
    helpful. It made a serious difference in getting me through to the end of the branch, so that
    we could merge it into master.
    </p>
    <p>
    The other thing that came out of this branch was preferring the "result type" to
    <a href="https://ziglang.org/documentation/0.5.0/#Peer-Type-Resolution">Peer Type Resolution</a>:
    </p>
    {#code_begin|test|result_loc_peer#}
const std = @import("std");
const expect = std.testing.expect;

test "result location type resolution" {
      var f = false;
      var x: i32 = 0;
      x = if (f) 1 else 2;
      expect(x == 2);
}
    {#code_end#}
    <p>
    Additionally:
    </p>
    <ul>
      <li>LemonBoy fixed result loc unwrapping with optional in error union. <a href="https://github.com/ziglang/zig/issues/2899">#2899</a></li>
    </ul>
    {#header_close#}

    {#header_open|@unionInit#}
    <pre>{#syntax#}@unionInit(comptime Union: type, comptime active_field_name: []const u8, init_expr) Union{#endsyntax#}</pre>
    <p>
    This is the same thing as <a href="https://ziglang.org/documentation/0.5.0/#union">union</a>
    initialization syntax, except that the field name is a
    <a href="https://ziglang.org/documentation/0.5.0/#comptime">comptime</a>-known value rather
    than an identifier token.
    </p>
    <p>
    {#syntax#}@unionInit{#endsyntax#} forwards its {#link|result location|Result Location Semantics#} to {#syntax#}init_expr{#endsyntax#}.
    </p>
    <p>Thank you Robert Scott for the initial implementation of <a href="https://ziglang.org/documentation/0.5.0/#unionInit">@unionInit</a>.</p>
    {#header_close#}

    {#header_open|Unicode Escapes#}
    <p>
    Zig's unicode escape syntax is changed to match most other popular programming languages.
    </p>
    <p>Old syntax:</p>
    <pre><code>"\U01f4a9"</code></pre>
    <p>New syntax:</p>
    <pre>{#syntax#}"\u{1f4a9}"{#endsyntax#}</pre>
    <p>This matches JavaScript (since ES6), Lua (since 5.3), Swift (who swapped from our previous syntax!),
    and Rust.</p>
    <p>Thank you daurnimator for doing the research on other languages, and
      Shawn Landden for the implementation.</p>
    <p>
    It is
    <a href="https://github.com/ziglang/zig/issues/2097">planned to additionally allow unicode escapes in character literals</a>,
    since character literals have type {#syntax#}comptime_int{#endsyntax#}. That accepted proposal is marked
    "Contributor Friendly" because it is limited in scope and/or knowledge of Zig internals.
    </p>
    {#header_close#}

    {#header_open|Async Functions#}
    <p>
    {#syntax#}async{#endsyntax#} functions have been completely reworked in Zig 0.5.0. Previously,
    I was calling these "stackless coroutines". However I'm now avoiding the word "coroutine" since
    it means different things to different people, and instead using the phrase "async functions".
    </p>
    <p>
    In Zig 0.4.0, all async functions were generic across an allocator type, all async functions took
    an allocator parameter, and calling an async function could fail. Additionally, async functions
    were required to be annotated as such.
    </p>
    <p>
    In Zig 0.5.0, calling an async function can no longer fail. The async function frame is provided
    by the caller via {#link|Result Location Semantics#}, and can be in the caller's stack frame. Async
    functions are no longer generic, and do not require the {#syntax#}async{#endsyntax#} keyword.
    Zig infers that a function is {#syntax#}async{#endsyntax#} when it observes that the function contains
    a <strong>suspension point</strong>. Async functions can be called the same as normal functions. A
    function call of an async function is a suspend point.
    </p>
    <p>
    When a regular function is called, a frame is pushed to the stack,
    the function runs until it reaches a return statement, and then the frame is popped from the stack.
    At the callsite, the following code does not run until the function returns.
    </p>
    <p>
    An async function is a function whose callsite is split into an {#syntax#}async{#endsyntax#} initiation,
    followed by an {#syntax#}await{#endsyntax#} completion. Its frame is
    provided explicitly by the caller, and it can be suspended and resumed any number of times.
    </p>
    <p>
    Here's a simple example of an async function:
    </p>
    {#code_begin|exe|async_fn#}
const std = @import("std");

var frame: anyframe = undefined;

pub fn main() void {
    std.debug.warn("begin main\n");
    _ = async func();
    std.debug.warn("resume func\n");
    resume frame;
    std.debug.warn("end main\n");
}

fn func() void {
    std.debug.warn("begin func\n");
    frame = @frame();
    suspend;
    std.debug.warn("end func\n");
}
    {#code_end#}
    <p>
    Here we have a seam between non-async (main) and async (func) code.
    A more typical usage of this feature:
    </p>
    {#code_begin|exe|typical_async_await#}
const std = @import("std");
const expect = std.testing.expect;

// Try toggling these
const simulate_fail_download = false;
const simulate_fail_file = false;
const suspend_download = true;
const suspend_file = true;

pub fn main() void {
    _ = async amainWrap();
    // This simulates an event loop
    if (suspend_file) {
        resume global_file_frame;
    }
    if (suspend_download) {
        resume global_download_frame;
    }
}
fn amainWrap() void {
    if (amain()) |_| {
        expect(!simulate_fail_download);
        expect(!simulate_fail_file);
    } else |e| switch (e) {
        error.NoResponse => expect(simulate_fail_download),
        error.FileNotFound => expect(simulate_fail_file),
        else => @panic("test failure"),
    }
}

fn amain() !void {
    const allocator = std.heap.direct_allocator;
    var download_frame = async fetchUrl(allocator, "https://example.com/");
    var download_awaited = false;
    errdefer if (!download_awaited) {
        if (await download_frame) |x| allocator.free(x) else |_| {}
    };

    var file_frame = async readFile(allocator, "something.txt");
    var file_awaited = false;
    errdefer if (!file_awaited) {
        if (await file_frame) |x| allocator.free(x) else |_| {}
    };

    download_awaited = true;
    const download_text = try await download_frame;
    defer allocator.free(download_text);

    file_awaited = true;
    const file_text = try await file_frame;
    defer allocator.free(file_text);

    expect(std.mem.eql(u8, "expected download text", download_text));
    expect(std.mem.eql(u8, "expected file text", file_text));
    std.debug.warn("OK!\n");
}

var global_download_frame: anyframe = undefined;
fn fetchUrl(allocator: *std.mem.Allocator, url: []const u8) anyerror![]u8 {
    const result = try std.mem.dupe(allocator, u8, "expected download text");
    errdefer allocator.free(result);
    if (suspend_download) {
        suspend {
            global_download_frame = @frame();
        }
    }
    if (simulate_fail_download) return error.NoResponse;
    std.debug.warn("fetchUrl returning\n");
    return result;
}

var global_file_frame: anyframe = undefined;
fn readFile(allocator: *std.mem.Allocator, filename: []const u8) anyerror![]u8 {
    const result = try std.mem.dupe(allocator, u8, "expected file text");
    errdefer allocator.free(result);
    if (suspend_file) {
        suspend {
            global_file_frame = @frame();
        }
    }
    if (simulate_fail_file) return error.FileNotFound;
    std.debug.warn("readFile returning\n");
    return result;
}
    {#code_end#}
    <p>
    The important thing to note here is that the {#syntax#}async{#endsyntax#}/{#syntax#}await{#endsyntax#}
    mechanism did not bring in a dependency on the host OS, and it did not bring in a dependency on
    an allocator.
    </p>
    <p>
    Now watch what happens when we do this:
    </p>
    <pre>{#syntax#}
const suspend_download = false;
const suspend_file = false;
    {#endsyntax#}</pre>
    <pre><code class="shell">$ zig build-exe typical_async_await.zig
$ ./typical_async_await
fetchUrl returning
readFile returning
OK!</code></pre>
    <p>
    It's the same output, except in reversed order. With these modifications, <em>there are no async
      functions in the entire program</em>! The expression
    {#syntax#}async fetchUrl(allocator, "https://example.com/"){#endsyntax#} is evaluated as a normal,
    blocking function, as is {#syntax#}async readFile(allocator, "something.txt"){#endsyntax#}.
    The {#syntax#}await{#endsyntax#}s are no-ops.
    </p>
    <p>
    The point here is that the <code>amain</code> function, which is the demo of typical async/await usage,
    works in both an async context and blocking context. The programmer was able to express the inherent
    parallelism of the logic, without resorting to
    <a href="http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">function coloring</a>.
    </p>
    <p>
    There is admittedly a bit of boilerplate in the example.
    <a href="https://github.com/ziglang/zig/issues/3164">Here's the tracking issue for that</a>.
    </p>
    <p>Now for the related {#link|Standard Library#} updates:</p>
    <p>
    This introduces the concept of "IO mode" which is configurable by the
    <a href="https://ziglang.org/documentation/0.5.0/#Root-Source-File">Root Source File</a> (e.g. next to
    {#syntax#}pub fn main{#endsyntax#}). Applications can put this in their root source file:
    </p>
    <pre>{#syntax#}
    pub const io_mode = .evented;
    {#endsyntax#}</pre>
    <p>
    This will populate {#syntax#}std.io.mode{#endsyntax#} to be {#syntax#}std.io.Mode.evented{#endsyntax#}.
    When I/O mode is evented, {#syntax#}std.os.read{#endsyntax#} handles EAGAIN by suspending until the
    file descriptor becomes available for reading. Although the std lib
    event loop supports epoll, kqueue, and Windows I/O Completion Ports,
    this integration with {#syntax#}std.os.read{#endsyntax#} currently only works on Linux.
    </p>
    <p>
    This integration is currently only hooked up to {#syntax#}std.os.read{#endsyntax#}, and not,
    for example, {#syntax#}std.os.write{#endsyntax#}, child processes, and timers. The fact that
    we can do this and still have a working master branch is thanks to Zig's
    lazy analysis, comptime, and inferred async. We can continue to make
    incremental progress on async std lib features, enabling more and more
    test cases and coverage.
    </p>
    <p>
    In addition to {#syntax#}std.io.mode{#endsyntax#} there is {#syntax#}std.io.is_async{#endsyntax#}
    which is equal to {#syntax#}std.io.mode == .evented{#endsyntax#}. In case I/O mode is async,
    {#syntax#}std.io.InStream{#endsyntax#} notices this and the read function pointer becomes an async function
    pointer rather than a blocking function pointer. Even in this case,
    {#syntax#}std.io.InStream{#endsyntax#} can <em>still be used as a blocking input stream</em>.
    Users of the API control whether it is blocking or async at runtime by whether
    or not the read function suspends. In case of file descriptors, for
    example, this might correspond to whether it was opened with {#syntax#}O_NONBLOCK{#endsyntax#}.
    The {#syntax#}noasync{#endsyntax#} keyword makes a function call or {#syntax#}await{#endsyntax#} assert
    that no suspension happens. This assertion has runtime safety enabled.
    </p>
    <p>
    {#syntax#}std.io.InStream{#endsyntax#}, in the case of async I/O, uses by default a 1 MiB
    frame size for calling the read function. If this is too large or too
    small, the application can globally increase the frame size used by
    declaring {#syntax#}pub const stack_size_std_io_InStream = 1234;{#endsyntax#} in their root
    source file. This way, {#syntax#}std.io.InStream{#endsyntax#} will only be generated once,
    avoiding bloat, and as long as this number is configured to be high
    enough, everything works fine. Zig has runtime safety to detect when
    <a href="https://ziglang.org/documentation/0.5.0/#asyncCall">@asyncCall</a> is given too small of a buffer for the frame size.
    </p>
    <p>
    This merge introduces -fstack-report which can help identify large async
    function frame sizes and explain what is making them so big.
    </p>
    <p>
    -fstack-report outputs JSON format, which can then be viewed in a GUI
    that represents the tree structure. As an example, Firefox does a decent
    job of this.
    </p>
    <p>
    One feature that is currently missing is detecting that the call stack
    upper bound is greater than the default for a given target, and passing
    this upper bound to the linker. As an example, if Zig detects that 20
    MiB stack upper bound is needed - which would be quite reasonable -
    currently on Linux the application would only be given the default of 16
    MiB.
    </p>
    <p>
    There is so much to go over with this feature, and these release notes are already ridiculously
    long. I'm going to have to resort to listing out some things here, and rely on a future post
    to elaborate on these features.
    </p>
    <ul>
      <li><a href="https://ziglang.org/documentation/0.5.0/#frameSize">@frameSize</a></li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#frame">@frame</a></li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#Frame">@Frame</a></li>
    </ul>
    <pre>{#syntax#}@frameSize() usize{#endsyntax#}</pre>
    <pre>{#syntax#}@frame() *@Frame(func){#endsyntax#}</pre>
    <pre>{#syntax#}@Frame(func: var) type{#endsyntax#}</pre>
    <p>
    It is confirmed that async functions will solve
    <a href="https://github.com/ziglang/zig/issues/1006">safe recursion</a> in Zig.
    </p>
    {#header_close#}

    {#header_open|SIMD#}
    <p>
    Zig's SIMD support in 0.5.0 is still far from complete, but significant progress has been made.
    </p>
    <p>
    <a href="https://www.subscribestar.com/slandden">Shawn Landden</a> has a
    <a href="https://github.com/ziglang/zig/pull/2945">branch of Zig</a> with SIMD fairly complete,
    and has been maintaining this patchset, as I slowly upstream the commits one-by-one (with
    adjustments, fixups, etc). Shawn is giving a talk on his work at the October LLVM Dev Meeting:
    <a href="https://llvm.org/devmtg/2019-10/talk-abstracts.html#tech1">Using LLVM's portable SIMD with Zig</a>
    </p>
    <ul>
      <li>Shawn Landden fixed array to vector and vector to array for many types, and
          allowed vector of {#syntax#}bool{#endsyntax#}.</li>
      <li>Shawn Landden improved comparisons of vectors to return vectors instead of
          {#syntax#}bool{#endsyntax#}.</li>
      <li>Shawn Landden added <a href="https://ziglang.org/documentation/0.5.0/#shuffle">@shuffle</a>.</li>
      <li>Added <a href="https://ziglang.org/documentation/0.5.0/#byteSwap">@byteSwap</a> support to vectors.
        Thanks Shawn Landden for the {#syntax#}comptime{#endsyntax#} implementation.</li>
      <li>Shawn Landden added <a href="https://ziglang.org/documentation/0.5.0/#splat">@splat</a>.</li>
    </ul>
    <p>
    See <a href="https://github.com/ziglang/zig/issues/903">#903</a> for more details.
    </p>
    {#header_close#}

    {#header_open|Alignment of Struct Fields#}
    <p>
    In Zig 0.4.0 there was <a href="https://github.com/ziglang/zig/blob/85edf55b73acda669a2388949d7cf31118d70764/src/analyze.cpp#L2249-L2258">this ugly kludge in the C++ stage1 compiler</a>:
    </p>
    <pre><code>// TODO If we have no type_entry for the field, we've already failed to
// compile the program correctly. This stage1 compiler needs a deeper
// reworking to make this correct, or we can ignore the problem
// and make sure it is fixed in stage2. This workaround is for when
// there is a false positive of a dependency loop, of alignment depending
// on itself. When this false positive happens we assume a pointer-aligned
// field, which is usually fine but could be incorrectly over-aligned or
// even under-aligned. See https://github.com/ziglang/zig/issues/1512
} else if (field-&gt;type_entry == nullptr) {
    this_field_align = g-&gt;builtin_types.entry_usize-&gt;abi_align;</code></pre>
    <p>
    It was a mistake to ever let this kludge into the C++ stage1 compiler, and it was difficult
    to remove this kludge in 0.5.0. But it's gone now.
    </p>
    <p>
    In Zig 0.5.0, the C++ stage1 compiler has the concept of "Lazy Values". This solved the problem
    of false positive dependencies without a kludge such as this. It also enabled Zig programs
    to explicitly specify {#syntax#}struct{#endsyntax#} field alignment:
    </p>
    {#code_begin|test|field_align#}
const std = @import("std");
const expect = std.testing.expect;

const Node = struct {
    next: *Node,
    massive_byte: u8 align(64),
};

test "struct field explicit alignment" {
    var node: Node = undefined;
    node.massive_byte = 100;
    expect(node.massive_byte == 100);
    comptime expect(@typeOf(&node.massive_byte) == *align(64) u8);
    expect(@ptrToInt(&node.massive_byte) % 64 == 0);
}
    {#code_end#}
    <p>In addition to this, "Lazy Values" solved the following bugs:</p>
    <ul style="columns: 2">
      <li><a href="https://github.com/ziglang/zig/issues/624">#624</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/1310">#1310</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/1735">#1735</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/1805">#1805</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/1995">#1995</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/3112">#3112</a></li>
    </ul>
    <p>"Lazy Values" also paved the way for {#link|Standard Library#} integrations with
    {#link|Async Functions#}.</p>
    {#header_close#}

    {#header_open|@Type#}
    <pre>{#syntax#}@Type(comptime info: @import("builtin").TypeInfo) type{#endsyntax#}</pre>
    <p>
    This function is the inverse of <a href="https://ziglang.org/documentation/0.5.0/#typeInfo">@typeInfo</a>. It reifies type information
    into a {#syntax#}type{#endsyntax#}.
    </p>
    <p>
    It is available for the following types:
    </p>
    <ul>
        <li>{#syntax#}type{#endsyntax#}</li>
        <li>{#syntax#}noreturn{#endsyntax#}</li>
        <li>{#syntax#}void{#endsyntax#}</li>
        <li>{#syntax#}bool{#endsyntax#}</li>
        <li>Integers- The maximum bit count for an integer type is {#syntax#}65535{#endsyntax#}.</li> 
        <li>Floats</li>
        <li>Pointers</li>
        <li>{#syntax#}comptime_int{#endsyntax#}</li>
        <li>{#syntax#}comptime_float{#endsyntax#}</li>
        <li>{#syntax#}@typeOf(undefined){#endsyntax#}</li>
        <li>{#syntax#}@typeOf(null){#endsyntax#}</li>
    </ul>
    <p>
    For these types it is a
    <a href="https://github.com/ziglang/zig/issues/2907">TODO in the compiler to implement</a>:
    </p>
    <ul>
        <li>Array</li>
        <li>Optional</li>
        <li>ErrorUnion</li>
        <li>ErrorSet</li>
        <li>Enum</li>
        <li>Opaque</li>
        <li>FnFrame</li>
        <li>AnyFrame</li>
        <li>Vector</li>
        <li>EnumLiteral</li>
    </ul>
    <p>
    For these types, {#syntax#}@Type{#endsyntax#} is not available.
    <a href="https://github.com/ziglang/zig/issues/383">There is an open proposal to allow unions and structs</a>.
    </p>
    <ul>
        <li>union</li>
        <li>Functions</li>
        <li>BoundFn</li>
        <li>ArgTuple</li>
        <li>struct</li>
    </ul>
    <p>Thank you to Jonathan Marler for the original implementation of <a href="https://ziglang.org/documentation/0.5.0/#Type">@Type</a>.</p>
    {#header_close#}

    {#header_open|Variable Declarations as Methods#}
    <p>
    Variable declarations can now be called as methods:
    </p>
    {#code_begin|test|var_decl_methods#}
const std = @import("std");
const expect = std.testing.expect;

const Foo = struct {
    a: u64 = 10,

    fn one(self: Foo) u64 {
        return self.a + 1;
    }

    const two = __two;

    fn __two(self: Foo) u64 {
        return self.a + 2;
    }

    const three = __three;

    const four = custom(Foo, 4);
};

fn __three(self: Foo) u64 {
    return self.a + 3;
}

fn custom(comptime T: type, comptime num: u64) fn (T) u64 {
    return struct {
        fn function(self: T) u64 {
            return self.a + num;
        }
    }.function;
}

test "fn delegation" {
    const foo = Foo{};
    expect(foo.one() == 11);
    expect(foo.two() == 12);
    expect(foo.three() == 13);
    expect(foo.four() == 14);
}
    {#code_end#}
    <p>
    Thank you to Michael Dusan for proposing and implementing this. <a href="https://github.com/ziglang/zig/issues/3306">#3306</a>
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|Standard Library#}
    <ul>
      <li>Sahnvour reworked {#syntax#}std.heap.DirectAllocator{#endsyntax#} to have more
        consistent behavior on Windows and POSIX. It no longer needs to be initialized with state;
        users of the API can now refer directly to a global (thread-safe) instance with
        {#syntax#}std.heap.direct_allocator{#endsyntax#}. On Windows, rather than being backed by
        <code>HeapAlloc</code>, it is backed by <code>VirtualAlloc</code>.
      </li>
      <li>Add doc comments for parameters in std.mem.Allocator.</li>
      <li>daurnimator improved {#syntax#}std.os.msghdr{#endsyntax#} definition.</li>
      <li>LemonBoy implemented <code>dl_phdr_info</code></li>
      <li>{#syntax#}std.io.COutStream{#endsyntax#} gains basic Windows support.</li>
      <li>Ryan Liptak reduced the amount of redundant memcpy calls on Windows of
        {#syntax#}std.heap.DirectAllocator{#endsyntax#}.
    Previously the memory would be copied to a different aligned address in some cases where the old offset could have been used. This fixes it so that it will always try to use the old offset when possible, and only uses a different offset if the old one is truly invalid (not aligned or not enough space to store the alloc at the old offset).
      </li>
      <li>daurnimator added {#syntax#}std.heap.LoggingAllocator{#endsyntax#}.</li>
      <li>Shawn Landden fixed excessive calls to mmap and munmap in {#syntax#}std.heap.DirectAllocator{#endsyntax#}.</li>
      <li>daurnimator added {#syntax#}std.os.linux.sendmmsg{#endsyntax#}.</li>
      <li>daurnimator added {#syntax#}std.ArrayList.orderedRemove{#endsyntax#}.</li>
      <li>tgschultz added {#syntax#}std.PackedIntArray{#endsyntax#} and {#syntax#}std.PackedIntSlice{#endsyntax#}.</li>
      <li>LemonBoy implemented failsafe logic for posixSleep. Now we'll sleep for the specified amount of time
        even though the number of seconds doesn't fit in an {#syntax#}isize{#endsyntax#} field.
        <br>
        After this commit, I made additional modifications:
        <br>
        The sleep APIs are now documented as having spurious wakeups and no
        precision of timing guaranteed. They also cannot fail. Now,
        the entire range of u64 is legal to pass to {#syntax#}std.os.time.sleep{#endsyntax#} and
        {#syntax#}std.os.time.posixSleep{#endsyntax#}. Values that do not fit in the native system APIs
        will cause a sleep for the longest possible duration and then be handled
        as a spurious wakeup.
      </li>
      <li>LemonBoy implemented {#syntax#}dl_iterate_phdr{#endsyntax#}.</li>
      <li>LemonBoy added <code>ARCH_SET_*</code> definitions for x86_64.</li>
      <li>daurnimator updated Linux syscalls and bits to 5.3. Notably this includes definitions for
        <code>io_uring</code>.</li>
      <li>{#syntax#}std.os.close{#endsyntax#} now uses <code>close$NOCANCEL</code> on Darwin,
        so that it is impossible to fail.</li>
      <li>LemonBoy added sigaltstack syscall.</li>
      <li>LemonBoy fixed {#syntax#}std.os.mprotect{#endsyntax#} syscall.</li>
      <li>emekoi updated std.dynamic_library implementation and improved it to not require an allocator.</li>
      <li>LemonBoy added guard pages for each new thread spawned.</li>
      <li>NBonaparte removed the <code>MAP_LOCKED</code> flag from load_dynamic_library and enabled the now passing tests.</li>
      <li>tgschultz updated {#syntax#}std.meta{#endsyntax#} and {#syntax#}std.meta.trait{#endsyntax#}
        "definition" renamed to "declaration", to be inline with the newly clarified semantics of
        <a href="https://ziglang.org/documentation/0.5.0/#hasDecl">@hasDecl</a> and <a href="https://ziglang.org/documentation/0.5.0/#hasField">@hasField</a>.</li>
      <li>tgschultz fixed {#syntax#}Deserializer.alignToByte(){#endsyntax#} and added {#link|Test Coverage#}.</li>
      <li>emekoi made {#syntax#}windows.unexpectedError{#endsyntax#} print a human friendly string and
        fixed Windows API function prototypes.</li>
      <li>Shawn Landden added a <code>bcmp</code> implementation to zig's multi-target libc implementation.
        This is especially useful because LLVM 9 now emits calls to bcmp.</li>
      <li>daurnimator improved {#syntax#}std.testing.expectEqual{#endsyntax#} for structs.</li>
      <li>daurnimator renamed {#syntax#}std.LinkedList{#endsyntax#} to {#syntax#}std.TailQueue{#endsyntax#}.</li>
      <li>daurnimator added {#syntax#}std.SinglyLinkedList{#endsyntax#}, and improved
        {#syntax#}std.heap.ArenaAllocator{#endsyntax#} to use a singly linked list instead of double.</li>
      <li>daurnimator added {#syntax#}std.http.Headers{#endsyntax#}.</li>
      <li>Jonathan Marler removed {#syntax#}const{#endsyntax#} on {#syntax#}std.process.argsAlloc{#endsyntax#}.</li>
      <li>daurnimator added gimli permutation to {#syntax#}std.crypto{#endsyntax#}.</li>
      <li>Josh Wolfe added {#syntax#}std.mem.concat{#endsyntax#}.</li>
      <li>Added missing {#syntax#}error.FileBusy{#endsyntax#} to {#syntax#}DeleteFileW{#endsyntax#}'s error set.</li>
      <li>emekoi added missing {#syntax#}error.FileNotFound{#endsyntax#} for <code>PATH_NOT_FOUND</code> in
        {#syntax#}DeleteFileW{#endsyntax#}'s error set.</li>
      <li>Sam Tebbs added doc comments to alignment functions.</li>
      <li>Update the default panic handler on freestanding. Now the infinite loop has a
        {#syntax#}@breakpoint(){#endsyntax#} in there.</li>
      <li>Sam Tebbs added support for returning {#syntax#}!u8{#endsyntax#} from <code>main()</code>.</li>
      <li>{#syntax#}std.os.abort{#endsyntax#} no longer calls msvcrt abort() when linking libc. <a href="https://github.com/ziglang/zig/issues/2071">#2071</a></li>
      <li>Added {#syntax#}std.os.windows.subsystem{#endsyntax#}.</li>
      <li>daurnimator consolidated Linux <code>AT_</code> constants because they are the same across
        architectures. He fixed <code>MAP_</code> definitions to match the kernel. <a href="https://github.com/ziglang/zig/issues/2837">#2837</a></li>
      <li>Cap getdents length argument to <code>INT_MAX</code>. The linux syscall treats this
        argument as having type int, so passing extremely long buffer sizes would be misinterpreted
        by the kernel. Since "short reads" are always acceptable, just cap it down.</li>
      <li>Added {#syntax#}std.fs.updateFile{#endsyntax#}.</li>
      <li>Added {#syntax#}std.fs.File.updateTimes{#endsyntax#}.</li>
      <li>{#syntax#}std.os.Stat{#endsyntax#} structs gain methods to abstract over the platform differences
        with regards to <code>mtime</code>, <code>ctime</code>, <code>atime</code>.</li>
      <li>Improved performance of {#syntax#}std.unicode.utf8ToUtf16Le{#endsyntax#}. On a simple test input:<br>
        <br>
        original utf8ToUtf16Le: elapsed: 111384483 ns (111 ms)<br>
        new utf8ToUtf16Le: elapsed: 138570 ns (0 ms)<br>
        <br>
        It's 800x faster in debug mode and ~4500x faster in release-fast mode. This was slowing
        down installation of files on Windows in build scripts.</li>
      <li>Joachim Henke improved startup code to avoid a register copy when fetching the stack pointer.</li>
      <li>Euan Torano implemented a check for <code>/dev/urandom</code> being a character device.
        This is a security measure. {#syntax#}std.os.getrandom{#endsyntax#} will return
        {#syntax#}error.NoDevice{#endsyntax#} if <code>/dev/urandom</code> is not a character device.</li>
      <li>Christoffer Rasmussen fixed {#syntax#}std.rb.Tree.lookup{#endsyntax#} and added
        {#link|Test Coverage#}.</li>
      <li>daurnimator improved {#syntax#}std.elf.Elf{#endsyntax#} open functions to return <code>Elf</code>
        struct directly instead of filling in pointer. <a href="https://github.com/ziglang/zig/issues/2998">#2998</a></li>
      <li>Euan Torano made {#syntax#}std.os.getrandom{#endsyntax#} on FreeBSD use the
        {#syntax#}getrandom{#endsyntax#} libc function. <a href="https://github.com/ziglang/zig/issues/2993">#2993</a></li>
      <li>Euan Torano fixed the function signature of
        {#syntax#}std.os.windows.advapi32.RtlGenRandom{#endsyntax#}. <a href="https://github.com/ziglang/zig/issues/3015">#3015</a></li>
      <li>The return type of {#syntax#}std.math.min{#endsyntax#} on integer operands will now return
        the type of the smaller integer when possible.</li>
      <li>Added {#syntax#}std.c.printf{#endsyntax#}.</li>
      <li>daurnimator added {#syntax#}std.BloomFilter{#endsyntax#}.</li>
      <li>Shawn Landden modified startup code to avoid providing a {#syntax#}_start{#endsyntax#} function
        when the <a href="https://ziglang.org/documentation/0.5.0/#Root-Source-File">Root Source File</a>
        already has one. This enables Zig applications to export their own startup if they wish to
        take this level of responsibility.</li>
      <li>Tetralux added {#syntax#}std.heap.FixedBufferAllocator.reset{#endsyntax#}.</li>
      <li>Added {#syntax#}std.os.gethostname{#endsyntax#}.</li>
      <li>Added {#syntax#}std.ascii.allocLowerString{#endsyntax#}.</li>
      <li>Added {#syntax#}std.ascii.eqlIgnoreCase{#endsyntax#}.</li>
      <li>Added {#syntax#}std.ascii.indexOfIgnoreCasePos{#endsyntax#}.</li>
      <li>Added {#syntax#}std.ascii.indexOfIgnoreCase{#endsyntax#}.</li>
    </ul>

    {#header_open|Debug Info and Stack Traces#}
    <p>
    Previously, due to a bug, the stack trace iteration code was using the number of
    frames collected as the number of frames to print, not recognizing the
    fixed size of the buffer. So it would redundantly print items, matching
    the total number of frames ever collected. Now the iteration code is limited to
    the actual stack trace frame count, and will not print duplicate frames. <a href="https://github.com/ziglang/zig/issues/2447">#2447</a> <a href="https://github.com/ziglang/zig/issues/2151">#2151</a>
    </p>
    <p>LemonBoy implemented a bunch of fixes for the DWARF parser (<a href="https://github.com/ziglang/zig/issues/2254">#2254</a>):</p>
    <ul>
      <li>Correct parsing of DWARF line_info section.</li>
      <li>Fix reading of udata/sdata encoded attributes.</li>
      <li>Add definition for DW_AT_alignment - even though it's been
        standardized in DWARF5 some compilers produce it anyway for DWARF4 infos too.</li>
      <li>Fix reading of reference attributes.</li>
      <li>Distinguish between absolute/relative addresses.</li>
      <li>Fix bug in LEB128 parsing.</li>
      <li>Stop emitting <code>DW_TAG_lexical_block</code> for variable declarations.</li>
      <li>Made {#syntax#}void{#endsyntax#} a signed type according to DWARF. This follows the
        convention set by C so that lldb stops complaining about it.</li>
      <li>Fixed DIFlags not getting propagated to LLVM.</li>
    </ul>
    <p>
    Thanks to this, and some other debug info fixes from LemonBoy, stack traces now work in release builds:
    </p>
    {#code_begin|exe_err#}
    {#code_release_safe#}
const std = @import("std");

fn foo() !void {
    return error.TheSkyIsFalling;
}

pub fn main() !void {
    try foo();
}
    {#code_end#}
    <p>
    LemonBoy additionally implemented reading symbol names from DWARF sections, so stack
    traces on Linux now have actual function names instead of <code>???</code>'s. You can see
    this in the above stack trace.
    </p>
    <p>
    There is an open issue with this, however -
    <a href="https://github.com/ziglang/zig/issues/2458">scanning all the symbol names is a bit slow</a>.
    A future improvement will improve the "Big-O" performance of this function, and bring Zig stack
    traces up to the same speed that one gets with, for example,
    <a href="https://www.gnu.org/software/gdb/">gdb</a>.
    </p>
    <p>
    Despite this trouble for debug info of very large Linux binaries, most projects will experience faster
    stack traces thanks to Marc Tiehuis switching to using <code>mmap</code> to read the debug info.
    Usually, such techniques are frowned upon due to making error handling difficult, however, this
    debug info code is currently designed for the use case of dumping a stack trace when
    the application has already panicked, and is about to abort. And so, an error in loading debug
    info from disk would be handled by aborting anyway.
    </p>
    <p>In addition, the following improvements were made:</p>
    <ul>
      <li>emekoi fixed debug info on Windows.</li>
      <li>Sahnvour improved correctness of Zig's coff and pdb implementation. It is now able to handle
        stage1 C++ compiler's PDB and print its stack traces. <a href="https://github.com/ziglang/zig/issues/2965">#2965</a></li>
      <li>Sahnvour improved stream reading performance of PDB code. Printing stack trace from a
        stage1 C++ compiler crash is now 10x faster.</li>
      <li>Fixed stack traces on macOS when passing absolute path to root source file. <a href="https://github.com/ziglang/zig/issues/2700">#2700</a></li>
      <li>Michael Dusan fixed a regression where stack traces stopped working on macOS, and then
        implemented {#link|Test Coverage#} for stack traces, to catch future regressions. <a href="https://github.com/ziglang/zig/issues/2485">#2485</a></li>
    </ul>
    {#header_close#}

    {#header_open|Formatted Printing#}
    <p>
    Marc Tiehuis created
    <a href="https://github.com/ziglang/zig/issues/1358">a plan to overhaul the std.fmt API</a>.
    The plan is partially implemented in 0.5.0, but there is
    <a href="https://github.com/ziglang/zig/issues/1358#issuecomment-511193492">remaining work</a>.
    </p>
    <p>
    The main difference in 0.5.0 is the positional, precision, and width support.
    This removes the odd width and precision specifiers found and replacing
    them with the more consistent api described in <a href="https://github.com/ziglang/zig/issues/1358">#1358</a>.
    </p>
    <p>
    Take the following example:
    </p>
    <pre><code>{1:5.9}</code></pre>
    <p>
    This refers to the second argument (0-indexed) in the argument list. It
    will be printed with a minimum width of 5 and will have a precision of 9
    (if applicable).
    </p>
    <p>
    Not all types correctly use these parameters just yet. There are still
    some missing gaps to fill in. Fill characters and alignment have yet to
    be implemented.
    </p>
    <p>In addition:</p>
    <ul>
      <li>Ryan Liptak added max_depth to {#syntax#}std.fmt.format{#endsyntax#} to avoid infinite
        recursion from self-references.</li>
      <li>Marc Tiehuis cleaned up fmt.zig with inferred enum literals and split the large test case up.</li>
      <li>tgschultz fixed handling of slices of slices.</li>
      <li>Evan Krause added support for zero-sized structs.</li>
      <li>Michael Dusan fixed <code>std.fmt</code> to handle <code>std.SegmentedList</code>:<ul>
          <li>add guards for use of prealloc_exp in SegmentedList.</li>
          <li>define prealloc_exp even when invalid because std.fmt comptime triggers lazy-init.</li>
          <li>fix std.fmt to print arrays of length 0 as style "[0]&lt;typename&gt;" because "&lt;typename&gt;@address" is n/a without address</li>
      </ul></li>
      <li>Marc Tiehuis moved pointer parsing out of main state machine. This allows us to
        format a pointer with alignment/padding as we would with any other format specifier.
        e.g. <code>{*:5}</code></li>
      <li>Marc Tiehuis made <code>FormatOptions</code> arguments non-{#syntax#}comptime{#endsyntax#}.
        No need and should help avoid exessive function monomorphizaton.</li>
      <li>Marc Tiehuis passed full options struct to all internal functions.
        The fill specifier is now handled in some cases. The default fill of '0' is now ' '
        for integers and non-byte sequences.</li>
    </ul>
    {#header_close#}

    {#header_open|Math#}
    <p>
    Marc Tiehuis ported upstream changes from <a href="https://www.musl-libc.org/">musl</a>'s math functions.
    </p>
    <p>
    This also starts the documentation effort for the math/ subdirectory.
    The intent is to use this as a somewhat representative test-case for any
    work on the documentation generator.
    </p>
    <ul>
      <li>Marc Tiehuis added {#syntax#}std.math.big.Rational{#endsyntax#}.</li>
      <li>Marc Tiehuis fixed {#syntax#}std.math.big.Int.toString{#endsyntax#}, as well as
        handling zero-limb trailing div case and fixing divN/gcdLehmer and fuzz-test failures.</li>
      <li>Marc Tiehuis packed {#syntax#}std.math.big.Int{#endsyntax#} sign and length fields,
        taking it down from 40 to 32 bits on a 64-bit architecture.</li>
      <li>Marc Tiehuis added documentation for all functions and algorithm sources.</li>
      <li>Marc Tiehuis corrected {#syntax#}math.nan{#endsyntax#} usage in cos.</li>
      <li>Marc Tiehuis fixed exponent calculation in {#syntax#}std.fmt.parseFloat{#endsyntax#}.</li>
      <li>Ryan Liptak added {#syntax#}std.math.ceilPowerOfTwo{#endsyntax#} and
        {#syntax#}std.math.ceilPowerOfTwoPromote{#endsyntax#}. <a href="https://github.com/ziglang/zig/issues/2426">#2426</a></li>
      <li>Sahnvour allowed parameters of type {#syntax#}comptime_int{#endsyntax#} in
        {#syntax#}std.math.shl{#endsyntax#} and {#syntax#}std.math.shr{#endsyntax#}.</li>
      <li>daurnimator added {#syntax#}std.math.isPowerOfTwo{#endsyntax#}, and
        Ryan Liptak updated the standard library to take advantage of it.</li>
    </ul>
    {#header_close#}

    {#header_open|Thread Local Storage#}
    <p>Thanks to LemonBoy, Zig now has support for {#syntax#}threadlocal{#endsyntax#} variables on
    Linux without relying on libc, on the following architectures:</p>
    <ul>
      <li>x86_64</li>
      <li>i386 (new)</li>
      <li>{#link|32-bit ARM|32-bit ARM Support#} (new)</li>
      <li>{#link|64-bit ARM|64-bit ARM Support#} (new)</li>
      <li>{#link|RISC-V|RISC-V Support#} (new)</li>
      <li>{#link|MIPS|MIPS Support#} (new)</li>
    </ul>
    <p>
    In addition to wider architecture support, he implemented on-demand TLS allocation. Previously,
    if there were too many thread local variables, Zig would panic on startup.
    </p>
    <p>
    With these changes, Zig has proper support for TLS on Linux.
    </p>
    {#header_close#}

    {#header_open|Reorganization of Operating System Abstractions#}
    <p>
    In Zig 0.5.0, OS abstractions are organized in a straightforward manner.
    {#syntax#}std.os{#endsyntax#} is "Zig-flavored POSIX". All the "bits" familiar to C
    programmers are available in this namespace, such as {#syntax#}O_RDONLY{#endsyntax#} and
    {#syntax#}open{#endsyntax#}. The functions have errno translated to Zig errors (on Linux
    without libc, there is no {#link|thread local variable|External Thread Local Variables#}
    for <code>errno</code> ðŸŽ‰) and slices are used rather than raw pointers where appropriate.
    </p>
    <p>
    Higher level, cross-platform abstractions are available in category-specific namespaces,
    for example {#syntax#}std.fs.File.openRead{#endsyntax#}.
    </p>
    <p>
    {#syntax#}std.os.windows{#endsyntax#} has "Zig-flavored Windows", with
    {#syntax#}GetLastError{#endsyntax#} translated to Zig errors. Raw Windows APIs are available
    directly via namespaces named after their DLLs, for example
    {#syntax#}std.os.windows.kernel32.ExitProcess{#endsyntax#}.
    </p>
    <p>
    Zig's optional integration with libc is significantly more robust. {#syntax#}std.os{#endsyntax#}
    functions call libc functions when linking against libc, and otherwise use the
    operating system's syscall ABI directly.
    </p>
    <p>After some experimentation, it was concluded that Windows
    does not integrate well with libc, and so on Windows, even when linking libc,
    the native Windows API calls are used rather than libc API.
    </p>
    <p>
    See <a href="https://github.com/ziglang/zig/issues/2380">#2380</a> for more details and discussion.
    </p>
    {#header_close#}

    {#header_open|Recursive Rewrite of Self-Hosted Parser#}
    <p>
    Zig's self-hosted parser is in the standard library - {#syntax#}std.zig.parse{#endsyntax#}.
    It's the backbone of {#link|zig fmt#}.
    </p>
    <p>
    I've <a href="https://www.recurse.com/events/localhost-andrew-kelley">said before</a> that
    recursion is one of the enemies of perfect software, because it represents a way that a
    program can fail with no foolproof way of preventing it. With recursion, pick any stack size
    and I'll give you an input that will crash your program. Embedded developers are all too
    familiar with this problem.
    </p>
    <p>
    It's always possible to rewrite code using an explicit stack using heap allocations, and
    that's exactly what Jimmi did in the self-hosted parser.
    </p>
    <p>This implementation of the self-hosted parser is an interesting case study of
    avoiding recursion by using an explicit stack. It is essentially a hand-written
    recursive descent parser, but with heap allocations instead of recursion.
    <a href="https://github.com/ziglang/zig/blob/0.3.0/std/zig/parse.zig#L12">This code is truly a work of art</a>.
    I like to call it "Jimmi's non-recursive recursive-descent parser".
    </p>
    <p>
    When Jimmi originally implemented the code, we thought that we could not solve the
    unbounded stack growth problem of recursion. However, now we have
    <a href="https://github.com/ziglang/zig/issues/1006">a plan for safe recursion</a>.
    </p>
    <p>
    And so it was time to lay the code to rest. This is where Stevie Hryciw came in. Stevie
    rewrote the entire self-hosted parser, to the full
    <a href="https://github.com/ziglang/zig-spec/">grammar specification</a>.
    This was a large project spanning across several weeks. During this time, Stevie endured
    painful rebases and dutifully updated <a href="https://github.com/ziglang/zig/pull/2405">the pull request</a>
    description to keep everyone informed.
    </p>
    <p>
    Stevie didn't stop there - he followed up by analyzing {#link|Performance Impact#} as well as
    {#link|Readability Impact#}. He writes:
    </p>

    {#header_open|Performance Impact#}
    <p>
    Here are some
    <a href="https://gist.github.com/hryx/91a656944c55039139391939a052d990">informal tests of parser_test.zig with perf stat -d on x86_64 Linux</a>.
    </p>
    <p>
    In the absence of visualizations and more formal testing, some quick findings based on my system:
    </p>
    <ul>
      <li>CPU cycles, instructions, branches: -55%</li>
      <li>Page faults are roughly the same</li>
      <li>Real time elapsed: -45%</li>
    </ul>
    {#header_close#}

    {#header_open|Readability Impact#}
    <p>Indentation stats of <code>std/zig/parse.zig</code>:</p>
    <pre>master                          | stage2-recursive-parser
--------------------------------+---------------------------------
indent count                    | indent count
------------                    | ------------
    0     92                    |      0   263
    1    241                    |      1   803
    2    123                    |      2   763
    3    291                    |      3   334
    4    654                    |      4   133
    5    662                    |      5    60
    6    700                    |      6    28
    7    347                    |      7     5
    8    229                    |
    9     42                    |
   10     18                    |
avg indentation level: 4.796999 | avg indentation level: 1.827543
source lines of code:      3399 | source lines of code:      2389</pre>
    <ul>
      <li>Maximum indentation level went from 10 to 7</li>
      <li>Average indentation level went from 4.79 to 1.82</li>
      <li>Lines of code (excluding blank/comments) went from 3399 to 2389</li>
    </ul>
    {#header_close#}
    {#header_close#}

    {#header_open|Default Segfault Handler#}
    <p>
    x86_64-linux and Windows now have, by default, a segfault handler that is attached before <code>main()</code>.
    Thanks to this, Zig programs now have stack traces for segfaults:
    </p>
    {#code_begin|exe_err#}
pub fn main() void {
    dereferenceAPointer(@intToPtr(*i32, 0x1));
}

fn dereferenceAPointer(ptr: *i32) void {
    ptr.* = 10;
}
    {#code_end#}
    <p>
    This can be disabled:
    </p>
    {#code_begin|exe_err#}
pub const enable_segfault_handler = false;

pub fn main() void {
    dereferenceAPointer(@intToPtr(*i32, 0x1));
}

fn dereferenceAPointer(ptr: *i32) void {
    ptr.* = 10;
}
    {#code_end#}
    <p>This works because the standard library uses the new feature {#link|@import("root")#}
    to check for this opt-out.</p>
    <p>Thank you to Rocknest for a proof-of-concept implementation of this in <a href="https://github.com/ziglang/zig/issues/2355">#2355</a>.</p>
    {#header_close#}

    {#header_open|HashMap and Hashing#}
    <ul>
      <li>Ryan Liptak optimized {#syntax#}std.HashMap{#endsyntax#} indexing by avoiding modulo operator.
        {#syntax#}x % y{#endsyntax#} can be optimized if y is a power of two by doing
        {#syntax#}x & (y-1){#endsyntax#} instead. HashMap already enforces power of two capacity,
        so we can take advantage of this optimization.</li>
      <li>Ryan Liptak added public ensureCapacity fn to {#syntax#}std.HashMap{#endsyntax#}, and
          made it round up to the nearest power of two. It now optimizes for the expected count.
          Finally, he added {#syntax#}putAssumeCapacity{#endsyntax#}.</li>
      <li>Josh Wolfe added {#syntax#}std.HashMap{#endsyntax#} APIs that assert the common case:<ul>
          <li>{#syntax#}putNoClobber(){#endsyntax#} for {#syntax#}put(){#endsyntax#}</li>
          <li>{#syntax#}removeAssertDiscard(){#endsyntax#} for {#syntax#}remove(){#endsyntax#}</li>
        </ul>
      </li>
      <li>Josh Wolfe added {#syntax#}std.HashMap.getValue(){#endsyntax#}.</li>
      <li>Timon Kruiper fixed using {#syntax#}std.AutoHashMap{#endsyntax#} with an {#syntax#}enum{#endsyntax#}
        key. <a href="https://github.com/ziglang/zig/issues/2669">#2669</a></li>
      <li>andersfr added CityHash and Murmur hashing algorithms. <a href="https://github.com/ziglang/zig/issues/2887">#2887</a></li>
      <li>Sahnvour added forced inlining of integer hashing so that the optimizer
        can see the fast path based on key's size which is known at comptime.
        Otherwise it will always outline the call to hasher.update, resulting in much worse performance.</li>
      <li>Sahnvour made wyhash stateless for iterative hashing and small keys.</li>
      <li>Sahnvour made <code>autoHash</code> make use of hashing streaming interface.</li>
      <li>Sahnvour adapted http/headers.zig to wyhash's new interface.</li>
      <li>Marc Tiehuis added a throughput test program for hash functions.</li>
      <li>Marc Tiehuis added an iterative wyhash API.</li>
    </ul>
    <p>
    Notably, Sahnvour made <code>std.HashMap</code> consistent about whether or not it will
    dereference keys. <code>std.AutoHashMap</code> no longer will dereference slices
    ({#syntax#}[]const u8{#endsyntax#} or {#syntax#}[]u8{#endsyntax#}), or any pointer type
    for that matter:
    </p>
    {#code_begin|test_err|not allow slices#}
const std = @import("std");

test "AutoHashMap with slices" {
    var map = std.AutoHashMap([]const u8, bool).init(std.heap.direct_allocator);
}
    {#code_end#}
    <p>
    {#syntax#}std.StringHashMap{#endsyntax#} is provided for this use case
    instead:
    </p>
    {#code_begin|test|string_hash_map#}
const std = @import("std");

test "StringHashMap" {
    var map = std.StringHashMap(bool).init(std.heap.direct_allocator);
    _ = try map.put("hello", true);
}
    {#code_end#}
    <p>
    Additionally:
    </p>
    <ul>
      <li>Sahnvour used wyhash in {#syntax#}std.HashMap{#endsyntax#}, and improve <code>autoHash</code>
        to handle more types and behave more correctly.</li>
      <li>Sahnvour added fastpath for <code>std.mem.eql</code> and simplified
        {#syntax#}std.hash_map.eqlString{#endsyntax#}.</li>
    </ul>
    <p>Marc Tiehuis made a series of improvements to hashing performance:</p>
    <p>Inline full slice hashing - this gives moderate speed improvements when hashing small keys.
    The crc/adler/fnv inlining did not provide enough speed up to warrant
    the change.</p>
    <p><strong>Old:</strong></p>
    <pre><code>wyhash
  small keys: 2277 MiB/s [c14617a1e3800000]
siphash(1,3)
  small keys:  937 MiB/s [b2919222ed400000]
siphash(2,4)
  small keys:  722 MiB/s [3c3d974cc2800000]
fnv1a
  small keys: 1580 MiB/s [70155e1cb7000000]
adler32
  small keys: 1898 MiB/s [00013883ef800000]
crc32-slicing-by-8
  small keys: 2323 MiB/s [0035bf3dcac00000]
crc32-half-byte-lookup
  small keys:  218 MiB/s [0035bf3dcac00000]</code></pre>
    <p><strong>New:</strong></p>
    <pre><code>wyhash
  small keys: 2775 MiB/s [c14617a1e3800000]
siphash(1,3)
  small keys: 1086 MiB/s [b2919222ed400000]
siphash(2,4)
  small keys:  789 MiB/s [3c3d974cc2800000]
fnv1a
  small keys: 1604 MiB/s [70155e1cb7000000]
adler32
  small keys: 1856 MiB/s [00013883ef800000]
crc32-slicing-by-8
  small keys: 2336 MiB/s [0035bf3dcac00000]
crc32-half-byte-lookup
  small keys:  218 MiB/s [0035bf3dcac00000]</code></pre>
    <p>Improve siphash performance for small keys by up to 30% (<a href="https://github.com/ziglang/zig/issues/3124">#3124</a>) -
    this removes the partial buffer handling from the full slice API.</p>
    <p><code>./benchmark --filter siphash --count 1024</code></p>
    <p><strong>Old:</strong></p>
    <pre><code>siphash(1,3)
   iterative: 3388 MiB/s [67532e53a0d210bf]
  small keys: 1258 MiB/s [948c91176a000000]
siphash(2,4)
   iterative: 2061 MiB/s [f792d39bff42f819]
  small keys:  902 MiB/s [e1ecba6614000000]</code></pre>
    <p><strong>New:</strong></p>
    <pre><code>siphash(1,3)
   iterative: 3410 MiB/s [67532e53a0d210bf]
  small keys: 1639 MiB/s [948c91176a000000]
siphash(2,4)
   iterative: 2053 MiB/s [f792d39bff42f819]
  small keys: 1074 MiB/s [e1ecba6614000000]</code></pre>
    <p>Simplify wyhash and improve speed -
    this removes the exposed stateless variant since the standard variant
    has similar speed now.</p>
    <p>Using <code>./benchmark --filter wyhash --count 1024</code>, the speed change has
    changed from:</p>
    <pre><code>wyhash
   iterative: 4093 MiB/s [6f76b0d5db7db34c]
  small keys: 3132 MiB/s [28c2f43c70000000]</code></pre>
    <p>to</p>
    <pre><code>wyhash
   iterative: 6515 MiB/s [673e9bb86da93ea4]
  small keys: 10487 MiB/s [28c2f43c70000000]</code></pre>
    {#header_close#}
    {#header_close#}

    {#header_open|Documentation#}
    <ul>
      <li>There is now a <a href="https://github.com/ziglang/zig/blob/0.5.0/CONTRIBUTING.md">CONTRIBUTING.md</a>.</li>
      <li>Added docs: <a href="https://ziglang.org/documentation/0.5.0/#Enum-Literals">Enum Literals</a></li>
      <li>Added docs: <a href="https://ziglang.org/documentation/0.5.0/#usingnamespace">usingnamespace</a></li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#truncate">@truncate</a> docs are updated and corrected. <a href="https://github.com/ziglang/zig/issues/2234">#2234</a></li>
      <li>Matt Stancliff fixed a test in the langref to assert against modified var.</li>
      <li>Ryan Liptak added README instructions for making changes to the standard library. <a href="https://github.com/ziglang/zig/issues/2324">#2324</a></li>
      <li>Ryan Liptak fixed README instructions for the filepath to test file when testing std lib changes.</li>
      <li>Add note to <a href="https://ziglang.org/documentation/0.5.0/#setRuntimeSafety">@setRuntimeSafety</a>.</li>
      <li>Remove <code>@setGlobalLinkage</code> section. <code>@setGlobalLinkage</code> was removed with
        <a href="https://github.com/ziglang/zig/issues/462">#462</a>. The not-yet-implemented proposal for external weak symbols is <a href="https://github.com/ziglang/zig/issues/1917">#1917</a>.</li>
      <li>Shritesh Bhattarai improved the language reference to show the <code>-target</code>
      command line argument.</li>
      <li>Many contributors fixed typos in small, easy-to-merge pull requests. Thank you for that.</li>
      <li>Shritesh Bhattarai added lib codeblock type to docgen and used it for wasm32-freestanding.</li>
      <li>Shritesh Bhattarai added recommendation to use optional pointers for nullptrs instead of
        {#syntax#}allowzero{#endsyntax#}.</li>
      <li>Shritesh Bhattarai added a comment about {#syntax#}for else{#endsyntax#} and {#syntax#}break{#endsyntax#}.</li>
      <li>Jonathan Pentecost updated {#syntax#}for else{#endsyntax#} example. <a href="https://github.com/ziglang/zig/issues/2614">#2614</a></li>
      <li>emekoi added missing syntax blocks.</li>
      <li>Michael Dusan clarified struct size and ABI-alignment.</li>
      <li>Corrected documentation regarding mixing object files. <a href="https://github.com/ziglang/zig/issues/2905">#2905</a></li>
      <li>Retire the <code>example/</code> folder. Code moved to become standalone tests. <a href="https://github.com/ziglang/zig/issues/2759">#2759</a></li>
      <li>JohnathanFL added a multidimensional array example.</li>
      <li>Added operations list to <a href="https://ziglang.org/documentation/0.5.0/#atomicRmw">@atomicRmw</a>.</li>
      <li>Aaron Klapatch added documentation for field access to C pointers. <a href="https://github.com/ziglang/zig/issues/3088">#3088</a></li>
      <li>Shritesh improved the README instructions for macOS to use the LLVM path provided by homebrew
        instead of a hardcoded value that became out-of-date.</li>
      <li>Vesa Kaihlavirta shortened <a href="https://ziglang.org/documentation/0.5.0/#field">@field</a> documentation and added an example.</li>
      <li>Jay Weisskopf updated README headline to match website, and made links underlined on hover.</li>
      <li>Duncan added a favicon to the language reference.</li>
      <li>Shawn Landden updated <a href="https://ziglang.org/documentation/0.5.0/#clz">@clz</a> and <a href="https://ziglang.org/documentation/0.5.0/#ctz">@ctz</a>, clarifying terminology to not be endian-specific.</li>
    </ul>
    {#header_close#}

    {#header_open|zig build#}
    <p>
    <code>zig build</code> is still in an experimental, proof-of-concept phase, and will remain
    that way until at least the {#link|package manager|Package Manager Status#} is complete.
    However, there were still improvements to <code>zig build</code>
    this release cycle:
    </p>
    <ul>
      <li>emekoi forwarded error code on non-successful exits of child processes to <code>zig build</code>.</li>
      <li>install is now the default step; the default prefix is zig-cache. <a href="https://github.com/ziglang/zig/issues/2817">#2817</a></li>
      <li><code>zig build</code> now searches up the directory hierarchy for <code>build.zig</code>. <a href="https://github.com/ziglang/zig/issues/2587">#2587</a></li>
      <li>Added <code>setLibCFile</code> API</li>
      <li>Install .pdb files along with binaries. <a href="https://github.com/ziglang/zig/issues/2848">#2848</a></li>
      <li>Added <code>standardTargetOptions</code> and deprecated <code>setTarget</code> in favor of
        <code>setTheTarget</code>.</li>
      <li>Added <a href="http://www.valgrind.org/">Valgrind</a> CLI options.</li>
      <li>Support <code>DESTDIR</code> environment variable. <a href="https://github.com/ziglang/zig/issues/2929">#2929</a></li>
      <li>Nick Erdmann fixed a regression in the stack checking option.</li>
      <li>Benjamin Feng added {#syntax#}builder.findProgram{#endsyntax#} test and fixed references.</li>
      <li>Made install prefix available to build.zig and prevented accident of <code>'/'</code>
        showing up in application/library names.</li>
      <li><code>linkSystemLibrary</code> integrates with <code>pkg-config</code>.</li>
      <li>Build scripts can now take advantage of QEMU and Wine integration by doing
          {#syntax#}artifact.enable_qemu = true;{#endsyntax#} and
          {#syntax#}artifact.enable_wine = true;{#endsyntax#}, respectively.</li>
      <li>Added ability to override the dynamic linker of an executable artifact.</li>
    </ul>
    {#header_close#}

    {#header_open|zig fmt#}
    <p>
    <code>zig fmt</code> now fixes invalid whitespace instead of rejecting it.
    The {#syntax#}// zig fmt: off{#endsyntax#} directive is ignored for whitespace fixes.
    </p>
    <ul>
      <li>Raul Leal added support for comptime blocks in containers. <a href="https://github.com/ziglang/zig/issues/2308">#2308</a></li>
      <li>Various bugs fixed, more {#link|Test Coverage#}.</li>
      <li>Timon Kruiper corrected formatting for multiline string in arrays.</li>
      <li>Timon Kruiper added LineComment support and test case for when MultiLines are used in ArrayInit.</li>
      <li>Vexu fixed comment formatting in arrays and fn params.</li>
      <li>Vexu fixed IfTypeExpr parsing.</li>
      <li>Vexu improved comment indentation in arrays.</li>
      <li>Vexu fixed comments getting removed after empty comments.</li>
      <li>Stevie Hryciw fixed crash when file ends with struct field.</li>
      <li>Benjamin Feng fixed zig fmt reinterpreting <code>a &amp;&amp; b</code> as {#syntax#}a & &b{#endsyntax#}. Now it has a helpful error message: "`&amp;&amp;` is invalid. Note that `and` is boolean AND.". <a href="https://github.com/ziglang/zig/issues/2660">#2660</a></li>
      <li>Timon Kruiper fixed an integer overflow in zig fmt and added testcase.</li>
      <li>Vexu implemented {#link|Async Functions#} syntax, including {#syntax#}noasync{#endsyntax#}.</li>
      <li>yvt improved the handling of {#syntax#}// zig fmt: off/on{#endsyntax#}.</li>
      <li>Hang Shick Pak fixed nested {#syntax#}if{#endsyntax#}.</li>
    </ul>
    <p>
    Thanks to {#link|WebAssembly Support#} improvements, there is also a
    <a href="https://shritesh.github.io/zigfmt-web/">web-based formatter</a> made
    by Shritesh Bhattarai.
    </p>
    {#header_close#}

    {#header_open|libc#}
    <p>
    Zig now provides libc for the following targets (find this information with <code>zig targets</code>):
    </p>
    <ul style="columns: 3">
<li>aarch64_be-linux-gnu</li>
<li>aarch64_be-linux-musl</li>
<li>aarch64_be-windows-gnu</li>
<li>aarch64-linux-gnu</li>
<li>aarch64-linux-musl</li>
<li>aarch64-windows-gnu</li>
<li>armeb-linux-gnueabi</li>
<li>armeb-linux-gnueabihf</li>
<li>armeb-linux-musleabi</li>
<li>armeb-linux-musleabihf</li>
<li>armeb-windows-gnu</li>
<li>arm-linux-gnueabi</li>
<li>arm-linux-gnueabihf</li>
<li>arm-linux-musleabi</li>
<li>arm-linux-musleabihf</li>
<li>arm-windows-gnu</li>
<li>i386-linux-gnu</li>
<li>i386-linux-musl</li>
<li>i386-windows-gnu</li>
<li>mips64el-linux-gnuabi64</li>
<li>mips64el-linux-gnuabin32</li>
<li>mips64el-linux-musl</li>
<li>mips64-linux-gnuabi64</li>
<li>mips64-linux-gnuabin32</li>
<li>mips64-linux-musl</li>
<li>mipsel-linux-gnu</li>
<li>mipsel-linux-musl</li>
<li>mips-linux-gnu</li>
<li>mips-linux-musl</li>
<li>powerpc64le-linux-gnu</li>
<li>powerpc64le-linux-musl</li>
<li>powerpc64-linux-gnu</li>
<li>powerpc64-linux-musl</li>
<li>powerpc-linux-gnu</li>
<li>powerpc-linux-musl</li>
<li>riscv64-linux-gnu</li>
<li>riscv64-linux-musl</li>
<li>s390x-linux-gnu</li>
<li>s390x-linux-musl</li>
<li>sparc-linux-gnu</li>
<li>sparcv9-linux-gnu</li>
<li>wasm32-freestanding-musl</li>
<li>x86_64-linux-gnu</li>
<li>x86_64-linux-gnux32</li>
<li>x86_64-linux-musl</li>
<li>x86_64-windows-gnu</li>
    </ul>
    {#header_open|musl 1.1.23#}
    <p>
    Zig ships with the source code to <a href="https://www.musl-libc.org/">musl</a>. Zig 0.5.0
    updates to the 1.1.23 release of musl, plus a handful of patches to fix various issues
    with {#link|64-bit ARM Support#} and {#link|RISC-V Support#}. All these patches are merged
    into musl upstream and will be part of the next release.
    </p>
    <p>
    Previously, the way that Zig built musl from source skipped some necessary files.
    LemonBoy solved this issue.
    </p>
    <p>
    Additionally, the updating process for musl was brittle and confusing. Now, the process
    is <a href="https://github.com/ziglang/zig/wiki/Updating-libc#musl">streamlined and fully documented</a>.
    Unnecessary patches were dropped.
    </p>
    <p>
    Now, Zig has excellent {#link|Test Coverage#} of musl. The Zig test suite tests building musl
    for these targets:
    </p>
    <ul>
      <li>x86_64-linux-musl</li>
      <li>aarch64v8_5a-linux-musl</li>
      <li>arm32v8_5a-linux-musleabihf</li>
      <li>mipsel-linux-musl</li>
    </ul>
    {#header_close#}

    {#header_open|glibc 2.30#}
    <p>
    In Zig 0.5.0, not only can Zig provide dynamically linked glibc for any target,
    but it can also provide <em>any version of glibc</em> for any target:
    </p>
    <p class="file">getrandom.zig</p>
    <pre>{#syntax#}
const std = @import("std");

pub fn main() void {
    var buf: [16]u8 = undefined;
    _ = std.c.getrandom(&buf, buf.len, 0);
}
    {#endsyntax#}</pre>
    <pre><code class="shell">$ ./zig build-exe test.zig -lc -target x86_64-linux-gnu -target-glibc 2.24
lld: error: undefined symbol: getrandom
&gt;&gt;&gt; referenced by test.zig:5 (/home/andy/dev/zig/build/test.zig:5)
&gt;&gt;&gt;               ./test.o:(main.0)

$ ./zig build-exe test.zig -lc -target x86_64-linux-gnu -target-glibc 2.25
$ ./test
$</code></pre>
    <p>
    Updating to the newest glibc version is now
    <a href="https://github.com/ziglang/zig/wiki/Updating-libc#glibc">streamlined and fully documented</a>.
    Even though Zig now supports every version of glibc, the amount of bytes required for a Zig installation
    with regards to glibc has decreased, because a dummy libc file is no longer required, as it is generated
    on-the-fly depending on the target version selected.
    </p>
    <p>
    The target glibc version is exposed in {#syntax#}@import("builtin"){#endsyntax#} and is used by
    the {#link|Standard Library#} to do a glibc version check, to decide whether to use libc
    <code>getrandom</code> or read from <code>/dev/urandom</code>. <a href="https://github.com/ziglang/zig/issues/397">#397</a>
    </p>
    <p>
    The supported glibc version range is increased to include 2.30.
    </p>
    <p>
    Building glibc now has {#link|Test Coverage#} when the <code>-Denable-qemu</code> and
    <code>-Denable-foreign-glibc</code> options are enabled, for these targets:
    </p>
    <ul>
      <li>x86_64-linux-gnu</li>
      <li>aarch64v8_5a-linux-gnu</li>
      <li><a href="https://github.com/ziglang/zig/issues/3287">arm32v8_5a-linux-musleabihf disabled due to #3287</a></li>
    </ul>
    {#header_close#}

    {#header_open|Zig ships with mingw-w64#}
    <p>
    Zig now ships with the source code and header files to mingw-w64 (version 6.0.0),
    and uses this to provide libc when targeting Windows.
    </p>
    <p>
    Combining this with <a href="https://www.winehq.org/">Wine</a>, one can cross-compile
    C code for Windows and run it, without even touching a Windows computer:
    </p>
    <p class="file">hello_windows.c</p>
    <pre><code>#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    printf("Hello Windows\n");
    return 0;
}</code></pre>
<pre><code class="shell">$ zig build-exe --c-source hello_windows.c -lc -target x86_64-windows-gnu
$ wine hello_windows.exe
Hello Windows</code></pre>
    <p>Building and linking against mingw-w64 libc now has {#link|Test Coverage#}
    for the <code>x86_64-windows-gnu</code> target.</p>
    <p>
    One of the use cases for this is creating {#link|Zig packages|Package Manager Status#}
    out of C libraries, and there is now
    <a href="https://github.com/andrewrk/zig-sdl">a proof of concept of this with SDL2</a>.
    </p>
    <p>
    The open-source game <a href="https://wolfesoftware.com/legend-of-swarkland/">Legend of Swarkland</a>
    is being written in Zig, and it uses this SDL2 package in order to support cross compiling
    for Windows with nothing installed other than Zig. The developer, Josh, does not have a Windows
    computer to test on, but has a brother who uses Windows he wants to be able to playtest his game.
    Using only Zig and Wine, Josh can create Windows builds of his game and even test them, before sending
    his brother an executable.
    </p>
<pre><code class="shell">$ git clone https://github.com/thejoshwolfe/legend-of-swarkland --recursive
$ cd legend-of-swarkland
$ zig build -Dtarget x86_64-windows-gnu
$ ls zig-cache/bin
legend-of-swarkland.exe           legend-of-swarkland_headless.pdb
legend-of-swarkland_headless.exe  legend-of-swarkland.pdb</code></pre>
    <p>
    Integration with mingw-w64 is easy and clean, because their headers are already
    multi-architecture. Thank you especially to IRC user <code>wbs</code>, who is
    largely responsible for that, and for patiently helping me
    work through my own issues caused by hacking up the mingw-w64 build system to
    integrate into Zig.
    </p>
    {#header_close#}

    {#header_open|Freestanding libc#}
    <p>
    Zig provides libc even when compiling in freestanding mode. This enables some
    C libraries to work even when there is no host Operating System.
    </p>
    <p>
    In Zig 0.5.0, this concept is a little bit more fleshed out and clear.
    One can observe this freestanding libc in action when building C code for
    {#link|WebAssembly|WebAssembly Support#}.
    </p>
    <ul>
      <li>Added strcmp, strncmp, strerror, strlen.</li>
      <li>Shawn Landden added fma and fmaf.</li>
    </ul>
    <p>
    There is still a lot to do on this front, and it could be an engaging project for contributors.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|C Translation#}
    <p>LemonBoy made several improvements:</p>
    <ul>
      <li>conversion to/from floating point types.</li>
      <li>parsing float/double literals.</li>
      <li>converting char literals.</li>
      <li>support for integer to boolean conversions.</li>
      <li>pointer to/from integral conversion.</li>
      <li>translation from pointer to boolean.</li>
      <li>improved support for pointer casting with different alignment.</li>
    </ul>
    <p>Thanks to {#link|C pointers supporting optional syntax|C Pointers Support Optional Syntax#},
    <code>NULL</code> pointers now translate to {#syntax#}null{#endsyntax#}.</p>
    <p>Additionally:</p>
    <ul>
      <li>handle int to ptr and ptr to int casting. <a href="https://github.com/ziglang/zig/issues/2451">#2451</a></li>
      <li>added enough C tokenization/parsing to handle shifting in macros. <a href="https://github.com/ziglang/zig/issues/2451">#2451</a></li>
      <li>better detection of pointer to struct demoted to opaque.</li>
      <li>Vexu fixed translation of escape sequences.</li>
      <li>Gustav Olsson forwarded framework dirs to embedded Clang in addition to linker on macOS.</li>
    </ul>

    {#header_open|Self-Hosted C Translation#}
    <p>
    In Zig 0.4.0, the <code>translate-c</code> and <a href="https://ziglang.org/documentation/0.5.0/#cImport">@cImport</a> implementations are 5,000 lines of C++.
    However, in this release, Zig is transitioning to a fully self-hosted implementation.
    </p>
    <p>
    The parts of <code>translate_c.cpp</code> that interact with the Clang C++ API have been extracted
    into <code>zig_clang.h</code> and <code>zig_clang.cpp</code>. This is a C API on top of the C++ API
    with some careful static assertions to ensure the file is kept up-to-date as Clang's C++ API changes.
    <code>translate_c.cpp</code> now interacts with the Clang C++ API exclusively via <code>zig_clang.h</code>.
    These files are generally useful for any project and they are MIT licensed.
    </p>
    <p>
    Based on <code>zig_clang.h</code>, <code>clang.zig</code> is created, updated, and maintained. This is
    extern functions and types so that Zig code can utilize the C layer on top of the Clang C++ API.
    And with this, we have <code>src-self-hosted/translate_c.zig</code> which is the self-hosted implementation
    of <code>translate-c</code> (and <a href="https://ziglang.org/documentation/0.5.0/#cImport">@cImport</a>). This is exposed with <code>zig translate-c-2</code>.
    Until the self-hosted implementation is brought up to feature parity, <code>zig translate-c</code>
    and <a href="https://ziglang.org/documentation/0.5.0/#cImport">@cImport</a> are still the C++ implementation. This work is partially done thanks to Stevie Hryciw; you can get a sense of progress by
    <a href="https://github.com/ziglang/zig/blob/0.5.0/test/translate_c.zig">examining the test cases</a>.
    More contributions welcome!
    </p>
    <p>
    See <a href="https://github.com/ziglang/zig/issues/1964">#1964</a> for more details.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|compiler-rt#}
    <p>
    compiler-rt is the library that provides, for example, 64-bit integer multiplication for
    32-bit architectures which do not have a machine code instruction for it.
    In the <a href="https://gcc.gnu.org/">gcc</a> world, it's called libgcc.
    </p>
    <p>
    Unlike most compilers, which depend on a binary build of compiler-rt being installed alongside
    the compiler, Zig builds compiler-rt on-the-fly, from source, as needed for the target platform.
    This release saw some improvements to Zig's compiler-rt implementation.
    </p>
    <ul>
      <li>@divTrunc rather than @divFloor in <code>__muloti4</code>.</li>
      <li>Added __muldi3 and __aeabi_lmul.</li>
      <li>Carter Sande added support for thumb versions older than armv6.</li>
      <li>Robin Voetter added __aeabi_read_tp.</li>
      <li>vegecode improved support for thumb and added:
        <ul>
          <li>__aeabi_dcmp</li>
          <li>__aeabi_fcmp</li>
          <li>__comparedf2</li>
          <li>__comparesf2</li>
        </ul>
      </li>
      <li>LemonBoy added:
        <ul style="columns: 2">
          <li>__aeabi_d2f</li>
          <li>__aeabi_f2d</li>
          <li>__aeabi_i2d</li>
          <li>__aeabi_i2f</li>
          <li>__aeabi_idiv</li>
          <li>__aeabi_idiv</li>
          <li>__aeabi_idiv</li>
          <li>__aeabi_idivmod</li>
          <li>__aeabi_l2d</li>
          <li>__aeabi_ldivmod</li>
          <li>__aeabi_ui2d</li>
          <li>__aeabi_ul2d</li>
          <li>__aeabi_unwind_cpp_pr0</li>
          <li>__aeabi_unwind_cpp_pr1</li>
          <li>__aeabi_unwind_cpp_pr2</li>
          <li>__ashlti3</li>
          <li>__ashrti3</li>
          <li>__divdi3</li>
          <li>__divmoddi4</li>
          <li>__divmodsi4</li>
          <li>__divsi3</li>
          <li>__divsi3</li>
          <li>__divsi3</li>
          <li>__extendsfdf2</li>
          <li>__floatdidf</li>
          <li>__floatsidf</li>
          <li>__floatsisf</li>
          <li>__floatsitf</li>
          <li>__floatundidf</li>
          <li>__floatunsidf</li>
          <li>__lshrti3</li>
          <li>__moddi3</li>
          <li>__modsi3</li>
          <li>__mulodi4</li>
          <li>__truncdfsf2</li>
          <li>__umodsi3</li>
        </ul>
      </li>
    </ul>
    <p>
    LemonBoy also fixed an edge case in <code>addXf3</code> - since the operands may be zero,
    he used the wrapping operators to avoid a spurious integer-overflow error. He then proceeded
    to other fixes:
    </p>
    <ul>
      <li>Fixed float comparison result in <code>__aeabi_{f,d}cmp*</code>.</li>
      <li>Avoid endless recursion in <code>__extendhfsf2</code> using <a href="https://ziglang.org/documentation/0.5.0/#bitCast">@bitCast</a>.</li>
    </ul>
    <p>
    With Zig 0.5.0, compiler-rt much more complete, but not fully. There are some
    <a href="https://github.com/ziglang/zig/issues/1290">missing functions</a>,
    and it's planned to do <a href="https://github.com/ziglang/zig/issues/1504">an audit</a>
    before 1.0.
    </p>
    {#header_close#}

    {#header_open|Test Coverage#}
    <p>
    Zig now has much more exhaustive test coverage of foreign architectures, thanks to
    <a href="https://www.qemu.org/">QEMU</a>. These new options are available to {#link|zig build#}
    when running the Zig test suite:
    </p>
    <ul>
      <li><code>-Denable-qemu</code> - runs cross-compiled compiler-rt, behavior, and std lib tests on
        foreign architectures.</li>
      <li><code>-Denable-wine</code> - runs cross-compiled compiler-rt, behavior, and std lib tests
        with Wine.</li>
      <li><code>-Denable-foreign-glibc=path</code> - if you have builds of glibc for other architectures
        available, this enables testing cross-compiled compiler-rt, behavior, and std lib tests
        on foreign architectures, dynamically linking glibc.</li>
      <li><code>-Dskip-non-native</code> - skips all non-native tests.</li>
      <li><code>-Dskip-libc</code> - if you don't want to wait for e.g. {#link|musl|musl 1.1.23#} to build.</li>
    </ul>
    <p>See <a href="https://github.com/ziglang/zig/blob/0.5.0/CONTRIBUTING.md">CONTRIBUTING.md</a>
    for more details.</p>
    <p>Michael Dusan implemented a new kind of test coverage for stack traces,
    to catch future regressions in {#link|Debug Info and Stack Traces#}.</p>
    <p>Additionally:</p>
    <ul>
      <li>Sahnvour implemented slightly better output for failure of tests based on text comparison.</li>
      <li>Compile error tests no longer pointlessly run in all build modes, speeding up tests.</li>
      <li>Assertions are now always enabled in the stage1 C++ compiler, and have stack traces when
          there is debug info available.</li>
      <li>LLVM IR verification is now always enabled in the stage1 C++ compiler.</li>
      <li>The self-hosted compiler is no longer being built. It's planned to resume work on the self-hosted
        compiler in the next release cycle.</li>
      <li>{#link|zig build#} scripts can take advantage of QEMU and Wine integration by doing
          {#syntax#}artifact.enable_qemu = true;{#endsyntax#} and
          {#syntax#}artifact.enable_wine = true;{#endsyntax#}, respectively.</li>
      <li>Windows CI image is updated to MSVC 2019. Build mode is changed to MinSizeRel to work
        around an MSVC bug. <a href="https://github.com/ziglang/zig/issues/3024">#3024</a></li>
    </ul>
    <p>{#syntax#}std.debug.global_allocator{#endsyntax#} is deprecated as far as being used in tests
    is concerned. Tests should use {#syntax#}std.heap.FixedBufferAllocator{#endsyntax#} and stack memory
    instead.</p>
    {#header_close#}

    {#header_open|Miscellaneous Improvements#}
    <ul>
      <li>freestanding target adds -ffreestanding to cc parameters. <a href="https://github.com/ziglang/zig/issues/2287">#2287</a></li>
      <li>hryx synchronized the grammar with the spec.</li>
      <li><a href="https://ziglang.org/documentation/0.5.0/#sizeOf">@sizeOf</a> is now defined to return <code>0</code> for {#syntax#}comptime{#endsyntax#} types.
        This defines <a href="https://ziglang.org/documentation/0.5.0/#sizeOf">@sizeOf</a> to be the runtime size of a type, which means
    that it is zero for types such as comptime_int, type, and (enum
    literal). <a href="https://github.com/ziglang/zig/issues/2209">#2209</a>
      </li>
      <li>Shawn Landden removed shebang (<code>#!</code>) support. <a href="https://github.com/ziglang/zig/issues/2165">#2165</a></li>
      <li>rylmovuk changed symbol name of tests in codegen. 
        Tests now have the symbol name of the format <code>test "&lt;name&gt;"</code> in order
        to be more easily distinguished from functions with similar names. <a href="https://github.com/ziglang/zig/issues/2267">#2267</a>
      </li>
      <li>Dong-hee Na changed the CLI parameters
        <code>--enable-pic</code> and <code>--disable-pic</code> to <code>-fPIC</code> and
        <code>-fno-PIC</code>.</li>
      <li>When using <a href="https://ziglang.org/documentation/0.5.0/#memset">@memset</a> to set bytes to {#syntax#}undefined{#endsyntax#}, Zig notices this
        case and does a single
        <a href="../0.4.0/release-notes.html#Valgrind-Compatibility">Valgrind client request</a> rather than
        N. Speeds up all allocators in safe modes. <a href="https://github.com/ziglang/zig/issues/2388">#2388</a>
      </li>
      <li>
        LemonBoy implemented stack probes for x86/x86_64 on non-Windows operating systems.
        Windows already had stack probes. This feature guarantees stack overflow to result
        in a segmentation violation when a function has a very large stack frame in danger
        of skipping over the guard page.
      </li>
      <li>Added <code>--bundle-compiler-rt</code> linker option.</li>
      <li>Added compile error for attempt to cast enum literal to error. <a href="https://github.com/ziglang/zig/issues/2203">#2203</a></li>
      <li>When Zig crashes with an assertion failure, many assertions now will print the
        Zig source code location that was related to the compiler bug.
      This helps users work around compiler bugs and helps with producing small test cases for filing a bug
      report.</li>
      <li>Jimmi Holst Christensen contributed fixes and simplifications for stage 1 parser. This
        solved the grammar ambiguity with enum literals inside array literals and struct literals. <a href="https://github.com/ziglang/zig/issues/2235">#2235</a></li>
      <li>LemonBoy implemented validation for enum tags of extern enums.
        The C specification mandates the enum to be compatible with signed char, signed int or unsigned int.
        He also implemented support for signed types as enum tags.</li>
      <li>LemonBoy improved assembly compilation to use <code>zig cc</code> rather than concatenating
        all assembly blocks into one large string and handing that to LLVM. This fixed bugs as well as
        enabling C preprocessor support for assembly files.</li>
      <li>Fix static builds of zig from requiring C compiler to be installed when linking libc.
        <br><br>
    When zig links against libc, it requires a dynamic linker path.
    Usually this can be determined based on the architecture and operating
    system components of the target. However on some systems this is not
    correct; because of this zig checks its own dynamic linker.
        <br><br>
    When zig is statically linked, this information is not available, and so
    it resorts to using cc -print-filename=foo to find the dynamic linker
    path.
        <br><br>
    Before this change, Zig incorrectly exited with an error if there was
    no C compiler installed. Now, Zig falls back to the dynamic linker
    determined based on the arch and os when no C compiler can be found.
      </li>
      <li>LemonBoy added a warning for when run/test is paired with emit options.</li>
      <li>emekoi added Windows subsystem to {#syntax#}@import("builtin"){#endsyntax#}.</li>
      <li>mrkishi added cache-control headers to tarballs on CI, making downloads faster and
          saving server costs.</li>
      <li>Sahnvour implemented the Sfc64 RNG from PractRand.</li>
      <li>No more redundant safety check when switching on tagged unions. Should improve debug build
        performance by a tiny bit.</li>
      <li>Better CLI error message for missing sub-architecture.</li>
      <li><code>std/special/bootstrap.zig</code> is renamed to <code>std/special/start.zig</code>.
        This makes a bit more sense, and actually is kinda important to make sense because it shows
        up in stack traces. Further, the logic on whether to include this file is improved.</li>
      <li>Zig now prints the directory name if it fails to write to the cache directory. <a href="https://github.com/ziglang/zig/issues/2429">#2429</a></li>
      <li>Michael Dusan added the missing help for {#syntax#}--override-lib-dir{#endsyntax#}.</li>
      <li>There is now a <code>lib/</code> directory that mirrors the directory tree of installed files,
          and <code>std/</code> is moved into it appropriately. These changes led to
          {#link|Self-Hosted Installation of Library Files#}.</li>
      <li>daurnimator added a cmake option to allow user to select static vs dynamic LLVM.</li>
      <li>Zig now calculates alignment of types itself rather than relying on LLVM. This fixes
        alignment of 128-bit integers, which is needed for <a href="https://ziglang.org/documentation/0.5.0/#cmpxchgWeak">@cmpxchgWeak</a> and <a href="https://ziglang.org/documentation/0.5.0/#cmpxchgStrong">@cmpxchgStrong</a> to
          function correctly. It also is one step in the direction of Zig having another backend
          besides LLVM.</li>
      <li>In the stage1 C++ compiler, <code>AstNode</code> objects have a <code>src()</code> method
          to print the corresponding source file, line number, and column number. This is handy
          when using a debugger.</li>
      <li>Jonathan Marler improved the C++ stage1 compiler's internal BigInt API to assert on
        unexpected data loss from casting.</li>
      <li>Michael Dusan enhanced stage1 debug printing of Zig IR:<ul>
          <li>pass2 now prints missing instructions in a trailing fashion.</li>
          <li>instruction struct name added to print as column 2.</li>
          <li>print fn name in pass1.</li>
          <li>replace scalar with enum IrPass for clarity.</li>
        </ul>
      </li>
      <li>Added ability to specify darwin framework search dirs.</li>
      <li>The CLI now accepts <code>-l</code> parameters as an alias for <code>--library</code>. As
        an example, one may specify <code>-lc</code> rather than <code>--library c</code>.</li>
      <li>Sahnvour added <code>/debug:fastlink</code> when building with MSVC and debug info.</li>
      <li>LemonBoy improved the C++ stage1 compiler to recognize and skip the UTF-8 Byte Order Mark.</li>
      <li>ScorrMorr changed ZigList::append in the C++ stage1 compiler to pass param as ref. Appears
        to be about a 2% improvement in performance.</li>
      <li>daurnimator updated the C++ stage1 compiler to use <code>zig_panic</code> rather than
        having LLVM abort.</li>
      <li>When <code>--test-cmd</code> is provided to <code>zig test</code>, it will run it regardlesso
          of whether the binary is native. This enables, for example, testing with
          <a href="https://www.qemu.org/">QEMU</a>.</li>
      <li>Added <code>-D</code> CLI parameter for setting C preprocessor definitions.</li>
    </ul>

    {#header_open|Self-Hosted .d File Parsing#}
    <p>
    When Zig compiles C code (using {#link|libclang|LLVM 9#}), it automatically enables .d file
    generation so that Zig can learn the dependencies and do proper caching.
    </p>
    <p>
    Previously, Zig's .d file parser was written in C++ and a bit brittle. Michael Dusan dove
    head-first into this and implemented a robust .d file parser, in self-hosted Zig code,
    <a href="https://github.com/ziglang/zig/blob/0.5.0/src-self-hosted/dep_tokenizer.zig#L362-L836">complete with unit tests</a>.
    </p>
    <p>
    Unfortunately, there is still
    <a href="https://github.com/ziglang/zig/issues/2046">an open issue regarding this</a>,
    because the first line Clang outputs cannot be parsed unambiguously.
    <a href="https://bugs.llvm.org/show_bug.cgi?id=41379">Clang Bug Report</a>.
    If you, the reader of these release notes, are a Clang developer, please fix ðŸ™
    </p>
    {#header_close#}

    {#header_open|Binary Size#}
    <p>{#syntax#}@import("builtin"){#endsyntax#} gained {#syntax#}strip_debug_info{#endsyntax#} which is
    a {#syntax#}comptime bool{#endsyntax#} value telling whether <code>--strip</code> was passed to the
    compiler.</p>
    <p>
    This makes Zig code aware <em>at compile-time</em> of when it will not have any debug information
    available at runtime. The standard library now takes advantage of this to avoid Zig binaries containing
    useless debug info code.
    </p>
    <p>This, along with Timon Kruiper's contribution of enabling the equivalent of
    <code>-ffunction-sections</code> in Zig's LLVM codegen, resulted in tiny
    <a href="https://ziglang.org/documentation/0.5.0/#ReleaseSmall">ReleaseSmall</a> binaries:
    <p class="file">hello.zig</p>
    <pre>{#syntax#}
const std = @import("std");

pub fn main() void {
    std.debug.warn("Hello, World!\n");
}
    {#endsyntax#}</pre>
    <pre><code class="shell">$ zig build-exe hello.zig --release-small --strip --single-threaded
$ ./hello 
Hello, World!
$ ls -ahl ./hello
-rwxr-xr-x 1 andy users 10K Sep 26 15:56 ./hello
$ ldd ./hello
  not a dynamic executable</code></pre>
    <p>The Windows build is even smaller:</p>
    <pre><code class="shell">$ zig build-exe hello.zig --release-small --strip --single-threaded -target x86_64-windows
$ wine64 ./hello.exe 
Hello, World!
$ ls -ahl ./hello.exe 
-rwxr-xr-x 1 andy users 3.0K Sep 26 15:57 ./hello.exe</code></pre>
    <p>
    Zig's ability to create tiny executables is especially attractive for {#link|WebAssembly|WebAssembly Support#}.
    </p>
    {#header_close#}

    {#header_open|Self-Hosted Installation of Library Files#}
    <p>
    Previously, when editing source files, it was required to <code>make install</code>
    (<code>msbuild -p:Configuration=Release INSTALL.vcxproj</code> on Windows) in order
    to test changes. This used cmake's <code>install()</code> function for all the library files,
    such as the {#link|Standard Library#}, as well as the {#link|libc#} files that Zig
    ships with. Unfortunately, this printed something like this every time:
    </p>
    <pre><code>-- Installing: /home/andy/dev/zig/build/lib/zig/std/array_list.zig
-- Installing: /home/andy/dev/zig/build/lib/zig/std/ascii.zig
-- Installing: /home/andy/dev/zig/build/lib/zig/std/atomic/int.zig
(...snip...)</code></pre>
    <p><em>...for all 6,091 lib files</em>. Even when the files are already installed,
    it would print:
    </p>
    <pre><code>-- Up-to-date: /home/andy/dev/zig/build/lib/zig/std/array_list.zig
-- Up-to-date: /home/andy/dev/zig/build/lib/zig/std/ascii.zig
-- Up-to-date: /home/andy/dev/zig/build/lib/zig/std/atomic/int.zig
(...snip...)</code></pre>
    <p>There is no way to disable this in cmake. This caused <code>make install</code>
    on my Linux computer to take 2.4 seconds even when it has to do nothing, and prints all these
    unnecessary lines to stdout. On my Windows it took even longer, upwards of 5 seconds.
    </p>
    <p>
    Now, installation of lib files is self-hosted, using {#link|zig build#}. Running
    <code>make</code> when there is nothing to do takes 0.3 seconds on my Linux computer;
    2.4 on Windows.
    </p>
    <p>Unfortunately, lib file installation
    happens in the <code>make</code> target instead of the <code>make install</code> target, because
    cmake has no way to add a custom command to the install target. So that's why Zig now has the
    option <code>-DZIG_SKIP_INSTALL_LIB_FILES=ON</code>, which is recommended to enable for
    contributors to Zig. It's off by default because otherwise installing Zig would be missing
    library files. However when contributing to Zig, running the <code>zig</code> binary from
    the build directory will search upwards for library files and find them directly in the source tree.
    This means one can directly edit the {#link|Standard Library#} in the source tree, and changes
    will be picked up without needing to run <code>make</code> at all.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|Bug Fixes#}
    <ul>
      <li>Shritesh Bhattarai fixed zig run not passing the exec path.</li>
      <li>Fixed 128-bit integer multiplication on Windows.</li>
      <li>LemonBoy fixed comptime shift-right. <a href="https://github.com/ziglang/zig/issues/2225">#2225</a></li>
      <li>
        Ben Noordhuis fixed an error with the cache system where it would incorrectly
        close the cache file descriptor, causing a file descriptor race condition when
        the descriptor got reused, leading to:
        <pre>Warning: Unable to write cache file [..]: unexpected seek failure</pre>
        Ben took care to make os_file_close poison the file handle
        after closing, to help track down future use-after-close bugs.
      </li>
      <li>Fixed issue with <a href="https://ziglang.org/documentation/0.5.0/#setEvalBranchQuota">@setEvalBranchQuota</a> causing assertion failure. <a href="https://github.com/ziglang/zig/issues/2261">#2261</a></li>
      <li>Fixed Debug mode when error return tracing is off. <a href="https://github.com/ziglang/zig/issues/2276">#2276</a></li>
      <li>Ryan Liptak fixed DirectAllocator not unmapping unused pages on large alignments. <a href="https://github.com/ziglang/zig/issues/2306">#2306</a></li>
      <li>Ryan Liptak fixed heap allocators when shrinking an object but growing its alignment.</li>
      <li>Ryan Liptak fixed aligned reallocs on Windows with std.heap.DirectAllocator.</li>
      <li>hryx fixed tag expression incorrectly being accepted for structs.</li>
      <li>Michael Dusan added <code>-fvisibility-inlines-hidden</code> to the build flags. 
      On macOS building with Xcode/clang the linker complains loudly when
      symbol visibility is inconsistent. This option syncs visibilty setting
      of both LLVM and Zig.
      </li>
      <li>tgschultz spotted and LemonBoy fixed Undefined Behavior invoked in the compiler's internal BigInt
        right shift operation.</li>
      <li>Fixed path canonicalization when $HOME has a trailing slash.</li>
      <li>Shritesh Bhattarai fixed docgen not properly closing tags for skipped execs.</li>
      <li>LemonBoy fixed generation of container initializers. <a href="https://github.com/ziglang/zig/issues/1636">#1636</a> <a href="https://github.com/ziglang/zig/issues/1608">#1608</a></li>
      <li>Matt Stancliff fixed a crash in command line argument parsing.</li>
      <li>LemonBoy fixed erroneous test case regarding {#syntax#}std.io.InStream{#endsyntax#}.</li>
      <li>Michael Dusan fixed compile error for loop expr val ignored. <a href="https://github.com/ziglang/zig/issues/2460">#2460</a></li>
      <li>Fix hang for some compile errors. <a href="https://github.com/ziglang/zig/issues/2467">#2467</a></li>
      <li>LemonBoy fixed <code>clock_gettime</code> on Linux systems without VDSO.</li>
      <li>daurnimator fixed <code>std.heap.FailingAllocator</code> not counting allocations.</li>
      <li>Tyler Philbrick fixed a memory leak in parser tests. See the
        <a href="https://github.com/ziglang/zig/commit/16aee1f58a80295f7599a8290d764a5c7040c373">commit message</a>
        for a nice explanation.
      </li>
      <li>LemonBoy fixed fixed formatting for multiline asm expressions.</li>
      <li>Sam Tebbs fixed zig crashing after a tokenization error.</li>
      <li>LemonBoy fixed VDSO calls not using the C calling convention.</li>
      <li>LemonBoy fixed load/store of non-integer fields in packed struct.</li>
      <li>LemonBoy fixed too eager comptime evaluation of error ptr.</li>
      <li>LemonBoy fixed build-lib on macOS. Due to a typo, Zig was not setting <code>K_DARWIN</code>
      as expected on the archive file. This allowed removing macOS-specific linking hacks.</li>
      <li>LemonBoy fixed signedness mismatch in comparison in os.cpp.</li>
      <li>emekoi fixed Zig not respecting the subsystem flag in all cases.</li>
      <li>Fix invalid LLVM IR generated for {#syntax#}?*void{#endsyntax#} const casts. <a href="https://github.com/ziglang/zig/issues/2578">#2578</a></li>
      <li>LemonBoy fixed a crash when there are no namespace components. <a href="https://github.com/ziglang/zig/issues/2500">#2500</a></li>
      <li>LemonBoy added a compile error for {#syntax#}undefined{#endsyntax#} used as a type. <a href="https://github.com/ziglang/zig/issues/2436">#2436</a></li>
      <li>Nick Erdmann fixed debug rendering of character literals &lt;= 0x0f.</li>
      <li>Sam Tebbs added a parser check for null body in {#syntax#}if{#endsyntax#}, {#syntax#}for{#endsyntax#},
        and {#syntax#}while{#endsyntax#}.</li>
      <li>Fixed <a href="https://ziglang.org/documentation/0.5.0/#export">@export</a> not working for arrays, and allow specifying link sections on {#syntax#}extern{#endsyntax#}
        variables. Additionally fixed <a href="https://ziglang.org/documentation/0.5.0/#export">@export</a> not respecting the name parameter. Previously, the variable
        name would be used instead. <a href="https://github.com/ziglang/zig/issues/2679">#2679</a></li>
      <li>Fixed compiler crash due to not resolving alignment of child types when slicing
          if custom alignment is provided.</li>
      <li>Fixed compiler crash with <a href="https://ziglang.org/documentation/0.5.0/#typeInfo">@typeInfo</a> on extern lib name.</li>
      <li>Jonathan Marler fixed duplicate exe name with <code>zig run</code>.</li>
      <li>Jonathan Marler fixed Windows create process retry/path search.</li>
      <li>joachimschmidt557 fixed {#syntax#}std.atomic.Queue.isEmpty{#endsyntax#}.</li>
      <li>Matthew Murray fixed a regression with {#syntax#}std.math.absFloat{#endsyntax#} and added tests.</li>
      <li>Michael Dusan fixed a compile error when building zig with Clang.</li>
      <li>Luna provided a quickfix on non-existing {#syntax#}std.net.Address.family{#endsyntax#}.</li>
      <li>Compile error for using slice as array init expr type when there are more than 0 elements. <a href="https://github.com/ziglang/zig/issues/2764">#2764</a></li>
      <li>Fixed {#syntax#}switch{#endsyntax#} with {#syntax#}null{#endsyntax#} and T peer types and inferred result location type. <a href="https://github.com/ziglang/zig/issues/2762">#2762</a></li>
      <li>Fixed {#syntax#}for{#endsyntax#} with {#syntax#}null{#endsyntax#} and T peer types and inferred result location type. <a href="https://github.com/ziglang/zig/issues/2762">#2762</a></li>
      <li>Michael Dusan fixed a stack escape in <code>add_source_file()</code>.</li>
      <li>Added missing compile error for comptime continue inside runtime catch. <a href="https://github.com/ziglang/zig/issues/2604">#2604</a></li>
      <li>dimenus fixed regression with static linking against MSVCRT. <a href="https://github.com/ziglang/zig/issues/2064">#2064</a></li>
      <li>Michael Dusan fixed a bug with array multiplication and functions in comptime blocks. <a href="https://github.com/ziglang/zig/issues/2916">#2916</a></li>
      <li>Michael Dusan fixed assigning an array with a non-const element value to another array (or vector) causing a segfault. <a href="https://github.com/ziglang/zig/issues/2942">#2942</a></li>
      <li>Michael Dusan updated {#syntax#}std.rb.Node.getParent{#endsyntax#} to return optional, fixing <a href="https://github.com/ziglang/zig/issues/2962">#2962</a>.</li>
      <li>Ryan Saunderson modiifed header precedence for <code>zig cc</code>,
        resolves intrinsics issues. <a href="https://github.com/ziglang/zig/issues/3027">#3027</a></li>
      <li>Fixed enum with one member and custom tag type.</li>
      <li>Fixed build errors due to vendored LLD being incorrectly dynamically linked.</li>
      <li>yvt corrected LLVM subarch names for ARM.</li>
      <li>Vexu added a compile error for incorrect atomic ordering in <a href="https://ziglang.org/documentation/0.5.0/#fence">@fence</a>. <a href="https://github.com/ziglang/zig/issues/3082">#3082</a></li>
      <li>Nick Erdmann corrected the error message when dependency requires Position Independent Code.</li>
      <li>Fixed <code>build-obj</code> not working with C files that use libc. <a href="https://github.com/ziglang/zig/issues/3093">#3093</a></li>
      <li>Fixed assigning a struct into an array defined using <code>**</code> causing a segfault when run. <a href="https://github.com/ziglang/zig/issues/3095">#3095</a></li>
      <li>Fixed {#syntax#}void{#endsyntax#} array as a local variable initializer. <a href="https://github.com/ziglang/zig/issues/1767">#1767</a></li>
      <li>Michael Dusan fixed <a href="https://ziglang.org/documentation/0.5.0/#bitCast">@bitCast</a> segfault with literal array param. <a href="https://github.com/ziglang/zig/issues/3010">#3010</a></li>
      <li>Fixed <a href="https://ziglang.org/documentation/0.5.0/#bitCast">@bitCast</a> of packed struct literal. <a href="https://github.com/ziglang/zig/issues/3042">#3042</a></li>
      <li>Timon Kruiper added compiler error when variable in asm template cannot be found. <a href="https://github.com/ziglang/zig/issues/3030">#3030</a></li>
      <li>Euan Torano fixed {#syntax#}std.os.getrandom{#endsyntax#} not filling the entire buffer when
        requesting larger than a 32-bit integer. <a href="https://github.com/ziglang/zig/issues/3012">#3012</a></li>
      <li>Jonathan Marler fixed a regression with the way LLVM types are handled causing a compiler
        crash (<a href="https://github.com/ziglang/zig/issues/3058">#3058</a>). He notes:<br>
        <blockquote>
One interesting thing here is that if the compiler was written in Zig this bug likely never would have happened as Zig would protect you from dereferencing a NULL pointer like this. The tag_type field would either be an optional type which would require testing for NULL before using it, or it wouldn't be optional and couldn't be set or initialized to NULL.
        </blockquote> 
      </li>
      <li>Fixed implicit cast from zero sized array ptr to slice. <a href="https://github.com/ziglang/zig/issues/1850">#1850</a></li>
      <li>Michael Dusan fixed stage1 build regression on macOS + xcode/clang.</li>
      <li>Michael Dusan improved building Zig from tarball source rather than git repository.<ul>
          <li>quiet <code>fatal: not a git repository</code> message.</li>
          <li>if git probe fails skip ZIG_VERSION modification.</li>
        </ul>
      </li>
      <li>Vesa Kaihlavirta fixed some test cases of {#syntax#}std.fmt.parseFloat{#endsyntax#} not parsing
        correctly.</li>
      <li>LemonBoy fixed lazy values not getting resolved when checking for definedness. <a href="https://github.com/ziglang/zig/issues/3154">#3154</a></li>
      <li>LemonBoy fixed assertions tripped from not resolving struct field types. <a href="https://github.com/ziglang/zig/issues/3143">#3143</a></li>
      <li>Timon Kruiper added compile error when shifting amount is not an int type.</li>
      <li>The C++ stage1 compiler now raises the maximum file descriptor limit by doing a
        binary search for the maximum <code>RLIMIT_NOFILE</code>. Patch lifted from node.js commit
        <a href="https://github.com/nodejs/node/commit/6820054d2d4">6820054d2d42ff9274ea0755bea59cfc4f26f353</a>.
        Thanks to Ben Noordhuis for the suggestion and patch.</li>
      <li>Timon Kruiper added compiler error when negating invalid type.</li>
      <li>emekoi fixed compiler error for gcc 9.2.0.</li>
      <li>Sahnvour added a compile error forbidding opaque types in function return types.</li>
      <li>LemonBoy forced LLVM to generate byte-aligned packed unions. Sometimes the frontend
        and LLVM would disagree on the ABI alignment of a packed union. Solve the problem by
        telling LLVM we're gonna manage the struct layout by ourselves. <a href="https://github.com/ziglang/zig/issues/3184">#3184</a></li>
      <li>LemonBoy made <a href="https://ziglang.org/documentation/0.5.0/#cDefine">@cDefine</a> accept {#syntax#}void{#endsyntax#} argument. <a href="https://github.com/ziglang/zig/issues/2612">#2612</a></li>
      <li>LemonBoy resolved lazy arguments passed to <a href="https://ziglang.org/documentation/0.5.0/#compileLog">@compileLog</a>. <a href="https://github.com/ziglang/zig/issues/3193">#3193</a></li>
      <li>Michael Dusan fixed build on macOS + xcode + clang.</li>
      <li>LemonBoy corrected <code>AT_FDCWD</code> definition.</li>
      <li>Michael Dusan fixed gcc 9.1.0 compiler error.</li>
      <li>Timon Kruiper fixed comptime bitcast inside an expression.</li>
      <li>Sahnvour added compile error rejecting types of automatic container layout in packed unions.</li>
      <li>Fixed invalid <code>tail</code> attribute for <a href="https://ziglang.org/documentation/0.5.0/#panic">@panic</a> causing undefined behavior in the stage1
        C++ compiler when it hit asserts, causing it to print garbage memory to the terminal. <a href="https://github.com/ziglang/zig/issues/3262">#3262</a></li>
      <li>LemonBoy fixed generation of tail fields for {#syntax#}packed struct{#endsyntax#}.</li>
      <li>LemonBoy corrected stack alignment for new stack.</li>
      <li>Michael Dusan fixed lost argv[0] in stage1 C++ compiler, manifesting on
        {#link|FreeBSD|FreeBSD Support#} when using <code>zig cc</code>.</li>
      <li>Fix regression causing stage1 C++ compiler crash regarding external types.</li>
      <li>LemonBoy fixed computation of switch coverage. <a href="https://github.com/ziglang/zig/issues/3258">#3258</a></li>
      <li>LemonBoy fixed crash with invalid extern type. <a href="https://github.com/ziglang/zig/issues/3240">#3240</a></li>
      <li>Jay Weisskopf made zig create the user-specified <code>output-dir</code> if it does not exist.
        <a href="https://github.com/ziglang/zig/issues/2637">#2637</a></li>
      <li>LemonBoy fixed assignment to optional payload. <a href="https://github.com/ziglang/zig/issues/3081">#3081</a></li>
      <li>LemonBoy fixed llseek behavior.</li>
      <li>LemonBoy {#syntax#}usingnamespace{#endsyntax#} causing error for redeclaration for the same var
        node. <a href="https://github.com/ziglang/zig/issues/3316">#3316</a></li>
      <li>LemonBoy added safety for truncating <code>mmap2</code> offsets if not multiple of page size.</li>
      <li>LemonBoy corrected calculation of padding length in struct, making sure the resulting type is
        in-sync with the one produced and used by LLVM. <a href="https://github.com/ziglang/zig/issues/3138">#3138</a></li>
    </ul>

    {#header_open|This Release Contains Bugs#}
    <p>
    Zig has <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Abug">known bugs</a>.
    </p>
    <p>Zig is immature. Even with Zig 0.5.0, working on a non-trivial project using Zig will likely mean
    participating in the development process.</p>
    <p>The first release that will ship with no known bugs will be 1.0.0.</p>
    {#header_close#}
    {#header_close#}

    {#header_open|Roadmap#}
    <p>The major theme of next release cycle will be <strong>safety</strong>.</p>
    <p>Along with this, it's planned to resume work on the self-hosted compiler now
    that new {#link|Async Functions#} are done.</p>
    <p>Issues that have the possibility of breaking changes to the language will be prioritized,
       so that the language can be stabilized.</p>

    {#header_open|Package Manager Status#}
    <p>
    Having a package manager built into the Zig compiler is a
    <a href="https://github.com/ziglang/zig/issues/943">long-anticipated feature</a>.
    Zig 0.5.0 does not have this feature, however the Zig project now that {#link|Async Functions#}
    are complete, it's time to begin on networking in the {#link|Standard Library#}.
    I expect to complete this along with at least an early prototype of the package manager
    during the next release cycle.
    </p>
    {#header_close#}

    {#header_open|Accepted Proposals#}
    <p>Here are proposals that have been accepted during the 0.5.0 release cycle,
    to give you an idea of the upcoming changes to Zig:</p>
    <ul>
    <li><a href="https://github.com/ziglang/zig/issues/1284">Saturating arithmetic</a></li>
    <li><a href="https://github.com/ziglang/zig/issues/1717">Make function definitions expressions</a></li>
    <li><a href="https://github.com/ziglang/zig/issues/1757">make implicit cast syntax different than function call syntax</a></li>
    <li><a href="https://github.com/ziglang/zig/issues/1770">wrapping negation -% should work on unsigned ints</a></li>
    <li><a href="https://github.com/ziglang/zig/issues/1907">introduce operating system versions as part of the target</a></li>
    <li><a href="https://github.com/ziglang/zig/issues/2022">support top level fields</a></li>
    <li><a href="https://github.com/ziglang/zig/issues/2067">add implicit cast from [*c]T to E!*T</a></li>
    <li><a href="https://github.com/ziglang/zig/issues/2097">allow unicode characters in character literals</a></li>
    <li><a href="https://github.com/ziglang/zig/issues/2292">Allocator interface: make shrinkFn optional</a></li>
    <li><a href="https://github.com/ziglang/zig/issues/2402">terminology update: use the phrase "detectable illegal behavior" rather than "safety-checked undefined behavior"</a></li>
    <li><a href="https://github.com/ziglang/zig/issues/2442">Add a way to globally have @setFloatMode set for the whole project</a></li>
    <li><a href="https://github.com/ziglang/zig/issues/2586">introduce the concept of "logging" to the standard library</a></li>
    <li><a href="https://github.com/ziglang/zig/issues/2698">@reduce builtin for turning a SIMD vector into a scalar value</a></li>
    <li><a href="https://github.com/ziglang/zig/issues/2984">make the C pointer type always a compile error unless the file declares that it is generated code</a></li>
    <li><a href="https://github.com/ziglang/zig/issues/3182">Allow COFF output for freestanding target</a></li>
    </ul>
    {#header_close#}
    {#header_close#}

    {#header_open|Active Open-Source Projects Using Zig#}
    <ul>
      <li><a href="https://dbandstra.github.io/oxid/">Oxid</a> - an arcade-style game where you fight waves of monsters in a fixed-screen maze.</li>
      <li><a href="https://donpdonp.github.io/zootdeck/">zootdeck</a> - the linux desktop fediverse reader.</li>
      <li><a href="https://fengb.github.io/fundude/">FUNâœœDUDE</a> - WebAssembly Gameboy emulator.</li>
      <li><a href="https://github.com/SamTebbs33/pluto">pluto</a> - kernel written almost entirely in Zig and supports x86, with aarch64 and x64 backends being planned.</li>
      <li><a href="https://github.com/nrdmn/uefi-paint">UEFI-paint</a> - UEFI-bootable touch paint app.</li>
      <li><a href="https://github.com/markfirmware/zig-bare-metal-raspberry-pi">zig-bare-metal-raspberry-pi</a> - demo bare-metal raspberry pi program written in zig.</li>
      <li><a href="https://wolfesoftware.com/legend-of-swarkland/">Legend of Swarkland</a> - Hack-n-slash roguelike inspired by NetHack.</li>
      <li><a href="https://prismjs.com/">PrismJS</a>
        <a href="https://github.com/PrismJS/prism/pull/2019">now supports Zig</a> - JavaScript-based syntax highlighter for web pages.</li>
    </ul>
    {#header_close#}

    {#header_open|Funding Status#}
    <p>
    During this release cycle, I joined the
    <a href="https://github.com/users/andrewrk/sponsorship">GitHub Sponsors program</a>.
    This transition went fairly smoothly, thanks to <a href="https://github.com/devonzuegel">Devon Zuegel</a>.
    It's pretty clear to me that she's going above and beyond what's professionally required of her
    to help maintainers get sponsored.
    </p>
    <p>
    At this point, funding for the Zig project is stable. There are enough funds that I can continue
    to work full time on Zig without burning down my savings. Based on current trends, I should even be
    able to get health insurance soon.
    </p>
    <p>
    However, <em>community growth has outpaced funding growth</em>. My job has become more and more demanding
    over time. Even just merging pull requests at this point is a full time job. <strong>I have averaged merging
      1.5 pull requests per day into Zig for the last 4 years.</strong> There is more than enough work for
    2 full-time developers on Zig, and I would love to get to the point where paying another full-time
    developer is possible.
    </p>
    <p>
    To facilitate this, I'm planning on starting <strong>Zig Software Foundation</strong>
    non-profit organization. I am looking for recommendations for a lawyer who would help me set this up.
    If you know one, please send me an email.
    </p>
    {#header_close#}

    {#header_open|Thank You Sponsors!#}
    <p>
    Special thanks to those who <a href="https://github.com/users/andrewrk/sponsorship">sponsor Zig</a>.
    Because of you, Zig is not driven by the needs of a business; instead it exists solely to serve
    the open source community.
    </p>
    <ul style="columns: 3">
      <li><a href="https://www.hryx.net/">Stevie Hryciw</a></li>
      <li><a href="https://github.com/mbarkhau">mbarkhau</a></li>

      <li><a href="https://wesleyhill.co.uk/">Wesley Hill</a></li>
      <li><a href="https://github.com/419928194516">419928194516</a></li>
      <li><a href="https://github.com/vegai">Vesa Kaihlavirta</a></li>
      <li><a href="https://github.com/THFKA4">THFKA4</a></li>
      <li><a href="https://github.com/ryanworl">ryanworl</a></li>
      <li><a href="https://github.com/iohzrd">iohzrd</a></li>
      <li><a href="https://ross.codes/">Ross Kilgariff</a></li>
      <li><a href="https://github.com/Bakhazard">Donald Harris</a></li>
      <li><a href="http://severnatazvezda.com/">Rickard Andersson</a></li>

      <li><a href="https://blog.filippo.io/hi">Filippo Valsorda</a></li>
      <li><a href="http://lahoda.pro/">Dzmitry Lahoda</a></li>
      <li><a href="https://github.com/overdew">Jeff Kelley</a></li>
      <li><a href="https://tav.dev/">tav</a></li>
      <li><a href="https://github.com/karrick">Karrick McDermott</a></li>
      <li><a href="https://shr.ite.sh/">Shritesh</a></li>
      <li><a href="https://dawnarc.com/">Neil Wang</a></li>
      <li><a href="https://github.com/qbradley">qbradley</a></li>
      <li><a href="http://zfeldman.com/">Zach Feldman</a></li>
      <li><a href="https://github.com/Sticksman">Felix Yuan</a></li>
      <li><a href="http://xyke.com/">Sean Jense</a></li>
      <li><a href="https://github.com/mschwaig">mschwaig</a></li>
      <li><a href="https://jayschwa.net/">Jay Weisskopf</a></li>
      <li><a href="http://champyen.blogspot.tw/">Champ Yen</a></li>
      <li><a href="https://kristoff.it/">Loris Cro</a></li>
      <li><a href="http://joshtob.in/">Josh Tobin</a></li>

      <li>Charles Palmer</li>
      <li>Yaroslav Zhavoronkov</li>
      <li>Christoffer Rasmussen</li>
      <li>Ashe Connor</li>
      <li>Jesse Meyer</li>
      <li>Simon Cruanes</li>
      <li>tschaei</li>
      <li>Omar Akkila</li>
      <li>rtroberts</li>
      <li>S-D-</li>
      <li>BenoitJGirard</li>
      <li>Jason Merrill</li>
      <li>Mitch Small</li>
      <li>dbandstra</li>
      <li>Brian Orr</li>
      <li>RaniSharim</li>
      <li>Steve Perkins</li>
      <li>redj</li>
      <li>Jeff Fowler</li>
      <li>John Schmidt</li>
      <li>via</li>
      <li>Jimmy Zelinskie</li>
      <li>Brian Mitchell</li>
      <li>Dan Boykis</li>
      <li>Mirek Rusin</li>
      <li>Audun Wilhelmsen</li>
      <li>Vladimir Vissoultchev</li>
      <li>Neil Henning</li>
      <li>Thomas Ballinger</li>
      <li>Lukas Attridge</li>
      <li>Steve Ray</li>
      <li>Will Sommers</li>
      <li>Jethro Nederhof</li>
      <li>Jack Halford</li>
      <li>Hong Shick Pak</li>
      <li>Jimmi Holst Christensen</li>
      <li>Haze Booth</li>
      <li>Johann Muszynski</li>
      <li>Eric</li>
      <li>Luis Alfonso Higuera Gamboa</li>
      <li>Åukasz Adamczak</li>
      <li>Clement 'cmc' Rey</li>
      <li>Hasan Yasin Ã–ztÃ¼rk</li>
      <li>Abdulrhman A. AlKhodiry</li>
      <li>Emily A. Bellows</li>
    </ul>
    {#header_close#}
    </div>
  </body>
</html>
