<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>0.4.0 Release Notes &middot; The Zig Programming Language</title>
    <link rel="icon" href="/favicon.png">
    <link rel="icon" href="/favicon.svg">
    <style type="text/css">
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
      }
      a:not(:hover) {
        text-decoration: none;
      }
      table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
      }
      th, td {
        padding: 0.1em;
      }
      .t0_1, .t37, .t37_1 {
        font-weight: bold;
      }
      .t2_0 {
        color: grey;
      }
      .t31_1 {
        color: red;
      }
      .t32_1 {
        color: green;
      }
      .t36_1 {
        color: #0086b3;
      }
      .file {
        text-decoration: underline;
      }
      pre,code {
        font-size: 12pt;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        color: #333;
        background: #f8f8f8;
      }
      .table-wrapper {
        width: 100%;
        overflow-y: auto;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      #contents {
        max-width: 50em;
        margin: auto;
      }

      h1 a, h2 a, h3 a, h4 a, h5 a {
        text-decoration: none;
        color: #333;
      }

      a.hdr {
        visibility: hidden;
      }
      h1:hover > a.hdr, h2:hover > a.hdr, h3:hover > a.hdr, h4:hover > a.hdr, h5:hover > a.hdr {
        visibility: visible;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background-color:#111;
            color: #bbb;
        }
        a {
            color: #88f;
        }
        table, th, td {
            border-color: grey;
        }
        .t2_0 {
            color: grey;
        }
        .t31_1 {
            color: red;
        }
        .t32_1 {
            color: green;
        }
        .t36_1 {
            color: #0086b3;
        }
        pre > code {
            color: #ccc;
            background: #222;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #e33;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
        h1 a, h2 a, h3 a, h4 a, h5 a {
            color: #aaa;
        }
      }
    </style>
  </head>
  <!--
▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
█░░░░░░░░▀█▄▀▄▀██████░▀█▄▀▄▀██████                                    
░░░░ ░░░░░░░▀█▄█▄███▀░░░ ▀█▄█▄███
cool sunglasses
  -->
  <body>
    <div id="contents">
    <a href="/"><img src="../../zig-logo.svg"></a>
    <h1>0.4.0 Release Notes</h1>
    <p>
    <a href="/download">Download &amp; Documentation</a>
    </p>
    <p>
    Zig is a general-purpose programming language designed for <strong>robustness</strong>,
    <strong>optimality</strong>, and <strong>maintainability</strong>. Zig is aggressively pursuing
    its goal of overthrowing C as the de facto language for system programming. Zig intends
    to be so practical that people find themselves using it even if they dislike it.
    </p>
    <p>
    This release features <strong>6 months of work</strong> and
    changes from <strong>46 different contributors</strong>, spread among
    <strong>875 commits</strong>.
    </p>
    <p>
    Special thanks to my <a href="https://github.com/users/andrewrk/sponsorship">sponsors who provide financial support</a>. You're making Zig sustainable.
    </p>

    {#header_open|Table of Contents#}
    {#nav#}
    {#header_close#}

    {#header_open|LLVM 8#}
    <p>
    This release of Zig upgrades to
    <a href="http://releases.llvm.org/8.0.0/docs/ReleaseNotes.html">LLVM 8</a>.
    Zig operates in lockstep with LLVM; Zig 0.4.0 is not compatible with LLVM 7.
    </p>
    <p>
    Notably this means that Zig now has {#link|WebAssembly Support#}, as well as recognizing
    the <a href="https://hermitcore.org/">HermitCore</a> and
    <a href="https://www.gnu.org/software/hurd/">Hurd</a> operating systems.
    On the other hand, support for the
    <a href="https://en.wikipedia.org/wiki/Nios_II">Nios II architecture</a> is dropped,
    due to it being an
    <a href="http://lists.llvm.org/pipermail/llvm-dev/2019-January/129121.html">experimental target which was largely unmaintained</a>.
    </p>
    {#header_close#}

    {#header_open|FreeBSD Support#}
    <p>
    Marc Tiehuis started an initial FreeBSD branch.
    Greg V picked up the figurative baton in
    <a href="https://github.com/ziglang/zig/pull/1661">#1661</a>, and Marcio Giaxa
    completed the effort.
    </p>
    <p>
    Now, FreeBSD works in the stage1 C++ compiler code, as well as the Zig Standard Library,
    which means it now has {#link|Tier 2 Support#}. To achieve {#link|Tier 1 Support#}, these things
    are needed:
    </p>
    <ul>
      <li>{#link|Implement building the FreeBSD libc startup files|Zig ships with libc#}</li>
      <li>Get all the tests passing. The CI does not have all the tests enabled for FreeBSD.</li>
    </ul>
    <p>
    Despite these issues, thanks to <a href="https://sourcehut.org/">SourceHut</a>,
    FreeBSD does have some CI testing support, as well as automated binary builds available
    for x86_64 on <a href="/download">the download page</a>.
    </p>
    <p>See <a href="https://github.com/ziglang/zig/issues/1759">#1759</a> for more details.</p>
    {#header_close#}

    {#header_open|NetBSD Support#}
    <p>Maya Rashish ported the stage1 C compiler as well as the Zig Standard Library
    to be compatible with NetBSD. Have a look at their writeup:
    <a href="http://coypu.sdf.org/porting-zig.html">Porting Zig to NetBSD - a fun, speedy port</a>
    </p>
    <p>
    NetBSD is limited to {#link|Tier 2 Support#} due to lack of a continuous integration service,
    as well as a missing implementation of
    {#link|building the system's libc startup files lazily from source|Zig ships with libc#}.
    </p>
    {#header_close#}

    {#header_open|WebAssembly Support#}
    <p>Now that Zig uses {#link|LLVM 8#}, the <code>wasm32</code> target architecture is
    guaranteed to be available in Zig.</p>
    <p>Ben Noordhuis fixed <code>zig build-exe</code> for the <code>wasm32</code> target
    (<a href="https://github.com/ziglang/zig/issues/1570">#1570</a>).</p>
    <p>Shritesh Bhattarai added <code>--allow-undefined</code> and <code>--export-all</code>
    to the wasm linker line, solving <a href="https://github.com/ziglang/zig/issues/1622">#1622</a>.
    There may be a better way to catch link errors in the future, but for now, this makes
    WebAssembly work out-of-the-box in Zig:
    </p>
    {#code_begin|syntax#}
extern fn print(i32) void;

export fn add(a: i32, b: i32) void {
    print(a + b);
}
    {#code_end#}
    <pre><code>$ zig build-exe math.zig -target wasm32-freestanding</code></pre>
    <p class="file">test.js</p>
    <pre><code>const fs = require('fs');
const source = fs.readFileSync("./math");
const typedArray = new Uint8Array(source);

WebAssembly.instantiate(typedArray, {
  env: {
    print: (result) =&gt; { console.log(`The result is ${result}`); }
  }
}).then(result =&gt; {
  const add = result.instance.exports.add;
  add(1, 2);
});</code></pre>
    <pre><code>$ node test.js
The result is 3</code></pre>
    <p>There is also the "WebAssembly System Interface" operating system target, <code>wasi</code>.
    I haven't really explored this use case yet, but I did make the C integer types work for it.
    More research and exploration is needed.</p>
    {#header_close#}

    {#header_open|64-bit ARM Linux Support#}
    <p>Shawn Landden implemented arm64 Linux support in the Zig Standard Library,
    as well as the necessary stage1 C++ compiler changes.</p>
    <p>The arm64-linux target has now graduated to {#link|Tier 2 Support#}. To achieve
    {#link|Tier 1 Support#}, we would need some way to run Continuous Integration
    tests on arm64 linux.</p>
    <p><a href="https://man.sr.ht/builds.sr.ht/compatibility.md">SourceHut has experimental arm64 Debian images</a>, which may be worth looking into.</p>
    {#header_close#}

    {#header_open|UEFI Support#}
    <p>GitHub user <a href="https://github.com/nebulaeonline">nebulaeonline</a>
    approached the Zig project with an interesting use case: creating a UEFI application.
    </p>
    <p>
    nebulaeonline <a href="https://github.com/ziglang/zig/pull/1855">submitted a pull request</a>
    adding UEFI as a new operating system that Zig recognizes. The patch contained the
    linker configuration and a few updates to the Zig Standard Library.
    </p>
    <p>With this patch merged, nebulaeonline went on to work on their
    <a href="https://github.com/nebulaeonline/nebulae/tree/a5f2bf6f90a3b28af4632cb1f5f54a97320c50d2">UEFI barebones project</a>. It looks like they ended up using C rather than Zig in the end,
    most likely due to Zig's lack of maturity. Here I have linked to the last revision before they
    removed the Zig code, in case anyone wants to poke around.
    Since then Zig has gained {#link|C Pointers#} which was a large pain point for nebulaeonline.
    </p>
    {#header_close#}

    {#header_open|Tier System#}
    <p>
    Zig now uses a "support tier" system to communicate the level of
    support for different targets.
    </p>
    {#header_open|Explanation of Tiers#}
    {#header_open|Tier 1 Support#}
    <ul>
      <li> Not only can Zig generate machine code for these targets, but the standard
   library cross-platform abstractions have implementations for these targets.
   Thus it is practical to write a pure Zig application with no dependency on
   libc.</li>
      <li>The CI server automatically tests these targets on every commit to master
      branch, and updates <a href="/download">ziglang.org/download</a> with links to pre-built binaries.</li>
      <li>These targets have debug info capabilities and therefore produce stack
 traces on failed assertions.</li>
      <li>(<a href="https://github.com/ziglang/zig/issues/514">coming soon</a>) {#link|libc is available for this target even when cross compiling|Zig ships with libc#}.</li>
    </ul>
    {#header_close#}

    {#header_open|Tier 2 Support#}
    <ul>
    <li> There may be some standard library implementations, but many abstractions
   will give an "Unsupported OS" compile error. One can link with libc or other
   libraries to fill in the gaps in the standard library.</li>
   <li> These targets are known to work, but are not automatically tested, so there
     are occasional regressions.</li>
   <li> Some tests may be disabled for these targets as we work toward Tier 1
     support.</li>
    </ul>
    {#header_close#}

    {#header_open|Tier 3 Support#}
    <ul>
    <li>The standard library has little to no knowledge of the existence of this
        target.</li>
   <li>Because Zig is based on LLVM, it has the capability to build for these
     targets, and LLVM has the target enabled by default.</li>
   <li>These targets are not frequently tested; one will likely need to contribute
     to Zig in order to build for these targets.</li>
   <li>The Zig compiler might need to be updated with a few things such as
     <ul>
       <li>what sizes are the C integer types</li>
       <li>C ABI calling convention for this target</li>
       <li>bootstrap code and default panic handler</li>
     </ul>
     <li><code>zig targets</code> is guaranteed to include this target.</li>
    </ul>
    {#header_close#}

    {#header_open|Tier 4 Support#}
    <ul>
      <li>Support for these targets is entirely experimental.</li>
      <li>LLVM may have the target as an experimental target, which means that you
   need to use Zig-provided binaries for the target to be available, or
   build LLVM from source with special configure flags. <code>zig targets</code> will
   display the target if it is available.</li>
   <li>This target may be considered deprecated by an official party,
     <a href="https://support.apple.com/en-us/HT208436">such as macosx/i386</a> in which
     case this target will remain forever stuck in Tier 4.</li>
   <li>This target may only support <code>--emit asm</code> and cannot emit object files.</li>
    </ul>
    {#header_close#}
    {#header_close#}
    {#header_open|Support Table#}
<table>
<thead>
<tr>
<th></th>
<th>freestanding</th>
<th>linux</th>
<th>macosx</th>
<th>windows</th>
<th>freebsd</th>
<th>netbsd</th>
<th>UEFI</th>
<th>other</th>
</tr>
</thead>
<tbody>
<tr>
<td>x86_64</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>i386</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>arm</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>arm64</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>bpf</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>hexagon</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>mips</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>powerpc</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>amdgcn</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>sparc</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>s390x</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>lanai</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>wasm32</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>wasm64</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>avr</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>riscv32</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>riscv64</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>xcore</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>nvptx</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>msp430</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>r600</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>arc</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>tce</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>le</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>amdil</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>hsail</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>spir</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>kalimba</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>shave</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>renderscript</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
</tbody>
</table>
    {#header_close#}
    {#header_close#}

    {#header_open|Zig is also a C Compiler#}
    <p>
    One of the main features of Zig is <a href="/documentation/0.4.0/#cImport">@cImport</a> and
    {#link|C Translation|C Translation Status#}. This is accomplished by linking against
    <a href="https://clang.llvm.org/">Clang</a> libraries. Clang is a fully featured
    C and C++ compiler. Zig has all this functionality - so we may as well expose it!
    </p>
    <p>
    The <code>zig cc</code> command exposes clang, which you can see with this amusing output:
    </p>
    <pre><code>$ zig cc --version
clang version 8.0.0
...</code></pre>
    <p><code>zig cc</code> is a bit of a low level command. The higher level command line
    interface <code>--c-source</code> (or the corresponding {#link|Zig Build System#} API)
    is recommended instead, for a few reasons:</p>
    <ul>
      <li>Compilers are core system components and often have compatibility patches to make
        them work on a given system. For example, a fresh build of clang from source does
        not work out-of-the-box on <a href="https://nixos.org/">NixOS</a>, because it is
        not aware of the location of the system libc. However if you install clang through
        the system package manager, everything works as expected, due to the patches.
        <code>zig cc</code> represents a fresh build of clang, which does not have such patches.
        This is actually A Good Thing - more on this below.
      </li>
      <li>
        The higher level interface has a consistent set of defaults for both C code and Zig code.
        For example, when using <code>--c-source</code>:<ul>
          <li>Automatic dependency tracking and caching. See {#link|Build Artifact Caching#}.</li>
          <li><code>-march=native</code> is enabled for the native target.</li>
          <li>Parameters such as <code>-target</code>, <code>--color</code>, and
            <code>--strip</code> will apply to both C and Zig Code.</li>
          <li>Zig has more capabilities as a linker driver than Clang. {#link|Zig ships with libc#}.</li>
          <li>Consistent features enabled or disabled such as stack protection,
            position independent code, and whether the frame pointer is omitted.</li>
        </ul>
      </li>
    </ul>
    <p>Here's an example of Zig building some C code:</p>
    <p class="file">hello.c</p>
    <pre><code>#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    printf("Hello world\n");
    return 0;
}</code></pre>
<pre><code>$ zig build-exe --c-source hello.c --library c
$ ./hello
Hello world</code></pre>
    <p>
    You can use <code>--verbose-cc</code> to see what C compiler command this executed:
    </p>
    <pre><code>$ zig build-exe --c-source hello.c --library c --verbose-cc
zig cc -MD -MV -MF zig-cache/tmp/42zL6fBH8fSo-hello.o.d -nostdinc -fno-spell-checking -isystem /home/andy/dev/zig/build/lib/zig/include -isystem /home/andy/dev/zig/build/lib/zig/libc/include/x86_64-linux-gnu -isystem /home/andy/dev/zig/build/lib/zig/libc/include/generic-glibc -isystem /home/andy/dev/zig/build/lib/zig/libc/include/x86_64-linux-any -isystem /home/andy/dev/zig/build/lib/zig/libc/include/any-linux-any -march=native -g -fstack-protector-strong --param ssp-buffer-size=4 -fno-omit-frame-pointer -o zig-cache/tmp/42zL6fBH8fSo-hello.o -c hello.c -fPIC</code></pre>
    <p>
    Note that if I run the command again, there is no output, and it finishes instantly:
    </p>
    <pre><code>$ time zig build-exe --c-source hello.c --library c --verbose-cc

real	0m0.027s
user	0m0.018s
sys	0m0.009s</code></pre>
    <p>
    This is thanks to {#link|Build Artifact Caching#}. Zig automatically parses the .d file that
    clang produces and uses a robust caching system to avoid duplicating work.
    </p>
    <p>In the {#link|Zig Build System#}, {#syntax#}builder.addCExecutable{#endsyntax#}
    used to be a system C compiler driver. That functionality is deleted. Instead,
    build scripts can attach C source files to any executable, library, or object
    with {#syntax#}foo.addCSourceFile{#endsyntax#}. You can see a nice example of
    this in <a href="https://github.com/mikdusan/benchmark.unicode">Michael Dusan's benchmark.unicode project</a>.</p>
    <p>Don't forget to use {#syntax#}foo.linkSystemLibrary("c");{#endsyntax#} if the C code
    expects to use libc.</p>
    <p>You may have noticed that the
    Zig-generated C compilation command included <code>-nostdinc</code>.
    </p><p>
    This is a crucial step in the direction Zig is headed - providing consistent,
    reliable builds that are insulated from the system-specific differences in the wild.
    </p><p>
    This affects <a href="/documentation/0.4.0/#cImport">@cImport</a> and
    {#link|C Translation|C Translation Status#} as well. By default, Zig no longer looks in
    system paths for C header files, instead relying only on what Zig ships and what
    users explicitly request with <code>-isystem</code>.
    </p>
    <p>
    However, when one uses the {#link|Zig Build System#}, and uses
    {#syntax#}linkSystemLibrary{#endsyntax#} API, Zig takes that as a hint to look in
    system default search paths.
    <a href="https://github.com/ziglang/zig/issues/2041#issuecomment-479335822">Marc Tiehuis proposed to expose this functionality to the command line interface</a>,
    and that is likely to be an accepted proposal.</p>
    <p>Thanks to Akuli for adding <code>/lib/x86_64-linux-gnu</code> or similar to default
    system library search paths for zig build scripts.</p>

    {#header_open|Zig ships with libc#}
    <p>
    One piece to this puzzle is that Zig now ships with libc. You can find the available
    libc targets with <code>zig targets</code>:
    </p>
    <pre><code>...
Available libcs:
  aarch64_be-linux-gnu
  aarch64_be-linux-musl
  aarch64-linux-gnu
  aarch64-linux-musleabi
  armeb-linux-gnueabi
  armeb-linux-gnueabihf
  armeb-linux-musleabi
  armeb-linux-musleabihf
  arm-linux-gnueabi
  arm-linux-gnueabihf
  arm-linux-musleabi
  arm-linux-musleabihf
  i386-linux-gnu
  i386-linux-musl
  mips64el-linux-gnuabi64
  mips64el-linux-gnuabin32
  mips64el-linux-musl
  mips64-linux-gnuabi64
  mips64-linux-gnuabin32
  mips64-linux-musl
  mipsel-linux-gnu
  mipsel-linux-musl
  mips-linux-gnu
  mips-linux-musl
  powerpc64le-linux-gnu
  powerpc64le-linux-musl
  powerpc64-linux-gnu
  powerpc64-linux-musl
  powerpc-linux-gnu
  powerpc-linux-musl
  riscv32-linux-musl
  riscv64-linux-gnu
  riscv64-linux-musl
  s390x-linux-gnu
  s390x-linux-musl
  sparc-linux-gnu
  sparcv9-linux-gnu
  x86_64-linux-gnu
  x86_64-linux-gnux32
  x86_64-linux-musl</code></pre>
    <p>
    What this means is that <code>--library c</code> for these targets <em>does not depend
      on any system files</em>!
    </p>
    <p>
    Let's look at that C hello world example again:
    </p>
<pre><code>$ zig build-exe --c-source hello.c --library c
$ ./hello
Hello world
$ ldd ./hello
	linux-vdso.so.1 (0x00007ffd03dc9000)
	libc.so.6 =&gt; /lib/libc.so.6 (0x00007fc4b62be000)
	libm.so.6 =&gt; /lib/libm.so.6 (0x00007fc4b5f29000)
	libpthread.so.0 =&gt; /lib/libpthread.so.0 (0x00007fc4b5d0a000)
	libdl.so.2 =&gt; /lib/libdl.so.2 (0x00007fc4b5b06000)
	librt.so.1 =&gt; /lib/librt.so.1 (0x00007fc4b58fe000)
	/lib/ld-linux-x86-64.so.2 =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007fc4b6672000)
</code></pre>
    <p><a href="https://www.gnu.org/software/libc/">glibc</a> does not support building
    {#link|statically|Static by Default#},
    but <a href="https://www.musl-libc.org/">musl</a> does:</p>
<pre><code>$ zig build-exe --c-source hello.c --library c -target x86_64-linux-musl
$ ./hello
Hello world
$ ldd hello
  not a dynamic executable</code></pre>
    <p>In this example, Zig built musl libc from source and then linked against it.
    The build of musl libc for x86_64-linux remains available thanks to the
    {#link|caching system|Build Artifact Caching#}, so any time this libc is needed
    again it will be available instantly.</p>
    <p>
    This means that this functionality is available on any platform. Windows and macOS users
    can build Zig and C code, and link against libc, for any of the targets listed above.
    Similarly code can be cross compiled for other architectures:
    </p>
<pre><code>$ zig build-exe --c-source hello.c --library c -target aarch64v8-linux-gnu
$ file hello
hello: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 2.0.0, with debug_info, not stripped</code></pre>
    <p>
    In some ways, Zig is a better C compiler than C compilers!
    </p>
    <p>
    This functionality is more than bundling a cross-compilation toolchain
    along with Zig. For example, the total size of libc headers that Zig ships is 22MiB
    uncompressed. Meanwhile, the headers for musl libc + linux headers on x86_64 alone
    are 8MiB, and for glibc are 3.1MiB (glibc is missing the linux headers), yet Zig currently
    ships with 40 libcs. With a naive bundling that would be 444MiB. However, thanks to
    this
    <a href="https://github.com/ziglang/zig/blob/0.4.0/libc/process_headers.zig">process_headers tool</a>
    that I made, and some
    <a href="https://github.com/ziglang/zig/wiki/Updating-libc-Headers">good old manual labor</a>,
    Zig binary tarballs remain roughly 30MiB total, despite supporting libc for all these targets,
    as well as compiler-rt, libunwind, and libcxx, and despite being a clang-compatible C compiler.
    For comparison, the Windows binary build of clang 8.0.0 itself from llvm.org is 132MiB.
    </p>
    <p>
    Note that only the {#link|Tier 1 Support#} targets have been thoroughly tested.
    It is planned to <a href="https://github.com/ziglang/zig/issues/514">add more libcs</a>
    (including for Windows), and to
    <a href="https://github.com/ziglang/zig/issues/2058">add test coverage for building against all the libcs</a>. Support for building the {#link|FreeBSD|FreeBSD Support#} libc startup files is the main feature
    needed to achieve {#link|Tier 1 Support#} for the target.
    </p>
    <p>Thanks to Jay Weisskopf for helping with the glibc targets by removing an
    obsolete compat shim file.</p>
    {#header_close#}

    {#header_open|Libc Detection#}
    <p>
    Although {#link|Zig ships with libc#} for some targets, it still supports building
    against the system-native libc.
    </p>
    <p>0.4.0 introduces a new command <code>zig libc</code> which prints
    the various paths of libc files. It outputs them to stdout
    in a simple text file format that it is capable of parsing.
    You can use <code>zig libc libc.txt</code> to validate a file.
    </p>
    <p>Here's what it looks like on my NixOS laptop:</p>
    <pre><code>$ zig libc
# The directory that contains `stdlib.h`.
# On POSIX-like systems, include directories be found with: `cc -E -Wp,-v -xc /dev/null`
include_dir=/nix/store/q2q1sg5sljia8sihhwcpbxir70yw33bw-glibc-2.27-dev/include
# The system-specific include directory. May be the same as `include_dir`.
# On Windows it's the directory that includes `vcruntime.h`.
# On POSIX it's the directory that includes `sys/errno.h`.
sys_include_dir=/nix/store/q2q1sg5sljia8sihhwcpbxir70yw33bw-glibc-2.27-dev/include

# The directory that contains `crt1.o`.
# On POSIX, can be found with `cc -print-file-name=crt1.o`.
# Not needed when targeting MacOS.
crt_dir=/nix/store/fivq0nbggp4y8mhy3ixprqd7qyn1hy2j-glibc-2.27/lib

# The directory that contains `vcruntime.lib`.
# Only needed when targeting MSVC on Windows.
msvc_lib_dir=

# The directory that contains `kernel32.lib`.
# Only needed when targeting MSVC on Windows.
kernel32_lib_dir=</code></pre>
    <p>And here's what it looks like on my Windows laptop:</p>
    <pre><code>&gt; zig.exe libc
# The directory that contains `stdlib.h`.
# On POSIX-like systems, include directories be found with: `cc -E -Wp,-v -xc /dev/null`
include_dir=C:\Program Files (x86)\Windows Kits\10\\Include\10.0.17134.0\ucrt
# The system-specific include directory. May be the same as `include_dir`.
# On Windows it's the directory that includes `vcruntime.h`.
# On POSIX it's the directory that includes `sys/errno.h`.
sys_include_dir=C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.15.26726\lib\x64\\..\..\include

# The directory that contains `crt1.o`.
# On POSIX, can be found with `cc -print-file-name=crt1.o`.
# Not needed when targeting MacOS.
crt_dir=C:\Program Files (x86)\Windows Kits\10\\Lib\10.0.17134.0\ucrt\x64\

# The directory that contains `vcruntime.lib`.
# Only needed when targeting MSVC on Windows.
msvc_lib_dir=C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.15.26726\lib\x64\

# The directory that contains `kernel32.lib`.
# Only needed when targeting MSVC on Windows.
kernel32_lib_dir=C:\Program Files (x86)\Windows Kits\10\\Lib\10.0.17134.0\um\x64\</code></pre>
    <p>These arguments are gone:</p>
    <pre>--libc-lib-dir [path]        directory where libc crt1.o resides
--libc-static-lib-dir [path] directory where libc crtbegin.o resides
--msvc-lib-dir [path]        (windows) directory where vcruntime.lib resides
--kernel32-lib-dir [path]    (windows) directory where kernel32.lib resides</pre>
    <p>Instead we have this argument:</p>
    <pre>--libc [file]                Provide a file which specifies libc paths</pre>
    <p>
    This is used to pass a libc text file (which can be generated with
    <code>zig libc</code>). So it is easier to manage multiple cross compilation
    environments.
    </p>
    <p>
    When Zig must depend on the native libc installation, it first looks for
    <code>zig-cache/native_libc.txt</code>. If found, this file will be used. If this
    file does not exist or has a parse error, Zig will perform native libc detection
    and then overwrite this file. This can save time, because native libc detection can
    be time consuming. For example it may need to invoke the system C compiler several
    times to find out paths of things, or it may invoke some Windows COM API which is a bit
    non-deterministic in terms of performance.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|Static by Default#}
    <p>The <code>--static</code> CLI option is removed and the <code>-dynamic</code>
    option is added.</p>
    <p>Instead of an explicit <code>--static</code> flag, Zig makes things as static
    as possible by default. Even <code>zig build-lib</code> will now create a static
    library by default, but <code>-dynamic</code> can be used to choose a dynamic
    library.</p>
    <p>
    When targeting Linux, Zig now automatically links statically when not linking against
    any shared libraries. It also disables Position Independent Code in this case, which
    <a href="http://ewontfix.com/18/">improves performance</a>, especially with regards
    to {#link|Thread-Local Variables#}. <code>--enable-pic</code>
    and <code>--disable-pic</code> can be used to override the default, but this
    should be a rare use case.
    </p>
    <p>Position Independent Code is also disabled by default for the freestanding OS target.
    When targeting Windows, Position Independent Code is always enabled.</p>
    <p>It is <a href="https://github.com/ziglang/zig/issues/2213">proposed to rename these options</a> to <code>-fPIC</code> and <code>-fno-PIC</code> to match C compilers.</p>
    {#header_close#}

    {#header_open|Single-Threaded Builds#}
    <p>
    For some use cases, it is known at compile-time that a given application or executable will
    never participate in multi-threading. For these use cases Zig has
    <a href="/documentation/0.4.0/#Single-Threaded-Builds">Single-Threaded Builds</a>.
    </p>
    <p>There is now a compile option <code>--single-threaded</code> which has the following effects:</p>
    <ul>
      <li>All {#link|Thread Local Variables#} are treated as
        <a href="/documentation/0.4.0/#Global-Variables">Global Variables</a>.</li>
      <li>The overhead of <a href="/documentation/0.4.0/#Coroutines">Coroutines</a> becomes
        equivalent to function call overhead. Note this will not be implemented until the
        upcoming {#link|Coroutine Rewrite|Coroutine Status#}</li>
      <li>The {#syntax#}@import("builtin").single_threaded{#endsyntax#} becomes
        {#syntax#}true{#endsyntax#}
        and therefore various userland APIs which read this variable become more efficient:<ul>
          <li>{#syntax#}std.Mutex{#endsyntax#} becomes an empty data structure and all of its functions become no-ops.</li>
          <li>John Schmidt made {#syntax#}std.heap.ThreadSafeFixedBufferAllocator{#endsyntax#}
            alias {#syntax#}std.heap.FixedBufferAllocator{#endsyntax#} when
            <code>--single-threaded</code>. <a href="https://github.com/ziglang/zig/issues/1910">#1910</a></li>
          <li>Shritesh Bhattarai made {#syntax#}std.os.exit{#endsyntax#} use the
            <code>exit_group</code> syscall when not single-threaded.</li>
        </ul>
      </li>
    </ul>
    <p>
    The feature is exposed in the {#link|Zig Build System#} with
    {#syntax#}foo.single_threaded = true;{#endsyntax#}
    </p>
    {#header_close#}

    {#header_open|Zig Build System#}
    <p>
    When one invokes the <code>zig build</code> command, this executes a user-defined
    build script. This is called the <strong>zig build system</strong>. It received
    a few improvements during this release cycle.
    </p>
    <p>
    Notably, {#link|Build Artifact Caching#} is enabled by default.
    This means that by default build artifacts are now output into the
    <code>zig-cache</code> directory. The output path is not predictable and if the build
    script desires to run an executable, rather than hard coding a path and using
    {#syntax#}builder.addCommand{#endsyntax#}, build scripts
    must use {#syntax#}executable.run{#endsyntax#} API, or {#syntax#}addArtifactArg{#endsyntax#}.
    An example of this can be found in the
    <a href="https://github.com/andrewrk/tetris/blob/166246d8f1d889333e74a1a9cee894750f2d4cca/build.zig#L27">tetris example</a>.
    </p>
    <p>
    {#syntax#}builder.addSystemCommand{#endsyntax#} is available to run commands that are not
    created by the build system itself. An example of this can be found in the
    <a href="https://github.com/andrewrk/clashos/blob/91f45cff49128b3322f98cc78ed08df5bcec35cb/build.zig#L32">Raspberry Pi OS example</a>.
    </p>
    <p>
    Another option build scripts have is to specify the output directory of an artifact with
    {#syntax#}artifact.setOutputDir{#endsyntax#}. This disables caching and makes
    {#syntax#}artifact.getOutputPath{#endsyntax#},
    {#syntax#}artifact.getOutputLibPath{#endsyntax#}, and
    {#syntax#}artifact.getOutputHPath{#endsyntax#} available.
    </p>
    <p>
    Finally, the best way to make the output path of an artifact predictable is to install it
    with the build system's install step. There are some ergonomics and defaults to improve
    with this strategy, which will be tackled during the next release cycle.
    </p>
    <p>Please note that Zig does no cache evicting yet. You may have to
       manually delete zig-cache directories periodically to keep disk
       usage down. It's planned for this to be a simple Least Recently
       Used eviction system eventually.</p>
    <p><code>--output</code>, <code>--output-lib</code>, and <code>--output-h</code> are removed.
      Instead, use <code>--output-dir</code> which defaults to the current working directory.
      Or take advantage of <code>--cache on</code>, which will print the main output
       path to stdout, and the other artifacts will be in the same directory
       with predictable file names. <code>--disable-gen-h</code> is available when
       one wants to prevent .h file generation.</p>
    <p><a href="/documentation/0.4.0/#cImport">@cImport</a> is always independently cached now.
       It always writes the generated Zig code to disk which makes debug
       info and compile errors better. No more "TODO: remember C source
       location to display here" <a href="https://github.com/ziglang/zig/issues/2015">#2015</a>.
       The <code>--verbose-cimport</code> command no longer dumps Zig AST to stderr; instead
       it prints the file paths of the generated .zig files for inspection. In addition to
       this improved behavior, the common case of {#syntax#}@cImport{#endsyntax#} with all the
       C header files unchanged is now fast due to being cached, yet still correct if any of
       the C files change.
    </p>
    <p>In addition, these improvements were made:</p>
    <ul>
      <li>Zig no longer creates "temporary files" other than inside a
        zig-cache directory.</li>
      <li>Zig uses <code>os_self_exe_path</code> to determine exe path not <code>argv[0]</code></li>
      <li>Tests as part of the build system support all of the same API as executables,
      libraries, and objects.</li>
      <li>{#syntax#}linkLibrary{#endsyntax#} will make the target depend on libc if the source does.</li>
      <li>When building C source file(s), don't try to generate .h files.</li>
      <li>Added {#syntax#}builder.addFmt{#endsyntax#} API and use it to test stage1 zig fmt. <a href="https://github.com/ziglang/zig/issues/1968">#1968</a></li>
      <li>Fixed build.zig not respecting <code>--static</code>. <a href="https://github.com/ziglang/zig/issues/2027">#2027</a></li>
      <li>Shritesh Bhattarai gave usageAndErr a clean exit which makes <code>zig build --help</code>
        more friendly. (<a href="https://github.com/ziglang/zig/issues/2194">#2194</a>)</li>
      <li>Ruslan Prokopchuk implemented support for {#syntax#}LibExeObjStep.disable_gen_h{#endsyntax#}.
        It is sometimes useful to skip generating of the header file (e.g.
        <a href="https://github.com/ziglang/zig/issues/2173">#2173</a>), and zig compiler
        provides an option <code>--disable-gen-h</code> to control that behaviour. However,
        setting {#syntax#}lib.disable_gen_h = true{#endsyntax#} in a typical <code>build.zig</code> didn't append
        the option to arguments. This commit fixes it and adds a convenient <code>setDisableGenH</code>
        setter.</li>
      <li>Windows doesn't have rpaths for DLLs so we instead add
        search paths to Path environment variable when running
        an executable that depends on DLLs built with zig build.</li>
    </ul>

    {#header_open|Build Artifact Caching#}
    <p>
    Zig comes with a robust caching system. When compiling Zig code, Zig knows all the files that
    it depends on, and when compiling C code, Zig uses <code>-MV -MD -MF</code> parameters to
    Clang and then parses the generated .d file.
    </p>
    <p>
    The other component of this is the "compiler id" concept:
    </p>
    <pre><code>$ zig id
Cxb7A-sAjt6VDq35pHZj3ACcwiSFqcCndt0NJkdQQlZVKolwm-QKnce1KEMUTqPr</code></pre>
    <p>
    This is the hash of the compiler binary itself, plus all the dynamic libraries it depends on,
    directly or indirectly. That means if you fix a bug in <code>memcpy</code> in the system libc,
    Zig will detect this change and the value of <code>zig id</code> will be different.
    However, the value is quickly computed because it also participates in the caching system.
    </p>
    <p>
    Here is a "manifest file" in the caching system for <code>zig id</code>:
    </p>
    <pre><code>4850313 1554740311 416647968 cOOP0xpsfiYfuMJCS3V_fLKdNmxFxLih_UACAUqwynGp1Y616NJ2lHL0hOpWOp_o /home/andy/dev/zig/build/zig
3077799 1 0 bBgfkt9ZSVN_HgBbzwHhzKmQxpssdDYq_HcbEkdu7KDcUhanATUER2_5l_U__9DE /nix/store/5dphwv1xs46n0qbhynny2lbhmx4xh1fc-zlib-1.2.11/lib/libz.so.1
1165671 1 0 jSVrSQyNkPFoz0Z6GesezdVP1ZBRpHL2UbbX7HbNEprcU4aBuIyG9z6bAOvvPZr0 /nix/store/fivq0nbggp4y8mhy3ixprqd7qyn1hy2j-glibc-2.27/lib/librt.so.1
1165626 1 0 scJm8rYLhDLp_SDXmbvdlcj9fEWQadEm_kHUBJn2oGnht3pSh2MNzsUJZjR1wwa1 /nix/store/fivq0nbggp4y8mhy3ixprqd7qyn1hy2j-glibc-2.27/lib/libdl.so.2
1165664 1 0 pGDNQn5x_j1NAWzjh4AOUP8OKyJj1KSPd4SJYzRVbTTp7TRb4IQpDs7ZAU3muqfz /nix/store/fivq0nbggp4y8mhy3ixprqd7qyn1hy2j-glibc-2.27/lib/libpthread.so.0
1165631 1 0 4tmxoKlbVwB42gYxT7B3CKIBXpbGdb_vuqfYiXlOZdyngmFJdQ7DBZxWqZKSO0Ss /nix/store/fivq0nbggp4y8mhy3ixprqd7qyn1hy2j-glibc-2.27/lib/libm.so.6
3077645 1 0 dxe6qw_yMCi8Bp7ocrVcl2XMdRlKfa0S3ATqbxsEMISRQdQ1dyxTEE1uDbv0R54z /nix/store/sf0wnp30savqz9ljn6fsrn8f63w5v0za-gcc-7.4.0-lib/lib/libstdc++.so.6
1165630 1 0 5boikua2jQubswAtj8MICJzjmGNUxTZrNreQm_DmtspgRsXULyCkyUUMYcNFamII /nix/store/fivq0nbggp4y8mhy3ixprqd7qyn1hy2j-glibc-2.27/lib/libgcc_s.so.1
1165616 1 0 qiXB510da3ryfL7LcPUvL2EQgY2tIwszLRvgQdDrQtnWVl4zA1Nfpq4SDpIz3IYW /nix/store/fivq0nbggp4y8mhy3ixprqd7qyn1hy2j-glibc-2.27/lib/libc.so.6
1165607 1 0 MpHwajxu3h0TtsHViKMAmHHeGMbi9IuDLlybX6PpqT66Xfa1h2GAT3XFIX19dEz- /nix/store/fivq0nbggp4y8mhy3ixprqd7qyn1hy2j-glibc-2.27/lib/ld-linux-x86-64.so.2</code></pre>
    <p>
    The fields are, respectively:
    </p>
    <ol>
      <li>inode</li>
      <li>mtime seconds</li>
      <li>mtime nanoseconds</li>
      <li>blake hash of file contents</li>
      <li>path to file</li>
    </ol>
    <p>
    This same system is used for build artifact caching. For example, here is the manifest file
    for hello world in Zig (when built with <code>--cache on</code>):
    </p>
    <pre><code>5505089 1548876783 204467480 rcnRrxBgZSiWki_XN9XKlQ2yfWkM6KLYhUWprzniEBtjgmeUSmtlv5mAguA4l2Q1 /home/andy/dev/zig/example/hello_world/hello.zig
4850617 1554305190 0 GXP-IfocPj934vVJYrccBKIVoOcWULaUtkBoR-iHnEKEIoXtdchyuQi8tk8FTncS /home/andy/dev/zig/build/lib/zig/std/std.zig
5114024 1551557778 0 6u-vFMcHH_FcfkAyqCcoYXAfF2TLMCkoP86Q3Ykecmage7_E4ObRsfP52-YXDHH6 /home/andy/dev/zig/build/lib/zig/std/special/panic.zig
4850617 1554305190 0 GXP-IfocPj934vVJYrccBKIVoOcWULaUtkBoR-iHnEKEIoXtdchyuQi8tk8FTncS /home/andy/dev/zig/build/lib/zig/std/std.zig
4850277 1553179780 0 9S5aQg0ORbkQnvDCVeW2aNPSeCu993I4iO3JoGrif4py7zBS4si4mCaeHHuo9TEn /home/andy/dev/zig/build/lib/zig/std/debug.zig
4849956 1554500038 0 8c76uDlKxK5jZ1L0Uup4Lu0y1NlU5-KrUCKFyZnzoi7Hv3dDByN8pvujTjxjaf0m /home/andy/dev/zig/build/lib/zig/std/os.zig
4850678 1554330534 0 wFvlet_2y9YT6NlFrsqybubwMafHFCIZqq4AxLlcUGuTSZ7VjI8kGmM-3VKPrhkt /home/andy/dev/zig/build/lib/zig/std/io.zig
5112957 1551560716 0 f29y95JhSfGVwEFrutPnquGPPuvvtOLu6_vUUgGbaqn-9uulgFvBnyPU8Zp_sH7r /home/andy/dev/zig/build/lib/zig/std/os/file.zig
5113386 1552707664 0 Mb9m-jj_wRe6yt-TFko9wUGNToAA-IAbVfmR2TYZyPjKP3D87df6BGALjai5uKr2 /home/andy/dev/zig/build/lib/zig/std/os/windows/util.zig
5113248 1551562209 0 F1infSSAdOgbOWl3y2FdUiB-6xrpTaeqUJ5xt_F9IZOeBvvTSLNpkGEg8mrYMcli /home/andy/dev/zig/build/lib/zig/std/os/linux.zig
5113251 1536869149 0 LAlDVvl1TX-3-SB3MOBBjxuEk2Ms8SpkcYBLXnJONgZuo7aV9OYfXLfih9bfGyBS /home/andy/dev/zig/build/lib/zig/std/os/linux/errno.zig
5113278 1551560715 0 TpIIt3DNczfgMKjhDA5mx-4JgoGd7SIV9lXK8GQs9Bix4EmPiL7VlV1oQVwv4gkO /home/andy/dev/zig/build/lib/zig/std/os/linux/x86_64.zig
4849832 1554482295 0 AszHJ9beyMCotgQx4vwYWMBUcRd1dBspsou64fATNYXsSqwB5zAiqVEokfpV5xkF /home/andy/dev/zig/build/lib/zig/std/fmt.zig
4850680 1551559869 0 Polq06O1t-jJ0SobBVqLaQrJVXaKzH4lQj6Na8NRN3Y5N0pZ2I4W2rpwL816MSz- /home/andy/dev/zig/build/lib/zig/std/io/seekable_stream.zig
4850605 1552687041 0 Al_VWoytLHeozYOvM69cCR2Dw1HGYdJc2lDGQDXYoiJy1VuD6GWLIQhxSJuf3Oza /home/andy/dev/zig/build/lib/zig/std/array_list.zig
4877695 1552687041 0 ouDIQ9yX5LXanXk6mc2ypFP-oy2zEt7uLLlPDVUFEfx4AKmeFP1cJWI7YSjYAVt9 /home/andy/dev/zig/build/lib/zig/std/mem.zig
4850649 1551560732 0 rVa_7s1plylcGIUAHEt3eGG8XwSJAEOQzuIaYcnq0KHnb1IoGWUEXUGIW7QHH7fi /home/andy/dev/zig/build/lib/zig/std/elf.zig
4849844 1554305190 0 58Tg88pYb1sgK8SI5_65Gy7lgCqaJmsW2NV-Hi4FeXOK8e2f2T1PofNfdUDgbYit /home/andy/dev/zig/build/lib/zig/std/math.zig
4850647 1536869149 0 9-R2p6FQ_7UIjQMt3N-chgeh-_e_o29Gr2Pybfh2PurmRYT9mIIwsdW9rs6kEJR8 /home/andy/dev/zig/build/lib/zig/std/dwarf.zig
5113295 1552687041 0 6oc1oIiWQJ1OIZGh5KFPtul93GCeAaLFx2VTICI3JMt-Ubnj-vjXvBBclnoo5UQ6 /home/andy/dev/zig/build/lib/zig/std/os/path.zig
4850677 1552707664 0 qom60op_QDptmhKO6SIlpm48SlVybcFOT0gHCjncJvtZhM6uUNqZZ2Q0WV5AsmRP /home/andy/dev/zig/build/lib/zig/std/heap.zig
4850683 1551560704 0 6t3PH8KaWwsz2MElBWZezzyZyeRS-Ttq6k2pJWwRK__NvVQ2hZSu1gk4jA7oDT_Y /home/andy/dev/zig/build/lib/zig/std/linked_list.zig
4850685 1548876783 0 EsROc7EV9MKNd74wRR9tYFhMGs4CL4eqYSPvJVzKTzSoXABBfxVoQwO3N_VivhNG /home/andy/dev/zig/build/lib/zig/std/macho.zig
4850663 1554667129 0 oWDxArJXQLKaeAqd-Uf52hiAjktfqEhJA4XIdlBKCeKOxbYZosChXsfReGM0azCQ /home/andy/dev/zig/build/lib/zig/std/hash_map.zig
4877700 1551559918 0 0SY3kFjpRYGQ1eVmh4UHluGBDFA9LcwANsSlEZLKfBO6hWxoZWcowtXk1SJvSALu /home/andy/dev/zig/build/lib/zig/std/pdb.zig
4850628 1551559906 0 QEww1cNolzNrXqhOMV8uMTXRXQmbekZ7nyUaEqj35x6ZjO8BRVzqvYxQeSmW8c_5 /home/andy/dev/zig/build/lib/zig/std/coff.zig
4877702 1551562259 0 9cFnTGm01DAKqMZim8dzEXoPyN8w3R8UAer53ycBv2PFgg-pM6AsNd6hDf0jlseT /home/andy/dev/zig/build/lib/zig/std/rand.zig
5113402 1554353707 0 m2d1Awh2J4qJuWpBI5sEZJyszBZB2VIZlHvVpXZlt9Vz9JdjXvMN2Cig4ohevME_ /home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig
4877697 1551560726 0 y2XL97U7jZ9PY4d5TVVZmBzYQc5wrCE_j_utDeU8zfLp5W6iLdFEf_HLbG4-W9Mf /home/andy/dev/zig/build/lib/zig/std/mutex.zig
4877707 1551560708 0 jd03IjTqKqI-sTTbTTL63EjXX2xp9vPInAn4fA0rRis3TeXGgWnP-44_8N0OTRPP /home/andy/dev/zig/build/lib/zig/std/spinlock.zig</code></pre>
    <p>
    The way the cache checking works, is that it calls <code>fstat</code> on all the files in the
    manifest. For each file, if the inodes and mtimes from the manifest match the results from
    <code>fstat</code>, then the hash is trusted to be up-to-date for that particular file.
    Any files with outdated hashes, have their contents hashed, and the manifest file updated
    with the updated hashes. Finally, all the hashes are hashed together, and that final hash
    is used as the directory name within <code>zig-cache</code> that Zig looks for previously
    created build artifacts.
    </p>
    <p>Because Zig uses <code>-MD -MF</code> args to clang when doing
        {#syntax#}@cImport{#endsyntax#}, Zig has a complete list of files that the C code read from,
        which Zig adds to the cache. So even when using {#syntax#}@cImport{#endsyntax#},
        Zig's caching system remains perfect. This is a proof of concept
        for the mechanism that the {#link|self-hosted compiler|Self-Hosted Compiler Status#}
        will use to watch and rebuild files.</p>
    <p>
    There is one really fascinating problem to solve when relying on file modification times
    to determine whether a file's contents have changed. Some file systems, such as macOS's HFS+,
    do not support nanosecond precision; only seconds. However even nanosecond precision exhibits
    the problem for very fast systems.
    </p>
    <p>
    Imagine that a file was modified, and then immediately after, added to the cache. When
    added to the manifest, the current time and the file's mtime will be the same. If the file
    is modified again quickly, and then the cache checked, it will still be the same instant in
    time; the modification to the file did not change the mtime.
    </p>
    <p>
    There is a beautiful solution to this problem, which is to disqualify a file from being cached
    if the current time, truncated to the file system time granularity, matches the mtime:
    </p>
    <pre><code>// If the wall clock time, rounded to the same precision as the
// mtime, is equal to the mtime, then we cannot rely on this mtime
// yet. We will instead save an mtime value that indicates the hash
// must be unconditionally computed.
static bool is_problematic_timestamp(const OsTimeStamp *fs_clock) {
    OsTimeStamp wall_clock = os_timestamp_calendar();
    // First make all the least significant zero bits in the fs_clock, also zero bits in the wall clock.
    if (fs_clock-&gt;nsec == 0) {
        wall_clock.nsec = 0;
        if (fs_clock-&gt;sec == 0) {
            wall_clock.sec = 0;
        } else {
            wall_clock.sec &amp;= (-1ull) &lt;&lt; ctzll(fs_clock-&gt;sec);
        }
    } else {
        wall_clock.nsec &amp;= (-1ull) &lt;&lt; ctzll(fs_clock-&gt;nsec);
    }
    return wall_clock.nsec == fs_clock-&gt;nsec &amp;&amp; wall_clock.sec == fs_clock-&gt;sec;
}</code></pre>
    <p>
    What's beautiful about this is that it generalizes to any granularity. If a file system had a
    1 day mtime granularity, then this would mean any files modified within 1 day would have to
    have their contents hashed, but files older than that could have their hashes trusted.
    If a file system always wrote 0 for the mtime, Zig would never trust it.
    </p>
    <p>
    Thanks to <a href="https://apenwarr.ca/log/20181113">apenwarr's insightful blog post about build system caching</a> for inspiration.
    </p>
    <p>
    The caching system is disabled by default for the command line interface, except for <code>zig test</code>. <code>zig test</code> does respect <code>--output-dir</code> however, which disables caching.
    The default caching behavior can be overridden with <code>--cache [on|off]</code>.
    The {#link|Zig Build System#} enables caching by default.
    </p>
    <p>
    Caching is always enabled, using the global cache directory, when building libc and compiler-rt.
    This saves a considerable amount of accumulated time, since they must be available for every
    compilation.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|Valgrind Compatibility#}
    <p>
    Zig's compatibility with Valgrind has improved. Notably,
    Valgrind 3.14 fixes
    <a href="https://github.com/ziglang/zig/issues/896">a bug where Zig programs' debug symbols
    would not be detected</a>. Because of this, the <code>--no-rosegment</code>
    command line option is removed from Zig. It was only meant to be a temporary workaround.
    </p>
    <p>Thanks to daurnimator for adding a valgrind module to the standard library.
    This allows Zig code to easily make
    <a href="http://valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.clientreq">Valgrind client requests</a>.
    </p>
    <p>In addition to userland API, Zig integrates more tightly with Valgrind. For example,
    one thing that Zig does in <a href="/documentation/0.4.0/#Debug">Debug</a> builds is 
    write {#syntax#}0xaa{#endsyntax#} bytes to {#syntax#}undefined{#endsyntax#} variables:
    </p>
    {#code_begin|exe|undef#}
const std = @import("std");

pub fn main() void {
    var array: [10]u8 = undefined;
    std.debug.warn("array: {x}\n", array);
}
    {#code_end#}
    <p>
    Valgrind has detection for branching on undefined values, but if Zig was writing
    {#syntax#}0xaa{#endsyntax#} values to uninitialized variables, Valgrind would not know
    that this is supposed to be an undefined canary. It would see the values as defined.
    However thanks to integrated Valgrind client requests with the Zig language, Valgrind
    knows what's going on:
    </p>
    {#code_begin|exe|undef#}
const std = @import("std");

pub fn main() void {
    var x: i32 = 1234;
    std.debug.warn("x = {}\n", x);
    x = undefined;
    if (x > 10) {
        std.debug.warn("greater than 10\n");
    }
}
    {#code_end#}
    <p>When run in valgrind:</p>
    <pre><code>==16484== Conditional jump or move depends on uninitialised value(s)
==16484==    at 0x224B6C: main (undef.zig:7)
==16484==    by 0x22455A: posixCallMainAndExit (bootstrap.zig:86)
==16484==    by 0x224350: _start (bootstrap.zig:43)</code></pre>
    <p>
    This is a debugging tool available in Zig that is not available in C -
    setting things to {#syntax#}undefined{#endsyntax#} so that Valgrind can
    catch it if you accidentally use it.
    </p>
    <p>
    Language integration with Valgrind is enabled by default in
    <a href="/documentation/0.4.0/#Debug">Debug</a> mode, and disabled by default in other
    modes. The feature can be force enabled or force disabled with
    <code>--enable-valgrind</code> and <code>--disable-valgrind</code>, respectively.
    Also available is {#syntax#}@import("builtin").valgrind_support{#endsyntax#} which is a
    {#syntax#}comptime{#endsyntax#} {#syntax#}bool{#endsyntax#} available for code to
    find out whether the programmer wants the executable to have Valgrind integration.
    It's always disabled for compiler_rt and libc/builtin.
    </p>
    <p>
    The cost of this feature is a few assembly instructions with each assignment to
    {#syntax#}undefined{#endsyntax#}. Only support for Linux, macOS, Solaris, and
    MinGW on x86_64 is currently implemented.
    </p>
    {#header_close#}

    {#header_open|zig fmt#}
    <p><code>zig fmt</code> is a tool to format your Zig code to a canonical style.
    It's implemented in Zig and it's been available as a
    {#link|self-hosted compiler|Self-Hosted Compiler Status#} subcommand for a while,
    but the self-hosted compiler is not done yet and it's not what's available on
    <a href="/download">the download page</a>.
    </p>
    <p>
    Zig 0.4.0 ships with <code>zig fmt</code> capabilities. Under the hood, it uses
    <code>zig run</code> and the {#link|Build Artifact Caching#} system, to lazily build
    <code>zig fmt</code> from source, and then run it.
    That means even the stage1 C++ Zig compiler is a sort of hybrid - part C++, and part Zig.
    </p>
    <p>
    Several editors have <code>zig fmt</code> integration available, such as the
    <a href="https://github.com/ziglang/zig.vim">vim plugin</a> that I use.
    I believe the <a href="https://github.com/ziglang/vscode-zig/">VSCode plugin</a> does as well.
    </p>
    <p>
    There is now has a <code>--check</code> flag, which does everything
    except modify file contents. That is, it lists non-conforming files on stdout,
    and then exits with an error if the list is non-empty. <a href="https://github.com/ziglang/zig/issues/1558">#1558</a> <a href="https://github.com/ziglang/zig/issues/1555">#1555</a>
    </p>
    <p>Other improvements during this release cycle:</p>
    <ul>
      <li>Fixed infix operator before multiline string literal.</li>
      <li>Fixed argv[0] handled incorrectly.</li>
      <li>Removed <code>this</code> as a keyword since it was
        <a href="/download/0.3.0/release-notes.html#remove-this">removed in 0.3.0</a>.</li>
      <li>Shritesh Bhattarai fixed zig fmt not detecting extra whitespace at the end
        of a file. <a href="https://github.com/ziglang/zig/issues/2074">#2074</a></li>
      <li>Shritesh Bhattarai implemented support for documentation comments on 
        parameter declarations.</li>
      <li>hryx implemented vertically aligning array literal columns.</li>
      <li>hryx implemented Always write a multiline struct literal if a field expr is multiline.</li>
      <li>Shritesh Bhattarai fixed first line comment indent in struct init.</li>
      <li>hryx implemented allowing one-line for loops.</li>
      <li>Shritesh Bhattarai implemented formatting multi line only on trailing comma.
        (<a href="https://github.com/ziglang/zig/issues/2184">#2184</a>)</li>
      <li>Shritesh Bhattarai implemented support for trailing comma after var_args.</a>
    </ul>
    <p>
    There is also a
    <a href="https://github.com/ziglang/zig/issues/2196">discussion about whether or not to align struct fields</a>,
    which has some interesting arguments on either side.
    </p>
    {#header_close#}

    {#header_open|C Translation Status#}
    <p>
    I have come up with <a href="https://github.com/ziglang/zig/issues/1964">a plan to migrate translate-c to userland</a>:
    </p>
    <ol>
      <li>Create a C API wrapper for Clang's C++ API.</li>
      <li>Implement translate-c in Zig with a C API, using the C API wrapper for libclang.</li>
      <li>The build process for stage1 will link zig.exe without translate-c support,
        build the translate-c userland library, and then re-link zig.exe with translate-c support.</li>
    </ol>
    <p>This will allow us to move thousands of lines of C++ to Zig, and to only have to maintain
    one implementation of C translation rather than two. This same strategy could be used
    for other pieces of the Zig project, such as the {#link|package manager|Package Manager Status#}.</p>
    <p>I started this effort with a proof of concept, but there is still a long way to go before this is done.</p>

    <p>In addition the following improvements were made:</p>
    <ul>
    <li>Much of translated C code looks cleaner thanks to {#link|C Pointers#}.</li>
    <li>support no-op cast</li>
    <li><code>--verbose-cimport</code> prints clang command</li>
    <li>Avoid array concatenation if the init node is empty, for clarity. -Antoine Vugliano</li>
    <li>Only detect ints as negative if they are signed. -Antoine Vugliano</li>
    <li>Correct array concatenation for incomplete C array initializers. -Antoine Vugliano</li>
    <li>Get real child type of array type for incomplete initializers and/or multi-dimensional arrays. -Antoine Vugliano</li>
    <li>LemonBoy implemented translation of parameterless C functions (<a href="https://github.com/ziglang/zig/issues/1978">#1978</a>).
      This solves <a href="https://stackoverflow.com/questions/49892119/zig-translate-c-doesnt-translate-main-function">the only StackOverflow question tagged "Zig"</a>.
    </li>
    <li>Antoine Vugliano added support for integer suffixes on 0 (zero) litteral inside
      macro definitions.</li>
    <li>Jimmi Holst Christensen implemented a workaround for <a href="https://github.com/ziglang/zig/issues/2043">#2043</a>.</li>
    <li>Jimmi Holst Christensen implemented enough of translate-c to translate the <code>assert</code>
      macro from glibc.</li>
    </ul>
    {#header_close#}

    {#header_open|Grammar Formalization and Specification#}
    <p>Jimmi lead this effort. Starting with solving the return type ambiguity (<a href="https://github.com/ziglang/zig/issues/1628">#1628</a>),
    he then moved on to create <a href="https://github.com/ziglang/zig-spec">zig-spec</a>,
    update the <a href="/documentation/0.4.0/#Grammar">grammar section of the language reference</a>,
    and update the stage1 parser to conform.
    </p>
    <p>
    Thanks to his efforts, Zig syntax now has a formal grammar specification and three independent
    implementations, despite the fact that the syntax is not fully stablized.
    </p>
    {#header_close#}

    {#header_open|Documentation#}
    <p>The <a href="/documentation/0.4.0">language reference manual</a>.
       now has a light theme by default, but respects the user's light/dark
       preference via the
       <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme">prefers-color-scheme media query</a>.
       Most browsers don't support this yet, so we just have to wait patiently
       for the future to arrive.
    </p>
    <p>Instead of a side bar index, the index is inline with the rest of the
       content. This is simpler and more friendly to all user agents, and means
       we don't need the media query for mobile devices. It also makes
       back-references work, so now headers link to the table of contents
       and the table of contents links to headers.
    </p>
    <p>
      Both of these things apply to this release notes document as well as the
      language reference manual.
    </p>
    <p>There is still no HTML documentation available for the Zig Standard Library.
    See the {#link|Roadmap#} for more details.</p>
    <p>The
    <a href="/documentation/master/">master branch language reference manual</a>
    is now automatically updated on master branch commits
    that pass all tests on all platforms.</p>
    <p>In addition to the above, the following changes were made to the documentation:</p>
    <ul>
      <li>Improved: <a href="/documentation/0.4.0/#Pointers">Pointers</a></li>
      <li>New section: <a href="/documentation/0.4.0/#volatile">volatile</a></li>
      <li>New section: <a href="/documentation/0.4.0/#Optional-Pointers">Optional Pointers</a></li>
      <li>Improved: <a href="/documentation/0.4.0/#Operators">Operators</a></li>
      <li>Improved: <a href="/documentation/0.4.0/#Pass-by-value-Parameters">Pass-by-value Parameters</a></li>
      <li>Improved: <a href="/documentation/0.4.0/#Shadowing">Shadowing</a></li>
      <li>John Schmidt made some tweaks to function documentation (<a href="https://github.com/ziglang/zig/issues/1961">#1961</a>)</li>
      <li>New section: <a href="/documentation/0.4.0/#packed-struct">packed struct</a></li>
      <li>New section: <a href="/documentation/0.4.0/#Zero-Bit-Types">Zero Bit Types</a></li>
      <li>Improved: <a href="/documentation/0.4.0/#union">union</a></li>
      <li>New section: <a href="/documentation/0.4.0/#Implicit-Casts">Implicit Casts</a></li>
      <li>Improved: <a href="/documentation/0.4.0/#export">@export</a></li>
      <li>Improved: <a href="/documentation/0.4.0/#import">@import</a></li>
      <li>New section: <a href="/documentation/0.4.0/#Memory">Memory</a></li>
      <li>New section: <a href="/documentation/0.4.0/#Assembly">Assembly</a></li>
      <li>New section: <a href="/documentation/0.4.0/#Zig-Test">Zig Test</a></li>
      <li>Matt Stancliff fixed typos around pointer usage.</li>
      <li>Vallentin fixed documentation typos.</li>
      <li>New section: <a href="/documentation/0.4.0/#extern-struct">extern struct</a></li>
      <li>New section: <a href="/documentation/0.4.0/#Variables">Variables</a></li>
      <li>Jay Weisskopf made the docs use the section symbol § rather than the paragraph symbol ¶,
      pointing out that a header may cover more than one paragraph, so a section symbol is more
      appropriate.</li>
      <li>Jay Weisskopf improved the documentation - and these release notes - to use the system-ui font family, as well as fallbacks for when this is not available.</li>
      <li>Henry Nelson documented explicitly ignoring expression values.</li>
    </ul>
    {#header_close#}

    {#header_open|Language Changes#}
    <ul>
    <li>Renamed <code>section</code> keyword to {#syntax#}linksection{#endsyntax#}. <a href="https://github.com/ziglang/zig/issues/1152">#1152</a></li>
    <li>
      Zig no longer has an <a href="/documentation/0.4.0/#Implicit-Casts">implicit cast</a> from {#syntax#}T{#endsyntax#} to {#syntax#}*const T{#endsyntax#}. <a href="https://github.com/ziglang/zig/issues/1465">#1465</a>
      <ul>
        <li>removed implicit cast from {#syntax#}*T{#endsyntax#} to {#syntax#}?*const T{#endsyntax#}</li>
        <li>removed implicit cast from {#syntax#}T{#endsyntax#} to {#syntax#}?*const T{#endsyntax#} when {#syntax#}T{#endsyntax#} is a struct/union</li>
      </ul>
    </li>
    <li>Remove <code>@minValue</code>,<code>@maxValue</code>; add {#syntax#}std.math.minInt{#endsyntax#} and {#syntax#}std.math.maxInt{#endsyntax#}. <a href="https://github.com/ziglang/zig/issues/1466">#1466</a> <a href="https://github.com/ziglang/zig/issues/1476">#1476</a></li>
    <li>Now the length expression in array type syntax implies {#syntax#}comptime{#endsyntax#},
      so function calls, for example, will be evaluated without the need for an explicit
      {#syntax#}comptime{#endsyntax#} block. Similarly:
      <ul>
        <li>{#syntax#}**{#endsyntax#} and {#syntax#}++{#endsyntax#} operators force comptime
          on operands. <a href="https://github.com/ziglang/zig/issues/1707">#1707</a></li>
      </ul>
    </li>
      <li>
        <a href="/documentation/0.4.0/#for">for</a> now works with single-item pointers to arrays. <a href="https://github.com/ziglang/zig/issues/1663">#1663</a> -Jimmi Holst Christensen
      </li>
    <li>Added <a href="/documentation/0.4.0/#bswap">@bswap</a> builtin function. <a href="https://github.com/ziglang/zig/issues/767">#767</a></li>
    <li>vegecode added the <a href="/documentation/0.4.0/#bitreverse">@bitreverse</a> builtin function. <a href="https://github.com/ziglang/zig/issues/767">#767</a></li>
    <li><a href="/documentation/0.4.0/#sizeOf">@sizeOf</a> is now defined to be the "ABI size"
      rather than the "store size". Quoting from the documentation:
      <br><br>
      This size may contain padding bytes. If there were two consecutive T in memory,
      this would be the offset in bytes between element at index 0 and the element at
      index 1. For <a href="/documentation/0.4.0#Integers">Integers</a>, consider whether
      you want to use {#syntax#}@sizeOf(T){#endsyntax#} or
      {#syntax#}@typeInfo(T).Int.bits{#endsyntax#}.
      <br><br>
      This fixes breaches of the guarantee that {#syntax#}@sizeOf(T) >= @alignOf(T){#endsyntax#}.
      It also fixes {#syntax#}std.mem.secureZero{#endsyntax#} for integers where this guarantee
      previously was breached, and it fixes {#syntax#}std.mem.Allocator{#endsyntax#} for integers
      where this guarantee previously was breached. <a href="https://github.com/ziglang/zig/issues/1851">#1851</a> <a href="https://github.com/ziglang/zig/issues/1864">#1864</a></li>
    <li>emekoi made <a href="/documentation/0.4.0#enumToInt">@enumToInt</a> work on {#syntax#}union(enum){#endsyntax#}. <a href="https://github.com/ziglang/zig/issues/1711">#1711</a></li>
    <li>Better handling of arrays in packed structs. <a href="https://github.com/ziglang/zig/issues/677">#677</a><ul>
        <li>Allow extern structs to be in packed structs.</li>
        <li>More helpful error messages when trying to use types in packed structs
          that are not allowed.</li>
        <li>Support arrays in packed structs even when they are not byte-aligned.</li>
        <li>Add compile error for using arrays in packed structs when the padding bits
          would be problematic. This is necessary since Zig does not have packed arrays.</li>
      </ul></li>
    <li>Better field access of types which have one possible value. <a href="https://github.com/ziglang/zig/issues/1554">#1554</a><ul>
        <li>When you do field access of a type which only has one possible
          value, the result is comptime-known.</li>
       <li>StorePtr instructions which operate on pointers to types which
         only have one possible value, the result is a comptime no-op.</li>
      </ul></li>
      <li><a href="/documentation/0.4.0/#returnAddress">@returnAddress</a> and
        <a href="/documentation/0.4.0/#frameAddress">@frameAddress</a> now return a {#syntax#}usize{#endsyntax#} rather than a pointer.</li>
      <li>{#syntax#}builtin.TypeInfo.ErrorSet{#endsyntax#} is now {#syntax#}?[]Error{#endsyntax#}
        instead of {#syntax#}struct{errors:[]Error}{#endsyntax#}. <a href="https://github.com/ziglang/zig/issues/1936">#1936</a></li>
      <li>Removed octal and binary floats from the language. This is technically a
        breaking change but I would be surprised if anyone was actually using this feature.
        MateuszOkulus did the documentation updates. <a href="https://github.com/ziglang/zig/issues/2093">#2093</a></li>
      <li>Character literals allow unicode escapes. <a href="https://github.com/ziglang/zig/issues/2097">#2097</a></li>
      <li>Added peer type resolution for {#syntax#}*const T{#endsyntax#} and {#syntax#}?*T{#endsyntax#}. <a href="https://github.com/ziglang/zig/issues/1298">#1298</a></li>
      <li>Added compile error for ignoring error. <a href="https://github.com/ziglang/zig/issues/772">#772</a></li>
      <li>Add {#syntax#}allowzero{#endsyntax#} pointer attribute. Only useful for
        freestanding targets. Also adds safety for
        <a href="/documentatino/0.4.0/#intToPtr">@intToPtr</a> when the address is zero. <a href="https://github.com/ziglang/zig/issues/1953">#1953</a></li>
      <li>alexander implemented switching on bools. <a href="https://github.com/ziglang/zig/issues/1768">#1768</a></li>
    </ul>

    {#header_open|Implicit Casting Comptime-Known Integers#}
    <p>All numbers with comptime known values now implicitly cast
    to all number types. If the value does not fit, a compile error
    is emitted.</p>
    {#code_begin|test|comptime_ints#}
const std = @import("std");
const assert = std.debug.assert;

test "implicit cast large integer to smaller with comptime value" {
    const x: u64 = 255;
    const y: u8 = x;
    assert(y == 255);
}
    {#code_end#}
    <p><a href="https://github.com/ziglang/zig/issues/422">#422</a> <a href="https://github.com/ziglang/zig/issues/1712">#1712</a></p>
    {#header_close#}

    {#header_open|Vectors and SIMD#}
    <p>
    Zig 0.4.0 ships with a new <a href="/documentation/0.4.0/#Vector">Vector</a> type.
    This feature is brand new and <a href="/documentation/0.4.0/#SIMD">not well documented yet</a>.
    Here are some example tests:
    </p>
    {#code_begin|test|vectors#}
const std = @import("std");
const mem = std.mem;
const expect = std.testing.expect;

test "vector wrap operators" {
    const S = struct {
        fn doTheTest() void {
            var v: @Vector(4, i32) = [4]i32{ 2147483647, -2, 30, 40 };
            var x: @Vector(4, i32) = [4]i32{ 1, 2147483647, 3, 4 };
            expect(mem.eql(i32, ([4]i32)(v +% x), [4]i32{ -2147483648, 2147483645, 33, 44 }));
            expect(mem.eql(i32, ([4]i32)(v -% x), [4]i32{ 2147483646, 2147483647, 27, 36 }));
            expect(mem.eql(i32, ([4]i32)(v *% x), [4]i32{ 2147483647, 2, 90, 160 }));
            var z: @Vector(4, i32) = [4]i32{ 1, 2, 3, -2147483648 };
            expect(mem.eql(i32, ([4]i32)(-%z), [4]i32{ -1, -2, -3, -2147483648 }));
        }
    };
    S.doTheTest();
    comptime S.doTheTest();
}

test "vector int operators" {
    const S = struct {
        fn doTheTest() void {
            var v: @Vector(4, i32) = [4]i32{ 10, 20, 30, 40 };
            var x: @Vector(4, i32) = [4]i32{ 1, 2, 3, 4 };
            expect(mem.eql(i32, ([4]i32)(v + x), [4]i32{ 11, 22, 33, 44 }));
            expect(mem.eql(i32, ([4]i32)(v - x), [4]i32{ 9, 18, 27, 36 }));
            expect(mem.eql(i32, ([4]i32)(v * x), [4]i32{ 10, 40, 90, 160 }));
            expect(mem.eql(i32, ([4]i32)(-v), [4]i32{ -10, -20, -30, -40 }));
        }
    };
    S.doTheTest();
    comptime S.doTheTest();
}

test "vector float operators" {
    const S = struct {
        fn doTheTest() void {
            var v: @Vector(4, f32) = [4]f32{ 10, 20, 30, 40 };
            var x: @Vector(4, f32) = [4]f32{ 1, 2, 3, 4 };
            expect(mem.eql(f32, ([4]f32)(v + x), [4]f32{ 11, 22, 33, 44 }));
            expect(mem.eql(f32, ([4]f32)(v - x), [4]f32{ 9, 18, 27, 36 }));
            expect(mem.eql(f32, ([4]f32)(v * x), [4]f32{ 10, 40, 90, 160 }));
            expect(mem.eql(f32, ([4]f32)(-x), [4]f32{ -1, -2, -3, -4 }));
        }
    };
    S.doTheTest();
    comptime S.doTheTest();
}

test "vector bit operators" {
    const S = struct {
        fn doTheTest() void {
            var v: @Vector(4, u8) = [4]u8{ 0b10101010, 0b10101010, 0b10101010, 0b10101010 };
            var x: @Vector(4, u8) = [4]u8{ 0b11110000, 0b00001111, 0b10101010, 0b01010101 };
            expect(mem.eql(u8, ([4]u8)(v ^ x), [4]u8{ 0b01011010, 0b10100101, 0b00000000, 0b11111111 }));
            expect(mem.eql(u8, ([4]u8)(v | x), [4]u8{ 0b11111010, 0b10101111, 0b10101010, 0b11111111 }));
            expect(mem.eql(u8, ([4]u8)(v & x), [4]u8{ 0b10100000, 0b00001010, 0b10101010, 0b00000000 }));
        }
    };
    S.doTheTest();
    comptime S.doTheTest();
}
    {#code_end#}
    <p>Note that Zig of course supports vectors at {#syntax#}comptime{#endsyntax#} and likewise
    all the safety features of arithmetic operators are available for vectors as well.</p>
    <p>
    Vectors provide a way to do Single Instruction Multiple Data in a portable and efficient way.
    It's much easier for the optimizer to break vectors into scalars than it is to
    turn scalars into vectors. Even in debug builds which have safety checks, vector operations
    provide more data throughput than scalar operations.
    </p>
    <p>Thanks to Jimmi Holst Christensen for many contributions to vector support.</p>
    <p>To follow progress on vectors and SIMD in Zig, watch issue
    <a href="https://github.com/ziglang/zig/issues/903">#903</a>.</p>
    {#header_close#}

    {#header_open|comptime memory reinterpretation#}
    <p>Zig's {#syntax#}comptime{#endsyntax#} facilities are improved to support
    reinterpreting memory, as long as the types in question have guaranteed
    in-memory representation.</p>
    {#code_begin|test|bitcast#}
const builtin = @import("builtin");
const std = @import("std");
const expect = std.testing.expect;

test "@bitCast extern structs at runtime and comptime" {
    const Full = extern struct {
        number: u16,
    };
    const TwoHalves = extern struct {
        half1: u8,
        half2: u8,
    };
    const S = struct {
        fn doTheTest() void {
            var full = Full{ .number = 0x1234 };
            var two_halves = @bitCast(TwoHalves, full);
            switch (builtin.endian) {
                builtin.Endian.Big => {
                    expect(two_halves.half1 == 0x12);
                    expect(two_halves.half2 == 0x34);
                },
                builtin.Endian.Little => {
                    expect(two_halves.half1 == 0x34);
                    expect(two_halves.half2 == 0x12);
                },
            }
        }
    };
    S.doTheTest();
    comptime S.doTheTest();
}

test "reinterpret bytes of an array into an extern struct" {
    testReinterpretBytesAsExternStruct();
    comptime testReinterpretBytesAsExternStruct();
}

fn testReinterpretBytesAsExternStruct() void {
    var bytes align(2) = []u8{ 1, 2, 3, 4, 5, 6 };

    const S = extern struct {
        a: u8,
        b: u16,
        c: u8,
    };

    var ptr = @ptrCast(*const S, &bytes);
    var val = ptr.c;
    expect(val == 5);
}

    {#code_end#}
    <p>These examples work because {#syntax#}extern struct{#endsyntax#} and {#syntax#}packed struct{#endsyntax#} have guaranteed in-memory layout.</p>
    <p>
    In addition, as long as the memory is never accessed, pointers with hard coded addresses
    and pointer arithmetic are supported at {#syntax#}comptime{#endsyntax#}:
    </p>
    {#code_begin|test|comptime_ptrs#}
const std = @import("std");
const expect = std.testing.expect;

test "C pointer comparison and arithmetic" {
    const S = struct {
        fn doTheTest() void {
            var one: usize = 1;
            var ptr1: [*c]u32 = 0;
            var ptr2 = ptr1 + 10;
            expect(ptr1 == 0);
            expect(ptr1 >= 0);
            expect(ptr1 <= 0);
            expect(ptr1 < 1);
            expect(ptr1 < one);
            expect(1 > ptr1);
            expect(one > ptr1);
            expect(ptr1 < ptr2);
            expect(ptr2 > ptr1);
            expect(ptr2 >= 40);
            expect(ptr2 == 40);
            expect(ptr2 <= 40);
            ptr2 -= 10;
            expect(ptr1 == ptr2);
        }
    };
    S.doTheTest();
    comptime S.doTheTest();
}

    {#code_end#}
    {#header_close#}

    {#header_open|Thread-Local Variables#}
    <p>A variable may be specified to be a thread-local variable using the
      {#syntax#}threadlocal{#endsyntax#} keyword:</p>
    {#code_begin|test|tls#}
const std = @import("std");
const assert = std.debug.assert;

threadlocal var x: i32 = 1234;

test "thread local storage" {
    const thread1 = try std.os.spawnThread({}, testTls);
    const thread2 = try std.os.spawnThread({}, testTls);
    testTls({});
    thread1.wait();
    thread2.wait();
}

fn testTls(context: void) void {
    assert(x == 1234);
    x += 1;
    assert(x == 1235);
}
    {#code_end#}
    <p>
      For {#link|Single-Threaded Builds#}, all thread local variables are treated
      as <a href="/documentation/0.4.0/#Global-Variables">Global Variables</a>.
    </p>
    <p>
    Thread local variables may not be {#syntax#}const{#endsyntax#}.
    </p>
    <p>
    Note that thread local variables have better performance for
    non- position independent code, which is one reason for
    {#link|Static by Default#}.
    </p>
    <p>
    Thanks to Rich Felker from the musl libc project,
    who gave me this crucial information, when I was implementing
    thread local storage for static builds:
    </p>
    <blockquote>
    to satisfy the abi, your init code has to write the same value
    to that memory location as the value passed to the [arch_prctl]
    syscall
    </blockquote>
    {#header_open|Avoid Creating Unnecessary Global Constants#}
    <p>
    This deletes some legacy cruft, and produces leaner object files.
    Example:
    </p>
    {#code_begin|syntax#}
var x: i32 = 1234;

export fn entry() i32 {
    return x;
}
    {#code_end#}
    
    <p>This produced:</p>
    
    <pre><code>@x = internal unnamed_addr global i32 1234, align 4
@0 = internal unnamed_addr constant i32* @x, align 8</code></pre>
    
    <p>
    and @0 was never even used. After Zig 0.4.0, @0 is not produced.
    </p>
    
    <p>
    This fixes a bug: Zig was creating invalid LLVM IR when one of these
    globals that shouldn't exist takes the address of a thread local
    variable. In {#link|LLVM 8#}, it would produce a linker error. But
    probably after my bug report is solved it will be caught by the IR
    verifier.
    </p>

    <p>
    Thanks to <strong>Rui Ueyama</strong> and <strong>George Rimar</strong> who helped me
    troubleshoot this problem
    when I filed an <a href="https://bugs.llvm.org/show_bug.cgi?id=40652">LLVM bug report</a>.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|C Pointers#}
    <p>
    One of the use cases of Zig is to beat C at its own game, and this means being a better
    language for using C libraries than C is.
    It's a tall order to fulfill, and it was compromised by Zig's
    <a href="/download/0.3.0/release-notes.html#pointer-reform">pointer reform</a>. An unfortunate
    side effect of having more type safety in pointer types was that C's very unsafe pointer types
    became awkward to use. It is ambiguous whether pointers should be {#link|translated|C Translation Status#} as
    single-item pointers ({#syntax#}*T{#endsyntax#}) or unknown-length pointers ({#syntax#}[*]T{#endsyntax#}).
    </p>
    <p>
    <a href="/documentation/0.4.0/#C-Pointers">C Pointers</a> are a compromise so that
    Zig code can utilize translated header files directly.
    </p>
    <p>
    This type is to be avoided whenever possible. The only valid reason for using a C pointer is in
    auto-generated code from translating C code.
    </p>
    <p>{#syntax#}[*c]T{#endsyntax#} - C pointer.</p>
    <ul>
      <li>Supports all the syntax of the other two pointer types.</li>
      <li>Implicitly casts to other pointer types, as well as <a href="/documentation/0.4.0/#Optional-Pointers">Optional Pointers</a>.
          When a C pointer is implicitly casted to a non-optional pointer, safety-checked
          <a href="/documentation/0.4.0/#Undefined-Behavior">Undefined Behavior</a> occurs if the address is 0.
      </li>
      <li>Allows address 0. On non-freestanding targets, dereferencing address 0 is safety-checked
        <a href="/documentation/0.4.0/#Undefined-Behavior">Undefined Behavior</a>. Optional C pointers introduce another bit to keep track of
          null, just like {#syntax#}?usize{#endsyntax#}. Note that creating an optional C pointer
          is unnecessary as one can use normal <a href="/documentation/0.4.0/#Optional-Pointers">Optional Pointers</a>.
      </li>
      <li>Supports <a href="/documentation/0.4.0/#Implicit-Casts">implicit casting</a> to and from integers.</li>
      <li>Supports comparison with integers.</li>
      <li>Does not support Zig-only pointer attributes such as alignment. Use normal
        <a href="/documentation/0.4.0/#Pointers">Pointers</a> please!</li>
    </ul>
    <p>It's planned to <a href="https://github.com/ziglang/zig/issues/1967">support `if`, `orelse`, `null`, and `.?` for C pointers</a>.</p>
    <p>
    While C pointers themselves have all the footguns associated with, well, C pointers, there
    is safety when converting to Zig pointers:
    </p>
    {#code_begin|test_err|causes pointer to be null#}
test "cast null C pointer to Zig pointer" {
    var c_ptr: [*c]i32 = 0;
    var zig_ptr: *i32 = c_ptr;
}
    {#code_end#}
    {#header_close#}

    {#header_open|Removal of the Namespace Type#}
    <p>
    In Zig 0.3.0, {#syntax#}@typeOf(@import("builtin")){#endsyntax#} is <code>(import)</code>,
    which was a special "namespace" type. In Zig 0.4.0,
    {#syntax#}@typeOf(@import("builtin")){#endsyntax#} is {#syntax#}type{#endsyntax#}.
    The special "namespace" type is removed; instead all files are structs with no fields.
    </p>
    <p>
    This makes the language smaller and simpler, and makes imported files easier to inspect
    with reflection, since they are structs.
    </p>
    <p>
    With this change, struct types get fully qualified names and function symbol names
    become fully qualified. This means that when using <code>zig test</code> it's no longer
    necessary to manually namespace test names as they will be automatically namespaced.
    </p>
    <p>
    There is a new compile error for importing a file outside the package path.
    The new CLI option <code>--main-pkg-path</code> can be used to choose
    a different root package directory besides the one inferred from the
    root source file. The corresponding {#link|Zig Build System#} API is 
    {#syntax#}artifact.setMainPkgPath(path){#endsyntax#}.
    </p>
    {#header_close#}

    {#header_open|Anonymous Enum Literal Type#}
    <p>
    Zig has a new type to make dealing with enums more attractive. It can be thought of as the
    {#syntax#}enum{#endsyntax#} equivalent of {#syntax#}comptime_int{#endsyntax#}. The {#syntax#}enum{#endsyntax#}
    equivalent of a number literal.
    </p>
    {#code_begin|exe|enum-lit#}
const std = @import("std");

pub fn main() void {
    print(1234, .hex);
    print(1234, .normal);
}

fn print(x: i32, mode: enum { normal, hex }) void {
    switch (mode) {
        .normal => std.debug.warn("{}\n", x),
        .hex => std.debug.warn("0x{x}\n", x),
    }
}
    {#code_end#}
    <p>
    Here you can see an anonymous
    {#syntax#}enum{#endsyntax#} was used rather than an opaque {#syntax#}bool{#endsyntax#} parameter.
    The idea here is to make it so easy to have meaningful values, that programmers will want
    to use them, even if they're feeling lazy.
    </p>
    <p>
    The ergonomics of this feature feel great. Here's
    <a href="https://github.com/ziglang/zig/pull/2175/files">tgschultz updating some of the standard
      library API to use anonymous enum literals</a>.
    </p>
    <p>
    Note that this feature is checked by the compiler. It's completely safe:
    </p>
    {#code_begin|test_err|has no field#}
const std = @import("std");

test "invalid enum literal" {
    print(1234, .hex);
    print(1234, .invalid);
}

fn print(x: i32, mode: enum { normal, hex }) void {
    switch (mode) {
        .normal => std.debug.warn("{}\n", x),
        .hex => std.debug.warn("0x{x}\n", x),
    }
}
    {#code_end#}
    {#header_close#}
    {#header_close#}

    {#header_open|Standard Library API Changes#}
    <ul>
      <li>{#syntax#}std.debug.failing_allocator{#endsyntax#} is now a {#syntax#}*Allocator{#endsyntax#}
        rather than the {#syntax#}FailingAllocator{#endsyntax#} state. -Jimmi Holst Christensen</li>
      <li>Renamed {#syntax#}std.event.tcp{#endsyntax#} to {#syntax#}std.event.net{#endsyntax#}.</li>
      <li>update std lib API for I/O<ul>
        <li>Renamed {#syntax#}std.io.FileInStream{#endsyntax#} to {#syntax#}std.os.File.InStream{#endsyntax#}</li>
        <li>Renamed {#syntax#}std.io.FileInStream.init(file){#endsyntax#} to {#syntax#}file.inStream(){#endsyntax#}</li>
        <li>Renamed {#syntax#}std.io.FileOutStream{#endsyntax#} to {#syntax#}std.os.File.OutStream{#endsyntax#}</li>
        <li>Renamed {#syntax#}std.io.FileOutStream.init(file){#endsyntax#} to {#syntax#}file.outStream(){#endsyntax#}</li>
        <li>Fewer error code possibilities from several os functions</li>
        <li>Renamed {#syntax#}std.event.net.socketRead{#endsyntax#} to {#syntax#}std.event.net.read{#endsyntax#}</li>
        <li>Renamed {#syntax#}std.event.net.socketWrite{#endsyntax#} to {#syntax#}std.event.net.write{#endsyntax#}</li>
        <li>Added {#syntax#}std.event.net.readv{#endsyntax#}</li>
        <li>Added {#syntax#}std.event.net.writev{#endsyntax#}</li>
        <li>Added {#syntax#}std.event.net.readvPosix{#endsyntax#}</li>
        <li>Added {#syntax#}std.event.net.writevPosix{#endsyntax#}</li>
        <li>Added {#syntax#}std.event.net.OutStream{#endsyntax#}</li>
        <li>Added {#syntax#}std.event.net.InStream{#endsyntax#}</li>
        <li>Added {#syntax#}std.event.io.InStream{#endsyntax#}</li>
        <li>Added {#syntax#}std.event.io.OutStream{#endsyntax#}</li>
        </ul></li>
      <li>std lib: posixRead can return less than buffer size. <a href="https://github.com/ziglang/zig/issues/1414">#1414</a>
        <ul>
          <li>{#syntax#}std.io.InStream.read{#endsyntax#} now can return less than buffer size</li>
          <li>introduce {#syntax#}std.io.InStream.readFull{#endsyntax#} for previous behavior</li>
    
          <li>add {#syntax#}std.os.File.openWriteNoClobberC{#endsyntax#}</li>
          <li>rename {#syntax#}std.os.deleteFileWindows{#endsyntax#} to {#syntax#}std.os.deleteFileW{#endsyntax#}</li>
          <li>remove {#syntax#}std.os.deleteFilePosix{#endsyntax#}</li>
          <li>add {#syntax#}std.os.deleteFileC{#endsyntax#}</li>
    
          <li>{#syntax#}std.os.copyFile{#endsyntax#} no longer takes an allocator</li>
          <li>{#syntax#}std.os.copyFileMode{#endsyntax#} no longer takes an allocator</li>
          <li>{#syntax#}std.os.AtomicFile{#endsyntax#} no longer takes an allocator</li>
    
          <li>add {#syntax#}std.os.renameW{#endsyntax#}</li>
          <li>add windows support for {#syntax#}std.os.renameC{#endsyntax#}</li>
        </ul>
      </li>
      <li>add {#syntax#}std.os.linux.vfork{#endsyntax#} and {#syntax#}std.os.linux.exit_group{#endsyntax#}</li>
      <li>changed {#syntax#}std.os.time.sleep(seconds: usize, nanoseconds: usize){#endsyntax#} to {#syntax#}(nanoseconds: u64){#endsyntax#}. -Marc Tiehuis</li>
      <li>Added {#syntax#}std.math.maxInt{#endsyntax#} and {#syntax#}std.math.minInt{#endsyntax#}</li>
      <li>Added {#syntax#}std.crypto.HmacBlake2s256{#endsyntax#}</li>
      <li>Added {#syntax#}std.net.Address.port{#endsyntax#} -Josh Wolfe</li>
      <li>Added {#syntax#}std.io.NullOutStream{#endsyntax#} and {#syntax#}std.io.CountingOutStream{#endsyntax#} -Jimmi Holst Christensen</li>
      <li>{#syntax#}std.io.InStream(E).readStruct{#endsyntax#} returns a value instead of taking a pointer. -Jimmi Holst Christensen</li>
      <li>Added {#syntax#}std.atomic.Int.set{#endsyntax#}. -Josh Wolfe</li>
      <li>Added {#syntax#}std.meta.intToEnum{#endsyntax#}.</li>
      <li>Revamped the {#syntax#}std.rand.Rand{#endsyntax#} API to better handle the
        concept of bias. -Josh Wolfe<ul>
          <li>Added {#syntax#}std.rand.Rand.uintLessThanBiased{#endsyntax#}</li>
          <li>Added {#syntax#}std.rand.Rand.uintAtMostBiased{#endsyntax#}</li>
          <li>Added {#syntax#}std.rand.Rand.intRangeLessThanBiased{#endsyntax#}</li>
          <li>Added {#syntax#}std.rand.Rand.intRangeAtMostBiased{#endsyntax#}</li>
        </ul></li>
      <li>Added {#syntax#}std.HashMap.getOrPutValue{#endsyntax#}. -Jimmi Holst Christensen</li>
      <li>Jimmi Holst Christensen revamped {#syntax#}std.io.readLine{#endsyntax#}<ul>
          <li>{#syntax#}std.io.readLine{#endsyntax#} has a new prototype</li>
          <li>Added {#syntax#}std.io.readLineFrom{#endsyntax#}</li>
          <li>Added {#syntax#}std.io.readLineSlice{#endsyntax#}</li>
          <li>Added {#syntax#}std.io.readLineSliceFrom{#endsyntax#}</li>
        </ul></li>
        <li>Added {#syntax#}std.io.SeekableStream{#endsyntax#}. Dwarf debug info
          is modified to use this instead of {#syntax#}std.os.File{#endsyntax#}
          directly to make it easier for
          <a href="https://andrewkelley.me/post/zig-stack-traces-kernel-panic-bare-bones-os.html">bare metal projects to take advantage of debug info parsing</a>.</li>
        <li>Added {#syntax#}std.debug.StackIterator{#endsyntax#}.</li>
      </li>
      <li>rework the readInt/writeInt functions:
<ul>
<li>io.InStream().readIntNe renamed to readIntNative</li>
<li>io.InStream().readIntLe renamed to readIntLittle</li>
<li>io.InStream().readIntBe renamed to readIntBig</li>
<li>introduced io.InStream().readIntForeign</li>
<li>io.InStream().readInt has parameter order changed</li>
<li>io.InStream().readVarInt has parameter order changed</li>
<li>io.InStream().writeIntNe renamed to writeIntNative</li>
<li>introduced io.InStream().writeIntForeign</li>
<li>io.InStream().writeIntLe renamed to writeIntLittle</li>
<li>io.InStream().writeIntBe renamed to writeIntBig</li>
<li>io.InStream().writeInt has parameter order changed</li>
<li>mem.readInt has different parameters and semantics</li>
<li>introduced mem.readIntNative</li>
<li>introduced mem.readIntForeign</li>
<li>mem.readIntBE renamed to mem.readIntBig and different API</li>
<li>mem.readIntLE renamed to mem.readIntLittle and different API</li>
<li>introduced mem.readIntSliceNative</li>
<li>introduced mem.readIntSliceForeign</li>
<li>introduced mem.readIntSliceLittle</li>
<li>introduced mem.readIntSliceBig</li>
<li>introduced mem.readIntSlice</li>
<li>mem.writeInt has different parameters and semantics</li>
<li>introduced mem.writeIntNative</li>
<li>introduced mem.writeIntForeign</li>
<li>mem.writeIntBE renamed to mem.readIntBig and different semantics</li>
<li>mem.writeIntLE renamed to mem.readIntLittle and different semantics</li>
<li>introduced mem.writeIntSliceForeign</li>
<li>introduced mem.writeIntSliceNative</li>
<li>introduced mem.writeIntSliceBig</li>
<li>introduced mem.writeIntSliceLittle</li>
<li>introduced mem.writeIntSlice</li>
<li>removed mem.endianSwapIfLe</li>
<li>removed mem.endianSwapIfBe</li>
<li>removed mem.endianSwapIf</li>
<li>added mem.littleToNative</li>
<li>added mem.bigToNative</li>
<li>added mem.toNative</li>
<li>added mem.nativeTo</li>
<li>added mem.nativeToLittle</li>
<li>added mem.nativeToBig</li>
</ul>
      </li>
      <li>Add {#syntax#}error.DeviceBusy{#endsyntax#} as a possible result of {#syntax#}std.os.posixOpen{#endsyntax#}. I observed <code>EBUSY</code> when trying to open for writing a tty fd that is already opened with screen.</li>
      <li>
        {#syntax#}std.debug.assert{#endsyntax#} no longer has special behavior for test builds.
        Use {#syntax#}std.testing.expect{#endsyntax#} to detect test failures in a way that will
        work in release builds. See {#link|assert vs expect#}.
      </li>
      <li>
        {#syntax#}std.mem.Allocator.create{#endsyntax#} is removed.
        {#syntax#}std.mem.Allocator.createOne{#endsyntax#} is renamed to
        {#syntax#}std.mem.Allocator.create{#endsyntax#}.
    The problem with the previous API is that even after copy elision,
    the initalization value passed as a parameter would always be a copy.
    With the new API, once copy elision is done, initialization
    functions can directly initialize allocated memory in place. <a href="https://github.com/ziglang/zig/issues/1872">#1872</a> <a href="https://github.com/ziglang/zig/issues/1873">#1873</a>
      </li>
      <li>
        {#syntax#}std.mem.split{#endsyntax#} is removed.
        {#syntax#}std.mem.separate{#endsyntax#} and {#syntax#}std.mem.tokenize{#endsyntax#} are added.
      </li>
      <li>Marc Tiehuis added {#syntax#}std.fmt.parseFloat{#endsyntax#}.
        This is not intended to be the long-term implementation as it doesn't
        provide various properties that we eventually will want (e.g.
        round-tripping, denormal support). It also uses {#syntax#}f64{#endsyntax#} internally so the
        wider {#syntax#}f128{#endsyntax#} will be inaccurate. See <a href="https://github.com/ziglang/zig/issues/2207">#2207</a> for robust float parsing
        in the Zig Standard Library.</li>
      <li>John Schmidt added {#syntax#}std.PriorityQueue{#endsyntax#}.</li>
      <li>Added {#syntax#}std.os.posixMProtect{#endsyntax#}.</li>
      <li>{#syntax#}std.os.changeCurDir{#endsyntax#} no longer has an allocator parameter.</li>
      <li>Shawn Landden added {#syntax#}std.ascii{#endsyntax#}. Rohlem 
        added test coverage and fixed the logic.</li>
      <li>Shawn Landden added {#syntax#}std.math.mulWide{#endsyntax#}.</li>
      <li>kristopher tate exposed {#syntax#}std.crypto.HmacBlake2s256{#endsyntax#}.</li>
      <li>Wink Saville added {#syntax#}SegmentedList.shrink{#endsyntax#}.</li>
      <li>tgschultz added serialization and deserialization abstractions:<ul>
          <li>Added {#syntax#}std.io.Serializer{#endsyntax#}.</li>
          <li>Added {#syntax#}std.io.Deserializer{#endsyntax#}.</li>
          <li>Added {#syntax#}std.io.BitInStream{#endsyntax#}.</li>
          <li>Added {#syntax#}std.io.BitOutStream{#endsyntax#}.</li>
          <li>Added {#syntax#}std.meta.TagPayloadType{#endsyntax#}.</li>
          <li>Added {#syntax#}std.meta.trait.isUnsignedInt{#endsyntax#}.</li>
          <li>Added {#syntax#}std.meta.trait.isSignedInt{#endsyntax#}.</li>
        </ul></li>
      <li>daurnimator added {#syntax#}std.meta.stringToEnum{#endsyntax#}</li>
      <li>kristopher tate introduced the concept of {#syntax#}std.mem.separate{#endsyntax#} vs {#syntax#}std.mem.tokenize{#endsyntax#}.</li>
      <li>daurnimator added {#syntax#}std.math.IntFittingRange{#endsyntax#}.</li>
      <li>daurnimator added {#syntax#}std.LinkedList.concat{#endsyntax#}.</li>
      <li>tgschultz added {#syntax#}std.meta{#endsyntax#} - helper functions for doing reflection. <a href="https://github.com/ziglang/zig/issues/1662">#1662</a></li>
    </ul>

    {#header_open|assert vs expect#}
    <p>Previously, {#syntax#}std.debug.assert{#endsyntax#} would
    <a href="/documentation/0.4.0/#panic">@panic</a> in test builds,
    if the assertion failed. Now, it's always {#syntax#}unreachable{#endsyntax#}.</p>
    
    <p>This makes release mode test builds more accurately test
    the actual code that will be run.</p>
    
    <p>However this requires tests to call {#syntax#}std.testing.expect{#endsyntax#}
    rather than {#syntax#}std.debug.assert{#endsyntax#} to make sure output is correct.</p>
    
    <p>Here is the explanation of when to use either one, copied from
    the assert doc comments:</p>
    
    <p>
    Inside a test block, it is best to use the {#syntax#}std.testing{#endsyntax#} module
    rather than assert, because assert may not detect a test failure
    in <a href="/documentation/0.4.0/#ReleaseFast">ReleaseFast</a> and
    <a href="/documentation/0.4.0/#ReleaseSmall">ReleaseSmall</a> modes.
    Outside of a test block, assert is the correct function to use.</p>
    <p>See <a href="https://github.com/ziglang/zig/issues/1304">#1304</a>.</p>
    {#header_close#}

    {#header_open|std.debug.captureStackTrace#}
    <p>Zig code can use {#syntax#}std.debug.captureStackTrace{#endsyntax#} at any time
    for debugging purposes:</p>
    {#code_begin|exe|stack-traces#}
const std = @import("std");
const builtin = @import("builtin");

var address_buffer: [8]usize = undefined;

var trace1 = builtin.StackTrace{
    .instruction_addresses = address_buffer[0..4],
    .index = 0,
};

var trace2 = builtin.StackTrace{
    .instruction_addresses = address_buffer[4..],
    .index = 0,
};

pub fn main() void {
    foo();
    bar();

    std.debug.warn("first one:\n");
    std.debug.dumpStackTrace(trace1);
    std.debug.warn("\n\nsecond one:\n");
    std.debug.dumpStackTrace(trace2);
}

fn foo() void {
    std.debug.captureStackTrace(null, &trace1);
}

fn bar() void {
    std.debug.captureStackTrace(null, &trace2);
}
    {#code_end#}
    <p>This feature is used in the
    <a href="https://github.com/andrewrk/zig-general-purpose-allocator/">GeneralPurposeDebugAllocator project</a> for helping detect and diagnose memory issues.
    </p>
    {#header_close#}

    {#header_open|Allocator interface#}
    <p>Zig 0.4.0 brings breaking changes to the {#syntax#}std.mem.Allocator{#endsyntax#} interface
    and API.</p>
    <p>
    Before, allocator implementations had to provide {#syntax#}allocFn{#endsyntax#},
    {#syntax#}reallocFn{#endsyntax#}, and {#syntax#}freeFn{#endsyntax#}.
    </p>
    <p>
    Now, they must provide only {#syntax#}reallocFn{#endsyntax#} and {#syntax#}shrinkFn{#endsyntax#}.
    Reallocating from a zero length slice is allocation, and
    shrinking to a zero length slice is freeing.
    </p>
    <p>
    When the new memory size is less than or equal to the
    previous allocation size, {#syntax#}reallocFn{#endsyntax#} now has the option
    to return {#syntax#}error.OutOfMemory{#endsyntax#} to indicate that the allocator
    would not be able to take advantage of the new size.
    </p>
    <p>
    For more details see <a href="https://github.com/ziglang/zig/issues/1306">#1306</a>.
    </p>
    <p>I have reproduced the documentation comments here:</p>
    {#code_begin|syntax#}
pub const Allocator = struct {
    pub const Error = error{OutOfMemory};

    /// Realloc is used to modify the size or alignment of an existing allocation,
    /// as well as to provide the allocator with an opportunity to move an allocation
    /// to a better location.
    /// When the size/alignment is greater than the previous allocation, this function
    /// returns `error.OutOfMemory` when the requested new allocation could not be granted.
    /// When the size/alignment is less than or equal to the previous allocation,
    /// this function returns `error.OutOfMemory` when the allocator decides the client
    /// would be better off keeping the extra alignment/size. Clients will call
    /// `shrinkFn` when they require the allocator to track a new alignment/size,
    /// and so this function should only return success when the allocator considers
    /// the reallocation desirable from the allocator's perspective.
    /// As an example, `std.ArrayList` tracks a "capacity", and therefore can handle
    /// reallocation failure, even when `new_n` <= `old_mem.len`. A `FixedBufferAllocator`
    /// would always return `error.OutOfMemory` for `reallocFn` when the size/alignment
    /// is less than or equal to the old allocation, because it cannot reclaim the memory,
    /// and thus the `std.ArrayList` would be better off retaining its capacity.
    /// When `reallocFn` returns,
    /// `return_value[0..min(old_mem.len, new_byte_count)]` must be the same
    /// as `old_mem` was when `reallocFn` is called. The bytes of
    /// `return_value[old_mem.len..]` have undefined values.
    /// The returned slice must have its pointer aligned at least to `new_alignment` bytes.
    reallocFn: fn (
        self: *Allocator,
    /// Guaranteed to be the same as what was returned from most recent call to
    /// `reallocFn` or `shrinkFn`.
    /// If `old_mem.len == 0` then this is a new allocation and `new_byte_count`
    /// is guaranteed to be >= 1.
        old_mem: []u8,
    /// If `old_mem.len == 0` then this is `undefined`, otherwise:
    /// Guaranteed to be the same as what was returned from most recent call to
    /// `reallocFn` or `shrinkFn`.
    /// Guaranteed to be >= 1.
    /// Guaranteed to be a power of 2.
        old_alignment: u29,
    /// If `new_byte_count` is 0 then this is a free and it is guaranteed that
    /// `old_mem.len != 0`.
        new_byte_count: usize,
    /// Guaranteed to be >= 1.
    /// Guaranteed to be a power of 2.
    /// Returned slice's pointer must have this alignment.
        new_alignment: u29,
    ) Error![]u8,

    /// This function deallocates memory. It must succeed.
    shrinkFn: fn (
        self: *Allocator,
    /// Guaranteed to be the same as what was returned from most recent call to
    /// `reallocFn` or `shrinkFn`.
        old_mem: []u8,
    /// Guaranteed to be the same as what was returned from most recent call to
    /// `reallocFn` or `shrinkFn`.
        old_alignment: u29,
    /// Guaranteed to be less than or equal to `old_mem.len`.
        new_byte_count: usize,
    /// If `new_byte_count == 0` then this is `undefined`, otherwise:
    /// Guaranteed to be less than or equal to `old_alignment`.
        new_alignment: u29,
    ) []u8,
};
    {#code_end#}
    <p>
    This allows allocators and data structures to "negotiate" with each other. For example,
    here is {#syntax#}std.ArrayList.shrink{#endsyntax#}:
    </p>
    {#code_begin|syntax#}
pub fn shrink(self: *Self, new_len: usize) void {
    assert(new_len <= self.len);
    self.len = new_len;
    self.items = self.allocator.realloc(self.items, new_len) catch |e| switch (e) {
        error.OutOfMemory => return, // no problem, capacity is still correct then.
    };
}
    {#code_end#}
    {#header_close#}
    {#header_close#}

    {#header_open|Please Welcome Antoine Vugliano to the Core Zig Team#}
    <p>
    I am pleased to announce our newest Zig team member, <a href="https://github.com/Sahnvour">Antoine Vugliano</a>.
    </p>
    <p>
He has shown continued dedication and discipline in his contributions
to the Zig programming language project. The quality of his work speaks
for itself.
    </p>
    <p>
I look forward to working with Antoine as we continue to push Zig
toward 1.0.0 and beyond.
    </p>
    {#header_close#}

    {#header_open|Syntax Highlighting on GitHub#}
    <p>Thanks to Jeff Fowler for creating <a href="https://github.com/ziglang/sublime-zig-language">sublime-zig-language</a> and for creating the
    <a href="https://github.com/github/linguist/pull/4005">pull request to GitHub</a> to add
    support for Zig.
    </p>
    <p>
    Finally, GitHub decided that Zig is popular enough to gain official recognition.
    </p>
    <p>As a fun last step, Marc Tiehuis marked third-party dependencies as vendored,
    so that we can have this pretty language bar on GitHub:
    </p>
    <img src="github-languages-bar.png">
    <p>
    Now you can <a href="https://github.com/trending/zig?since=daily">discover Zig projects on GitHub via their "trending" web page</a>.
    </p>
    {#header_close#}

    {#header_open|Miscellaneous Improvements#}
    <ul>
      <li>The cmake configuration no longer tries to find libxml since it's not a direct
        dependency.</li>
      <li>add a test for {#syntax#}std.os.AtomicFile{#endsyntax#}</li>
      <li>increase stack size on windows for all executables. <a href="https://github.com/ziglang/zig/issues/157">#157</a></li>
      <li>{#syntax#}std.Mutex{#endsyntax#} now has a high quality Linux implementation based on
        <a href="http://dept-info.labri.fr/~denis/Enseignement/2008-IR/Articles/01-futex.pdf">Ulrich Drepper's "Futexes are tricky" paper</a>, Mutex, Take 3.
        Thanks to Shawn Landden for the original implementation. <a href="https://github.com/ziglang/zig/issues/1463">#1463</a></li>
      <li>The cmake build looks for llvm-config-8 before llvm-config. Fixes building from source
      on some systems.</li>
      <li>
        Zig now supports building static libraries, with no system dependency on <code>ar</code>.
        <a href="https://github.com/ziglang/zig/issues/1493">#1493</a> <a href="https://github.com/ziglang/zig/issues/54">#54</a>
      </li>
      <li>
        On POSIX systems, the stage1 compiler uses <code>posix_spawn</code> rather than
        <code>fork</code> and <code>execv</code>. The logic is simplified and the memory usage
        is more deterministic.
      </li>
      <li>
        Zig's startup code inlines some functions so that stack traces have fewer frames before main.
      </li>
      <li>Support C ABI for returning structs on ARM. <a href="https://github.com/ziglang/zig/issues/1481">#1481</a></li>
      <li>add __multi3 compiler rt function. <a href="https://github.com/ziglang/zig/issues/1290">#1290</a></li>
      <li>compiler rt includes ARM functions for thumb and aarch64 and
        other sub-arches left out. <a href="https://github.com/ziglang/zig/issues/1526">#1526</a></li>
      <li>std.io: fix compile error when InStream has empty error set</li>
      <li>Support both MSVC 2015 and MSVC 2017 when linking libc, as well as for building stage1.</li>
      <li>macOS builds of master branch are now available on <a href="/download">the download page</a>.</li>
      <li>aarch64 improvements<ul>
          <li>support C ABI for all return types</li>
          <li>don't include __aeabi_uldivmod &amp; co on aarch64 since
            it's 64 bit</li></ul>
      </li>
      <li>improve error message when wrong type returned. <a href="https://github.com/ziglang/zig/issues/1650">#1650</a></li>
      <li>Crash fixes and small improvements to inline asm. (<a href="https://github.com/ziglang/zig/issues/1756">#1756</a>) -Antoine Vugliano<ul>
          <li>codegen: fix use of deprecated LLVMConstInlineAsm.</li>
          <li>codegen: replace commas in asm constraint strings by pipes as required by LLVM.</li>
          <li>ir: enforce usage of '=' constraint modifier for inline assembly outputs.</li>
          <li>asm: forbid comptime_int/floats as inputs in favor of explicitely sized constants.</li>
          <li>asm: handle inputs with integers of less than 8 or non power of 2 bitsize by widening them to the next highest power of two.</li>
        </ul></li>
      <li>{#syntax#}std.rand.Rand{#endsyntax#}: better debiased random range implementation. -Josh Wolfe</li>
      <li>Add a workaround to support Debian's patch of LLVM which breaks the public API.
        <a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=924953">Debian bug report</a>. <a href="https://github.com/ziglang/zig/issues/2076">#2076</a></li>
      <li>comptime evaluation facilities are improved to be able to handle a
        <a href="/documentation/0.4.0/#ptrCast">@ptrCast</a> with a backing array.</li>
      <li><a href="/documentation/0.4.0/#truncate">@truncate</a> allows "truncating" a
        {#syntax#}u0{#endsyntax#} value to any integer type, and the result is always
        comptime known to be {#syntax#}0{#endsyntax#}.</li>
      <li>
    {#syntax#}std.fmt.formatType{#endsyntax#} can now format comptime_int -Jimmi Holst Christensen
      </li>
      <li>
    {#syntax#}std.fmt.format{#endsyntax#} can now format function pointers -Jimmi Holst Christensen
      </li>
      <li>Added compile errror for <a href="/documentation/0.4.0/#bitCast">@bitCast</a> when bit counts mismatch.</li>
      <li>Antoine Vugliano improved behaviour of ChildProcess under windows. Notify failure to create a
        process when the executable is not found even in PATH.</li>
      <li>Better error message when LLVM does not understand a triple.</li>
      <li>stage1 cmake build configuration ensures that the LLVM it finds is the exact correct
        version and that it has all the default targets enabled.</li>
      <li>Matthew McAllister enabled compileLog to display slices.</li>
      <li>Marc Tiehuis Added __addtf3, __subtf3 and __truncdfhf2 to compiler-rt.
        Allows addition/subtraction of {#syntax#}f128{#endsyntax#} and narrowing casts to {#syntax#}f16{#endsyntax#} from larger float types.</li>
      <li>Marc Tiehuis added {#syntax#}f128{#endsyntax#} support for fabs, isinf, isnan, inf and nan functions.</li>
      <li>Marc Tiehuis added float parsing support to {#syntax#}std.json{#endsyntax#}.</li>
      <li>Removed the "top of the comptime stack" compile error. It's still best practice
        to put <a href="/documentation/0.4.0/#setEvalBranchQuota">@setEvalBranchQuota</a>
        at the top of the comptime stack, but as Jimmi notes in <a href="https://github.com/ziglang/zig/issues/1949">#1949</a>, when a function
        can be called at comptime and also can be the top of the comptime stack,
        this compile error is fundamentally unsound. So now it's gone.</li>
      <li>Matthew McAllister deduplicated compile log statement warnings.</li>
      <li>LemonBoy added the LLVM align attribute for pointer parameters.</li>
      <li>Fixed {#syntax#}std.os.getBaseAddress{#endsyntax#} for objects and libraries on macOS.
        See <a href="https://github.com/ziglang/zig/issues/1878">#1878</a>. This removed the workaround in example/shared_library/mathtest.zig. Along the way
        these fixes were made:<ul>
          <li>Fixed extern variables with initialiaztion values to generate runtime code.</li>
          <li>Introduceed the ability for global variables to have Weak and LinkOnce linkage.</li>
          <li>Fixed <a href="/documentation/0.4.0/#export">@export</a> to work for non-functions.
            This code needs to be audited though.</li>
          <li>Fixed comptime ptrcast not keeping bigger alignment.</li>
          <li>Fixed linker warnings when targeting darwin.</li>
        </ul></li>
      <li>Deduplicate compile errors for undeclared identifiers. <a href="https://github.com/ziglang/zig/issues/111">#111</a></li>
      <li>Added a compile error note when C import fails and not linking libc. <a href="https://github.com/ziglang/zig/issues/558">#558</a></li>
      <li>Better error message when forgetting to link against libc. <a href="https://github.com/ziglang/zig/issues/1698">#1698</a></li>
      <li>Breaking changes to the way targets work.<ul>
          <li>CLI: <code>-target [name]</code> instead of <code>--target-*</code> args.
            This matches clang's command line interface.</li>
          <li>{#syntax#}builtin.Environ{#endsyntax#} renamed to {#syntax#}builtin.Abi{#endsyntax#};
            likewise {#syntax#}builtin.environ{#endsyntax#} renamed to
            {#syntax#}builtin.abi{#endsyntax#}.</li>
          <li>stop hiding the concept of sub-arch. <a href="https://github.com/ziglang/zig/issues/1526">#1526</a></li>
          <li><code>zig targets</code> only shows available targets. <a href="https://github.com/ziglang/zig/issues/438">#438</a></li>
          <li>include all targets in {#link|Support Table#}, even those that don't
            print with <code>zig targets</code> but note they are {#link|Tier 4 Support#}.</li>
        <li>introduce the concept of a "default C ABI" for a given OS/Arch combo.
          As a rule of thumb, if the system compiler is clang or gcc then the
          default C ABI is the gnu ABI.</li>
        <li>Better error message for `-target windows` CLI. <a href="https://github.com/ziglang/zig/issues/1169">#1169</a></li>
      </ul></li>
      <li>Marc Tiehuis improved Zig's
        <a href="/documentation/0.4.0/#Error-Return-Traces">error return trace</a>
        code to use bitwise-and instead of modulo, which avoids emitting compiler-rt div
        calls on some targets.</li>
      <li>Antoine Vugliano made all integers returned by <a href="/documentation/0.4.0/#typeInfo">@typeInfo</a> {#syntax#}comptime_int{#endsyntax#}.</li>
      <li>Added {#syntax#}popcountdi2{#endsyntax#} to compiler_rt</li>
      <li>Matt Whiteside added elf riscv32 and elf riscv64 as options in getLDMOption during construction of link job.</li>
      <li>Better buffer length for {#syntax#}std.fmt.formatIntUnsigned{#endsyntax#}. <a href="https://github.com/ziglang/zig/issues/1358">#1358</a></li>
      <li>Added mulXf3 to compiler-rt. <a href="https://github.com/ziglang/zig/issues/1290">#1290</a></li>
      <li>Suirad updated the standard library to use GetEnvironmentStringsW instead of GetEnvironmentStringsA. <a href="https://github.com/ziglang/zig/issues/534">#534</a></li>
      <li>Shawn Landden improved the compile error message when incorrectly
        comparing against {#syntax#}null{#endsyntax#}. <a href="https://github.com/ziglang/zig/issues/2104">#2104</a></li>
      <li>vegecode improved compiler-rt support for armv7m:<ul>
          <li>Added {#syntax#}memcmp{#endsyntax#} to builtins.</li>
          <li>Added all __aeabi functions (C versions) who alias currently existing functions to compiler-rt.</li>
          <li>Added __aeabi_{f,d}neg and __neg{s,d,X}f2 to compiler-rt.</li>
          <li>Added __aeabi_{f,d}{add,sub} and __{add,sub}{s,d}f3 to compiler-rt.</li>
          <li>Added __aeabi_mem{cmp,clr,set,cpy,move} to compiler-rt.</li>
        </ul></li>
      <li>emekoi made terminal color output of the compiler more consistent (<a href="https://github.com/ziglang/zig/issues/1706">#1706</a>)</li>
      <li>kristopher tate reduced code bloat by having {#syntax#}std.mem.join{#endsyntax#} and {#syntax#}std.os.path.join{#endsyntax#} use a slice parameter rather than var args.</li>
      <li>Shawn Landden removed an invalid formatted printing test that relied
        on negative NaN.</li>
      <li>kristopher tate added support for printing hex bytes on slices</li>
      <li>kristopher tate made the internal compiler error handling more robust</li>
      <li>Matthew O'Connor updated {#syntax#}std.rb{#endsyntax#} to conform to the
        <a href="/documentation/0.4.0/#Style-Guide">style guide</a>.</li>
      </li>
      <li>emekoi added dynamic library loading for windows. <a href="https://github.com/ziglang/zig/issues/1594">#1594</a></li>
      <li>emekoi maintained the MinGW build of Zig.</li>
      <li><a href="/download/index.json">The download page also has a JSON URL available.</a></li>
      <li>vegecode added divsf3 to compiler rt. <a href="https://github.com/ziglang/zig/issues/1290">#1290</a></li>
      <li>Added <code>__modti3</code> to compiler-rt. <a href="https://github.com/ziglang/zig/issues/1290">#1290</a></li>
      <li>Shawn Landden simplified {#syntax#}std.math.isnan{#endsyntax#} to use {#syntax#}x != x{#endsyntax#} rather than looking at the bits.</li>
      <li>Shritesh Bhattarai added support for {#syntax#}comptime_int{#endsyntax#} in
        {#syntax#}std.fmt.formatInt{#endsyntax#} and {#syntax#}std.fmt.formatValue{#endsyntax#}.</li>
      <li>vegecode added divdf3 and __aeabi_ddiv to compiler_rt.</li>
      <li>kristopher tate added compile error notes to hint using {#syntax#}and{#endsyntax#} and {#syntax#}or{#endsyntax#} when {#syntax#}&&{#endsyntax#} and {#syntax#}||{#endsyntax#} are used.</li>
      <li>Matthew McAllister made tokenization errors more helpful.
        Previously, it pointed to the start of the current token, but this made
      it difficult to tell where the error occurred when it was, say, in the
      middle of a string.</li>
      <li>tharvik added llvm-config sanity check to the stage1 cmake build configuration.</li>
      <li>dbandstra made {#syntax#}std.fmt.parseUnsigned{#endsyntax#} handle types less than 8 bits wide.</li>
      <li>Wink Saville added compiler_rt routines for float to signed integer conversion</li>
      <li>emekoi added a {#syntax#}std.Mutex{#endsyntax#} implementation for Windows.</li>
      <li>kristopher tate improved stage1 os.cpp regarding opening files and 
        getting the modification time.</li>
      <li>emekoi added math.pow support for integer types and math.powi. <a href="https://github.com/ziglang/zig/issues/1637">#1637</a> (<a href="https://github.com/ziglang/zig/issues/1642">#1642</a>)</li>
      <li>Wink Saville added tests and documentation comments to the Zig standard library.</li>
      <li>kristopher tate added a temporary workaround to break a false positive dependency loop when a struct depends on its own alignment. <a href="https://github.com/ziglang/zig/issues/1832">#1832</a> <a href="https://github.com/ziglang/zig/issues/2174">#2174</a></li>
      <li>tgschultz removed unnecessary allocator field from Linux implementation of
        std.DynLib and improved test coverage.</li>
      <li>LemonBoy silenced gcc8 class-memaccess warnings using an explicit
        cast to tell gcc we know what we're doing.</li>
      <li>kristopher tate improved test coverage of self-referential generic functions.</li>
    </ul>

    {#header_open|Recursive Type Mismatch Error Notes#}
    <p>
    Function type mismatches now have an error note which explains in more detail why the
    function types were incompatible:
    </p>
    {#code_begin|test_err|cannot cast into#}
fn do_the_thing(func: fn (arg: i32) void) void {}
fn bar(arg: bool) void {}
test "fn types" {
    do_the_thing(bar);
}
    {#code_end#}
    {#header_close#}
    {#header_close#}

    {#header_open|Bug Fixes#}
    <ul>
      <li>Antoine Vugliano fixed --emit asm on windows. <a href="https://github.com/ziglang/zig/issues/1612">#1612</a></li>
      <li>Jimmi Holst Christensen fixed StackTrace not being resolved when panic is invalid (<a href="https://github.com/ziglang/zig/issues/1615">#1615</a>)</li>
      <li>Fixed missing .h files for <a href="https://ziglang.org/documentation/0.4.0/#cImport">@cImport</a>. <a href="https://github.com/ziglang/zig/issues/1634">#1634</a></li>
      <li>No more blank lines printed after linker errors. Fixed by disabling the error limit when invoking LLD. </li>
      <li>Fixed code still using old ptr syntax. -Jimmi Holst Christensen</li>
      <li>Fixed stack pointer register name on i386</li>
      <li>Removed implicit cast from number literal to enum</li>
      <li>limit integer types to maximum bit width of 65535. <a href="https://github.com/ziglang/zig/issues/1541">#1541</a></li>
      <li>Fixed .h file locating on macos 10.14</li>
      <li>fix assertion failure related to @intToEnum</li>
      <li>std/rand: fix ziggurat next_f64 call. -Marc Tiehuis</li>
      <li>fix <a href="/documentation/0.4.0/#intCast">@intCast</a> not catching negative numbers to unsigned</li>
      <li>better file path handling in stage1 compiler. <a href="https://github.com/ziglang/zig/issues/1693">#1693</a> <a href="https://github.com/ziglang/zig/issues/1746">#1746</a></li>
      <li>Antoine Vugliano fixed stack traces on windows.</li>
      <li>Josh Wolfe fixed child_process piped streams not getting closed</li>
      <li>Fixed intToPtr to fn type when the address is hardcoded (<a href="https://github.com/ziglang/zig/issues/1842">#1842</a>) -Jimmi Holst Christensen</li>
      <li>vegecode fixed mutate through ptr initialized with constant intToPtr
        value. <a href="https://github.com/ziglang/zig/issues/1171">#1171</a></li>
      <li>Jimmi Holst Christensen fixed <a href="/documentation/0.4.0/#typeInfo">@typeInfo</a> returning incorrect results sometimes.</li>
      <li>Jimmi Holst Christensen fixed using mem.writeInt at comptime can change the type of a structs field. <a href="https://github.com/ziglang/zig/issues/1866">#1866</a></li>
      <li>Fixed debug info for function pointers.</i>
      <li>Fixed <a href="/documentation/0.4.0/#typeInfo">@typeInfo</a> returning incorrect function return type sometimes.</li>
      <li>Fixed incorrect parameter names for {#syntax#}std.math.atan2{#endsyntax#}.</li>
      <li>Sauhnvour improved the line number accuracy of stack traces on Windows. <a href="https://github.com/ziglang/zig/issues/1503">#1503</a></li>
      <li>krisopher tate fixed <a href="/documentation/0.4.0/#compileLog">@compileLog</a> with a pointer to an opaque value.</li>
      <li>Fixed incorrect timeval struct type on macOS. <a href="https://github.com/ziglang/zig/issues/1648">#1648</a></li>
      <li>Matthew McAllister fixed runtime assignment to comptime aggregate field.</li>
      <li>Matthew McAllister fixed slice concatenation.</li>
      <li>Fixed using the result of @intCast to u0. <a href="https://github.com/ziglang/zig/issues/1817">#1817</a></li>
      <li>Fixed compiler assertion failure when returning value from test. <a href="https://github.com/ziglang/zig/issues/1935">#1935</a></li>
      <li><a href="/documentation/0.4.0/#truncate">@truncate</a> now is {#syntax#}comptime{#endsyntax#}-known to be 0 when destination integer type has 0 bits.
        If the destination type is a {#syntax#}comptime_int{#endsyntax#}, treat it as an <a href="/documentation/0.4.0/#Implicit-Casts">Implicit Cast</a>. <a href="https://github.com/ziglang/zig/issues/1568">#1568</a></li>
      <li>Add missing compile error for OpaqueType inside structs/unions. <a href="https://github.com/ziglang/zig/issues/1862">#1862</a></li>
      <li>Fix mmap syscalls invoking undefined behavior when address 0 is used. Found
        thanks to Zig's new safety checks for null pointers.</li>
      <li>Typecheck the panic function. The prototype of panic is added to
        {#syntax#}@import("builtin"){#endsyntax#} and then used to do an implicit cast of the panic
        function to this prototype, rather than redoing all the implicit cast logic. <a href="https://github.com/ziglang/zig/issues/1894">#1894</a> <a href="https://github.com/ziglang/zig/issues/1895">#1895</a></li>
      <li>emekoi fixed the secret debug safety union tag incorrectly being
        included in release modes.</li>
      <li>Matthew McAllister fixed lvalue dereference type checking. Previously,
        if a dereference instruction was an lvalue, it would fail to typecheck
        that the value being dereferenced was indeed a pointer.</li>
      <li>sjdh02 fixed BufferedInStream not reading delayed input.</li>
      <li>Benoit Jauvin-Girard fixed std.math.powi so powi(x, +-0) = 1 for any x.</li>
      <li>LemonBoy prevented crashing in tagged enums rendering (<a href="https://github.com/ziglang/zig/issues/1986">#1986</a>)</li>
      <li>Fix <a href="/documentation/0.4.0/#bitCast">@bitCast</a> when src/dest types have
        mismatched <code>handle_is_ptr</code>. <a href="https://github.com/ziglang/zig/issues/991">#991</a> <a href="https://github.com/ziglang/zig/issues/1934">#1934</a></li>
      <li>Fixed incorrectly trying to memset at comptime. <a href="https://github.com/ziglang/zig/issues/718">#718</a></li>
      <li>Correctly handle the case when there are multiple externs and an export in the same object, and they all share the same name. <a href="https://github.com/ziglang/zig/issues/529">#529</a></li>
      <li>Better error message on Windows when a file name contains an asterisk.</li>
      <li>Fixed .h file generation not respecting <a href="/documentation/0.4.0/#export">@export</a>.</li>
      <li>Fixed <a href="/documentation/0.4.0/#typeName">@typeName</a> on slices. <a href="https://github.com/ziglang/zig/issues/2026">#2026</a></li>
      <li>Jimmi Holst Christensen fixed function taking TypeInfo and returning type crashed compiler. <a href="https://github.com/ziglang/zig/issues/1600">#1600</a></li>
      <li>Added test for spawning child process with empty environment. Thanks to BenoitJGirard
        for pointing out the child process implementation needs 3 extra null bytes in <a href="https://github.com/ziglang/zig/issues/2031">#2031</a>.</li>
      <li>LemonBoy fixed generation of comptime slices.</li>
      <li>Fixed <a href="/documentation/0.4.0/#setRuntimeSafety">@setRuntimeSafety</a> not able to override release modes.</li>
      <li>Fixed while continue block not checking for ignored expression. <a href="https://github.com/ziglang/zig/issues/957">#957</a></li>
      <li>Added compile error for wrong type with {#syntax#}use{#endsyntax#}. <a href="https://github.com/ziglang/zig/issues/1557">#1557</a></li>
      <li>Antoine Vugliano improved Zig's PDB (Windows) debug info parsing and used it to fix
        Zig's C ABI support for Windows. The C ABI tests are now passing on all
        {#link|Tier 1 Support#} targets.</li>
      <li>Fixed global assembly parsing. Previously, global assembly was parsed expecting it to have
      the template syntax. However global assembly has no inputs, outputs, or clobbers,
      and thus does not have template syntax. This is now fixed.</li>
      <li>Fixed parsing of large hex float literals. Float literals now parse using musl's
        128 bit float code. Fixes float literals not having 128 bit precision. <a href="https://github.com/ziglang/zig/issues/2083">#2083</a></li>
      <li>Marc Tiehuis fixed <code>bigint_append_buf</code>. All current usages had base 10
        and a limb length of 2, hence why we weren't hitting this error in practice.</li>
      <li>Wink Saville fixed {#syntax#}std.json.pushToParent{#endsyntax#} to work for arrays of Objects</li>
      <li>Shawn Landden fixed ELF auxv handling.</li>
      <li>Duncan fixed the setsockopt syscall on linux.</li>
      <li>Michael Dusan fixed zig run to accept executable args.
        <br><br>
        The <code>--</code> double-hyphen is now used to end further zig processing
        of command line options. All arguments after <code>--</code> will be passed
        on to the executable. eg. <code>--help</code> will be passed on:
        <br><br>
        <code>zig run foo.zig -- --help</code>
        <br><br>
        <a href="https://github.com/ziglang/zig/issues/2148">#2148</a></li>
      <li>emekoi added a missing compile error for implicit cast from
        {#syntax#}*const T{#endsyntax#} to {#syntax#}*[1]T{#endsyntax#} based on a patch
        from kristopher tate.</li>
      <li>Fixed <a href="/documentation/0.4.0/#divFloor">@divFloor</a> returning incorrect
        value. <a href="https://github.com/ziglang/zig/issues/2152">#2152</a></li>
      <li>Fixed NaN comparing equal to itself. This was broken both in comptime code
        and in runtime code. <a href="https://github.com/ziglang/zig/issues/1174">#1174</a></li>
      <li>Fixed dereferencing a zero bit type. Before only u0 was special cased in
        handling a dereference; now all zero bit types are handled the same way. Dereferencing
        a pointer to a zero bit type always gives a comptime-known result.</li>
      <li>Jimmi Holst Christensen fixed inability to capture pointer to elements of const array
        in {#syntax#}for{#endsyntax#} loop. <a href="https://github.com/ziglang/zig/issues/1726">#1726</a></li>
      <li>Ryan Liptak fixed {#syntax#}std.HashMap.remove{#endsyntax#} returning invalid memory.
        <br><br>
        Now returns a copy of the removed kv instead of a pointer to the removed kv.
        The removed kv gets overwritten when shifting the hash map after the removal,
        so returning a pointer to it will have another kv's values in it after the return.
        <br><br>
        This bug had some nasty downstream effects in things like {#syntax#}std.BufSet{#endsyntax#}
        and {#syntax#}std.BufMap{#endsyntax#} where delete would free a still in-use KV and leave
        the actually removed KV un-free'd.</li>
      <li>Ryan Saunderson fixed detecting the latest installed version of the
        Windows SDK and related tests. <a href="https://github.com/ziglang/zig/issues/1665">#1665</a></li>
      <li>alexander added DIFlagStaticMember flag to functions. This
        prevents LLVM from generating debug info for struct member functions with a
        pointer as the first parameter as though the first parameter were the
        implicit "this" pointer from C++.</li>
      <li>Quetzal Bradley fixed a compile error in
        {#syntax#}std.os.File.openWriteNoClobber{#endsyntax#} and added test coverage.</li>
      <li>sjdh02 fixed check for 64-bit arm platforms with new targets.</li>
    </ul>

    {#header_open|This Release Contains Bugs#}
   <p>
   Zig has <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Abug">known bugs</a>.
   </p>
   <p>The first release that will ship with no known bugs will be 1.0.0.</p>
    {#header_close#}

    {#header_close#}

    {#header_open|Roadmap#}
    <p>Here is the <a href="/download/0.3.0/release-notes.html">roadmap from 0.3.0 release notes</a>:</p>
   <ul>
     <li>Redo coroutines without using LLVM Coroutines and rework the semantics. See <a href="https://github.com/ziglang/zig/issues/1363"><a href="https://github.com/ziglang/zig/issues/1363">#1363</a></a> and <a href="https://github.com/ziglang/zig/issues/1194"><a href="https://github.com/ziglang/zig/issues/1194">#1194</a></a>.</li>
     <li>Tuples instead of var args. <a href="https://github.com/ziglang/zig/issues/208"><a href="https://github.com/ziglang/zig/issues/208">#208</a></a></li>
     <li>Well-defined copy-eliding semantics. <a href="https://github.com/ziglang/zig/issues/287"><a href="https://github.com/ziglang/zig/issues/287">#287</a></a></li>
     <li>Self-hosted compiler. <a href="https://github.com/ziglang/zig/issues/89"><a href="https://github.com/ziglang/zig/issues/89">#89</a></a></li>
     <li>Get to 100% documentation coverage of the language</li>
     <li>Auto generated documentation. <a href="https://github.com/ziglang/zig/issues/21"><a href="https://github.com/ziglang/zig/issues/21">#21</a></a></li>
     <li>Package manager. <a href="https://github.com/ziglang/zig/issues/943"><a href="https://github.com/ziglang/zig/issues/943">#943</a></a></li>
   </ul>
   <p>
   I am sad to report that this list was too ambitious for one release cycle, and while there has
   been considerable progress, none of these items are complete. And so the roadmap for 0.4.0 is
   the same.
   </p>
    {#header_open|Type-Based Alias Analysis Status#}
    <p>
    It's no longer planned for Zig to have Type Based Alias Analysis. However,
    there are some open research topics on potentially outlawing all kinds of aliasing
    unless explicitly declared.
    Subscribe to <a href="https://github.com/ziglang/zig/issues/1108">#1108</a>
    for more details.
    </p>
    <p>
    For now, Zig has a
    {#link|well-defined memory model|comptime memory reinterpretation#},
    and aliasing is always allowed. Note, however,
    that not all types have a guaranteed in-memory layout.
    </p>
    {#header_close#}

    {#header_open|macOS/Mach-O Linker Status#}
    <p>
    Linking macOS/COFF files is still in a sad state. The Mach-O code in
    <a href="http://lld.llvm.org/">LLD</a>, Zig's linker, has been barely maintained for several
    years now. Zig has a fork of LLD in its source tree with a hacky patch to fix linking "Hello World"
    on macOS.
    </p>
    <p>
    <a href="https://github.com/ziglang/zig/issues/1535">It's now planned for the Zig project to have its own linker</a>.
    This is in part due to the lack of Mach-O maintenance, and in part because LLD has no
    plans to do incremental linking - a feature that I foresee to be necessary to achieve
    the performance we want to have for large projects in the self-hosted compiler.
    </p>
    <p>For now the self-hosted compiler uses <code>--system-linker-hack</code>
    to be able to link successfully, which is a compromise of Zig's promise that it can build
    on any target, for any target.</p>
    <p>
    There is also a workaround in the linker phase of Zig for compiler-rt.a and builtin.a.
    I had to make them object files rather than archive files to avoid crashing LLD.
    </p>
    {#header_close#}

    {#header_open|Self-Hosted Compiler Status#}
    <p>
    There has been no progress on the self-hosted compiler in this release cycle.
    Progress is blocked on the volume of core language changes still happening, as
    well as <a href="https://github.com/ziglang/zig/issues/287">no-copy semantics</a>,
    and {#link|Reworking Coroutines|Coroutine Status#}.
    </p>
    {#header_close#}

    {#header_open|Package Manager Status#}
    <p>
    The package manager will be one of the focus areas of the 0.5.0 release cycle.
    It depends on networking, which depends on {#link|Reworking Coroutines|Coroutine Status#},
    which depends on <a href="https://github.com/ziglang/zig/issues/287">no-copy semantics</a>.
    </p>
    {#header_close#}

    {#header_open|Coroutine Status#}
    <p>
    There is no progress on coroutines in this release cycle. In fact there has been anti-progress.
    </p>
    <p>Zig 0.4.0 introduces a memory leak to all coroutines.
    There is an issue where a coroutine calls the function and it
    frees its own stack frame, but then the return value of {#syntax#}shrinkFn{#endsyntax#}
    is a slice, which is implemented as an sret struct. Writing to
    the return pointer causes invalid memory write. We could work
    around it by having a global helper function which has a void
    return type and calling that instead. But instead this hack will
    suffice until I rework coroutines to be non-allocating. Basically
    coroutines are not supported right now until they are reworked as
    in <a href="https://github.com/ziglang/zig/issues/1194">#1194</a>.
    </p>
    <p>
    Reworking coroutines is to be a major focus of 0.5.0 as it is blocking networking,
    the {#link|Package Manager|Package Manager Status#}, and the {#link|Self-Hosted Compiler|Self-Hosted Compiler Status#}.
    </p>
    {#header_close#}

    {#header_open|Accepted Proposals#}
    <p>Here is a small selection of interesting proposals that have been accepted,
    to give you an idea of the upcoming changes to Zig.</p>
    <ul>
      <li><a href="https://github.com/ziglang/zig/issues/2165">Remove shebang line support</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/1512">Ability to set alignment of struct fields</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/485">Default struct field initialization values</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/2029">Add a builtin function for source information</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/265">Support null-terminated pointer types</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/685">Anonymous struct literals</a></li>
      <li><a href="https://github.com/ziglang/zig/issues/114">Require parentheses sometimes to disambiguate confusing operator precedence</a></li>
    </ul>
    <p>
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Aaccepted">Full list of accepted proposals</a>
    </p>
    {#header_close#}

    {#header_close#}

    {#header_open|Active External Projects Using Zig#}
    <ul>
      <li><a href="https://github.com/andrewrk/zig-general-purpose-allocator/">GeneralPurposeDebugAllocator</a> - work in progress general purpose debug allocator with livestreamed development.</li>
      <li><a href="https://github.com/Sahnvour/zig-benchmark">zig-benchmark</a> - Small and easy micro-benchmarking library.</li>
      <li><a href="https://github.com/dbandstra/oxid">Oxid</a> - an arcade-style game where you fight waves of monsters in a fixed-screen maze.</li>
      <li><a href="https://github.com/sjdh02/trOS">trOS</a> - tiny aarch64 baremetal OS thingy.</li>
      <li><a href="https://github.com/Hejsil/zig-clap">zig-clap</a> - Simple command line argument parsing library</li>
      <li><a href="https://github.com/ul/simple-amplifier">Simple Amplifier</a> - a very simple example of LV2 plugin built in Zig.</li>
      <li><a href="https://github.com/mikdusan/benchmark.unicode">benchmark.unicode</a> - A command-line tool written in Zig to measure the performance of various UTF8 decoders. The decoders are written in Zig or C.</li>
      <li><a href="https://github.com/thejoshwolfe/hexdump-zip">hexdump-zip</a> - produce an annotated hexdump of a zipfile</li>
    </ul>
    {#header_close#}

    {#header_open|Thank you financial supporters!#}
<p>
Special thanks to those who <a href="https://github.com/users/andrewrk/sponsorship">donate monthly</a>.
Thanks to you, Zig is not driven by the needs of a business; instead it exists solely to serve
the open source community.
</p>
<ul style="columns: 3">
<li>connectFree Corporation</li>
<li>Raph Levien</li>
<li>Stevie Hryciw</li>
<li>Lauren Chavis</li>
<li>Ali Anwar</li>
<li>Andrea Orru</li>
<li>Josh Wolfe</li>
<li>Filippo Valsorda</li>
<li>Ryan Worl</li>
<li>jeff kelley</li>
<li>Martin Schwaighofer</li>
<li>Jimmy Zelinskie</li>
<li>Tyler Bender</li>
<li>Tanner Schultz</li>
<li>Kelly Wilson</li>
<li>Brendon Scheinman</li>
<li>Trenton Cronholm</li>
<li>Champ Yen</li>
<li>Don Poor</li>
<li>Locke Monster</li>
<li>Thomas Ballinger</li>
<li>Paul Merrill</li>
<li>Audun Wilhelmsen</li>
<li>Adrian Sinclair</li>
<li>David Joseph</li>
<li>Elizabeth Ryan</li>
<li>Tom Phinney</li>
<li>Steve Perkins</li>
<li>Clement Rey</li>
<li>Jeff </li>
<li>Ross Rheingans-Yoo</li>
<li>Ross Kilgariff</li>
<li>Rudi Angela</li>
<li>Justin B Alexander</li>
<li>Ville Tuulos</li>
<li>shen xizhi</li>
<li>Ross Cousens</li>
<li>William L Sommers</li>
<li>Mirek Rusin</li>
<li>Peter Ronnquist</li>
<li>Felix Yuan</li>
<li>Aharon sharim</li>
<li>Caius </li>
<li>Matthew </li>
<li>Brian Glusman</li>
<li>Christopher A. Butler</li>
<li>Raymond Imber</li>
<li>Jack Wakefield</li>
<li>Mitch Small</li>
<li>Josh Gentry</li>
<li>Benoit Jauvin-Girard</li>
<li>Josh McDonald</li>
<li>Jay Weisskopf</li>
<li>Dan Boykis</li>
<li>Le Bach</li>
<li>Jordan Torbiak</li>
<li>Gerdus van Zyl</li>
<li>Furkan Mustafa</li>
<li>S.D. </li>
<li>Yaroslav Zh</li>
<li>Eduard Nicodei</li>
<li>Thomas Lopatic</li>
<li>joe ardent</li>
<li>Luis Alfonso Higuera Gamboa</li>
<li>Jason Merrill</li>
<li>Andriy Tyurnikov</li>
<li>Sanghyeon Seo</li>
<li>Neil Henning</li>
<li>Aaron St George </li>
<li>Brian Orr</li>
<li>Frans van den Heuvel</li>
<li>David Bremner</li>
<li>Wesley Kelley</li>
<li>Quetzal Bradley</li>
<li>Wink Saville</li>
<li>Anthony J. Benik</li>
<li>stdev </li>
<li>Ben Morris</li>
<li>Brian Ketelsen</li>
<li>Serge Paquet</li>
<li>Joseph Jaoudi</li>
<li>Torben Clasen</li>
<li>occivink </li>
<li>curtis gagliardi</li>
<li>Codi Matters</li>
<li>Ruslan Prakapchuk</li>
<li>Tyler Philbrick</li>
<li>Jan Halsema</li>
<li>Samantha Weddle</li>
<li>Jeff Hochgesang</li>
<li>Anatoly Polinsky</li>
<li>McSpiros </li>
<li>George K</li>
<li>Jon Raphaelson</li>
<li>Brian Lewis</li>
<li>Matt Whiteside</li>
<li>AnonymousGuy </li>
<li>Blazej Floch</li>
<li>Dmitriy Filchenko</li>
<li>ers35 </li>
<li>Martin Holly</li>
<li>RCherry </li>
<li>Charles Palmer</li>
<li>Ryan Roberts</li>
<li>Andrew Fernandes</li>
<li>Fabien Freling</li>
<li>Lewis </li>
<li>Marko Mikulicic</li>
<li>Jonathan Wright</li>
<li>James Haggerty</li>
<li>earthfront </li>
<li>Jakob Falke</li>
<li>John Judnich</li>
<li>Chris W</li>
<li>Drosin </li>
<li>John Biesnecker</li>
<li>Alexander Ellis</li>
<li>bb010g </li>
<li>Pau Fernández</li>
<li>Krishna Aradhi</li>
<li>Adrian Hatch</li>
<li>Deniz Kusefoglu</li>
<li>Hans Wennborg</li>
<li>Tim Hutt</li>
<li>John Schmidt</li>
<li>Rasmus Rønn Nielsen</li>
<li>Johann Muszynski</li>
<li>Eigil Skjæveland</li>
<li>Harry </li>
<li>Matus Hamorsky</li>
<li>Fabio Utzig</li>
<li>Gregoire Picquot</li>
<li>Lorenz Bauer</li>
<li>Cameron Miller</li>
<li>Igor Butenko</li>
<li>Akifumi Fukumoto</li>
<li>Alexandra Gillis</li>
<li>david karapetyan</li>
<li>Chad Russell</li>
<li>Wojciech Miłkowski</li>
<li>Ernst Rohlicek</li>
<li>Gudmund Vatn</li>
<li>Martin Angers</li>
<li>Christoph Müller</li>
<li>brian cleary</li>
<li>moomeme </li>
<li>xash </li>
<li>Jacques de Laval</li>
<li>blank </li>
<li>Joran Dirk Greef</li>
<li>Rickard Gustafsson</li>
<li>Mohamed </li>
<li>Romain Beaumont</li>
<li>Nate Dobbins</li>
<li>Paul Anderson</li>
<li>Jon Renner</li>
<li>Karl Syvert Løland</li>
<li>Stanley Zheng</li>
<li>myfreeweb </li>
<li>Dennis Furey</li>
<li>Dana Davis</li>
<li>Drew Carmichael</li>
<li>Doug Thayer</li>
<li>Henryk Gerlach</li>
<li>David Pippenger</li>
<li>Matthew Steele</li>
<li>Alex Alex</li>
<li>Andrew London</li>
<li>Jirka Grunt</li>
<li>Dillon A</li>
<li>Yannik </li>
<li>VilliHaukka </li>
<li>Chris Castle</li>
<li>Timothy Schumann</li>
<li>Antonio D'souza</li>
<li>Damien Dubé</li>
<li>Dbzruler72 </li>
<li>Francisco Vallarino</li>
<li>SP </li>
<li>Silicas </li>
<li>Falk Hüffner</li>
<li>allan </li>
<li>jose maria gonzalez ondina</li>
<li>Adrian Boyko</li>
<li>Benedikt Mandelkow</li>
<li>Will Cassella</li>
<li>Michael Weber</li>
<li>Darren </li>
<li>eliott </li>
<li>Vladimir Kraus</li>
<li>komu </li>
<li>LeRoyce </li>
<li>Jörg Sonnenberger</li>
<li>Alexandru Nedel</li>
<li>Oleg Alexeev</li>
<li>Ilya Semyonov</li>
<li>Brian </li>
<li>Myles Byrne</li>
<li>Jethro Nederhof</li>
<li>Harris Brakmic</li>
<li>Riking </li>
<li>daurnimator </li>
<li>Luke Paireepinart</li>
<li>Paulius Šarka</li>
<li>burtonageo </li>
<li>Neil Wang</li>
<li>Jason Pepas</li>
<li>Chris </li>
<li>Jedd Fenner</li>
<li>Robin Trujillo</li>
<li>Kristleifur Daðason</li>
<li>Raphael Schweikert</li>
<li>Jimmy Andrews</li>
<li>Robin Eidissen</li>
<li>Corentin Kerisit</li>
<li>Jonathan Dahan</li>
<li>Bruce Zeng</li>
<li>Yasuhiro Fujii</li>
<li>Micaiah Parker</li>
<li>Rahul Nair</li>
<li>Justin Voss</li>
<li>Harm Aarts</li>
<li>Dylan </li>
<li>samuel Schneck</li>
<li>Ayodele Akingbule</li>
</ul>
    {#header_close#}
    </div>
  </body>
</html>
