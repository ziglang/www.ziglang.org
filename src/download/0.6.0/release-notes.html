<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>0.6.0 Release Notes &middot; The Zig Programming Language</title>
    <link rel="icon" href="https://ziglang.org/favicon.png">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        line-height: 1.45;
        margin-left: 0;
        margin-right: 0;
      }
      p {
        margin: 0.8em 0;
      }

      h1, h2, h3, h4, h5 {
        margin: 0.5em 0 0.5em;
        line-height: 1.2;
        font-weight: bold;
        color: #666;
      }

      h1 a, h2 a, h3 a, h4 a, h5 a {
        text-decoration: none;
        color: #666;
      }

      h1 { font-size: 2.0em; }
      
      h2 { font-size: 1.5em; }
      
      h3 { font-size: 1.25em; }

      h4 { font-size: 1.0em; }

      a.hdr {
        visibility: hidden;
      }
      h1:hover > a.hdr, h2:hover > a.hdr, h3:hover > a.hdr, h4:hover > a.hdr, h5:hover > a.hdr {
        visibility: visible;
      }

      a {
        color: #2A6286;
      }
      
      a:not(:hover) {
        text-decoration: none;
      }

      th, td {
        padding: 0.6em;
        text-align: left;
      }
      
      td {
        font-size: 0.96em;
      }
      
      th {
        border-bottom: 2px solid #f2f3f3;
      }
      
      tr:nth-child(even) {
        background: #f2f3f3;
      }
      
      .t0_1, .t37, .t37_1 {
        font-weight: bold;
      }
      .t2_0 {
        color: grey;
      }
      .t31_1 {
        color: red;
      }
      .t32_1 {
        color: green;
      }
      .t36_1 {
        color: #0086b3;
      }
      .file {
        text-decoration: underline;
      }
      pre,code {
        font-size: 12pt;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        color: #333;
        background: #f8f8f8;
      }
      .table-wrapper {
        width: 100%;
        overflow-y: auto;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      #contents {
        max-width: 60em;
        margin: auto;
        padding: 0 0.2em;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background-color:#111;
            color: #bbb;
        }
        a {
            color: #88f;
        }
        table, th, td {
            border-color: grey;
        }
        tr:nth-child(even) {
          background: #1e1e1e;
        }
        .t2_0 {
            color: grey;
        }
        .t31_1 {
            color: red;
        }
        .t32_1 {
            color: green;
        }
        .t36_1 {
            color: #0086b3;
        }
        pre > code {
            color: #ccc;
            background: #222;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #e33;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
        h1, h2, h3, h4, h5 {
          color: #aaa;
        }
        h1 a, h2 a, h3 a, h4 a, h5 a {
            color: #aaa;
        }
      }
    </style>
  </head>
  <!--
                                 .m//oooo/:.```h``y +/```.:/+++/oyo                                  
                               `:yNy+-``       h` s +/       ``-/yds:`                              
                             -sdy/.            h` s +/            `:sho-                            
                           :yh+.               h` o +/               `/yy-                          
                         -yh/`                 h` + +/                 `-yy.                        
                       `oh/........```         h` / +/           ``.....``:h+`                      
                      .hNhyyyyysssoo++/-`      h` / +/      `.-:/+oooossssoomy.                      
                     -mmdyyso+++++++o+++o/-`   h` : +/   `.:+/++++/////++oyyhNd-                    
                    -myoso++/:::::-.....-/+/-  h` - +/  .:+/-.....-:::::/++ossdm.                    
                   .ms-ysossyhyyyyhyyso:.``:+/`o+ .`y-`/o:` .:+syhhhhhhhyssooh/hd`                  
                   yh-hshysshhdmmddhysyhy+-` :s:+o.y:-s/` .+yhyyhdmmmmmddhyyhsh/ms                  
                  :N.yshohNMMMNMMMMMMMmyohy+` `y//h:-h. `/yhyhmMMMMMMNMMMMMdshyy/N-                  
                  hs:om+NMMMMMMMNMMMMMMMNsyh+` `d.``d- `+yhyNMMMMMMNNMMMMMMMMsdo/hs                  
                 `N-/yomMMMMMMMMMNNMMMMMMM+hs+  os +y  /omoMMMMMMMNMMMMMMMMMMN+d//m                  
                 -N :d/MMMMMMMMMMMMNMMMMMMm+do  /h oo  +ysmMMMMMNMMMMMMMMMMMMM+N/.N.                
                 :m :d+MMMMMMMMMMMMMMNMMMMhsy+``s+ :h``/ohhMMMNMMMMMMMMMMMMMMM+N:`N.                
                 -N :h+MMMMMMMMMMMMMMMMNMmodo-~/h`. y+~-ohsmNNMMMMMMMMMMMMMMMM+m:`N.                
                 `N..ssdMMMMMMMMMMMMMMMNhsho/:+y` / `so/:oyyhNMMMMMMMMMMMMMMMNoy~-m`                
                  h/ +moMMMMMMMMMMMMMMmsyso++so`  o   +s++oshymMMMMMMMMMMMMMMydo`+y                  
                  /d :homMMMMMMMMMMMmyyyooosy:   .o.`  -ssoosyyymMMMMMMMMMMMN+d: d-                  
                   d/ +m+mNMMMMMMNdyyysssss/`    :s/.    :ysssoyyyhNMMMMMMMN+do`+y                  
                   .d-.ohshNNNNdyyyysyhsy+-`  ```+s+:`  ```:shsyyyhyyhNNNNd+hy..d.                  
                   .+h..+dhyyhodyyydyhy/.~-` ..`.yss+``-.`. .+ohydhhyhshyyyho:.h:                    
                    ./h- ++yydsmdmhh+/+..~-  -...yyd+  `.....+-~/sdmddydhy+:.:h:                    
                   `..:hoo//:/.-:.:o+/++:-:- .~-:+/s+:-...:-:++/+:~-:-`/::+ohd..-`                  
                       `smhsooososooo+++/::.~-.`   `  .::-:///+++sosoosssyhmo`                      
                         :dmdmdhyysyoso+o/::`      /  `.-~/+ooosssyyhhddmNh-                        
                          `/dMMmmhdyyyss/-         +     -:-/syshyddmNMMh:                          
                            `:yNMNNmho/.           +      `-:::shmNMMNy-                            
                               ./dh/.`             +         .::/omy/`                              
                       ./o-      `++               +           `.y/         -o/.                    
                  `-/+o+/d/+`      /y:/oy:     .///y///.     /yooo.`      `o/h/+++/.                
              `-/+o+//+::d`.+-   .sooooooh-  `o/:/:+:/:/+`  :hoooo+os`   -s. h:////+o+/-`            
          `-/+o+/+/:/+:/+y/ `+:  `hsooooooh. o-/hoyhyoh/:o -hoooooosy`  /o` /y+/:+/:///+o+:-`        
        -so+++:/+/://:/+:/d. `//  -doooooosy`h-oNyMMMyNo:h.yoooooood.  ++` `d/:+/://:/+::+++oo.      
        d+://://:/+/://:/+os  `sosdNdoooooosy+/:yhhdhhy:/+yooooooodNdsss`  so+/://://:/+/://:+y      
       .h///://:///://://:/y+ :NMMMMMhooooooss////+s+//+/ssoooooodMMMMMN/ +y/://://:///://://:h      
       `d+/:+/://:/+/://://:y/`mMMMMMNyooooooy+`-:/+/:-`oyoooooohMMMMMMN.:y///://:///://://:/+h      
        y////://://:///://:/+h::mMMMmhysooooooy/       +yooooooyyhmMMMm:-h+/://:///://://:////o      
        -y/:/+/://://:///://:/h:.+:s: `ysooooooy      `hooooooys  /y/+.-h/://://:///://://::/y.      
         o+//:///://://:/+/:///y:  `s` `yss+/-.`  .-://+syyyoss` .y`  :y///://:/+/://://:///++      
         `y+:///://://:///://:/+y/  .o  `sh    ``.://+osyhNN~-` `y.  /y+/://:/+/://://:///:+s`      
          .y+/:///:+/://:/+/://:/so` //  +d-///////++++oydNd    +/ `oy/://:/+/://://:/+/:/+o`        
           .s///:/+/://://:/+/:+/:+s-`s` sh-:oy:-----:+o~-yh   .y`-so://:/+::+/://:/+::///o`        
            .so:/+::+/://:/+:/+/:///o+y/ /s:mdo       .md-s/   +y+o///:/+:/+/://:/+:/+/:+o`          
             `+s+:/+::+/://:/+::+//+ooo.  `:yy+       /yy:`    -ooo+//+:/+/://:/+:/+/:+o/            
               -so+:/+/:+/:/+/+o+//-`       `+s-`o:`-/s+          `-//+o+/+/:/+:/+::+++.            
                 :oso//+/+so//-`              `-:::::-`                `-/+os//+//+o+:              
                   ./os+/-`                                                 `:/+s+:.
  -->
  <body>
    <div id="contents">
    <a href="https://ziglang.org/"><img alt="zig" src="https://ziglang.org/zig-logo.svg" style="width: 28em"></a>
    <h1>0.6.0 Release Notes</h1>
    <p>
    <a href="https://ziglang.org/download/">Download &amp; Documentation</a>
    </p>
    <p>
    Zig is a general-purpose programming language and toolchain for maintaining
    <strong>robust</strong>, <strong>optimal</strong>, and <strong>reusable</strong> software.
    With special thanks to
    <a href="https://github.com/users/andrewrk/sponsorship">many generous sponsors</a>,
    the Zig project is financially sustainable and currently supports
    <a href="https://andrewkelley.me/">one full-time developer</a>.
    Let's reboot systems programming.</p>
    <p>
    This release features <strong>6 months of work</strong> and
    changes from <strong>112 different contributors</strong>, spread among
    <strong>2510 commits</strong>.
    </p>

    {#header_open|Table of Contents#}
    {#nav#}
    {#header_close#}

    {#header_open|LLVM 10#}
    <p>
    This release of Zig upgrades to
    <a href="http://releases.llvm.org/10.0.0/docs/ReleaseNotes.html">LLVM 10</a>.
    Zig operates in lockstep with LLVM; Zig 0.6.0 is not compatible with LLVM 9.
    </p>
    <p>
    As far as Zig is concerned, the primary benefits of the new LLVM version are bug
    fixes, especially for {#link|ARM Support#}, {#link|MIPS Support#}, and {#link|RISC-V Support#}.
    </p>
    <p>
    This is the first release of <a href="https://lld.llvm.org/">LLD</a> that has all of Zig's patches
    merged upstream. Consequently, Zig's source repository no longer includes a fork of LLD sources.
    Amusingly, it also means that the source tarball
    <a href="https://ziglang.org/download/0.6.0/zig-0.6.0.tar.xz">zig-0.6.0.tar.xz</a>
    is 0.5 MiB smaller than
    <a href="https://ziglang.org/download/0.5.0/zig-0.5.0.tar.xz">zig-0.5.0.tar.xz</a>,
    since the deletion of LLD sources saved more space than all the rest of the changes made
    in this release cycle combined. Note that the new {#link|Bootstrap Tarball#}
    bundles all dependencies of the Zig compiler, which includes LLVM, LLD, and Clang.
    </p>
    <p>
    Thanks to LemonBoy for submitting patches to update Zig's codebase to LLVM 10, as well as
    submitting countless bug reports and patches upstream to LLVM and LLD, to get various
    cross-compiling issues sorted out.
    </p>
    {#header_close#}

    {#header_open|Bootstrap Tarball#}
    <p>With {#link|zig cc#} now available, the 0.6.0 release of Zig comes with a special new source tarball:
    <a href="https://ziglang.org/download/0.6.0/zig-bootstrap-0.6.0.tar.xz" style="white-space: nowrap">zig-bootstrap-0.6.0.tar.xz</a>
    </p>
    <p>
    This is made from the <a href="https://github.com/ziglang/bootstrap">ziglang/bootstrap</a>
    source repository, which contains unpatched LLVM, Clang, LLD, and Zig sources, and a
    <a href="https://github.com/ziglang/bootstrap/blob/0.6.0/build">simple build script with <strong>no branching logic</strong></a>.
    </p>
    <p>
    The purpose of the bootstrap tarball is to start with minimum system dependencies and end with
    a fully operational Zig compiler for any target. It does this in exactly 4 steps:
    </p>
    <ol>
      <li>Build LLVM, Clang, and LLD from source, for the native target, using the native C++ compiler.</li>
      <li>Build Zig from source for the native target, linking against LLVM, Clang, and LLD.</li>
      <li>Now we have Zig as a cross compiler. Use it to rebuild LLVM, Clang, and LLD for the specified target.</li>
      <li>Finally, use Zig to build itself, for the specified target.</li>
    </ol>
    <p>And thus, the <a href="https://github.com/ziglang/zig/issues/853">Grand Bootstrapping Plan</a>
    is fulfilled. The number of steps will always be these four, or less. Never more.</p>
    <p>
    This bootstrap process provides the five new binary builds available in this release, that were not
    available previously:
    </p>
    <ul>
      <li><a href="https://ziglang.org/download/0.6.0/zig-linux-armv7a-0.6.0.tar.xz">zig-linux-armv7a-0.6.0.tar.xz</a> (32-bit {#link|ARM|ARM Support#} Linux)</li>
      <li><a href="https://ziglang.org/download/0.6.0/zig-linux-armv6kz-0.6.0.tar.xz">zig-linux-armv6kz-0.6.0.tar.xz</a> (older 32-bit ARM that notably works on Raspberry Pi 1 and RPi Zero)</li>
      <li><a href="https://ziglang.org/download/0.6.0/zig-linux-i386-0.6.0.tar.xz">zig-linux-i386-0.6.0.tar.xz</a> ({#link|32-bit x86|32-bit x86 Support#} Linux)</li>
      <li><a href="https://ziglang.org/download/0.6.0/zig-linux-riscv64-0.6.0.tar.xz">zig-linux-riscv64-0.6.0.tar.xz</a> ({#link|RISC-V|RISC-V Support#} Linux)</li>
      <li><a href="https://ziglang.org/download/0.6.0/zig-windows-i386-0.6.0.zip">zig-windows-i386-0.6.0.zip</a> ({#link|32-bit x86 Windows|32-bit Windows Support#})</li>
    </ul>
    <p>
    See <a href="https://ziglang.org/download/">the download page</a> for a full list of
    tarballs.
    </p>
    <p>
    Thanks to Timon Kruiper and LemonBoy for contributions related to this.
    </p>
    {#header_close#}

    {#header_open|Support Table#}
    <p>
    Zig uses a {#link|Tier System#} to communicate the level of support for different targets. 
    Notably, in this release:
    </p>
<table>
<thead>
<tr>
<th></th>
<th>free standing</th>
<th>Linux 3.16+</th>
<th>macOS 10.13+</th>
<th>Windows 8.1+</th>
<th>FreeBSD 12.0+</th>
<th>NetBSD 8.0+</th>
<th>UEFI</th>
</tr>
</thead>
<tbody>
<tr>
<td>x86_64</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td style="white-space: nowrap">{#link|Tier 2|Tier 2 Support#}</td>
</tr>
<tr>
<td>arm64</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>arm32</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>mips32 LE</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>i386</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
</tr>
<tr>
<td>riscv64</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>bpf</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>hexagon</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>mips32 BE</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>mips64</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>amdgcn</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>sparc</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>s390x</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>lanai</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>powerpc32</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>powerpc64</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>avr</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>riscv32</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>xcore</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>nvptx</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>msp430</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>r600</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>arc</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>tce</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>le</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>amdil</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>hsail</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>spir</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>kalimba</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>shave</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>renderscript</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
</tbody>
</table>

    {#header_open|WebAssembly Support#}
<table>
<thead>
<tr>
<th></th>
<th>free standing</th>
<th>emscripten</th>
<th>WASI</th>
</tr>
</thead>
<tbody>
<tr>
<td>wasm32</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
</tr>
<tr>
<td>wasm64</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
</tbody>
</table>
    
    <p>
    Thanks to Benjamin Feng and Colin Svingen's contributions:
    </p>
    <ul>
      <li>The WASI OS bits are audited and updated.</li>
      <li>{#syntax#}std.heap.page_allocator{#endsyntax#} gains a WebAssembly implementation.</li>
    </ul>
    {#header_close#}

    {#header_open|Tier System#}

    {#header_open|Tier 1 Support#}
    <ul>
      <li>Not only can Zig generate machine code for these targets, but the standard
   library cross-platform abstractions have implementations for these targets.
   Thus it is practical to write a pure Zig application with no dependency on
   libc.</li>
      <li>The CI server automatically tests these targets on every commit to master
      branch, and updates <a href="https://ziglang.org/download/">the download page</a>
      with links to pre-built binaries.</li>
      <li>These targets have debug info capabilities and therefore produce stack traces
        on failed assertions.</li>
      <li>libc is available for this target even when cross compiling.</li>
      <li>All the behavior tests and applicable standard library tests pass for this target.
          All language features are known to work correctly.</li>
    </ul>
    {#header_close#}

    {#header_open|Tier 2 Support#}
    <ul>
    <li>The standard library supports this target, but it's possible that some
      APIs will give an "Unsupported OS" compile error. One can link with libc or other
      libraries to fill in the gaps in the standard library.</li>
    <li>These targets are known to work, but may not be automatically tested, so there
      are occasional regressions.</li>
    <li>Some tests may be disabled for these targets as we work toward
      {#link|Tier 1 Support#}.
    </li>
    </ul>
    {#header_close#}

    {#header_open|Tier 3 Support#}
    <ul>
    <li>The standard library has little to no knowledge of the existence of this
        target.</li>
    <li>Because Zig is based on LLVM, it has the capability to build for these
      targets, and LLVM has the target enabled by default.</li>
    <li>These targets are not frequently tested; one will likely need to contribute
      to Zig in order to build for these targets.</li>
    <li>The Zig compiler might need to be updated with a few things such as<ul>
       <li>what sizes are the C integer types</li>
       <li>C ABI calling convention for this target</li>
       <li>bootstrap code and default panic handler</li>
     </ul>
     <li><code>zig targets</code> is guaranteed to include this target.</li>
    </ul>
    {#header_close#}

    {#header_open|Tier 4 Support#}
    <ul>
      <li>Support for these targets is entirely experimental.</li>
      <li>LLVM may have the target as an experimental target, which means that you
   need to use Zig-provided binaries for the target to be available, or
   build LLVM from source with special configure flags. <code>zig targets</code> will
   display the target if it is available.</li>
   <li>This target may be considered deprecated by an official party,
     <a href="https://support.apple.com/en-us/HT208436">such as macosx/i386</a> in which
     case this target will remain forever stuck in Tier 4.</li>
   <li>This target may only support <code>--emit asm</code> and cannot emit object files.</li>
    </ul>
    {#header_close#}
    {#header_close#}

    {#header_open|Windows Support#}
    <p>
    Zig's Windows support improved considerably in this release. Counterintuitively,
    in the {#link|Support Table#}, x86_64-windows went from
    {#link|Tier 1|Tier 1 Support#} =&gt; {#link|Tier 2|Tier 2 Support#},
    but this is due to more {#link|SIMD#} test coverage added, and it was
    discovered that vectors of {#syntax#}f16{#endsyntax#} are failing some behavior tests.
    This is the <a href="https://github.com/ziglang/zig/issues/4952">only issue</a>
    holding Windows (both 32-bit and 64-bit) back from {#link|Tier 1|Tier 1 Support#}.
    </p>
    <p>
    In this release, the minimum supported Windows version is bumped from 7+ to 8.1+, following the
    <a href="https://support.microsoft.com/en-us/help/13853/windows-lifecycle-fact-sheet">extended support lifecycle of Microsoft</a>.
    </p>
    <p>In addition:</p>
    <ul>
      <li>More cross compiling support for Windows system DLLs.</li>
      <li>{#syntax#}wWinMain{#endsyntax#}, {#syntax#}wWinMainCRTStartup{#endsyntax#},
        and {#syntax#}DllMain{#endsyntax#} are now recognized entrypoints. (#4376)</li>
      <li>Improved {#link|Debug Info and Stack Traces#}</li>
      <li>The hack to disable native {#link|CPU Features#} on Windows is removed
          thanks to bug fixes in {#link|LLVM 10#}. (#508)</li>
    </ul>
    <p>
    Thanks Jared Miller, emekoi, syscall0, and LemonBoy for contributions related to this.
    </p>

    {#header_open|32-bit Windows Support#}
    <p>
    In this release, i386-windows goes from
    {#link|Tier 3|Tier 3 Support#} =&gt; {#link|Tier 2|Tier 2 Support#}.
    A {#link|pre-made .zip build of 32-bit Windows|Bootstrap Tarball#} is newly available.
    </p>
    <p>
    Thanks to LemonBoy's work on this:
    </p>
    <ul>
      <li>Support for Win32 Thread-Local Storage.</li>
      <li>Adding more lib32 .def files from {#link|mingw-w64|mingw-w64 7.0.0#}.</li>
      <li>Removing x86/Windows name mangling hack and properly generating
        correct .lib files from mingw-w64 sources, by adding dlltool functionality to Zig.</li>
      <li>Adding {#link|Test Coverage#} for i386-windows.</li>
      <li>Fixing stack-probe symbol redefinition.</li>
    </ul>
    <p>
    The only thing holding 32-bit Windows back from {#link|Tier 1 Support#} is enabling
    i386-windows CI builds of Zig that update the download page and the
    <a href="https://github.com/ziglang/zig/issues/4952">same f16 vector issue from 64-bit Windows</a>.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|RISC-V Support#}
    <p>
    RISC-V support in Zig is now excellent! We even have
    riscv64 binary tarballs now thanks to the {#link|Bootstrap Tarball#}.
    It does, however require
    <a href="https://github.com/ziglang/bootstrap/issues/4#issuecomment-608549353">one workaround</a>
    due to
    <a href="https://bugs.llvm.org/show_bug.cgi?id=45419">clang crashing when it tries to build itself for self-hosted riscv64</a>.
    </p>
    <p>riscv64-freestanding went from
    {#link|Tier 4|Tier 4 Support#} =&gt; {#link|Tier 1|Tier 1 Support#}.
    </p>
    <p>riscv64-linux went from {#link|Tier 4|Tier 4 Support#} =&gt; {#link|Tier 2|Tier 2 Support#}
    and is already nearing {#link|Tier 1|Tier 1 Support#}.</p>
    <p>
    {#link|Debug Info and Stack Traces#} on RISC-V is now working.
    </p>
    <p>
    The default ABI of riscv32-linux and riscv64-linux is changed to be 
    ilp32d and lp64d, respectively. Likewise, the default ABI of non-linux riscv32 and riscv64
    are changed to be ilp32 and lp64. This matches Clang's behavior. (#4863)
    </p>
    <p>
    Zig now has {#link|Test Coverage#} for riscv64 with no libc and riscv64 with
    {#link|musl|musl 1.2.0#} libc. The issue for Zig providing {#link|glibc|glibc 2.31#} for
    riscv64 is #3340.
    </p>
    <p>
    Thanks to LemonBoy for contributions related to this, and to Lu√≠s Marques for fixing
    RISC-V issues upstream, which landed in {#link|LLVM 10#}.
    </p>
    {#header_close#}

    {#header_open|ARM Support#}
    <p>
    aarch64-linux is very nearly {#link|Tier 1|Tier 1 Support#}. The only thing preventing it is
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+label%3Aarch-arm64+label%3Abug">some behavior tests are disabled</a>.
    </p>
    <p>
    In this release, Zig gained CI {#link|Test Coverage#} for aarch64, and the download page
    is updated with every master branch commit with a binary tarball for aarch64.
    </p>
    <p>
    Thanks to the {#link|Bootstrap Tarball#} this release additionally gains a
    32-bit ARM binary available (armv7a), as well as another 32-bit slightly older ARM
    binary (armv6kz) which notably works on Raspberry Pi 1 and RPi 0.
    </p>
    <p>
    Thank you to Timon Kruiper and LemonBoy for working together to solve undefined behavior
    bugs revealed by building Zig with {#link|zig cc#}.
    </p>
    <ul>
      <li>Fix signedness for some fields in ARM stat definition</li>
      <li>C ABI support is partially implemented.</li>
      <li>Fix possible unaligned ptr from <code>getauxval</code>. This caused SIGILL on armv7a-linux. (#4796)</li>
      <li>Fix multiplication overflow in <code>hash_const_val</code>. In some cases the compiler
        was actually emitting an 64 bit signed multiplication, instead of a 32 bit unsigned one.</li>
    </ul>
    {#header_close#}

    {#header_open|32-bit x86 Support#}
    <p>
    i386-linux went from {#link|Tier 3|Tier 3 Support#} =&gt; {#link|Tier 2|Tier 2 Support#},
    and is nearing {#link|Tier 1|Tier 1 Support#}.
    </p>
    <p>
    Thanks to the {#link|Bootstrap Tarball#} this release additionally gains a
    i386-linux binary available.
    </p>
    <p>Thanks LemonBoy for implementing i386 support during this cycle. (#3808, #4408)</p>
    {#header_close#}

    {#header_open|MIPS Support#}
    <p>LemonBoy contributed MIPS fixes:</p>
    <ul>
      <li>Correct signal bits for MIPS. Also enable the segfault handler for all the
        supported architectures beside MIPS.</li>
      <li>Fix pipe syscall for MIPS.</li>
      <li>Implement target_dynamic_linker for MIPS.</li>
    </ul>
    {#header_close#}

    {#header_open|NetBSD Support#}
    <p>
    LemonBoy contributed NetBSD fixes: (#4793)
    </p>
    <ul>
      <li>Fixes some nasty errors in the threading code</li>
      <li>Makes Zig able to run all the tests (at least on x86-64) except the event ones</li>
      <li>Audits and corrects some defines for NetBSD</li>
    </ul>
    {#header_close#}

    {#header_open|UEFI Support#}
    <p>Nick Erdmann and Heppokoyuki contributed UEFI improvements:</p>
    <ul>
      <li>make the subsystem configurable in {#link|zig build#}</li>
      <li>fix con_in definition and add EFI_SIMPLE_TEXT_INPUT_PROTOCOL definition</li>
      <li>add file protocols and improvements</li>
      <li>add documentation</li>
      <li>loading images</li>
      <li>snp, mnp, ip6, and udp6 support</li>
      <li>protocol handling improvements</li>
      <li>boot services and runtime services improvements</li>
      <li>loaded image protocol improvements</li>
      <li>Add shell parameters protocol</li>
      <li>device path protocol improvements</li>
      <li>status reform</li>
    </ul>
    {#header_close#}

    {#header_open|macOS Support#}
    <p>
    In this release, x86_64-macos went from 
    {#link|Tier 1|Tier 1 Support#} =&gt; {#link|Tier 2|Tier 2 Support#},
    however, this is not because Zig dropped any kind of support for macOS, but rather because
    the bar for meeting {#link|Tier 1|Tier 1 Support#} requirements was raised,
    to include "libc is available for this target even when cross-compiling."
    </p>
    {#header_close#}

    {#header_close#}

    {#header_open|Target Details#}
    <p>
    Zig's awareness of {#link|CPU model and features|CPU Features#} as well as
    {#link|operating system versions|OS Version Ranges#} has broadened.
    </p>
    <p>
    The standard library now has two distinct concepts:
    {#syntax#}std.Target{#endsyntax#} and {#syntax#}std.zig.CrossTarget{#endsyntax#}.
    </p>
    <p>
    CrossTarget is what Zig's command line options get parsed into. It contains the concept
    of "native" and "default". Once this structure is populated, it can be <em>resolved</em>
    into a Target.
    </p>
    <p>
    A Target has all the information available; the CPU, OS, and ABI are all populated.
    As an example, a CrossTarget might be set to "native", and then when it is resolved,
    it turns into a Target which has the triple <code>riscv64-linux-musl</code>.
    </p>
    <p>
    {#link|zig build#} scripts set the desired CrossTarget of a build artifact; the Zig
    code being compiled only has access to the resolved Target as {#syntax#}std.Target.current{#endsyntax#}.
    </p>
    <p>
    Zig now supports a more fine-grained sense of what is native and what is not.
    Some examples:
    </p>
    <p>This is now allowed:</p>
    <pre>-target native</pre>
    <p>Different OS but native CPU, default Windows C ABI:</p>
    <pre>-target native-windows</pre>
    <p>This could be useful for example when running in Wine.</p>
    
    <p>Different CPU but native OS, native C ABI.</p>
    <pre>-target x86_64-native -mcpu=skylake</pre>
    
    <p>Different C ABI but otherwise native target:</p>
    <pre>-target native-native-musl</pre>
    <pre>-target native-native-gnu</pre>

    <p>
    This is a <strong>breaking change</strong> to std lib APIs for checking the OS and CPU architecture. 
    To update from 0.5.0 to 0.6.0:
    </p>
    <p>
    {#syntax#}builtin.os{#endsyntax#} =&gt; {#syntax#}builtin.os.tag{#endsyntax#}
    </p>
    <p>
    {#syntax#}builtin.arch{#endsyntax#} =&gt; {#syntax#}builtin.cpu.arch{#endsyntax#}
    </p>
    <p>{#syntax#}std.build.Builder.standardTargetOptions{#endsyntax#} is changed to accept its
    parameters as a struct with default values. It now has the ability to
    specify a whitelist of targets allowed, as well as the default target.
    Rather than two different ways of collecting the target, it's now always
    a string that is validated, and prints helpful diagnostics for invalid
    targets. This feature should now be actually useful, and contributions
    welcome to further improve the user experience.</p>
    <p>{#syntax#}std.build.LibExeObjStep.setTheTarget{#endsyntax#} is removed.
    {#syntax#}std.build.LibExeObjStep.setTarget{#endsyntax#} is updated to take a CrossTarget
    parameter.</p>
    <p>
    {#syntax#}std.build.LibExeObjStep.setTargetGLibC{#endsyntax#} is removed. glibc versions are
    handled in the CrossTarget API and can be specified with the <code>-target</code>
    triple.
    </p>
    <p>
    {#syntax#}std.builtin.Version{#endsyntax#} gains a {#syntax#}format{#endsyntax#} method.
    </p>
    <p>Thanks to Timon Kruiper for contributions related to this.</p>

    {#header_open|CPU Features#}
    <p>
    Zig now has a database of CPU models and CPU features for every architecture.
    Now that <code>zig targets</code> is {#link|self-hosted|Self-Hosted Compiler Progress#}
    and outputs JSON, the easiest way to see this is to pipe <code>zig targets</code> into a JSON
    file and inspect it with a graphical JSON viewer, such as Firefox. 
    </p>
    <p>
    Here I will show you <code>zig targets | jq .native</code> on the laptop that I am typing
    these release notes on:
    </p>
    <pre><code>{
  "triple": "x86_64-linux.5.4.15...5.4.15-gnu.2.27",
  "cpu": {
    "arch": "x86_64",
    "name": "skylake",
    "features": [
      "64bit",
      "adx",
      "aes",
      "avx",
      "avx2",
      "bmi",
      "bmi2",
      "clflushopt",
      "cmov",
      "cx16",
      "cx8",
      "ermsb",
      "f16c",
      "false_deps_popcnt",
      "fast_gather",
      "fast_scalar_fsqrt",
      "fast_shld_rotate",
      "fast_variable_shuffle",
      "fast_vector_fsqrt",
      "fma",
      "fsgsbase",
      "fxsr",
      "idivq_to_divl",
      "invpcid",
      "lzcnt",
      "macrofusion",
      "merge_to_threeway_branch",
      "mmx",
      "movbe",
      "nopl",
      "pclmul",
      "popcnt",
      "prfchw",
      "rdrnd",
      "rdseed",
      "rtm",
      "sahf",
      "sgx",
      "slow_3ops_lea",
      "sse",
      "sse2",
      "sse3",
      "sse4_1",
      "sse4_2",
      "ssse3",
      "vzeroupper",
      "x87",
      "xsave",
      "xsavec",
      "xsaveopt",
      "xsaves"
    ]
  },
  "os": "linux",
  "abi": "gnu"
}</code></pre>
    <p>
    Here you can see the CPU model and set of CPU features Zig detected. The implementation
    of this is <strong>fully self-hosted</strong>. Although Zig properly informs LLVM about
    CPU features when it does code generation, the awareness of CPU features and detection of
    CPU features is all implemented in Zig code. Currently, only x86 CPU feature detection is
    implemented; Zig falls back to LLVM for detecting native CPU model and features on other
    architectures. <a href="https://github.com/ziglang/zig/issues/4591">Contributions welcome</a>!
    </p>
    <p>
    Zig now has the ability to parse CPU features as part of the target triple.
    </p>
    <p>Native architecture, OS, and ABI, but baseline CPU features:</p>
    <pre>-target native -mcpu=baseline</pre>
    <p>RISC-V 64-bit architecture, OS linux, default ABI, native CPU plus the rdpid feature, minus the sse3 feature:</p>
    <pre>-target riscv64-linux -mcpu=native+rdpid-sse3</pre>
    <p>Target the RPi Zero:</p>
    <pre>-target arm-linux-musleabi -mcpu=arm1176jzf_s</pre>
    <p>
    Now that it is possible to select what CPU features are enabled, freestanding no longer
    has SSE enabled by default.
    </p>
    <p>Thanks to Layne Gustafson for the initial exploration and implementation of
    this feature, and to alichay for the initial implementation of x86 CPU feature detection.
    </p>
    <p>Thanks to LemonBoy, Michael Dusan, and Noam Preil for related contributions.</p>
    {#header_close#}

    {#header_open|Removal of Sub-Architecture#}
    <p>
    The whole point of Zig is to re-examine the premises of system programming, and
    rework abstractions that have shown to be less than ideal. Naturally, once Zig
    gained CPU feature awareness, it raised the question, <em>what is the purpose of
    sub-architectures?</em>
    </p>
    <p>
    As it turns out, the answer is "none". Sub-architectures are rendered redundant by
    the existence of CPU features, and so they no longer exist in Zig.
    </p>
    <p>
    This has the happy consequence of making {#syntax#}std.Target.Cpu.Arch{#endsyntax#}
    an enum rather than a tagged union.
    </p>
    <p>Rather than:</p>
    <pre>-target armv7a-linux-gnu</pre>
    <p>Now it is:</p>
    <pre>-target arm-linux-gnu</pre>
    <p><code>v7a</code> is considered baseline, so to target a different sub-architecture such as
    v6kz, it would look like:</p>
    <pre>-target arm-linux-gnu -mcpu=generic+v6kz</pre>
    {#header_close#}

    {#header_open|OS Version Ranges#}
    <p>Operating System version ranges are now part of the target. This means that
    {#syntax#}comptime{#endsyntax#} code has access to exactly which version(s) of
    an OS are being targeted. You can see this by looking at the output of <code>zig builtin</code>,
    which displays the source code provided by {#syntax#}std.builtin{#endsyntax#}. Here's a snippet
    of the output on the computer I'm using to type release notes:</p>
    <pre>{#syntax#}// ...
pub const os = Os{
    .tag = .linux,
    .version_range = .{ .linux = .{
        .range = .{
            .min = .{
                .major = 5,
                .minor = 4,
                .patch = 15,
            },
            .max = .{
                .major = 5,
                .minor = 4,
                .patch = 15,
            },
        },
        .glibc = .{
            .major = 2,
            .minor = 27,
            .patch = 0,
        },
    }},
};
// ...{#endsyntax#}</pre>
    <p>Updated syntax for <code>-target</code> to take into account OS version ranges:</p>
    <pre><code># still valid. default version range
-target x86_64-windows-msvc

# minimum windows version: XP
# maximum windows version: 10
-target x86_64-windows.xp...win10-msvc

# minimum windows version: 7
# maximum windows version: latest
-target x86_64-windows.win7-msvc

# linux example
-target aarch64-linux.3.16...5.3.1-musl

# specifying glibc version
-target mipsel-linux.4.10-gnu.2.1</code></pre>
    <p>Here's what it will look like to populate a {#syntax#}CrossTarget{#endsyntax#}:</p>
    <pre><code>-        tc.target = tests.Target{
-            .Cross = .{
-                .arch = .x86_64,
-                .os = .linux,
-                .abi = .gnu,
-            },
+        tc.target = std.zig.CrossTarget{
+            .cpu_arch = .x86_64,
+            .os_tag = .linux,
+            .abi = .gnu,</code></pre>
    <p>Code that used {#syntax#}Target.parse{#endsyntax#} need not be updated.</p>
    <p>Checking for the OS when doing conditional compilation:</p>
    <pre><code>--- a/lib/std/build/run.zig
+++ b/lib/std/build/run.zig
@@ -82,7 +82,7 @@ pub const RunStep = struct {
 
         var key: []const u8 = undefined;
         var prev_path: ?[]const u8 = undefined;
-        if (builtin.os == .windows) {
+        if (builtin.os.tag == .windows) {
             key = "Path";
             prev_path = env_map.get(key);
             if (prev_path == null) {</code></pre>

    <p>{#syntax#}std.Target.getStandardDynamicLinkerPath{#endsyntax#} is renamed to
    {#syntax#}std.Target.standardDynamicLinkerPath{#endsyntax#} and no longer requires an allocator.</p>

    <p>
    Zig's method of detecting the native system ABI and dynamic linker is now simple but portable:
    it inspects the dynamic linker path of its own executable. If statically linked, Zig looks at the
    dynamic linker path of <code>/usr/bin/env</code>, which is ubiquitous due to its use in shebang
    lines. Based on the dynamic linker file name, the ABI can be deduced. The same static Zig build
    will correctly detect the native ABI and dynamic linker path on Debian, NixOS, and Apline Linux,
    for example.
    </p>

     <p>No more {#syntax#}std.os.foo.is_the_target{#endsyntax#}.
     It had the downside of running all the comptime blocks and resolving
     all the usingnamespaces of each system, when just trying to discover if
     the current system is a particular one.
     For Darwin, where it's nice to use {#syntax#}std.Target.current.isDarwin(){#endsyntax#}, this
     demonstrates the utility that the proposal #425 would provide.
     </p>
     <p>
     This change allowed the removal of special Darwin OS version min handling. Now it is integrated
     with Zig's target OS range. The command line options
     <code>-mios-version-min</code> and <code>-mmacosx-version-min</code>
     are removed.
     </p>
     <p>
     Thanks LemonBoy for contributing OS version detection implementations for Windows and OSX.
     </p>
    {#header_close#}

    {#header_close#}

    {#header_open|Language Changes#}
    <ul>
      <li>Improved names of error sets when using merge error sets operator ({#syntax#}||{#endsyntax#}).</li>
      <li>{#syntax#}pub{#endsyntax#} syntax for container fields is removed.</li>
      <li>Type coercion from {#syntax#}*[0]T{#endsyntax#} to {#syntax#}E![]const T{#endsyntax#} is now allowed. This is an unambiguous, safe cast.</li>
      <li>{#syntax#}asm{#endsyntax#} now accepts comptime-known values, rather than
        requiring string literal syntax.</li>
      <li>Removed compile error for peer result {#syntax#}comptime_int{#endsyntax#} and
        {#syntax#}null{#endsyntax#}. (#2763)</li>
      <li>Ability to pass {#syntax#}comptime{#endsyntax#} types and non {#syntax#}comptime{#endsyntax#} types to same parameter.</li>
      <li><code>@typeOf</code> is renamed to {#syntax#}@TypeOf{#endsyntax#}. {#link|zig fmt#} automatically performs the conversion, and the next release of Zig after this one will remove the automatic conversion.</li>
      <li>Ability to switch on pointer types. (#4074)</li>
      <li>Multiline strings in test and library names are disallowed.</li>
      <li>Zig language no longer requires the expression {#syntax#}a else unreachable{#endsyntax#} with
        {#syntax#}comptime{#endsyntax#} {#syntax#}a{#endsyntax#} to produce a
        {#syntax#}comptime{#endsyntax#} result.</li>
      <li>Timon Kruiper implemented casting between {#syntax#}[*c]T{#endsyntax#} and {#syntax#}?[*:0]T{#endsyntax#} on {#syntax#}fn{#endsyntax#} parameter. (#4176)</li>
      <li>Timon Kruiper improved {#syntax#}@typeInfo{#endsyntax#} to lazily resolve declarations.
        This way all the declarations in a namespace won't be resolved until the user actually
        uses the declarations slice in the builtin TypeInfo union. (#2594, #3893, #4435)</li>
      <li>{#syntax#}@ptrCast{#endsyntax#} supports casting a slice to a pointer.</li>
      <li>LemonBoy implemented peer type resolution between {#syntax#}?[]T{#endsyntax#} and {#syntax#}*[N]T{#endsyntax#}. (#4767)</li>
      <li>There is now peer type resolution between mixed-const {#syntax#}[]T{#endsyntax#} and {#syntax#}*[N]T{#endsyntax#}. (#4766)</li>
    </ul>

    <p>
    Thanks to Vexu and LemonBoy for contributions related to the above list.
    </p>

    {#header_open|Type Coercion Syntax#}
    <p>
    <strong>Type coercion</strong> (previously called "implicit casting") is now
    performed with the {#syntax#}@as{#endsyntax#} builtin, rather than by calling
    a type as a function. (#1757)
    </p>
    <p>
    While a bit more verbose, Zig now has the property that all function calls are
    always function calls and not type casts, and thus it is
    <strong>no longer required for
    someone reading Zig code to know the type to determine whether something is a
    type cast or a function call</strong>.
    </p>
    <p>Type coercion is now hooked up into the result location mechanism,
    and additionally hooked up with variable declarations, maintaining the property that:
    </p>
    <pre>{#syntax#}var a: T = b;{#endsyntax#}</pre>
    <p>is semantically equivalent to:</p>
    <pre>{#syntax#}var a = @as(T, b);{#endsyntax#}</pre>
    {#header_close#}

    {#header_open|Sentinel-Terminated Pointers#}
    <p>
    With this change, one feature was added to the language, and one feature was removed.
    </p>
    <p>
    There are no longer any C string literals such as <code>c"hello"</code>. Instead,
    the type of all string literals is changed from</p>
    <p>{#syntax#}[]const u8{#endsyntax#}</p>
    <p>to</p>
    <p>{#syntax#}*const [N:0]u8{#endsyntax#}</p>
    <p>Where N is the number of bytes in the string literal.</p>
    <p>
    Let's unpack that. Reading the type from left-to-right, this is a
    <strong>reference, immutable-memory, array of N items, followed by an element with value {#syntax#}0{#endsyntax#}, element type {#syntax#}u8{#endsyntax#}</strong>.
    </p>
    <p>
    Note that the sentinel value is <em>not counted in the length</em>.
    </p>
    <p>
    This type has the length encoded in multiple ways. This means that it can automatically
    coerce to both {#syntax#}[]const u8{#endsyntax#} (because the length is encoded in the type),
    and it can also automatically coerce to {#syntax#}[*:0]const u8{#endsyntax#} (because both types
    are null-terminated).
    </p>
    <p>
    So, Zig string literals now can be passed directly to C functions which accept null-terminated
    strings, and they can also be passed directly to Zig functions which accept slices.
    </p>
    {#code_begin|exe|sentinel_ptrs#}
    {#link_libc#}
const std = @import("std");

pub fn main() void {
    do_it_the_zig_way("world");
    do_it_the_c_way("world");
}

fn do_it_the_zig_way(arg: []const u8) void {
    std.debug.warn("hello {}\n", .{arg});
}

fn do_it_the_c_way(arg: [*:0]const u8) void {
    _ = std.c.printf("hello %s\n", arg);
}
    {#code_end#}
    <p>
    Additionally, slicing syntax now supports a way to assert that a sentinel exists at a particular
    element:
    </p>
    {#code_begin|test|slice_sentinel#}
const std = @import("std");

test "slice with sentinel" {
    var array = [_]i32{ 'a', 'b', 'c', 'd', 'e' };
    const slice = array[1..3 :'d'];
    const result = foo(slice);
    std.testing.expect(result == 'b' + 'c');
}

fn foo(s: [*:'d']i32) i32 {
    var sum: i32 = 0;
    var index: usize = 0;
    while (s[index] != 'd') : (index += 1) {
        sum += s[index];
    }
    return sum;
}
    {#code_end#}
    <p>
    If the sentinel is incorrect, a safety check is activated:
    </p>
    {#code_begin|test_err|sentinel mismatch#}
test "slice with sentinel" {
    var array = [_]i32{ 'a', 'b', 'c', 'd', 'e' };
    const slice = array[1..3 :'f'];
}
    {#code_end#}
    <p>
    Thanks to LemonBoy, Raul Leal, daurnimator, and Michael Dusan for contributions
    related to this feature.
    </p>
    {#header_close#}

    {#header_open|Remove Array-to-Reference Type Coercion#}
    <p>
    Now that {#link|Sentinel-Terminated Pointers#} is done, the main motivation for type coercion
    from array values to slices is gone. It's a footgun for Zig to automatically convert a value
    into a pointer to that value; such an operation should be explicit.
    </p>
    {#code_begin|test_err|array literal requires#}
test "coerce array value to slice" {
    var array: []const i32 = [_]i32{ 1, 2, 3, 4 };
}
    {#code_end#}
    <p>
    How to upgrade code for these new semantics:
    </p>
    {#code_begin|test|coerce_array_ptr#}
test "coerce array pointer to slice" {
    var array: []const i32 = &[_]i32{ 1, 2, 3, 4 };
}
    {#code_end#}
    <p>This change to simplifies the result location semantics, which helps with reasoning about
    Zig code, as well as reducing the complexity of a Zig compiler.</p>
    {#header_close#}

    {#header_open|Numerical Comparisons#}
    <p>
    All numerical comparisons are now allowed no matter the type combinations.
    For example, small signed integers can be compared against large unsigned integers,
    and floats can be compared against integers.
    </p>
    <p>
    For a demonstration of this, you can look at the new {#syntax#}std.math.compare{#endsyntax#}
    function added to the {#link|Standard Library#} and the test cases for it:
    </p>
    {#code_begin|test|compare#}
const std = @import("std");
const expect = std.testing.expect;

/// See also `Order`.
pub const CompareOperator = enum {
    /// Less than (`<`)
    lt,

    /// Less than or equal (`<=`)
    lte,

    /// Equal (`==`)
    eq,

    /// Greater than or equal (`>=`)
    gte,

    /// Greater than (`>`)
    gt,

    /// Not equal (`!=`)
    neq,
};

/// This function does the same thing as comparison operators, however the
/// operator is a runtime-known enum value. Works on any operands that
/// support comparison operators.
pub fn compare(a: var, op: CompareOperator, b: var) bool {
    return switch (op) {
        .lt => a < b,
        .lte => a <= b,
        .eq => a == b,
        .neq => a != b,
        .gt => a > b,
        .gte => a >= b,
    };
}

test "compare between signed and unsigned" {
    expect(compare(@as(i8, -1), .lt, @as(u8, 255)));
    expect(compare(@as(i8, 2), .gt, @as(u8, 1)));
    expect(!compare(@as(i8, -1), .gte, @as(u8, 255)));
    expect(compare(@as(u8, 255), .gt, @as(i8, -1)));
    expect(!compare(@as(u8, 255), .lte, @as(i8, -1)));
    expect(compare(@as(i8, -1), .lt, @as(u9, 255)));
    expect(!compare(@as(i8, -1), .gte, @as(u9, 255)));
    expect(compare(@as(u9, 255), .gt, @as(i8, -1)));
    expect(!compare(@as(u9, 255), .lte, @as(i8, -1)));
    expect(compare(@as(i9, -1), .lt, @as(u8, 255)));
    expect(!compare(@as(i9, -1), .gte, @as(u8, 255)));
    expect(compare(@as(u8, 255), .gt, @as(i9, -1)));
    expect(!compare(@as(u8, 255), .lte, @as(i9, -1)));
    expect(compare(@as(u8, 1), .lt, @as(u8, 2)));
    expect(@bitCast(u8, @as(i8, -1)) == @as(u8, 255));
    expect(!compare(@as(u8, 255), .eq, @as(i8, -1)));
    expect(compare(@as(u8, 1), .eq, @as(u8, 1)));
}
    {#code_end#}
    <p>Thanks to Shawn Landden for the proposal.</p>
    {#header_close#}

    {#header_open|Anonymous Struct Literals#}
      <p>
      Zig now allows omitting the struct type of a literal. When the result is
      {#link|coerced|Type Coercion Syntax#},
      the struct literal will directly instantiate the result location, with no copy:
      </p>
      {#code_begin|test|struct_result#}
const std = @import("std");
const expect = std.testing.expect;

test "anonymous struct literal" {
    checkPoint(.{
        .x = 13,
        .y = 67,
    });
}

fn checkPoint(pt: struct {x: i32, y: i32}) void {
    expect(pt.x == 13);
    expect(pt.y == 67);
}
      {#code_end#}
      <p>
      The struct type can be inferred. Here the result location does not include a type, and
      so Zig infers the type:
      </p>
      {#code_begin|test|struct_anon#}
const std = @import("std");
const expect = std.testing.expect;

test "fully anonymous struct" {
    dump(.{
        .int = 1234,
        .float = 12.34,
        .b = true,
        .s = "hi",
    });
}

fn dump(args: var) void {
    expect(args.int == 1234);
    expect(args.float == 12.34);
    expect(args.b);
    expect(args.s[0] == 'h');
    expect(args.s[1] == 'i');
}
      {#code_end#}

      <p>This syntax can also be used to initialize unions without specifying the type:</p>
      {#code_begin|test|anon_union#}
const std = @import("std");
const expect = std.testing.expect;

const Number = union {
    int: i32,
    float: f64,
};

test "anonymous union literal syntax" {
    var i: Number = .{.int = 42};
    var f = makeNumber();
    expect(i.int == 42);
    expect(f.float == 12.34);
}

fn makeNumber() Number {
    return .{.float = 12.34};
}
      {#code_end#}

    <p>Thanks to Vexu, LemonBoy, dbandstra, and Alexander Naskos for
    contributing fixes related to this feature.</p>
    {#header_close#}

    {#header_open|Tuples Added, Var Args Removed#}
    <p>Similar to
    <a href="https://ziglang.org/documentation/0.6.0/#Enum-Literals">Anonymous Enum Literals</a>
    and {#link|Anonymous Struct Literals#}, the type can be omitted from array literals.
    In this example, tuple syntax directly populates the array elements:</p>
      {#code_begin|test|tuple#}
const std = @import("std");
const expect = std.testing.expect;

test "tuple syntax" {
    var array: [4]u8 = .{11, 22, 33, 44};
    expect(array[0] == 11);
    expect(array[1] == 22);
    expect(array[2] == 33);
    expect(array[3] == 44);
}
      {#code_end#}
      <p>
      A tuple is a {#syntax#}struct{#endsyntax#} with auto-numbered field names:
      </p>
      {#code_begin|test|infer_tuple#}
const std = @import("std");
const expect = std.testing.expect;

test "fully anonymous tuple" {
    dump(.{ @as(u32, 1234), @as(f64, 12.34), true, "hi"});
}

fn dump(args: var) void {
    expect(args.@"0" == 1234);
    expect(args.@"1" == 12.34);
    expect(args.@"2");
    expect(args.@"3"[0] == 'h');
    expect(args.@"3"[1] == 'i');
}
      {#code_end#}
    <p>
    However, the {#syntax#}@""{#endsyntax#} syntax is not needed, because
    although tuples are structs, they also have array-like qualities:
    </p>
    {#code_begin|test|tuples_are_array_like#}
const std = @import("std");
const expect = std.testing.expect;

test "tuples support element access and .len field" {
    var x: i32 = 1234;
    var y: i32 = 4567;
    var tup = .{ x, y };
    tup[0] += 1; // works as long as the indexes are comptime-known
    tup[1] -= 1;

    expect(tup[0] == 1235);
    expect(tup[1] == 4566);

    // now we iterate over the fields
    var sum: i32 = 0;
    comptime var index = 0;
    inline while (index < tup.len) : (index += 1) {
        sum += tup[index];
    }
    expect(sum == 1235 + 4566);
}

test "tuple concatenation" {
    var one = .{ "hi", true };
    var two = .{ 12.34, .ok };
    var combined = one ++ two;

    expect(combined[3] == .ok);
}
    {#code_end#}
    <p>
    Zig is determined to remain a small language.
    With the addition of tuples comes the removal of variadic parameter functions (#208).
    Printing and formatting are no exception. Formatted printing now uses tuples
    for the parameters to print, rather than var args:
    </p>
    {#code_begin|exe|hello#}
const std = @import("std");

pub fn main() void {
    std.debug.warn("Hello, {}\n", .{"World!"});
}
    {#code_end#}
    <p>
    Note: Zig still supports C ABI functions with var args. Nothing is changed there.
    </p>
    <p>
    Zig's var args design was flawed, with many issues such as
    <a href="https://github.com/ziglang/zig/issues/557">var args can't handle void or number literal arguments</a>. With tuples, these issues are resolved.
    Zig's Tuples are much more robust and generally useful than its var args ever was.
    </p>
    <p>
    <a href="https://github.com/ziglang/zig/issues/4335">It is planned to add tuple type declaration syntax</a>.
    </p>
    <p>Thanks to Vexu, LemonBoy, dbandstra, and Alexander Naskos for fixes related to this feature.</p>
    {#header_close#}

    {#header_open|SIMD#}
    <p>
    Zig's SIMD support in 0.6.0 is still far from complete, but significant progress has been made.
    </p>
    <p>
    Vectors gain element access syntax (#3575, #3580).
    This introduces the concept of vector index being part of a pointer
    type. This avoids vectors having well-defined in-memory layout, and
    allows vectors of any integer bit width to work the same way.
    </p>
    <p>
    When a vector is indexed with a scalar, this is vector element access,
    which is implemented in 0.6.0. When a vector is indexed with a vector,
    this is gather/scatter, which is not available in this release.
    </p>
    {#code_begin|test|vector_elem#}
const std = @import("std");
const expect = std.testing.expect;

test "vector element access" {
    var v: @Vector(4, i32) = [_]i32{ 1, 5, 3, undefined };

    v[2] = 42;
    expect(v[1] == 5);
    v[3] = -364;
    expect(v[2] == 42);
    expect(-364 == v[3]);

    storev(&v[0], 100);
    expect(v[0] == 100);
}
fn storev(ptr: var, x: i32) void {
    ptr.* = x;
}
    {#code_end#}
    <p>
    Vectors now support comparisons, which returns a vector of {#syntax#}bool{#endsyntax#}:
    </p>
    {#code_begin|test|vector_cmp#}
const std = @import("std");
const expect = std.testing.expect;
const mem = std.mem;

test "vector comparisons" {
    var v: @Vector(4, i32) = [4]i32{ 2147483647, -2, 30, 40 };
    var x: @Vector(4, i32) = [4]i32{ 1, 2147483647, 30, 4 };
    expect(mem.eql(bool, &@as([4]bool, v == x), &[4]bool{ false, false, true, false }));
    expect(mem.eql(bool, &@as([4]bool, v != x), &[4]bool{ true, true, false, true }));
    expect(mem.eql(bool, &@as([4]bool, v < x), &[4]bool{ false, true, false, false }));
    expect(mem.eql(bool, &@as([4]bool, v > x), &[4]bool{ true, false, false, true }));
    expect(mem.eql(bool, &@as([4]bool, v <= x), &[4]bool{ false, true, true, false }));
    expect(mem.eql(bool, &@as([4]bool, v >= x), &[4]bool{ true, false, true, true }));
}
    {#code_end#}
    <p>
    Floating-point vector operations were broken; now they are fixed and no
    longer require a type parameter (#4027).
    </p>
    <p>
    Vector division is now supported, including with runtime-safety checks for integer overflow (#4737):
    </p>
    {#code_begin|test_safety|integer overflow#}
const std = @import("std");

test "vector division safety" {
    var a: @Vector(4, i16) = [_]i16{ 1, 2, -32768, 4 };
    var b: @Vector(4, i16) = [_]i16{ 1, 2, -1, 4 };
    const x = div(a, b);
    if (x[2] == 32767) return error.Whatever;
}
fn div(a: @Vector(4, i16), b: @Vector(4, i16)) @Vector(4, i16) {
    return @divTrunc(a, b);
}
    {#code_end#}
    <p>See #903 for more details.</p>
    <p>
    Thanks to Shawn Landden, data-man, and LemonBoy for contributions related to SIMD.
    </p>
    {#header_close#}

    {#header_open|@newStackCall Removed#}
    <p>
    The original purpose of {#syntax#}@newStackCall{#endsyntax#} was as an exploration
    for <a href="https://github.com/ziglang/zig/issues/1006">safe recursion</a>, but
    now the plan for safe recursion is via async functions.
    </p>
    <p>
    This plus the fact that this builtin had
    <a href="https://github.com/ziglang/zig/issues/3268">serious flaws</a>,
    it is now removed from the language.
    </p>
    <p>
    Whether this builtin will be revived before Zig 1.0 or permanently gone is yet
    to be determined. To update to Zig 0.6.0, users of this builtin will have to
    resort to inline assembly.
    </p>
    {#header_close#}

    {#header_open|@call#}
      <pre>{#syntax#}@call(options: std.builtin.CallOptions, function: var, args: var) var{#endsyntax#}</pre>
      <p>
      This new builtin calls a function, in the same way that invoking an expression with
      parentheses does, except the parameters are a {#link|tuple|Tuples Added, Var Args Removed#}:
      </p>
      {#code_begin|test|call#}
const assert = @import("std").debug.assert;

test "noinline function call" {
    assert(@call(.{}, add, .{3, 9}) == 12);
}

fn add(a: i32, b: i32) i32 {
    return a + b;
}
      {#code_end#}
      <p>
      {#syntax#}@call{#endsyntax#} allows more flexibility than normal function call syntax does. The
      {#syntax#}CallOptions{#endsyntax#} struct is reproduced here:
      </p>
      {#code_begin|syntax#}
pub const CallOptions = struct {
    modifier: Modifier = .auto,

    /// Only valid when `Modifier` is `Modifier.async_kw`.
    stack: ?[]align(std.Target.stack_align) u8 = null,

    pub const Modifier = enum {
        /// Equivalent to function call syntax.
        auto,

        /// Equivalent to async keyword used with function call syntax.
        async_kw,

        /// Prevents tail call optimization. This guarantees that the return
        /// address will point to the callsite, as opposed to the callsite's
        /// callsite. If the call is otherwise required to be tail-called
        /// or inlined, a compile error is emitted instead.
        never_tail,

        /// Guarantees that the call will not be inlined. If the call is
        /// otherwise required to be inlined, a compile error is emitted instead.
        never_inline,

        /// Asserts that the function call will not suspend. This allows a
        /// non-async function to call an async function.
        no_async,

        /// Guarantees that the call will be generated with tail call optimization.
        /// If this is not possible, a compile error is emitted instead.
        always_tail,

        /// Guarantees that the call will inlined at the callsite.
        /// If this is not possible, a compile error is emitted instead.
        always_inline,

        /// Evaluates the call at compile-time. If the call cannot be completed at
        /// compile-time, a compile error is emitted instead.
        compile_time,
    };
};
      {#code_end#}
      <p>
      The builtins <code>@noInlineCall</code> and <code>@inlineCall</code> are removed;
      instead {#syntax#}@call{#endsyntax#} supports {#syntax#}.modifier = .never_inline{#endsyntax#},
      and {#syntax#}.modifier = .always_inline{#endsyntax#}.
      </p>
      <p>
      Additionally, the {#syntax#}.never_tail{#endsyntax#} and {#syntax#}.always_tail{#endsyntax#}
      modifiers are available (#3732). These are still experimental; proper compile errors are
      not implemented to detect when these modifiers are used incorrectly.
      </p>
      <p>
      For an explanation of {#syntax#}.no_async{#endsyntax#}, see {#link|noasync#}.
      </p>
    <p>
    Thanks to LemonBoy for contributions related to this feature.
    </p>
    {#header_close#}

    {#header_open|callconv#}
    <p>
    Old syntax for a function that has the C calling convention:
    </p>
    <pre>{#syntax#}extern fn foo() void {}{#endsyntax#}</pre>
    <p>
    New syntax:
    </p>
    {#code_begin|syntax#}
fn foo() callconv(.C) void {}
    {#code_end#}
    <p>
    In Zig 0.6.0, {#link|zig fmt#} automatically transforms the old syntax to the new syntax.
    In Zig 0.7.0, it will no longer do that.
    </p>
    <p>
    Similarly the keywords {#syntax#}stdcallcc{#endsyntax#} and {#syntax#}nakedcc{#endsyntax#}
    are obsoleted by {#syntax#}callconv(.Stdcall){#endsyntax#} and {#syntax#}callconv(.Naked){#endsyntax#}.
    </p>
    <p>
    The enum that {#syntax#}callconv{#endsyntax#} takes as a parameter is defined in
    {#syntax#}std.builtin.CallingConvention{#endsyntax#}:
    </p>
    {#code_begin|syntax#}
pub const CallingConvention = enum {
    Unspecified,
    C,
    Cold,
    Naked,
    Async,
    Interrupt,
    Signal,
    Stdcall,
    Fastcall,
    Vectorcall,
    Thiscall,
    APCS,
    AAPCS,
    AAPCSVFP,
};
    {#code_end#}
    <p>
    This allows the calling convention of a function to depend on
    {#syntax#}comptime{#endsyntax#} logic, which can be useful for dealing with
    code that works differently on different architectures.
    </p>
    <p>
    Thanks to LemonBoy for implementing this.
    </p>
    {#header_close#}

    {#header_open|Non-Exhaustive Enums#}
      <p>
      A Non-exhaustive enum can be created by adding a trailing '_' field.
      It must specify an integer tag type and may not consume every enumeration value.
      </p>
      <p>
      <a href="https://ziglang.org/documentation/0.6.0/#intToEnum">@intToEnum</a>
      on a non-exhaustive enum never fails.
      </p>
      <p>
      A switch on a non-exhaustive enum can include a '_' prong as an alternative to an
      {#syntax#}else{#endsyntax#} prong
      with the difference being that it makes it a compile error if all the known tag names
      are not handled by the switch.
      </p>
      {#code_begin|test|switch_non_exhaustive_enum#}
const std = @import("std");
const assert = std.debug.assert;

const Number = enum(u8) {
    One,
    Two,
    Three,
    _,
};

test "switch on non-exhaustive enum" {
    const number = Number.One;
    const result = switch (number) {
        .One => true,
        .Two,
        .Three => false,
        _ => false,
    };
    assert(result);
    const is_one = switch (number) {
        .One => true,
        else => false,
    };
    assert(is_one);
}
      {#code_end#}
      <p>
      Non-exhaustive enums are useful for future-proofing code, so that it will
      continue to work correctly even when encountering values that were not
      present at the time the code was written.
      </p>
      <p>
      Various bits in the {#link|Standard Library#} have been updated to use
      non-exhaustive enums rather than numerical constants.
      </p>
    <p>
    Thanks to Vexu, LemonBoy, and daurnimator for contributions related to this feature.
    </p>
    {#header_close#}

    {#header_open|Unicode Character Literals#}
    {#code_begin|test|unicode_char_lit#}
const std = @import("std");

test "utf8 character literal" {
    const x = 'üí©';
    std.testing.expect(x == 128169);
}
    {#code_end#}
    <p>This makes sense because Zig is defined to have
      <a href="https://ziglang.org/documentation/0.6.0/#Source-Encoding">UTF-8 Source Encoding</a>.
      A unicode character literal is a {#syntax#}comptime_int{#endsyntax#} with the value
      equal to the code point.
    </p>
    <p>Thanks to Nick Erdmann for implementing this feature.</p>
    {#header_close#}

    {#header_open|Atomics#}
    <p>
    Thanks to {#link|Vexu|Please Welcome Vexu to the Core Zig Team#}:
    </p>
    <ul>
      <li>Atomic operations additionally support enums, bools, non-power-of-two integers, and floats.</li>
      <li>There is a new {#syntax#}@atomicStore{#endsyntax#} builtin.</li>
      <li>{#syntax#}@cmpxchgWeak{#endsyntax#}, {#syntax#}@cmpxchgStrong{#endsyntax#}, and
        {#syntax#}@atomicRmw{#endsyntax#} now support being evaluated in
        {#syntax#}comptime{#endsyntax#} code.</li>
    </ul>
    {#header_close#}

    {#header_open|Container-Level Doc Comments#}
    {#code_begin|syntax#}
//! This is a container doc comment, which applies to the
//! entire file rather than the `foo` declaration below.

/// This is a declaration doc comment, which applies to
/// the `foo` declaration below.
const foo = bar;
    {#code_end#}
    <p>Thanks Marc Tiehuis for the proposal (#2288) and
    Vexu for the implementation (#3697).</p>
    {#header_close#}

    {#header_open|Comptime Struct Fields#}
    {#code_begin|test|comptime_struct_field#}
const std = @import("std");

const Foo = struct {
    a: i32,
    comptime b: i32 = 1234,
};

test "example" {
    var foo: Foo = undefined;
    comptime std.debug.assert(foo.b == 1234);
}
    {#code_end#}
    <p>
    A comptime struct field requires a default initialization value.
    Loads from a comptime struct field result in a comptime value of the
    default initialization value.
    Stores to a comptime struct field assert that the stored value is the
    default initialization value.
    </p>
    <p>
    Generally, one should use a global const instead of a comptime field.
    The reason for using a comptime field is when you want reflection over
    struct fields to find the data as a field. For example:
    </p>
    {#code_begin|exe|csf_example#}
const std = @import("std");

fn dump(args: var) void {
    inline for (std.meta.fields(@TypeOf(args))) |field| {
        std.debug.warn("{} = {}\n", .{field.name, @field(args, field.name)});
    }
}

pub fn main() void {
    var runtime_float: f32 = 12.34;
    dump(.{
        .int = 1234,
        .float = runtime_float,
        .b = true,
        .s = "hi",
        .T = [*]f32,
    });
}
    {#code_end#}
    <p>
    This will construct an anonymous struct with all comptime fields
    (except {#syntax#}float{#endsyntax#}) and pass it to {#syntax#}dump{#endsyntax#}.
    Each iteration in the for loop will evaluate the {#syntax#}@field(...){#endsyntax#}
    expression and produce a comptime value, except {#syntax#}float{#endsyntax#}, which will
    be a runtime value.
    </p>
    <p>
    This feature makes formatted printing, and {#link|tuples|Tuples Added, Var Args Removed#}
    in general, support mixed comptime and runtime values (#3677).
    </p>
    {#header_close#}

    {#header_open|Untyped Struct Fields#}
    <p>
    It's now possible to omit the type from struct fields. This allows the field
    to have any value of any type. The catch is that it causes the entire struct
    to be required to be {#syntax#}comptime{#endsyntax#}-known.
    </p>
    {#code_begin|test|untyped_struct_fields#}
const std = @import("std");
const expect = std.testing.expect;

test "struct with var field" {
    const Point = struct {
        x: var,
        y: var,
    };
    comptime var pt = Point {
        .x = 1,
        .y = 2,
    };
    expect(pt.x == 1);
    expect(pt.y == 2);

    pt.x = true;
    pt.y = "hello";
    expect(pt.x);
    expect(std.mem.eql(u8, pt.y, "hello"));
}
    {#code_end#}
    <p>
    The motivation behind this feature is to expose default struct field initialization values
    and sentinel values in {#syntax#}@typeInfo{#endsyntax#}:
    </p>
    {#code_begin|syntax#}
pub const StructField = struct {
    name: []const u8,
    offset: ?comptime_int,
    field_type: type,
    default_value: var,
};
    {#code_end#}
    <p>
    With Zig 0.6.0, this works now:
    </p>
    {#code_begin|test|type_info_struct#}
const std = @import("std");
const expect = std.testing.expect;

test "access default initialization value" {
    const Foo = struct {
        x: i32 = 1234,
        y: i32,
    };
    const info = @typeInfo(Foo).Struct;
    expect(info.fields[0].default_value.? == 1234);
    expect(info.fields[1].default_value == null);
}
    {#code_end#}
    <p>
    Similarly, the {#syntax#}@typeInfo{#endsyntax#} for {#link|Sentinel-Terminated Pointers#}
    now exposes the sentinel value.
    </p>
    <p>
    <a href="https://github.com/ziglang/zig/issues/4820">It is planned to rename
    {#syntax#}var{#endsyntax#} to {#syntax#}anytype{#endsyntax#} in this context</a>,
    to disambiguate it from variable declarations.
    </p>
    <p>
    Thanks to LemonBoy for contributions related to this feature.
    </p>
    {#header_close#}

    {#header_open|Pointer Arithmetic and Alignment#}
    <p>
    Pointer arithmetic now appropriately modifies the alignment of a pointer type:
    </p>
    {#code_begin|test|ptr_arith_align#}
const std = @import("std");
const expect = std.testing.expect;

test "pointer math alignment" {
    var arr: [10]u8 align(4) = undefined;
    var runtime_known_2: usize = 2;

    const ptr: [*]u8 = &arr;
    const ptr2 = ptr + 1;
    const ptr3 = ptr + 2;
    const ptr4 = ptr + runtime_known_2;

    comptime {
        expect(@TypeOf(ptr) == [*]align(4) u8);
        expect(@TypeOf(ptr2) == [*]u8);
        expect(@TypeOf(ptr3) == [*]align(2) u8);
        expect(@TypeOf(ptr4) == [*]u8);
    }
}
    {#code_end#}
    <p>
    Thanks to LemonBoy for implementing this (#1528).
    </p>
    {#header_close#}

    {#header_open|@export#}
    <pre>{#syntax#}@export(target: var, comptime options: std.builtin.ExportOptions) void{#endsyntax#}</pre>
    <p>
    {#syntax#}@export{#endsyntax#} now uses {#syntax#}std.builtin.ExportOptions{#endsyntax#}
    to accept its parameters:
    </p>
    {#code_begin|syntax#}
pub const ExportOptions = struct {
    name: []const u8,
    linkage: GlobalLinkage = .Strong,
    section: ?[]const u8 = null,
};
    {#code_end#}
    <p>
    The {#syntax#}section{#endsyntax#} option is new; it is now possible to specify the
    {#syntax#}linksection{#endsyntax#} using {#syntax#}@export{#endsyntax#}.
    </p>
    <p>
    Thanks LemonBoy for implementing this (#2679).
    </p>
    {#header_close#}

    {#header_open|@bitSizeOf#}
    <pre>{#syntax#}@bitSizeOf(comptime T: type) comptime_int{#endsyntax#}</pre>
    <p>
    This function returns the number of bits it takes to store {#syntax#}T{#endsyntax#} in memory.
    The result is a target-specific compile time constant.
    </p>
    <p>
    This function measures the size allocated at runtime. For types that are disallowed at runtime,
    such as {#syntax#}comptime_int{#endsyntax#} and {#syntax#}type{#endsyntax#}, the result is
    {#syntax#}0{#endsyntax#}.
    </p>
    <p>
    Note that this value does not necessarily equal {#syntax#}@sizeOf(T) * 8{#endsyntax#}.
    For example, {#syntax#}@bitSizeOf(u7){#endsyntax#} is {#syntax#}7{#endsyntax#}, but
    {#syntax#}@sizeOf(u7){#endsyntax#} is {#syntax#}1{#endsyntax#}.
    </p>
    <p>
    When the
    <a href="https://github.com/ziglang/zig/issues/3802">accepted proposal for align(0) fields</a>
    is implemented, {#syntax#}@bitSizeOf{#endsyntax#} measures how many bits a type would take up
    in a struct if all fields were {#syntax#}align(0){#endsyntax#}.
    </p>
    <p>
    Thanks to Vexu for the implementation of this.
    </p>
    {#header_close#}

    {#header_open|No More Capture Aliasing#}
    <p>
    Captured payloads from optionals and tagged-unions are no longer aliases to
    the same memory of the optional or tagged-union. The (unwrapped) payloads are
    copies.
    </p>
    {#code_begin|test|no_capture_aliasing#}
const std = @import("std");
const expect = std.testing.expect;

test "no capture value aliasing" {
    // In Zig 0.5.0, foo() returns 5678.
    expect(foo() == 1234);
}

fn foo() i32 {
    var optional_x: ?i32 = 1234;

    if (optional_x) |x| {
        optional_x = 5678;
        return x;
    }

    unreachable;
}
    {#code_end#}
    <p>
    There are two competing proposals for non-copyable data structures:
    <a href="https://github.com/ziglang/zig/issues/3803">#3803</a>
    <a href="https://github.com/ziglang/zig/issues/3804">#3804</a>
    </p>
    <p>
    When one of these is accepted, it will be a compile error to copy some types.
    to avoid copying, one can denote the capture value to make it a pointer:
    </p>
    {#code_begin|test|capture_aliasing#}
const std = @import("std");
const expect = std.testing.expect;

test "capture value aliasing" {
    expect(foo() == 5678);
}

fn foo() i32 {
    var optional_x: ?i32 = 1234;

    if (optional_x) |*x| {
        optional_x = 5678;
        return x.*;
    }

    unreachable;
}
    {#code_end#}
    <p>
    Thanks to LemonBoy for implementing this.
    </p>
    {#header_close#}

    {#header_open|noasync#}
    <p>
    {#syntax#}noasync{#endsyntax#}, similar to {#syntax#}comptime{#endsyntax#}, creates a scope
    in which the programmer asserts there will be no suspension points.
    </p>
    <p>
    Normally, async function calls and awaiting an async function frame introduce a
    <strong>suspension point</strong> at the callsite, causing the containing function
    to have the {#syntax#}async{#endsyntax#} calling convention.
    However, inside a {#syntax#}noasync{#endsyntax#} scope, async function calls and
    awaiting async function frames do not cause a suspension point. Instead, the code
    asserts that the callee never suspends, or in the case of {#syntax#}await{#endsyntax#},
    that the function frame already has the result completed.
    </p>
    <p>
    This allows a non-async function to call an async function:
    </p>
    {#code_begin|test|noasync#}
const std = @import("std");
const expect = std.testing.expect;

test "noasync function call" {
    const result = noasync add(50, 100);
    expect(result == 150);
}

fn add(a: i32, b: i32) i32 {
    if (a > 100) {
        suspend;
    }
    return a + b;
}
    {#code_end#}
    <p>
    This is especially useful for {#syntax#}main(){#endsyntax#} to set up
    async functions initially:
    </p>
    {#code_begin|exe|async_main#}
const std = @import("std");
const expect = std.testing.expect;

var global_frame_1: anyframe = undefined;
var global_frame_2: anyframe = undefined;

pub fn main() void {
    var main_frame = async asyncMain();
    resume global_frame_1;
    resume global_frame_2;
    const result = noasync await main_frame;
    std.debug.warn("result: {}\n", .{result});
}

fn asyncMain() i32 {
    var a = async foo();
    var b = async bar();
    return await a + await b;
}

fn foo() i32 {
    global_frame_1 = @frame();
    suspend;
    return 1;
}

fn bar() i32 {
    global_frame_2 = @frame();
    suspend;
    return 2;
}
    {#code_end#}
    <p>
    Notice that the function {#syntax#}asyncMain{#endsyntax#} is able to participate in the
    async/await abstraction without having to care about the setup and teardown happening
    in {#syntax#}main{#endsyntax#}.
    </p>
    <p>
    For {#link|Async I/O#} in the {#link|Standard Library#}, Zig handles this setup and teardown
    in the {#link|Start Code#} that calls {#syntax#}main{#endsyntax#}.
    </p>
    <p>
    Now, watch what happens when we remove {#syntax#}noasync{#endsyntax#} from the above example:
    </p>
    {#code_begin|exe_build_err|oops_await#}
const std = @import("std");
const expect = std.testing.expect;

var global_frame_1: anyframe = undefined;
var global_frame_2: anyframe = undefined;

pub fn main() void {
    var main_frame = async asyncMain();
    resume global_frame_1;
    resume global_frame_2;
    const result = await main_frame;
    std.debug.warn("result: {}\n", .{result});
}

fn asyncMain() i32 {
    var a = async foo();
    var b = async bar();
    return await a + await b;
}

fn foo() i32 {
    global_frame_1 = @frame();
    suspend;
    return 1;
}

fn bar() i32 {
    global_frame_2 = @frame();
    suspend;
    return 2;
}
    {#code_end#}
    <p>
    Here, the {#syntax#}await{#endsyntax#} inside {#syntax#}main{#endsyntax#} is a
    suspension point, which causes {#syntax#}main{#endsyntax#} to have the
    async calling convention, which has a cascading effect, causing {#syntax#}_start{#endsyntax#}
    to have the async calling convention. But {#syntax#}_start{#endsyntax#} already has the
    "naked" calling convention, because it is the entry point from the kernel!
    </p>
    <p>
    We can use {#syntax#}noasync{#endsyntax#} to create a "seam" between async code and blocking
    code, because in this example, we know that {#syntax#}main_frame{#endsyntax#} has already
    completed by the time we call {#syntax#}await{#endsyntax#}.
    </p>
    <p>
    Thanks to Vexu for contributions related to this feature.
    </p>
    {#header_close#}

    {#header_open|Deprecated Builtins Removed#}
    <p>
    Many deprecated builtins have been removed.
    </p>
    <p>
    Thanks to Maciej Walczak for removing these and implementing the corresponding std lib functions:
    </p>
    <ul>
      <li>{#syntax#}@bytesToSlice{#endsyntax#} becomes {#syntax#}mem.bytesAsSlice{#endsyntax#}</li>
      <li>{#syntax#}@sliceToBytes{#endsyntax#} becomes {#syntax#}mem.sliceAsBytes{#endsyntax#}</li>
    </ul>
    <p>
    Thanks to Vexu for removing these:
    </p>
    <ul>
      <li>{#syntax#}@typeId{#endsyntax#} becomes {#syntax#}@typeInfo{#endsyntax#} tag-type</li>
      <li>{#syntax#}@memberCount{#endsyntax#} becomes {#syntax#}std.meta.fields(T).len{#endsyntax#}</li>
      <li>{#syntax#}@memberName{#endsyntax#} becomes {#syntax#}std.meta.fields(T)[i].name{#endsyntax#}</li>
      <li>{#syntax#}@memberType{#endsyntax#} becomes {#syntax#}std.meta.fields(T)[i].field_type{#endsyntax#}</li>
      <li>{#syntax#}@ArgType{#endsyntax#} becomes {#syntax#}@typeInfo(T).Fn.args[i].arg_type.?{#endsyntax#}</li>
      <li>{#syntax#}@IntType{#endsyntax#} becomes {#syntax#}std.meta.IntType{#endsyntax#}</li>
    </ul>
    {#header_close#}

    {#header_open|Allow Empty Inferred Error Sets#}
    <p>
    The body of functions returning inferred error sets are no longer required
    to return any possible errors.
    </p>
    {#code_begin|test|empty_inferred_error_set#}
fn foo() !void {}

test "" {
    foo() catch |err| switch (err) {};
}
    {#code_end#}
    <p>
    Thanks to LemonBoy for implementing this.
    </p>
    {#header_close#}

    {#header_open|@TypeOf Supports Multiple Parameters#}
    <p>
    Multiple parameters can now be specified with {#syntax#}@TypeOf{#endsyntax#} in cases where
    <a href="https://ziglang.org/documentation/0.6.0/#Peer-Type-Resolution">Peer Type Resolution</a>
    is needed.
    </p>
    {#code_begin|syntax#}
// std.math.max
pub fn max(x: var, y: var) @TypeOf(x, y) {
    return if (x > y) x else y;
}
    {#code_end#}
    <p>
    Thanks to Josh Wolfe for proposal and LemonBoy for implementing this.
    </p>
    {#header_close#}

    {#header_open|Underscore Separators in Number Literals#}
    <p>
    Underscores may be placed between two digits as a visual separator.
    Consecutive underscores are not allowed.
    </p>
    {#code_begin|syntax#}
fn digits() void {
    _ = 1_234_567;
    _ = 0xff00_00ff;
    _ = 0b10000000_10101010;
    _ = 0b1000_0000_1010_1010;
    _ = 0x123_190.109_038_018p102;
    _ = 3.14159_26535_89793;
}
    {#code_end#}
    <p>
    Thanks to Marc Tiehuis for original proposal and momumi for making a strong case
    to re-open the proposal, and for implementing it.
    </p>
    {#header_close#}

    {#header_open|Slicing with Comptime Indexes#}
    <p>
    When slicing and the length is comptime-known, the expression type is now
    a single-item pointer to array {#syntax#}*[N]T{#endsyntax#} .
    Prior to this change an error-prone {#syntax#}@ptrCast{#endsyntax#} was required.
    </p>
    {#code_begin|test|slice_comptime_indexes#}
const std = @import("std");
const assert = std.debug.assert;

test "slicing with comptime indexes" {
    var a = "abcdefgh".*;
    assert(@TypeOf(a) == [8:0]u8);

    // both indices are comptime, thus length is comptime
    var b = a[3..6];
    assert(@TypeOf(b) == *[3]u8);

    // length is runtime
    var runtime_i: usize = 3;
    var c = a[runtime_i..6];
    assert(@TypeOf(c) == []u8);

    // copy array
    a[0..3].* = a[5..8].*;
    assert(std.mem.eql(u8, &a, "fghdefgh"));
}
    {#code_end#}
    <p>
    Thanks to Jimmi Holst Christensen for proposing this.
    </p>
    {#header_close#}

    {#header_open|errdefer Payload#}
    <p>
    {#syntax#}errdefer{#endsyntax#} now provides syntax to access the in-flight error.
    </p>
    {#code_begin|test|errdefer_payload#}
const std = @import("std");

fn perform() !void {
    errdefer |err| std.debug.assert(err == error.Overflow);
    _ = try std.math.add(u8, 255, 1);
}

test "errdefer with payload" {
    perform() catch return;
    unreachable;
}
    {#code_end#}
    <p>
    Thanks to Byron Heads for the proposal and LemonBoy for implementing this.
    </p>
    <p>Follow-up proposal: <a href="https://github.com/ziglang/zig/issues/5018">errdefer with unreachable should allow function type to not have an error union</a></p>
    {#header_close#}

    {#header_close#}

    {#header_open|Standard Library#}
    <p>
    There are so many breaking changes that it is not feasible to list them all here. Instead,
    the release notes will cover contributions and high-level topics. In the future, it should
    be possible to use the same backend of {#link|Documentation Generation#} to make a tool
    that detects all API changes - additions, removals, and modifications.
    </p>
    <ul>
      <li>Various contributors updated the standard library to use newer Zig syntax, such as
      anonymous enum literals, and to fix regressions from breaking language changes.</li>
      <li>LemonBoy added support for the statx syscall.</li>
      <li>Jonathan Marler fixed accept function API.</li>
      <li>std.os.accept4: improve docs and integrate with evented I/O</li>
      <li>Jonathan Marler improved TTY detection to take into account TERM=dumb.</li>
      <li>{#syntax#}std.os.dup2{#endsyntax#} makes EBADF more obvious in stack traces.</li>
      <li>lukechampine added an AES implementation to {#syntax#}std.crypto{#endsyntax#}.
      data-man improved the code, replacing variables with constants. lukechampine
      additionally added support for AES-CTR.</li>
      <li>daurnimator updated the standard library OS bits to Linux 5.6, added missing OS bits,
        organized declarations, and swapped constants for {#link|Non-Exhaustive Enums#}.</li>
      <li>Brendan Hansknecht improved big ints to use the more efficient karatsuba algorithm
        for multiplication.</li>
      <li>daurnimator contributed LinearFifo which is useful for buffers. schroffl and Tetralux
        contributed improvements.</li>
      <li>{#syntax#}std.ChildProcess.spawn{#endsyntax#} now has a consistent error set across targets.</li>
      <li>{#syntax#}std.io.getStdOut{#endsyntax#} and related functions no longer can error.
        Thanks to the
        <a href="https://en.wikipedia.org/wiki/Process_Environment_Block">Windows Process Environment Block</a>,
        it is possible to obtain handles
      to the standard input, output, and error streams without the possibility of failure.</li>
      <li>dbandstra added {#syntax#}std.math.tau{#endsyntax#} constant (equivalent to {#syntax#}2 * pi{#endsyntax#}).</li>
      <li>Johan Bolmsj√∂ improved {#syntax#}std.testing.expectEqual{#endsyntax#} to show differing pointer values, avoiding confusion when the values pointed to are the same.</li>
      <li>{#syntax#}std.heap.direct_allocator{#endsyntax#} is renamed to {#syntax#}std.heap.page_allocator{#endsyntax#}, to make it more clear that this is not an appropriate general-purpose allocator.</li>
      <li>Benjamin Feng size-optimized the std.sort internal binary search algorithm.</li>
      <li>LemonBoy added {#syntax#}std.sort.binarySearch{#endsyntax#}. (#4337)</li>
      <li>{#syntax#}std.elf{#endsyntax#} API updated to remove redundant namespacing, and
        integrate with {#syntax#}std.Target.Arch{#endsyntax#}.</li>
      <li>Felix Quei√üner implemented {#syntax#}std.testing.expectEqual{#endsyntax#} for tagged unions. (#3773)
      </li>
      <li>{#syntax#}std.math{#endsyntax#}: remove constants that should be expressions. There were
        four cases where the value can be represented in fewer characters with
        expressions, which will be guaranteed to happen at compile-time, and
        have the same or better precision.
      </li>
      <li>Robin Voetter made improvements to {#syntax#}std.sort{#endsyntax#}:<ul>
          <li>Added {#syntax#}isSorted{#endsyntax#}.</li>
          <li>Updated {#syntax#}max{#endsyntax#} to accept const slices, and added tests.</li>
          <li>Updated {#syntax#}min{#endsyntax#} and {#syntax#}max{#endsyntax#} to return {#syntax#}?T{#endsyntax#}.</li>
          <li>Added {#syntax#}argMax{#endsyntax#} and {#syntax#}argMin{#endsyntax#} which return indexes rather than values.</li>
        </ul>
      </li>
      <li>{#syntax#}std.fmt.ParseUnsignedError{#endsyntax#} is now public.</li>
      <li>frmdstryr put in a hot path for {#syntax#}std.io.BufferedInStream.readByte{#endsyntax#},
      speeding it up by ~75% (#3858).</li>
      <li>Dynamic library loading API functions are improved to follow the standard conventions
          with regards to filename parameters.</li>
      <li>LemonBoy improved {#syntax#}std.ChildProcess{#endsyntax#} to use eventfds on Linux
        rather than pipe for communicating an error from child to parent process. (#819)</li>
      <li>Dmitry Atamanov and daurnimator improved
        {#syntax#}std.unicode.utf8ToUtf16Le{#endsyntax#} to support surrogate pairs. (#3923)</li>
      <li>daurnimator improved the performance of unicode functions. (#3987)</li>
      <li>daurnimator updated {#syntax#}std.meta.TagPayloadType{#endsyntax#} to take the tag type of the union.</li>
      <li>lukechampine implemented ChaCha20-Poly1305 AEAD. (#4011)</li>
      <li>Luna added {#syntax#}std.os.memfd_create{#endsyntax#}. (#3687)</li>
      <li>data-man added {#syntax#}std.os.getrusage{#endsyntax#}. (#3854)</li>
      <li>Nathan Michaels added removeIndex function to PriorityQueue. (#4070)</li>
      <li>Jonathan Marler added {#syntax#}std.os.windows.WaitForSingleObject{#endsyntax#}.</li>
      <li>Hersh Krishna added {#syntax#}std.math.clamp{#endsyntax#}.</li>
      <li>Shawn Landden made breaking changes to {#syntax#}std.rb{#endsyntax#} to make it thread-safe.</li>
      <li>daurnimator updated {#syntax#}std.mem.Allocator{#endsyntax#} interface to set
        memory to undefined when freed (#4087). However note that it is
        <a href="https://github.com/ziglang/zig/issues/4298">planned to revert this and implement this as part of allocator implementations rather than the interface</a>.
      </li>
      <li>LemonBoy made {#syntax#}writeByteNTimes{#endsyntax#} faster and leaner.</li>
      <li>nofmal added a basic Linux termios implementation.</li>
      <li>daurnimator added a Gimli based PRNG to {#syntax#}std.rand{#endsyntax#}, added
        gimli to the crypto hash benchmark, and added AEAD modes for Gimli. (#4369)</li>
      <li>Felix (xq) Quei√üner made {#syntax#}std.heap.ArenaAllocator.deinit{#endsyntax#} not require a mutable reference.</li>
      <li>Implement {#syntax#}std.os.faccessat{#endsyntax#} for Windows.</li>
      <li>Support the concept of a target not having a dynamic linker.</li>
      <li>Improved handling of environment variables on Windows.<ul>
          <li>
            std.os.getenv and std.os.getenvZ have nice compile errors when not linking
            libc and using Windows.
          </li>
          <li>
            std.os.getenvW is provided as a Windows-only API that does not require
            an allocator. It uses the Process Environment Block.
            std.process.getEnvVarOwned is improved to be a simple wrapper on top of
            std.os.getenvW.
          </li>
          <li>
            std.process.getEnvMap is improved to use the Process Environment Block
            rather than calling GetEnvironmentVariableW.
          </li>
          <li>
            std.zig.system.NativePaths uses process.getEnvVarOwned instead of
            std.os.getenvZ, which works on Windows as well as POSIX.
          </li>
        </ul>
      </li>
      <li>Heide Onas Auri improved {#syntax#}std.time.Timer.lap{#endsyntax#} to only
      read system time once. (#4533)</li>
      <li>{#syntax#}std.Thread.cpuCount{#endsyntax#} on Windows uses the PEB,
        rather than calling GetSystemInfo from kernel32.dll. Also remove OutOfMemory
        from the error set.</li>
      <li>Jared Miller implemented {#syntax#}std.unicode.utf8ToUtf16LeStringLiteral{#endsyntax#}
        which can be used to provide convenient "wide string literals": {#syntax#}w("foo"){#endsyntax#}
      </li>
      <li>LemonBoy added {#syntax#}std.os.fnctl{#endsyntax#}</li>
      <li>Joachim Schmidt improved bigint comparison code to use {#syntax#}math.Order{#endsyntax#} rather than {#syntax#}i8{#endsyntax#} (#4791)</li>
      <li>Ilmari Autio improved {#syntax#}std.os.getenv{#endsyntax#} and related functions to be
        ascii-case-insensitive on Windows. (#4608)</li>
      <li>joachimschmidt557 moved {#syntax#}std.big.rational.gcd{#endsyntax#} to {#syntax#}std.big.int.gcd{#endsyntax#}</li>
      <li>Phil Schumann improved {#syntax#}std.zig.parseStringLiteral{#endsyntax#} to support
        hex and unicode escapes. (#4678)</li>
      <li>
        {#syntax#}std.io.readLine{#endsyntax#} is removed.
    <br><br>
    This was deceptive. It was always meant to be sort of a "GNU readline"
    sort of thing where it provides a Command Line Interface to input text.
    However that functionality did not exist and it was basically a red
    herring for people trying to read line-delimited input from a stream.
    (See {#link|I/O Streams#} for that.)
    <br><br>
    In this commit the API is deleted, so that people can find the proper
    API more easily.
    <br><br>
    A CLI text input abstraction would be useful but may not even need to be
    in the standard library. The guess_number CLI game example gets by just
    fine by using {#syntax#}std.fs.File.read{#endsyntax#}.
      </li>
      <li>
        std.os.execvpe related functions support optionally expanding argv[0] into the absolute
        path based on the PATH environment variable. This can be useful to work around a third
        party program which improperly using argv[0] to find the path to its own executable.
      </li>
      <li>
        {#syntax#}std.os.execve{#endsyntax#} had the wrong name; it should have been
        {#syntax#}std.os.execvpe{#endsyntax#}. This is now corrected. It is also
        improved to handle {#syntax#}ENOTDIR{#endsyntax#} (#3415).
      </li>
      <li>
        Introduce {#syntax#}std.os.execveZ{#endsyntax#} which does not look at PATH, and uses
        null terminated parameters, matching POSIX ABIs. It does not require an allocator.
      </li>
      <li>
        Introduce {#syntax#}std.os.execvpeZ{#endsyntax#}, which is like {#syntax#}execvpe{#endsyntax#}
        except it uses null terminated parameters, matching POSIX ABIs, and thus
        does not require an allocator.
      </li>
      <li>
        Sebsatian Keller added std.math constants such as log2e and sqrt2.
        Note that with #425 solved these would not be needed, and would be removed.
      </li>
    </ul>

    {#header_open|Async I/O#}
    <p>
    Async I/O in 0.6.0 is still experimental, but rapidly approaching usable. 
    </p>
    <p>
    kprotty contributed significant improvements to synchronization primitives. kprotty writes:
    </p>
    <p>{#syntax#}std.Mutex{#endsyntax#} uses a simple locking scheme for Linux,
    relies on CriticalSection for Windows and falls back to spinlocking on other platforms.
    There are two parts towards improving it:</p>
    <p><strong>1) Adaptive Locking</strong></p>
    <p>
    For high contention cases, eager blocking mutexes incur a penalty of a syscall when they
    may not need to. In order to address this, the mutex can spin for a little bit trying to
    acquire the lock similar to a spinlock before deciding to block. This improves performance
    when the time spent in the critical section is minimal and acquiring/releasing is done
    frequently. The implementation chosen for this was that of lock_futex.go from Golang 1.13
    as it provides a nice balance between spinning and deciding to block (another possibility
    could be rust/webkit `parking_lot`). Because this implementation only needs a futex interface,
    it can be reused:
    </p>
    <p><strong>2) Parker API</strong></p>
    <p>
    Most synchronization primitives such as Mutexes, RwLocks, Condvars, Events and Semaphores
    can be built upon atomic instructions and futexes for handling blocking. Another point of
    this change was to setup a cross-platform futex (Parker) interface in which other primitives
    as listed above could be built off of. The default one provided is
    {#syntax#}ThreadParker{#endsyntax#} which differs from the current blocking implementation scheme:
    </p>
    <ul>
      <li>On Windows, it detects at runtime whether to use WaitOnAddress
        (supported since Win8+ and most similar to linux futex) or NT Keyed Events
        (supported since WinXP+ and is the inner backing of CriticalSection).
        This allows the distinction between std.Mutex and std.StaticallyInitializedMutex to
        dissapear as it can now be initialized statically
      </li>
      <li>On POSIX platforms, it uses {#syntax#}pthread_cond_t{#endsyntax#} for synchronization
        which also supports static initialization. This fares better for longer blocking
        critical sections compared to the spinlock default of the current std.Mutex implementation.
      </li>
      <li>On Linux, it still uses {#syntax#}linux_futex{#endsyntax#} so not many improvements
        besides adaptive spinning there
      </li>
    </ul>
    <p><strong>Results &amp; Future Implications</strong></p>
    <p>
    Because the Parker now has a standardized interface, one could replace
    {#syntax#}ThreadParker{#endsyntax#} with something like {#syntax#}AsyncParker{#endsyntax#}
    and reuse the synchronization primitive code for {#syntax#}std.event{#endsyntax#}
    synchronization objects. In order to demonstrate this, I've provided some example
    code for {#syntax#}AsyncParker{#endsyntax#} as well as a naive benchmark to test
    the performance of {#syntax#}std.Mutex{#endsyntax#} in comparison to this new adaptive
    mutex: <a href="https://github.com/kprotty/zig-adaptive-lock/">zig-adaptive-lock</a>
    </p>
    <p>
    The results for high contended, small critical section cases are promising:
    </p>
    <ul>
      <li>Windows 10: 7-8x speedup</li>
      <li>MacOSX: 19-22x speedup</li>
      <li>Linux (Pthread): 2x speedup</li>
      <li>Linux (Futex): 2x speedup</li>
    </ul>
    <p>
    These synchronization primitives are building blocks for an <strong>event loop</strong>,
    which is what drives async I/O.
    </p>
    <p>
    In 0.6.0, you can start to see the ideas behind the standard library's event loop
    coming together. Notably, {#link|Start Code#} will set up an event loop before
    calling main(), when the root source file defines:
    {#code_begin|syntax#}
pub const io_mode = .evented;
    {#code_end#}
    This means that
    <em>main() is now allowed to use {#syntax#}await{#endsyntax#}</em>.
    Same with tests, and <code>zig test</code> supports
    <code>--test-evented-io</code> which affects whether the test runner sets
    {#syntax#}io_mode{#endsyntax#} to evented or blocking.
    </p>
    <p>
    The standard library's async I/O integration, together with {#link|I/O Streams#} improvements, are
    now capable of passing behavior tests with <code>--test-evented-io</code> enabled.
    Standard library tests are now compiling successfully with evented I/O mode, but the
    event loop implementation needs to be improved in order for tests to pass. Additionally,
    "glue" code is needed to be added to the event loop implementation to support more
    operating systems. It's not quite stable enough to be added to CI {#link|Test Coverage#}.
    </p>
    <p>
    In previous versions of Zig, there was a {#syntax#}std.event{#endsyntax#} namespace for APIs
    that only applied to evented I/O, but in this release, many of these APIs have been removed,
    superceded by normal APIs integrating properly into async I/O. For example,
    {#syntax#}std.event.fs{#endsyntax#} is removed and all the normal {#syntax#}std.fs{#endsyntax#}
    ({#link|Filesystem#}) APIs work correctly for both blocking and evented I/O modes.
    </p>
    <p>
    Here is an example of a simple program that writes to a file:
    </p>
    {#code_begin|exe|write_file_blocking#}
const std = @import("std");

pub fn main() anyerror!void {
    const file = try std.fs.cwd().createFile("hello.txt", .{});
    defer file.close();

    try file.writeAll("hello\n");
}
    {#code_end#}
    <p>
    Looking at the strace, we can see it is quite simple:
    </p>
    <pre><code>arch_prctl(ARCH_SET_FS, 0x233190)       = 0
rt_sigaction(SIGSEGV, {sa_handler=0x22a8d0, sa_mask=[], sa_flags=SA_RESTORER|SA_RESTART|SA_RESETHAND|SA_SIGINFO, sa_restorer=0x204310}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
rt_sigaction(SIGILL, {sa_handler=0x22a8d0, sa_mask=[], sa_flags=SA_RESTORER|SA_RESTART|SA_RESETHAND|SA_SIGINFO, sa_restorer=0x204310}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
rt_sigaction(SIGBUS, {sa_handler=0x22a8d0, sa_mask=[], sa_flags=SA_RESTORER|SA_RESTART|SA_RESETHAND|SA_SIGINFO, sa_restorer=0x204310}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
openat(AT_FDCWD, "hello.txt", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 3
write(3, "hello\n", 6)                  = 6
close(3)                                = 0
exit_group(0)                           = ?</code></pre>
    <p>
    Set up thread-local storage, attach some signal handlers for
    {#link|debugging|Debug Info and Stack Traces#}, openat, write, close, done.
    Now we enable evented I/O:
    </p>
    {#code_begin|exe|write_file_evented#}
const std = @import("std");

pub const io_mode = .evented;

pub fn main() anyerror!void {
    const file = try std.fs.cwd().createFile("hello.txt", .{});
    defer file.close();

    try file.writeAll("hello\n");
}
    {#code_end#}
    <p>
    I can't paste the full strace output here, because it is too long, but I'll highlight some
    of the interesting parts:
    </p>
    <pre><code>clone(child_stack=0x7fe36dbdeff8, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID|0x400000strace: Process 8891 attached
, parent_tid=[8891], tls=0x7fe36dbdf028, child_tidptr=0x7fe36dbdf000) = 8891
futex(0x7fe36dbdf000, FUTEX_WAIT, 8891, NULL <unfinished ...>
[pid  8891] futex(0x260b50, FUTEX_WAIT, 0, NULL <unfinished ...>
[pid  8891] <... futex resumed>)        = 0
[pid  8891] openat(AT_FDCWD, "hello.txt", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 20
[pid  8891] epoll_ctl(18, EPOLL_CTL_ADD, 17, {EPOLLIN|EPOLLOUT|EPOLLONESHOT|EPOLLET, {u32=1841168864, u64=140614775472608}}) = 0
[pid  8891] futex(0x260b50, FUTEX_WAIT, 0, NULL <unfinished ...>
[pid  8891] <... futex resumed>)        = 0
[pid  8891] write(20, "hello\n", 6)     = 6
[pid  8891] epoll_ctl(18, EPOLL_CTL_MOD, 17, {EPOLLIN|EPOLLOUT|EPOLLONESHOT|EPOLLET, {u32=1841168864, u64=140614775472608}}) = 0
[pid  8891] futex(0x260b50, FUTEX_WAIT, 0, NULL <unfinished ...>
[pid  8891] <... futex resumed>)        = -1 EAGAIN (Resource temporarily unavailable)
[pid  8891] close(20 <unfinished ...>
[pid  8891] <... close resumed>)        = 0
[pid  8891] exit(0 <unfinished ...>
[pid  8891] <... exit resumed>)         = ?
<... futex resumed>)                    = -1 EAGAIN (Resource temporarily unavailable)
exit_group(0)                           = ?</code></pre>
    <p>
    Here we can see that a separate thread is created, which ends up doing the file system I/O.
    Some operating systems such as Linux do not have async file system support, and so the technique
    used by evented I/O libraries is to have a thread pool for doing blocking operations. In this way,
    you can make anything async by giving the task to another thread.
    </p>
    <p>
    Now that Linux has <code>io_uring</code>, this could be improved. With Zig's
    {#link|OS Version Ranges#}, the event loop code could be improved to detect if io_uring is
    within the target OS version range, and take advantage of it if so. If the minimum OS version
    is high enough, the non-io_uring code could be omitted, and if the maximum OS version is low
    enough, the io_uring code could be omitted. If the OS version range includes both, then the
    code should try io_uring, and fall back at runtime to a non-io_uring strategy.
    </p>
    <p>
    Anyway, the point here is that because evented I/O is enabled, it now becomes meaningful
    to express concurrency:
    </p>
    {#code_begin|exe|concurrent#}
const std = @import("std");

pub const io_mode = .evented;

pub fn main() anyerror!void {
    var a_frame = async doA();
    var b_frame = async doB();

    try await a_frame;
    try await b_frame;
}

fn doA() !void {
    const file = try std.fs.cwd().createFile("a.txt", .{});
    defer file.close();

    try file.writeAll("A\n");
}

fn doB() !void {
    const file = try std.fs.cwd().createFile("b.txt", .{});
    defer file.close();

    try file.writeAll("B\n");
}
    {#code_end#}
    <p>
    I'll refrain from pasting more strace output here, but now we can start to see
    things happening in parallel (depending on the OS support for async file system I/O, or
    the file system thread pool size).
    </p>
    <p>
    Finally, I want to point out one crucial point about Zig's async I/O.
    <strong>It still works if you switch back to blocking I/O</strong>:
    </p>
    {#code_begin|exe|async_blocking#}
    {#code_release_fast#}
const std = @import("std");

pub fn main() anyerror!void {
    var a_frame = async doA();
    var b_frame = async doB();

    try await a_frame;
    try await b_frame;
}

fn doA() !void {
    const file = try std.fs.cwd().createFile("a.txt", .{});
    defer file.close();

    try file.writeAll("A\n");
}

fn doB() !void {
    const file = try std.fs.cwd().createFile("b.txt", .{});
    defer file.close();

    try file.writeAll("B\n");
}
    {#code_end#}
    <p>
    This time I will show the strace since it's very short:
    </p>
    <pre><code>arch_prctl(ARCH_SET_FS, 0x203cf0)       = 0
openat(AT_FDCWD, "a.txt", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 3
write(3, "A\n", 2)                      = 2
close(3)                                = 0
openat(AT_FDCWD, "b.txt", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 3
write(3, "B\n", 2)                      = 2
close(3)                                = 0
exit_group(0)                           = ?</code></pre>
    <p>
    You can see that the async stuff folded into simple, linear, blocking code.
    </p>
    <p>
    This is a big deal. It means that Zig code can express concurrency, yet
    be reusable in both a blocking I/O and an evented I/O environment. There is no
    "async-std".
    <em>The Zig Standard Library supports both async and blocking I/O with the same codebase</em>.
    </p>
    <p>
    Thanks to Benjamin Feng, Vexu, and Timon Kruiper for contributions related to this feature.
    </p>

    {#header_close#}

    {#header_open|Debug Info and Stack Traces#}
    <p>LemonBoy made a number of improvements to Zig's debug info code:</p>
    <ul>
      <li>Fix stack iteration stop condition, and further improve the frame-walking strategy.
        The code is now stable enough not to cause panics during the call frame walking.</li>
      <li>Make the {#syntax#}leb{#endsyntax#} module available to non-std code</li>
      <li>Don't generate any type info for void return types. Closely matches what the LLVM debug emitter expects, the generated DWARF infos are now standard-compliant.</li>
      <li>Show a nice error message on SIGBUS.</li>
      <li>Support handling DWARF version 3.</li>
      <li>Properly handle multiple threads panicking at the same time. Instead of walking all
          over each other, both stack traces will be printed sequentially.</li>
    </ul>
    <p>Now, stack traces work even in release builds!</p>
    <p>Additionally, Rocknest brought Windows segfault handler code on par with POSIX. (#4319)</p>
    {#header_close#}

    {#header_open|Formatted Printing#}
    <p>TODO look at git shortlog</p>

    <p>
    Thanks to daurnimator, LemonBoy, Benjamin Feng, Felix Quei√üner, Michael Dusan,
    Nathan Michaels, data-man, frmdstryr, markfirmware, shiimizu, and vegecode for
    contributions related to this feature.
    </p>
    {#header_close#}

    {#header_open|I/O Streams#}
    TODO
commit ba0e3be5cfa2f60f2f9d2a4eb319408f972796c2
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Tue Mar 10 15:27:45 2020 -0400

    (breaking) rework stream abstractions #4710
    
    The main goal here is to make the function pointers comptime, so that we
    don't have to do the crazy stuff with async function frames.
    
    Since InStream, OutStream, and SeekableStream are already generic
    across error sets, it's not really worse to make them generic across the
    vtable as well.
    
    See #764 for the open issue acknowledging that using generics for these
    abstractions is a design flaw.
    
    See #130 for the efforts to make these abstractions non-generic.
    
    This commit also changes the OutStream API so that `write` returns
    number of bytes written, and `writeAll` is the one that loops until the
    whole buffer is written.
    {#header_close#}

    {#header_open|Filesystem#}
    <p>TODO talk about all the file system API changes</p>
    TODO Mention stratact's improvements to make directory iteration not require heap allocation.
    TODO mention sendfile support (Thanks Terin Stock for contributing initial os.zig implementation)

commit 5b1a492012241276a4b7539ca6664234f0629c79
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Sun Oct 20 21:48:23 2019 -0400

    breaking: improve std.fs directory handling API
    
     * Added `std.c.unlinkat` and `std.os.unlinkat`.
     * Removed `std.fs.MAX_BUF_BYTES` (this declaration never made it to
       master branch)
     * Added `std.fs.Dir.deleteTree` to be used on an open directory handle.
     * `std.fs.deleteTree` has better behavior for both relative and
       absolute paths. For absolute paths, it opens the base directory
       and uses that handle for subsequent operations. For relative paths,
       it does a similar strategy, using the cwd handle.
     * The error set of `std.fs.deleteTree` is improved to no longer have
       these possible errors:
       - OutOfMemory
       - FileTooBig
       - IsDir
       - DirNotEmpty
       - PathAlreadyExists
       - NoSpaceLeft
     * Added `std.fs.Dir.posix_cwd` which is a statically initialized
       directory representing the current working directory.
     * The error set of `std.Dir.open` is improved to no longer have these
       possible errors:
       - FileTooBig
       - IsDir
       - NoSpaceLeft
       - PathAlreadyExists
       - OutOfMemory
     * Added more alternative functions to `std.fs` for when the path
       parameter is a null terminated string. This can sometimes be more
       effecient on systems which have an ABI based on  null terminated
       strings.
     * Added `std.fs.Dir.openDir`, `std.fs.Dir.deleteFile`, and
       `std.fs.Dir.deleteDir` which all operate on an open directory handle.
     * `std.fs.Walker.Entry` now has a `dir` field, which can be used to do
       operations directly on `std.fs.Walker.Entry.basename`, avoiding
       `error.NameTooLong` for deeply nested paths.
     * Added more docs to `std.os.OpenError`
    
    This commit does the POSIX components for these changes. I plan to
    follow up shortly with a commit for Windows.

commit 555a2c03286507ffe4bd3bea2154dbfb719ebef1
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Thu Mar 19 14:38:21 2020 -0400

    (breaking) std.fs.copyFile now integrates with Dir
    
    Removed:
     * `std.fs.updateFile`
     * `std.fs.updateFileMode`
     * `std.fs.copyFile`
     * `std.fs.copyFileMode`
    
    Added:
     * `std.fs.Dir.copyFile`
     * `std.fs.copyFileAbsolute`
     * `std.fs.updateFileAbsolute`
    
    Moved:
     * `std.fs.Dir.UpdateFileOptions` => `std.fs.CopyFileOptions`
    
    Deprecated:
     * `std.fs.deleteDir`
     * `std.fs.deleteDirC`
     * `std.fs.deleteDirW`
     * `std.fs.readLink`
     * `std.fs.readLinkC`


commit 6ab156ce7dd781875db4965361418d8cdf4b3771
Merge: 9b1b44b41 25d9ab95d
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Mon Mar 9 13:01:26 2020 -0400

    Merge pull request #4695 from leroycep/feature-inode-stat
    
    Expose file inode number on posix and file index on windows

commit 11df0d0cf8c786d5b502c21a42d47631657a42f4
Author: LemonBoy <thatlemon@gmail.com>
Date:   Wed Mar 11 20:56:43 2020 +0100

    std: Add setEndPos to fs.file #4716
    
    Allow the user to shrink/grow the file size as needed.

commit 27affde592653ac7f92489cec404b4bf3e0d1b29
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Wed Mar 18 14:45:01 2020 -0400

    (breaking) clarify openDir API
    
     * remove deprecated `std.fs.Dir` APIs
     * `std.fs.Dir.openDir` now takes a options struct with bool fields for
       `access_sub_paths` and `iterate`. It's now much more clear how
       opening directories works.
     * fixed the std lib and various zig code calling the wrong openDir
       function.
     * the runtime safety check for dir flags is removed in favor of the
       cheaper option of putting a comment on the same line as handling
       EBADF / ACCESS_DENIED, since that will show up in stack traces.


     improvements to std.fs, std.os #4618

    add missing errors to std.os.windows.CreateDirectoryError
      TODO Ryan Liptak fixed std.fs.realpath/os.realpathW for directories on Windows.

     <p>
     Thank you to contributors Jonathan S, daurnimator, LemonBoy,
     dimenus, and stratact.
     </p>
    {#header_close#}

    {#header_open|Networking#}
    TODO explain status
commit bf16fc210bc765202489ae83e0ad1dce8d9b4e16
Author: Luna <git@l4.pm>
Date:   Sat Oct 26 22:00:50 2019 -0300

    fix std.os.accept4
    
     - add WouldBlock to list of errors in AcceptError
     - ptrCast addr_size to the system's socklen_t, instead of assuming it's
        usize



    TODO std.net.getAddressList - basic DNS address resolution for linux without libc
    std.net: port the RFC 3484/6724 destination address selection from musl libc

commit c3d816a98e1126f5de4ec1a45e5f65bb2ff2f43c
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Tue Oct 29 22:59:30 2019 -0400

    std lib networking improvements, especially non-blocking I/O
    
     * delete the std/event/net directory
     * `std.event.Loop.waitUntilFdReadable` and related functions
       no longer have possibility of failure. On Linux, they fall
       back to poll() and then fall back to sleep().
     * add some missing `noasync` decorations in `std.event.Loop`
     * redo the `std.net.Server` API. it's quite nice now, but
       shutdown does not work cleanly. There is a race condition with
       close() that I am actively working on.
     * move `std.io.OutStream` to its own file to match `std.io.InStream`.
       I started working on making `write` integrated with evented I/O,
       but it got tricky so I backed off and filed #3557. However
       I did integrate `std.os.writev` and `std.os.pwritev` with evented I/O.
     * add `std.Target.stack_align`
     * move networking tests to `lib/std/net/test.zig`
     * add `std.net.tcpConnectToHost` and `std.net.tcpConnectToAddress`.
     * rename `error.UnknownName` to `error.UnknownHostName` within the
       context of DNS resolution.
     * add `std.os.readv`, which is integrated with evented I/O.
     * `std.os.preadv`, is now integrated with evented I/O.
     * `std.os.accept4` now asserts that ENOTSOCK and EOPNOTSUPP never
        occur (misuse of API), instead of returning errors.
     * `std.os.connect` is now integrated with evented I/O.
       `std.os.connect_async` is gone. Just use `std.os.connect`.
     * fix false positive dependency loop regarding async function frames
     * add more compile notes to help when dependency loops occur
       in determining whether a function is async.
     * ir: change an assert to ir_assert to make it easier to find
       workarounds for when such an assert is triggered. In this case
       it was trying to parse an IPv4 address at comptime.
commit 0de862e8bafce9a58c1018e9b6f81b3d17279c10
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Wed Oct 30 19:27:42 2019 -0400

    make std.net more portable
    
     * Delete `std.net.TmpWinAddr`. I don't think that was ever meant to
       be a real thing.
     * Delete `std.net.OsAddress`. This abstraction was not helpful.
     * Rename `std.net.Address` to `std.net.IpAddress`. It is now an extern
       union of IPv4 and IPv6 addresses.
     * Move `std.net.parseIp4` and `std.net.parseIp6` to the
       `std.net.IpAddress` namespace. They now return `IpAddress` instead of
       `u32` and `std.net.Ip6Addr`, which is deleted.
     * Add `std.net.IpAddress.parse` which accepts a port and parses either
       an IPv4 or IPv6 address.
     * Add `std.net.IpAddress.parseExpectingFamily` which additionally
       accepts a `family` parameter.
     * `std.net.IpAddress.initIp4` and `std.net.IpAddress.initIp6` are
       improved to directly take the address fields instead of a weird
       in-between type.
     * `std.net.IpAddress.port` is renamed to `std.net.IpAddress.getPort`.
     * Added `std.net.IpAddress.setPort`.
     * `os.sockaddr` struct on all targets is improved to match the
       corresponding system struct. Previously I had made it a union of
       sockaddr_in, sockaddr_in6, and sockaddr_un. The new abstraction for
       this is now `std.net.IpAddress`.
     * `os.sockaddr` and related bits are added for Windows.
     * `os.sockaddr` and related bits now have the `zero` fields default
       to zero initialization, and `len` fields default to the correct size.
       This is enough to abstract the differences across targets, and so
       no more switch on the target OS is needed in `std.net.IpAddress`.
     * Add the missing `os.sockaddr_un` on FreeBSD and NetBSD.
     * `std.net.IpAddress.initPosix` now takes a pointer to `os.sockaddr`.

    canonicalize std.os IPPROTO constants

commit 2e0dd5733f9aec168f72167ca0a0e306b2810ae2
Author: Luna <git@l4.pm>
Date:   Sat Nov 2 16:46:48 2019 -0300

    add FileNotFound to os.ConnectError error set

commit d535bf2c7d22ff2039158bfa8d21bfb012a34c0c
Author: Luna <git@l4.pm>
Date:   Sat Nov 2 16:41:32 2019 -0300

    add FileNotFound error to os.connect

commit 9458620e18cb89b71cd0ad2755b9a7ae4f63e846
Author: Luna <git@l4.pm>
Date:   Fri Nov 8 19:59:30 2019 -0300

    replace Address.parse Address.parseIp

commit 5d05cfcfe6144a7f49f57cb376863edd0059d9ca
Author: Luna <git@l4.pm>
Date:   Fri Nov 8 19:35:04 2019 -0300

    rename IpAddress to Address, add Address.unix

commit 05ae21b78ed58e621fd2c10456a3f100a8107e3a
Author: Luna <git@l4.pm>
Date:   Sat Nov 9 12:51:33 2019 -0300

    make StreamServer.listen family-agnostic
    
     - rename Address.parseUnix to Address.initUnix

commit f4d8dc278b312fc3eccf33a37cfe89c7c012d6fd
Author: Luna <git@l4.pm>
Date:   Sat Nov 9 12:40:56 2019 -0300

    rename TcpServer -> StreamServer
    
     - add AF_UNIX support to getOsSockLen

commit 348c0232a5612eb9bdb445e80e6e201d24911dcc
Author: Luna <git@l4.pm>
Date:   Sat Nov 9 14:53:48 2019 -0300

    miscellaneous fixes
    
     - make connextUnixSocket use std.net.Address
     - fix StreamServer.listen giving wrong protocol for unix sockets

commit c8a8da28049d2e9aece857359725b2a8f6d3732b
Author: Luna <git@l4.pm>
Date:   Sun Nov 10 16:44:18 2019 -0300

    remove builtin.os check in Address.initUnix

commit d1eabe81a99c3fe6c0e551e9bab90a3bbae509fe
Author: Luna <git@l4.pm>
Date:   Sun Nov 10 14:38:33 2019 -0300

    add sockaddr_un to os/bits/windows

    Luna: std.net: add unix socket support to Address and StreamServer

commit 6e786b60d4fb3a39b717e077d034131be613d6aa
Author: Vexu <15308111+Vexu@users.noreply.github.com>
Date:   Mon Nov 4 19:54:36 2019 +0200

    support ipv4-mapped ipv6 addresses

commit 32ac1b5927ba9314b9fa0ec2bb21dba4b2e66c66
Author: Vexu <15308111+Vexu@users.noreply.github.com>
Date:   Mon Nov 4 18:59:14 2019 +0200

    improve ipv6 parsing and formatting

commit 6c1728206288264c4d2508a190d392ade68d115c
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Mon Nov 4 14:39:59 2019 -0500

    std.os.read can fail with ConnectionResetByPeer

commit a26e9fa7238e972301f761db80434fa0205d1016
Author: Vexu <15308111+Vexu@users.noreply.github.com>
Date:   Mon Nov 4 23:11:52 2019 +0200

    add special formatting for ipv4-mapped ipv6 addresses

commit aa4e92f3b3dc4b349eeabf589f8b9047e7342f03
Author: frmdstryr <frmdstryr@protonmail.com>
Date:   Mon Nov 18 08:45:25 2019 -0500

    Make StreamServer return address of accecpted client



    Luna: net: add reuse_address option to StreamServer. (#3820)


commit 778dbc17acce77588a46a27074ecb8b418786d94
Author: LemonBoy <thatlemon@gmail.com>
Date:   Tue Mar 24 19:14:01 2020 +0100

    std: Fix setsockopt definition
    
    * Add socketpair definition


     <p>
     Thank you to contributors Luna, Vexu, Jonathan Marler, Sebastian,
     and frmdstryr.
     </p>
    {#header_close#}

    {#header_open|JSON#}
commit a0abd3be85a6c24a913ee650e1fd51bf3f457c68
Author: xackus <14938807+xackus@users.noreply.github.com>
Date:   Sun Oct 27 10:45:54 2019 +0100

    fix json parser crashing on empty input
    remove unreachable code
    <ul>
      <li>Sebastian Keller added {#syntax#}std.json.WriteStream.writeJson{#endsyntax#}.</li>
      <li>Sebastian Keller fixed a leak in the json parser.</li>
      <li>Sebastian Keller: std.json.Value: added dumpStream(), utilize WriteStream for dump().</li> 
      <li>xackus improved documentation for JSON APIs, fixed unescaping of strings, as well as
      other bugs, and added more test coverage.</li> 
      <li>daurnimator improved the {#syntax#}std.json{#endsyntax#} API. (#4007)</li>
    </ul>
    TODO git audit this

    xackus: json: implement copy_strings=false (#4091)

commit 2933a8241a54af436f2df5eac73aa2acf5eabd40
Author: hryx <codroid@gmail.com>
Date:   Sun Jan 5 23:16:38 2020 -0800

    json: disallow overlong and out-of-range UTF-8
    
    Fixes #2379
    
    = Overlong (non-shortest) sequences
    
    UTF-8's unique encoding scheme allows for some Unicode codepoints
    to be represented in multiple ways. For any of these characters,
    the spec forbids all but the shortest form. These disallowed longer
    sequences are called "overlong". As an interesting side effect of
    this rule, the bytes C0 and C1 never appear in valid UTF-8.
    
    = Codepoint range
    
    UTF-8 disallows representation of codepoints beyond U+10FFFF,
    which is the highest character which can be encoded in UTF-16.
    Because a 4-byte sequence is capable of resulting in such characters,
    they must be explicitly rejected. This rule also has an interesting
    side effect, which is that bytes F5 to FF never appear.
    
    = References
    
    Detecting an overlong version of a codepoint could get gnarly, but
    luckily The Unicode Consortium did the hard work by creating this
    handy table of valid byte sequences:
    
    https://unicode.org/versions/corrigendum1.html
    
    I thought this mapped nicely to the parser's state machine, so I
    rearranged the relevant states to make use of it.

    {#header_close#}

    {#header_open|Bring-Your-Own-OS Abstraction Layer#}
commit dcbd5ad1553c5994353de47babc0e07e02153bd8
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Mon Dec 2 12:01:49 2019 -0500

    remove upstream support for Zen hobby OS
    
    The new plan to support hobby operating systems is #3784.
    
    And what kind of name is "Zen" anyway? There's already a
    [Zen programming language](http://zenlang.sourceforge.net/)
    and that's just confusing.
commit ad214c7aa00fc82b243eb38061f41588a0c58867
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Mon Dec 2 15:02:17 2019 -0500

    bring your own OS layer in the std lib
    
    closes #3784

commit 10e172b1d77619469653b0521d8f65604fa549c7
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Wed Dec 4 14:42:18 2019 -0500

    add `other` OS and fix regression in build-exe for freestanding

commit b375f6e027a159616e80906aa05e253fbe8cc9df
Author: Christine Dodrill <me@christine.website>
Date:   Wed Dec 11 18:37:52 2019 -0500

    lib/std/io: let the bring-your-own OS package handle stdio (#3887)

commit b37acc4d6870a090c3501d81d3f647bc30220e4b
Author: Christine Dodrill <me@christine.website>
Date:   Thu Dec 12 01:31:32 2019 +0000

    allow custom OS entrypoint
    
    Also:
    
     * Expose `std.start.callMain`.
     * Other fixes added to fix issues found in development.


    {#header_close#}

    {#header_open|ArrayList#}

commit c3d8b1ffebb94d180c382bd74128d17dc21c1392
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Tue Dec 10 15:08:10 2019 -0500

    remove iterator API from std.ArrayList
    
    This is not a meaningful abstraction. Use a for loop on the result
    of `toSlice` or `toSliceConst`.
    
    An iterator can be implemented on top of ArrayList by applications which
    want additional functionality, such as removing elements while
    iterating.
    
    Closes #3037.

commit 1483ae37f2dae6a5b9db1f7851cf5dc9a86e57f3
Author: Bas <BarabasGitHub@users.noreply.github.com>
Date:   Wed Feb 19 17:33:35 2020 +0100

    Add an appendValues method to ArrayList to append a value n times. (#4460)


    TODO mention deprecated API
    TODO mention std.ArrayList: make the slice field valid and public, and the capacity a separate field #4852
    TODO mention outStream()
    TODO mention daurnimator's efforts to reduce Buffer usage #4665
    TODO git shortlog for this file

    TODO Thanks xackus

    <ul>
      <li>MCRusher added {#syntax#}initCapacity{#endsyntax#} to {#syntax#}std.ArrayList{#endsyntax#} and {#syntax#}std.ArrayListSentineled{#endsyntax#}.</li>
    </ul>

    {#header_close#}

    {#header_open|Memory#}
commit 5575e2a168c07d2dcc0e58146231e490ef8a898e
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Wed Jan 1 18:08:40 2020 -0500

    std.mem.compare: breaking API changes
    
     * `std.mem.Compare` is now `std.math.Order` and the enum tags
       renamed to follow new style convention.
     * `std.mem.compare` is renamed to `std.mem.order`.
     * new function `std.math.order`

commit 0deab8fd3bba3fa25ab70f6cf2e04b234aba8eb4
Author: Timon Kruiper <timonkruiper@gmail.com>
Date:   Mon Jan 6 21:38:11 2020 +0100

    Add std.mem.zeroes to the standard library
    
    This zero initializes the type passed in. Can be used to zero
    initialize c structs.


commit 5b26128bacddf594dfe45958a236bfa2459f878b
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Sun Mar 1 13:07:55 2020 -0500

    add new functions to std.mem and deprecate others
    
    add std.mem.Span
    add std.mem.span
    add std.mem.length
    add std.mem.indexOfSentinel
    
    deprecate std.mem.len
    deprecate std.mem.toSlice
    deprecate std.mem.toSliceConst

commit ef3d761da545a3a72928ed0e0ba3b749a4cb74d8
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Sun Mar 1 13:21:29 2020 -0500

    breaking: std.mem.len no longer takes a type argument
    
    also update fmt code to use std.mem.span.

    revert std.mem.span to prefer len over sentinel; add spanZ

commit 3be720a729e20720a033f2cf1958311a0112d1f4
Author: daurnimator <quae@daurnimator.com>
Date:   Mon Mar 30 21:56:09 2020 +1100

    std: mem span functions can take an optional pointer

commit ef419dd72d3fc9ec1454099367bd8d43f1b5037b
Author: Sebastian <15335529+Sobeston@users.noreply.github.com>
Date:   Mon Mar 30 02:57:50 2020 +0100

    mem.zeroes .Array improvements
    
    Before (when given an array with many elements):
    ```
    zig\std\mem.zig:345:13: error: evaluation exceeded 1000
    backwards branches
                for (array) |*element| {
                ^
    ```
    related to https://github.com/ziglang/zig/issues/4847#issuecomment-605721461

commit cd20e0cc672249555709e1b58a415ddd50b03ad9
Author: xackus <14938807+xackus@users.noreply.github.com>
Date:   Sat Apr 4 19:15:08 2020 +0200

    rename mem.separate to mem.split

    <ul>
      <li>Bas van den Berg made {#syntax#}std.mem.zeros{#endsyntax#} support more types besides
        extern structs. (#4544)</li>
      <li>Jonathan Marler added {#syntax#}std.mem.Allocator.allocSentinel{#endsyntax#}.</li>
    </ul>
    {#header_close#}

    {#header_open|Crypto#}
    TODO find other crypto refs here


commit 4b86c1e3bbe65b8caa9c2e769af633fa8825bb94
Author: Jay Petacat <jay@jayschwa.net>
Date:   Sat Feb 1 22:29:51 2020 -0500

    crypto: Add BLAKE3 hashing algorithm (#4366)
    
    This is a translation of the [official reference implementation][1] with
    few other changes. The bad news is that the reference implementation is
    designed for simplicity and not speed, so there's a lot of room for
    performance improvement. The good news is that, according to the crypto
    benchmark, the implementation is still fast relative to the other
    hashing algorithms:
    
    ```
             md5: 430 MiB/s
            sha1: 386 MiB/s
          sha256: 191 MiB/s
          sha512: 275 MiB/s
        sha3-256: 233 MiB/s
        sha3-512: 137 MiB/s
         blake2s: 464 MiB/s
         blake2b: 526 MiB/s
          blake3: 576 MiB/s
        poly1305: 1479 MiB/s
        hmac-md5: 653 MiB/s
       hmac-sha1: 553 MiB/s
     hmac-sha256: 222 MiB/s
          x25519: 8685 exchanges/s
    ```
    
    [1]: https://github.com/BLAKE3-team/BLAKE3
    {#header_close#}

    {#header_open|Start Code#}
    <p>Logic involving startup code has been moved from being hard-coded in the compiler to
    {#syntax#}comptime{#endsyntax#} logic inside the
    <a href="https://github.com/ziglang/zig/blob/0.6.0/lib/std/start.zig">start.zig</a>
    file from the standard library.
    </p>
    <p>
    Additionally, the startup code is un-special-cased.
    </p>
    <p>
    Previously, the compiler had special logic to determine whether to
    include the startup code, which was in <code>std/special/start.zig</code>. Now,
    the file is moved to <code>std/start.zig</code>, and there is no special logic
    in the compiler. Instead, the standard library unconditionally imports
    the <code>start.zig</code> file, which then has a <code>comptime</code> block that does the
    logic of determining what, if any, start symbols to export. Instead of
    <code>start.zig</code> being in its own special package, it is just another normal
    file that is part of the standard library.
    </p>
    <p>
    <code>std.builtin.TestFn</code> is now part of the standard library rather than
    specially generated by the compiler.
    </p>
    <p>
    Additionally, some minor changes to Thread-Local Storage handling (#4807):
    </p>
    <ul>
      <li>Always allocate an info block per-thread so that libc can store important stuff there.</li>
      <li>Respect ABI-mandated alignment in more places.</li>
      <li>Nicer code, use slices/pointers instead of raw addresses whenever possible.</li>
    </ul>
    <p>Thanks to LemonBoy, Vexu, Jared Miller, and Nick Erdmann for contributions related to this.</p>
    {#header_close#}

    {#header_close#}

    {#header_open|Documentation#}
    <ul>
      <li>Language reference updated to take into account {#link|Language Changes#}.</li>
      <li>Language reference makes it more obvious that {#syntax#}if{#endsyntax#} is an expression.</li>
      <li>New section: <a href="https://ziglang.org/documentation/0.6.0/#Function-Parameter-Type-Inference">Function Parameter Type Inference</a></li>
      <li>Clarify {#syntax#}allowzero{#endsyntax#} interaction with optional pointers.</li>
      <li>Language reference has table of contents in a separate column on large displays.</li>
    </ul>
    <p>
    Thanks to Vexu, xackus, LemonBoy, data-man, Benjamin Feng, Emilio G. Cota,
    Jonathan Marler, MateuszOkulus, Matt Keeter, Maximilian Hunt, Nathan Michaels,
    Nick Erdmann, Robin Voetter, Shritesh, hryx, momumi, and yvt for contributions
    to the language reference.
    </p>

    {#header_open|Documentation Generation#}
    <p>This feature is still experimental.</p>
    <p>There is a new <code>-fdump-analysis</code> command line option, which creates
    a <code>$NAME-analysis.json</code> file with all of the finished
    semantic analysis that the stage1 compiler produced.
    It contains types, packages, declarations, and files.</p>
    <p>
    This feature can be used to power IDE integration features until such time
    as the self-hosted compiler is available and supports such features more directly.
    </p>
    <p>
    Additionally, there is a proof-of-concept documentation generation feature (#21):
    </p>
    <p>The new <code>-femit-docs</code> CLI option outputs:
    <ul>
      <li>doc/index.html</li>
      <li>doc/data.js</li>
      <li>doc/main.js</li>
    </ul>
    <p>
    In this strategy, we have 1 static html page and 1 static javascript
    file, which loads the semantic analysis dump directly and renders it
    using DOM manipulation.
    </p>
    <p>
    There is now
    <a href="https://ziglang.org/documentation/0.6.0/std/">experimental std lib documentation</a>.
    </p>
    <p>
    There are still some missing features. For example, it does not handle generic types ideally,
    multiple packages are not handled well, and some URLs are broken. Additionally, the
    <a href="https://github.com/ziglang/zig/blob/0.6.0/tools/merge_anal_dumps.zig">merge_anal_dumps tool</a>
    is not yet complete, so generated documentation can only apply to a single build configuration.
    For example, if the generated docs targeted Windows, then Linux-only functions will not be
    shown in the documentation, and vice-versa. Due to Zig's lazy analysis many declarations
    are not semantically analyzed, causing them to be omitted in the generated documentation.
    These are all open issues to be addressed.
    </p>
    <p>
    Despite the flaws it can still be a useful way to explore the {#link|Standard Library#}.
    It has motivated some contributions to improve doc comments to various APIs:
    </p>
    <ul>
      <li>Felix Quei√üner added documentation for std.fmt.format grammar and customization. (#3474)</li>
      <li>Nathan Michaels added docs for ArrayList, failing_allocator, and Allocator. (#3540)</li>
      <li>Nathan Michaels documented std.Mutex.</li>
      <li>Nathan Michaels documented PriorityQueue.</li>
      <li>Josh Wolfe added documentation for mutable HashMap KV pointers.</li>
      <li>Felix (xq) Quei√üner added documentation to {#syntax#}std.atomic.Queue{#endsyntax#}.</li>
    </ul>
    <p>
    Thank you Rocknest, Timon Kruiper, Henry Wu, Felix Quei√üner, Vexu, dtw-waleee,
    pfg, and xackus for related contributions.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|Safety#}
    TODO Resuming non-suspended functions now has runtime safety. #3469
    {#header_close#}

    {#header_open|zig build#}
    <p>
    <code>zig build</code> is still in an experimental, proof-of-concept phase, and will remain
    that way until at least the {#link|package manager|Package Manager Status#} is complete.
    Nonetheless, there were plenty of improvements to <code>zig build</code> this release cycle:
    </p>
    <p>
    The most notable changes to zig build have to do with the new {#link|Target Details#}.
    See that section for how to use the new {#syntax#}setTarget{#endsyntax#} API.
    </p>
    <p>
    One new trick that may be useful to Windows developers is to set the default target to be
    <code>native-native-gnu</code>. This will use the native
    {#link|OS and version range|OS Version Ranges#} as well as the
    {#link|native CPU|CPU Features#}, but take advantage of
    {#link|mingw-w64|mingw-w64 7.0.0#} rather than trying to integrate with system MSVC.
    This is more likely to "just work" for all your project contributors,
    because it eliminates a problematic system dependency.
    </p>
    <p>
    Additionally the following improvements were made:
    </p>
    <ul>
      <li>Bumped default max exec output size to 400 KB. (#3415)</li>
      <li>{#syntax#}addIncludeDir{#endsyntax#} does <code>-I</code> instead of <code>-isystem</code>.</li>
      <li>Initial support for using vcpkg libraries. However it is
        <a href="https://github.com/ziglang/zig/issues/4510">not integrated automatically yet</a>.</li>
      <li>Fixed failure to recognize the PATH environment variable due to
          incorrectly treating the environment variable as case sensitive on Windows.</li>
      <li>Rework and improve some of the zig build steps<ul>
          <li> RunStep gains ability to compare
       output and exit code against expected values. Multiple redundant
       locations in the test harness code are replaced to use RunStep.</li>
       <li> WriteFileStep gains
       ability to write more than one file into the cache directory, for
       when the files need to be relative to each other. This makes
       usage of WriteFileStep no longer problematic when parallelizing
       zig build.</li>
       <li> Added CheckFileStep, which can be used to validate that the output
       of another step produced a valid file. Multiple redundant locations
       in the test harness code are replaced to use CheckFileStep.</li>
       <li> Added TranslateCStep. This exposes zig translate-c to the build
       system, which is likely to be rarely useful by most Zig users;
       however Zig's own test suite uses it both for translate-c tests and
       for run-translated-c tests.</li>
       <li> Refactored ad-hoc code to handle source files coming from multiple
         kinds of sources, into std.build.FileSource.</li>
       <li> Added std.build.Builder.addExecutableFromWriteFileStep.</li>
       <li> Added std.build.Builder.addExecutableSource.</li>
       <li> Added std.build.Builder.addWriteFiles.</li>
       <li> Added std.build.Builder.addTranslateC.</li>
       <li> Added std.build.LibExeObjStep.addCSourceFileSource.</li>
       <li> Added std.build.LibExeObjStep.addAssemblyFileFromWriteFileStep.</li>
       <li> Added std.build.LibExeObjStep.addAssemblyFileSource.</li>
      </ul></li>
      <li><code>--</code> can be used to pass args to zig build commands.</li>
      <li><code>-D</code> now supports "list" type options.</li>
      <li>Nesting package dependencies is now supported.</li>
      <li>InstallRawStep is available to do a similar job to objcopy. It can be
        used with {#syntax#}exe.installRaw("kernel.bin");{#endsyntax#} where exe is a LibExeObjStep. (#2826)</li>
      <li>zig build now correctly handles multiple output artifacts (#4733, #4735)<br>
    Previously the zig build system incorrectly assumed that the only build
    artifact was a binary. Now, when you enable the cache, only the output
    dir is printed to stdout, and the zig build system iterates over the
    files in that directory, copying them to the output directory.</li>
      <li>-ffunction-sections switch exposed to zig build scripts.</li>
      <li>The default stdin behavior of RunStep is now .Inherit. Since this is a breaking change,
        previous behavior can be restored by doing: {#syntax#}RunStep.stdin_behavior = .Ignore{#endsyntax#}.</li>
      <li>Configuring the subsystem is exposed to build scripts.</li>
    </ul>
    <p>
    Thanks to Benjamin Feng, David Cao, Layne Gustafson, LemonBoy, Michael Dusan,
    Micha√´l Larouche, Nick Erdmann, Noam Preil, Sahnvour, Timon Kruiper,
    Valentin Anger, dbandstra, emekoi, frmdstryr, meme, mogud, pwzk, stratact,
    syscall0, and xackus for related contributions.
    </p>
    {#header_close#}

    {#header_open|zig fmt#}
    <p>
    In this release, <code>zig fmt</code> performs a few automatic syntax upgrades for you,
    for example, renaming {#syntax#}@typeOf{#endsyntax#} to {#syntax#}@TypeOf{#endsyntax#},
    as well as updating to the new {#link|callconv#} syntax.
    </p>
    <ul>
      <li>Updates to support {#link|Language Changes#}.</li>
      <li>Trailing comma is respected for builtin calls, field declarations, and error set declarations.</li>
      <li>Handle declarations in line with the opening brace.</li>
      <li>Allow single newline before doc comments.</li>
    </ul>
    <p>
    Thanks to LemonBoy, Vexu, Robin Voetter, Brendan Hansknecht, Michael Raymond, and xackus
    for contributions to <code>zig fmt</code>.
    </p>
    {#header_close#}

    {#header_open|zig cc#}
    <p>
    Many people discovered this feature from the blog post,
    <a href="https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html">`zig cc`: a Powerful Drop-In Replacement for GCC/Clang</a>.
    </p>
    <p>
    In summary, since Zig links against libclang, Zig has the ability
    to act as a C compiler. And since Zig ships with {#link|libc#}, it has the ability to act as a
    cross-compiling C compiler. <a href="https://ziglang.org/download/0.4.0/release-notes.html#Zig-is-also-a-C-Compiler">This feature has been available since 0.4.0</a>, however, what's new is the
    sub-command, <code>zig cc</code>, which has the ability to parse C compiler flags.
    </p>
    <p>
    In this release, <code>zig cc</code> has full compatibility with
    <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">Clang's command line options</a>.
    Clang is not invoked directly; some components are replaced with Zig's own.
    For example, Zig provides all the include paths for libc, and acts as the linker driver.
    Zig translates the semantics of the arguments to its own internal build logic.
    Clang options that Zig is not aware of are forwarded to Clang directly.
    Some parameters are handled specially.
    </p>
    <p>
    Since the writing of the blog post a few weeks ago, this feature has been further improved
    with more flag integration, as well as the ability to provide <code>-lc++</code>.
    The sub-command <code>zig c++</code> is added for convenience.
    </p>
    <p>
    Yes, that's right, <strong>Zig now acts as a C++ cross-compiler as well</strong>.
    </p>
    <p class="file">hello.cpp</p>
    <pre><code>#include &lt;iostream&gt;

int main() {
    std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl;
    return 0;
}</code></pre>
    <p>My host is currently x86-64 linux, but I'll build it for {#link|Windows|Windows Support#}
    as well as
    {#link|RISC-V|RISC-V Support#}:</p>
<pre><code>$ zig c++ -o hello hello.cpp -lc
$ ./hello
Hello World!
$ zig c++ -o hello hello.cpp -lc -target x86_64-windows-gnu
$ wine64 hello.exe
Hello World!
$ zig c++ -o hello hello.cpp -lc -target riscv64-linux
$ qemu-riscv64 ./hello
Hello World!</code></pre>
    <p>
    Thanks to this new ability, Zig is now able to {#link|bootstrap itself|Bootstrap Tarball#}.
    Bootstrapping is not to be confused with {#link|self-hosting|Self-Hosted Compiler Progress#}.
    </p>
    <p>
    I forgot to mention in the blog post, when you don't pass any optimization flags to
    <code>zig cc</code>, Zig determines that
    <a href="https://ziglang.org/documentation/0.6.0/#Debug">Debug Mode</a> is appropriate,
    and enables <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">Clang's UBSAN</a>.
    </p>
    <p>
    People are finding out now that their C code has undefined behavior: #4830 #4965
    </p>
    <p>
    zig cc is intentionally an interface to the Zig compiler, a bit higher level than using Clang
    directly.
    With no optimization flags specified, zig cc infers debug mode.
    As you know from writing Zig code, debug mode has safety checks to prevent undefined behavior
    at runtime. This applies for C code as well, taking advantage of clang's UBSAN.
    The fact that debug mode is "default" is entirely intentional.
    I expect this to identify many bugs in existing codebases as people use zig cc out of
    convenience or curiosity and their code gets vetted by UBSAN for the first time.
    </p>
    <p>
    Note that the presence of -O2,-O3 will cause zig to select release-fast,
    -Os will cause zig to select release-small, and optimization flags plus
    -fsanitize=undefined will cause zig to select release-safe.
    </p>
    <p>
    I wrote a FAQ entry so that people can easily link to it to help explain when this situation
    comes up:
    <a href="https://github.com/ziglang/zig/wiki/FAQ#why-do-i-get-illegal-instruction-when-using-with-zig-cc-to-build-c-code">Why do I get illegal instruction when using with zig cc to build C code?</a>
    </p>
    <p>
    So - is it production ready?
    </p>
    <p>As long as you are aware of
    <a href="https://github.com/ziglang/zig/labels/zig%20cc">the open issues</a>,
    and you have tested <code>zig cc</code> for your use case, and it successfully builds
    your project, then it should be safe to use <code>zig cc</code> with 0.6.0.
    It's not expected for this feature to change much; it is already very nearly in its
    final form.
    </p>
    <p>
    However, this is not a guarantee. Until Zig 1.0, the project
    reserves the right to make breaking changes as necessary.
    </p>
    <p>
    <a href="https://github.com/nim-lang/Nim/pull/13757">Nim has added zig cc as one of the C compiler backend options</a>.
    </p>
    <p>
    Thank you to Michael Dusan and Ryan Liptak for contributions related to this feature.
    </p>
    {#header_close#}

    {#header_open|libc#}
    <p>Because cross-compiling is a first-class use case, Zig provides libc whenever possible, rather
    than depending on the host libc.</p>

    {#header_open|musl 1.2.0#}
    <p>
    Zig ships with the source code to <a href="https://www.musl-libc.org/">musl</a>.
    When the musl C ABI is selected, Zig builds musl from source for the selected target.
    </p>
    <p>
    This release updates the bundled musl source code to
    <a href="https://musl.libc.org/releases.html">v1.2.0</a>.
    </p>
    <p>
    With this release, Zig no longer has any patches against upstream.
    </p>
    {#header_close#}

    {#header_open|glibc 2.31#}
    <p>
    Zig gains the ability to target
    <a href="https://sourceware.org/legacy-ml/libc-announce/2020/msg00001.html">glibc 2.31</a>
    in addition to the other 41 glibc versions.
    </p>
    <p>
    In this release, Zig's glibc support is improved to additionally provide <code>-lutil</code>
    and symbols provided by the dynamic linker. (#4748)
    </p>
    {#header_close#}

    {#header_open|mingw-w64 7.0.0#}
    <p>
    Zig ships with the source code to <a href="https://mingw-w64.org/">mingw-w64</a>.
    When targeting *-windows-gnu and linking against libc, Zig builds mingw-w64 from source
    for the selected target.
    </p>
    <p>
    This release updates the bundled mingw-w64 source code to
    <a href="https://sourceforge.net/p/mingw-w64/mailman/message/36804945/">v7.0.0</a>.
    </p>
    <p>Additionally:</p>
    <ul>
      <li>Linking is now aware -lm is provided by mingw-w64.</li>
      <li>Zig additionally provides -lpsapi, -luuid, and -lshlwapi. (#3711)</li>
    </ul>
    {#header_close#}
    {#header_close#}

    {#header_open|C Translation#}
    <p>
    During this release cycle, all of the Clang C++ API that Zig's translate-c feature relies on
    has been extracted into:
    </p>
    <ul>
      <li><code>zig_clang.h</code> (C)</li>
      <li><code>zig_clang.cpp</code> (C++)</li>
    </ul>
    <p>
    Next, <code>zig_clang.zig</code> was added to match the zig_clang.h C ABI.
    </p>
    <p>
    Once translate_c.cpp was fully updated to use zig_clang.h instead of the C++ includes,
    compilation of that source file went from 5 seconds to 0.5 seconds.
    </p>
    <p>
    At this point the self-hosting effort began. I started
    <code>src-self-hosted/translate-c.zig</code> and hooked up the translate-c test suite
    to support adding cases that are intended to pass in the new implementation.
    </p>
    <p>
    Slowly the contributions started coming in and gradually improving self-hosted translate-c,
    and it started passing more and more test cases.
    </p>
    <p>
    After a few individual contributions,
    {#link|Vexu|Please Welcome Vexu to the Core Zig Team#} got the hang of things, and
    <em>finished the entire self-hosted implementation of translate-c</em>,
    ultimately deleting the 5,000 line C++ implementation in one final blow.
    </p>
    <p>
    All the previous test cases pass now, plus new ones, and there is even a new kind
    of test, <code>zig build test-run-translated-c</code>, which attempts to compile and
    run the Zig code that was translated from C code.
    </p>
    <p>
    Vexu didn't stop there. He implemented a full C tokenizer and a partial C AST parser,
    which are both now available in the
    {#link|Standard Library#} in the {#syntax#}std.c{#endsyntax#} namespace. As a result,
    Zig's support for macro translation is much improved in 0.6.0.
    </p>
    <p>
    This is as big deal for {#link|Self-Hosted Compiler Progress#}, because it means that
    contributions to Zig's translate-c feature apply not only to the stage1 compiler, but
    to the (incomplete) self-hosted compiler as well.
    </p>
    <p>
    I won't list translate-c improvements or bug fixes because they are too numerous, but
    the following things stick out:
    </p>
    <ul>
      <li>There is now a {#link|zig build#} step for translate-c.</li>
      <li>{#syntax#}@cImport{#endsyntax#} now automatically caches results, so subsequent builds are fast.</li>
      <li>There is now an <a href="https://github.com/ziglang/zig/blob/0.6.0/CONTRIBUTING.md#improving-translate-c">Improving Translate-C</a>
        section in CONTRIBUTING.md, to help contributors get started.</li>
    </ul>
    <p>
    Additional thanks to LemonBoy, Merlyn Morgan-Graham, Feix Weiglhofer,
    Josh Wolfe, Lachlan Easton, Layne Gustafson, Michael Dusan, Rocknest,
    Tadeo Kondrak, frmdstryr, travisstaloch, and via for contributions
    related to this feature.
    </p>

    {#header_close#}

    {#header_open|Self-Hosted Compiler Progress#}
    <p>
    Although there has been no progress during this release cycle directly on
    self-hosted semantic analysis and code generation, there has been significant
    progress towards self-hosting in other areas:
    </p>
    <ul>
      <li>{#link|C Translation#} is now self-hosted. To be clear, it still uses
        libclang to parse C code, however, 5,000 lines of C++ code were deleted
        in favor of a zig implementation.
      </li>
      <li><code>zig targets</code> is now self-hosted, and outputs JSON.</li>
      <li>Native system {#link|libc#} detection is now self-hosted.</li>
      <li>Native system dynamic linker detection is now self-hosted.</li>
      <li>Native system include search path detection is now self-hosted.</li>
      <li>Native system {#link|CPU Features#} detection is now self-hosted for x86
        (<a href="https://github.com/ziglang/zig/issues/4591">contributions welcome for other architectures</a>).</li>
    </ul>
    <p>
    More and more of the compiler is moving to be implemented in Zig rather than in C++.
    The C++ percent is shrinking and Zig percent is increasing. However,
    {#link|bootstrapping|Bootstrap Tarball#} remains forever a fixed, four-step process.
    </p>
    {#header_close#}

    {#header_open|compiler-rt#}
    <p>
    compiler-rt is the library that provides, for example, 64-bit integer multiplication for
    32-bit architectures which do not have a machine code instruction for it.
    In the <a href="https://gcc.gnu.org/">GNU</a> world, it's called libgcc.
    </p>
    <p>
    Unlike most compilers, which depend on a binary build of compiler-rt being installed alongside
    the compiler, Zig builds compiler-rt on-the-fly, from source, as needed for the target platform.
    This release saw some improvements to Zig's compiler-rt implementation.
    </p>
    <p>
    LemonBoy spent two days on an epic bug sleuthing quest, which was only reproducible
    inside docker, on AArch64, and finally managed to
    <a href="https://github.com/ziglang/zig/pull/4832">solve the problem</a>.
    An unrelated change to compiler-rt had exposed a latent bug, where
    {#syntax#}__floatunditf{#endsyntax#} was accidentally defined with
    parameter type {#syntax#}u128{#endsyntax#} rather than {#syntax#}u64{#endsyntax#}.
    Typos on the ABI boundary are especially nasty!
    </p>
    <p>In addition to that, LemonBoy contributed most of the improvements to compiler-rt
    during this release cycle.</p>
    <ul>
      <li>compiler_rt and freestanding libc are always built with optimizations, even
      when used by Debug Mode Zig code.</li>
      <li>Fix __stack_chk_guard emitted even when not linking libc.</li>
      <li>Add __clzsi2 - it is required for using std.fmt.format on some ARM architecture.</li>
      <li>Add clear_cache for aarch64, arm32-linux, and more.</li>
      <li>Remove x86/Windows name mangling hack</li>
      <li>Fix stack-probe symbol redefinition</li>
      <li>Add more compiler-rt functions for ARM platform</li>
      <li>Use the correct calling convention for AEABI intrinsics</li>
      <li>Fix div builtins to use the correct calling convention</li>
      <li>Remove useless wrappers around f32/f64 aeabi builtins</li>
      <li>Export MSVC builtins unconditionally</li>
      <li>Port __mulsi3 builtin</li>
      <li>Export the AEABI builtins when targeting thumb</li>
      <li>Add __divtf3</li>
      <li>Fix __floatunditf</li>
      <li>Implement all the shift builtins</li>
      <li>Add the __atomic family of builtins</li>
      <li>Separate max size allowed for load/store and CAS</li>
    </ul>
    <p>
    With Zig 0.6.0, compiler-rt is much more complete, but not fully. There are some
    <a href="https://github.com/ziglang/zig/issues/1290">missing functions</a>,
    and it's planned to do <a href="https://github.com/ziglang/zig/issues/1504">an audit</a>
    before 1.0.
    </p>
    <p>
    Additional thanks to Michael Dusan, daurnimator, Micha√´l Larouche, and Timon Kruiper
    for related contributions.
    </p>
    {#header_close#}

    {#header_open|Test Coverage#}
    <p>TODO</p>
    <p>TODO during this release cycle zig gained aarch64 test coverage</p>
    TODO note that many bugs were discovered to have been fixed on accident, and
    regression test cases were added for them.

    mention run-translated-c tests


commit 4d134a01f5a8baae346783f19d9b5db8c8256d32
Author: Benjamin Feng <benjamin.feng@glassdoor.com>
Date:   Wed Jan 29 12:21:29 2020 -0600

    Move debug.global_allocator to testing.allocator

    note about std.testing.allocator and how it leak checks and stuff
    it found leaks in std and he fixed them

    daurnimator helped migrate more tests to use testing allocator


commit 058f38220afecb96d115143f8888496162029aed
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Thu Feb 13 16:56:26 2020 -0500

    enable passing freebsd tests
    
    See #3210 and #4455

commit 64365bc5d7b1e2c507806ee8976acc3479ad7862
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Mon Feb 17 00:06:19 2020 -0500

    enable behavior and std lib tests for RISC-V 64-bit
    
    closes #3338


commit c70471fae617fb91ca0a323f079574a3caaa7775
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Sun Mar 29 10:33:37 2020 -0400

    enable now-passing test cases
    
    These can now be enabled thanks to bug fixes that landed in
    LLVM 10.


      <p>Michael Dusan figured out how to produce a static binary tarball of QEMU, allowing
        the CI server to use a newer QEMU version, allowing more test coverage of SIMD.</p>

    {#header_close#}

    {#header_open|Memory Usage Reduction#}
    <p>
    The large portion of Zig compiler that is (currently) implemented in C++ is memory
    hungry and our continuous-integration process exacerbates the issue to the point
    where the RAM/VRAM sizes of open-source CI providers are sometimes insufficient.
    Additionally as we add more features and tests, yet more memory pressure is applied.
    </p>
    <p>
    The following bits are related to reducing the max RSS footprint of the compiler.
    Implementations by Andrew Kelley (ak) and Michael Dusan (md).
    </p>
    <ul>
      <li>(ak)
        Zig driver built with <code>-DZIG_ENABLE_MEM_PROFILE</code> accepts
        command-line option -fmem-report to produce a list of objects
        allocated by compiler code. Some useful invocations:
        <ul>
            <li><code>./zig test ../lib/std/std.zig --cache off -fmem-report</code></code></li>
            <li><code>/usr/bin/time -v ./zig test ../lib/std/std.zig --cache off -fmem-report</code></li>
        </ul>
        Reduce the size of <code>IrInstruction</code> by 8 bytes on 64 bit targets.
        (#3482) RSS savings of ~3%
      </li>
      <li>(md)
        Unembed <code>ZigValue</code> from <code>IrInstruction</code>.
        Add const interning for 1-possible-value types.
        (#3502) RSS savings of ~6%
      </li>
      <li>(ak)
        Sometimes free stuff from Zig IR pass 1.
        RSS savings of ~6%
      </li>
      <li>(ak)
        Inline <code>ConstGlobalRefs</code> into <code>ZigValue</code>.
        (#3817) RSS savings of ~1.1%
      </li>
      <li>(ak)
        Free <code>IrAnalyze</code> sometimes.
        RSS savings of ~1%
      </li>
      <li>(ak)
        Split <code>IrInstruction</code> into <code>IrInst</code>, <code>IrInstSrc</code>, <code>IrInstGen</code>.
        This makes it so that less memory is used for IR instructions, as well
        as catching bugs when one expected one kind of instruction and received
        the other.
        (#4290)
      </li>
      <li>(md)
        Overhaul C++ memory allocation:
        <ul>
          <li>new <code>mem::Allocator</code> interface</li>
          <li>new <code>heap::CAllocator</code> impl with global <code>heap::c_allocator</code></li>
          <li>new <code>heap::ArenaAllocator</code> impl</li>
          <li>new <code>mem::List</code> takes explicit <code>Allocator&</code> parameter</li>
          <li>new <code>mem::HashMap</code> takes explicit <code>Allocator&</code> parameter</li>
          <li>add <code>Codegen.pass1_arena</code> and use for all <code>ZigValue</code> allocs</li>
          <li>deinit <code>Codegen.pass1_arena</code> early in <code>zig_llvm_emit_output()</code></li>
        </ul>
        (#4389) RSS savings of ~13-15%
      </li>
      <li>(md)
        Free more heap after analysis.
        (#4515) RSS savings of ~5.5-6.3%
      </li>
    </ul>
    <p>
    The main goal of memory usage reduction is to ensure that
    {#link|bootstrapping|Bootstrap Tarball#} takes 3.5 GiB or less
    on the host system (<a href="https://github.com/ziglang/zig/issues/471">#471</a>).
    </p>
    {#header_close#}

    {#header_open|Advanced IR Debugging#}
    Andrew added native-debug helper functions for the Zig compiler.
    <p>
    Print triplet of (source:line:col) by calling member function <code>src()</code> for types
    <code>IrExecutable{Src,Gen}</code>,
    <code>AstNode</code>,
    <code>IrInst</code>,
    <code>IrInst{Src,Gen}</code> .
    </p>
    <p>
    Dump IR segment by calling member function <code>dump()</code> for types
    <code>IrExecutable{Src,Gen}</code>,
    <code>AstNode</code>,
    <code>IrInst</code>,
    <code>IrInst{Src,Gen}</code> .
    </p>
    <p>
    Dump <code>ZigValue</code> type-as-string by calling member function <code>Dump</code> .
    </p>
    <p>
    When <code>--verbose-ir</code> is enabled,
    call <code>dbg_ir_break(src_file_zig, line)</code> to breakpoint inside <code>ir_analyze()</code> .
    </p>
    <p>
    Call <code>dbg_ir_clear()</code> to clear all breakpoints.
    </p>
    {#header_close#}

    {#header_open|Command Line Interface#}
    <p><strong>Added:</strong></p>
    <ul>
      <li><code>--eh-frame-hdr</code> - enable C++ exception handling by passing --eh-frame-hdr to link</li>
      <li><code>-fsanitize-c</code> - enable C undefined behavior detection in unsafe builds</li>
      <li><code>-fno-sanitize-c</code> - disable C undefined behavior detection in safe builds</li>
      <li><code>-fmem-report</code> - print {#link|memory usage|Memory Usage Reduction#} diagnostics</li>
      <li><code>-fdump-analysis</code> - write analysis.json file with type information</li>
      <li><code>-femit-docs</code> - create a docs/ dir with {#link|html documentation|Documentation Generation#}</li>
      <li><code>-fno-emit-docs</code> - do not produce docs/ dir with html documentation</li>
      <li><code>-femit-bin</code> - (default) output machine code</li>
      <li><code>-fno-emit-bin</code> - do not output machine code</li>
      <li><code>-femit-asm</code> - output .s (assembly code)</li>
      <li><code>-fno-emit-asm</code> - (default) do not output .s (assembly code)</li>
      <li><code>-femit-llvm-ir</code> - produce a .ll file with LLVM IR</li>
      <li><code>-fno-emit-llvm-ir</code> - (default) do not produce a .ll file with LLVM IR</li>
      <li><code>-femit-h</code> -  generate a C header file (.h)</li>
      <li><code>-fno-emit-h</code> - (default) do not generate a C header file (.h)</li>
      <li><code>--verbose-llvm-cpu-features</code> - enable compiler debug output for LLVM CPU features</li>
      <li><code>-I[dir]</code> - add directory to include search path</li>
      <li><code>-mcpu [cpu]</code> - specify {#link|target CPU and feature set|CPU Features#}</li>
      <li><code>-code-model [default|tiny|small|kernel|medium|large]</code> - set target code model</li>
      <li><code>--test-evented-io</code> - runs the test in {#link|evented I/O mode|Async I/O#}</li>
    </ul>
    <p><strong>Removed:</strong></p>
    <ul>
      <li><code>-target-glibc [version]</code> - now specified as part of {#link|target triple|Target Details#}</li>
      <li><code>-mios-version-min [ver]</code> - obsoleted by {#link|OS Version Ranges#}</li>
      <li><code>-mmacosx-version-min [ver]</code> - obsoleted by {#link|OS Version Ranges#}</li>
    </ul>
    <p><strong>Deprecated:</strong></p>
    <ul>
      <li><code>--emit [asm|bin|llvm-ir]</code> - prefer the new -femit-* or -fno-emit* options above.</li>
    </ul>
    <p>This will be removed once <a href="https://godbolt.org/">Compiler Explorer</a>
    updates to the new CLI.</p>
    <p>
    The command line interface now supports detecting native system headers and libraries
    (include/ and lib/ search paths). The implementation of this is {#link|self-hosted|Self-Hosted Compiler Progress#} (#2041).
    </p>
    <p>The error output is improved when an invalid CPU model or CPU feature is specified:</p>
    <pre><code>andy@ark ~&gt; zig build-exe hello.zig -mcpu=bogus
Unknown CPU: 'bogus'
Available CPUs for architecture 'x86_64':
 amdfam10
 athlon
 athlon_4
 athlon_fx
 athlon_mp
 athlon_tbird
 athlon_xp
 athlon64
 athlon64_sse3
 atom
 barcelona
 bdver1
 bdver2
 bdver3
 bdver4
 bonnell
 broadwell
 btver1
 btver2
 c3
 c3_2
 cannonlake
 cascadelake
 cooperlake
 core_avx_i
 core_avx2
 core2
 corei7
 corei7_avx
 generic
 geode
 goldmont
 goldmont_plus
 haswell
 _i386
 _i486
 _i586
 _i686
 icelake_client
 icelake_server
 ivybridge
 k6
 k6_2
 k6_3
 k8
 k8_sse3
 knl
 knm
 lakemont
 nehalem
 nocona
 opteron
 opteron_sse3
 penryn
 pentium
 pentium_m
 pentium_mmx
 pentium2
 pentium3
 pentium3m
 pentium4
 pentium4m
 pentiumpro
 prescott
 sandybridge
 silvermont
 skx
 skylake
 skylake_avx512
 slm
 tigerlake
 tremont
 westmere
 winchip_c6
 winchip2
 x86_64
 yonah
 znver1
 znver2
andy@ark ~&gt; zig build-exe hello.zig -mcpu=x86_64+bogus
Unknown CPU feature: 'bogus'
Available CPU features for architecture 'x86_64':
 3dnow: Enable 3DNow! instructions
 3dnowa: Enable 3DNow! Athlon instructions
 64bit: Support 64-bit instructions
 adx: Support ADX instructions
 aes: Enable AES instructions
 avx: Enable AVX instructions
 avx2: Enable AVX2 instructions
 avx512bf16: Support bfloat16 floating point
 avx512bitalg: Enable AVX-512 Bit Algorithms
 avx512bw: Enable AVX-512 Byte and Word Instructions
 avx512cd: Enable AVX-512 Conflict Detection Instructions
 avx512dq: Enable AVX-512 Doubleword and Quadword Instructions
 avx512er: Enable AVX-512 Exponential and Reciprocal Instructions
 avx512f: Enable AVX-512 instructions
 avx512ifma: Enable AVX-512 Integer Fused Multiple-Add
 avx512pf: Enable AVX-512 PreFetch Instructions
 avx512vbmi: Enable AVX-512 Vector Byte Manipulation Instructions
 avx512vbmi2: Enable AVX-512 further Vector Byte Manipulation Instructions
 avx512vl: Enable AVX-512 Vector Length eXtensions
 avx512vnni: Enable AVX-512 Vector Neural Network Instructions
 avx512vp2intersect: Enable AVX-512 vp2intersect
 avx512vpopcntdq: Enable AVX-512 Population Count Instructions
 bmi: Support BMI instructions
 bmi2: Support BMI2 instructions
 branchfusion: CMP/TEST can be fused with conditional branches
 cldemote: Enable Cache Demote
 clflushopt: Flush A Cache Line Optimized
 clwb: Cache Line Write Back
 clzero: Enable Cache Line Zero
 cmov: Enable conditional move instructions
 cx16: 64-bit with cmpxchg16b
 cx8: Support CMPXCHG8B instructions
 enqcmd: Has ENQCMD instructions
 ermsb: REP MOVS/STOS are fast
 f16c: Support 16-bit floating point conversion instructions
 false_deps_lzcnt_tzcnt: LZCNT/TZCNT have a false dependency on dest register
 false_deps_popcnt: POPCNT has a false dependency on dest register
 fast_11bytenop: Target can quickly decode up to 11 byte NOPs
 fast_15bytenop: Target can quickly decode up to 15 byte NOPs
 fast_bextr: Indicates that the BEXTR instruction is implemented as a single uop with good throughput
 fast_gather: Indicates if gather is reasonably fast
 fast_hops: Prefer horizontal vector math instructions (haddp, phsub, etc.) over normal vector instructions with shuffles
 fast_lzcnt: LZCNT instructions are as fast as most simple integer ops
 fast_scalar_fsqrt: Scalar SQRT is fast (disable Newton-Raphson)
 fast_scalar_shift_masks: Prefer a left/right scalar logical shift pair over a shift+and pair
 fast_shld_rotate: SHLD can be used as a faster rotate
 fast_variable_shuffle: Shuffles with variable masks are fast
 fast_vector_fsqrt: Vector SQRT is fast (disable Newton-Raphson)
 fast_vector_shift_masks: Prefer a left/right vector logical shift pair over a shift+and pair
 fma: Enable three-operand fused multiple-add
 fma4: Enable four-operand fused multiple-add
 fsgsbase: Support FS/GS Base instructions
 fxsr: Support fxsave/fxrestore instructions
 gfni: Enable Galois Field Arithmetic Instructions
 idivl_to_divb: Use 8-bit divide for positive values less than 256
 idivq_to_divl: Use 32-bit divide for positive values less than 2^32
 invpcid: Invalidate Process-Context Identifier
 lea_sp: Use LEA for adjusting the stack pointer
 lea_uses_ag: LEA instruction needs inputs at AG stage
 lwp: Enable LWP instructions
 lzcnt: Support LZCNT instruction
 macrofusion: Various instructions can be fused with conditional branches
 merge_to_threeway_branch: Merge branches to a three-way conditional branch
 mmx: Enable MMX instructions
 movbe: Support MOVBE instruction
 movdir64b: Support movdir64b instruction
 movdiri: Support movdiri instruction
 mpx: Deprecated. Support MPX instructions
 mwaitx: Enable MONITORX/MWAITX timer functionality
 nopl: Enable NOPL instruction
 pad_short_functions: Pad short functions
 pclmul: Enable packed carry-less multiplication instructions
 pconfig: platform configuration instruction
 pku: Enable protection keys
 popcnt: Support POPCNT instruction
 prefer_128_bit: Prefer 128-bit AVX instructions
 prefer_256_bit: Prefer 256-bit AVX instructions
 prefer_mask_registers: Prefer AVX512 mask registers over PTEST/MOVMSK
 prefetchwt1: Prefetch with Intent to Write and T1 Hint
 prfchw: Support PRFCHW instructions
 ptwrite: Support ptwrite instruction
 rdpid: Support RDPID instructions
 rdrnd: Support RDRAND instruction
 rdseed: Support RDSEED instruction
 retpoline: Remove speculation of indirect branches from the generated code, either by avoiding them entirely or lowering them with a speculation blocking construct
 retpoline_external_thunk: When lowering an indirect call or branch using a `retpoline`, rely on the specified user provided thunk rather than emitting one ourselves. Only has effect when combined with some other retpoline feature
 retpoline_indirect_branches: Remove speculation of indirect branches from the generated code
 retpoline_indirect_calls: Remove speculation of indirect calls from the generated code
 rtm: Support RTM instructions
 sahf: Support LAHF and SAHF instructions
 sgx: Enable Software Guard Extensions
 sha: Enable SHA instructions
 shstk: Support CET Shadow-Stack instructions
 slow_3ops_lea: LEA instruction with 3 ops or certain registers is slow
 slow_incdec: INC and DEC instructions are slower than ADD and SUB
 slow_lea: LEA instruction with certain arguments is slow
 slow_pmaddwd: PMADDWD is slower than PMULLD
 slow_pmulld: PMULLD instruction is slow
 slow_shld: SHLD instruction is slow
 slow_two_mem_ops: Two memory operand instructions are slow
 slow_unaligned_mem_16: Slow unaligned 16-byte memory access
 slow_unaligned_mem_32: Slow unaligned 32-byte memory access
 soft_float: Use software floating point features
 sse: Enable SSE instructions
 sse_unaligned_mem: Allow unaligned memory operands with SSE instructions
 sse2: Enable SSE2 instructions
 sse3: Enable SSE3 instructions
 sse4_1: Enable SSE 4.1 instructions
 sse4_2: Enable SSE 4.2 instructions
 sse4a: Support SSE 4a instructions
 ssse3: Enable SSSE3 instructions
 tbm: Enable TBM instructions
 use_aa: Use alias analysis during codegen
 use_glm_div_sqrt_costs: Use Goldmont specific floating point div/sqrt costs
 vaes: Promote selected AES instructions to AVX512/AVX registers
 vpclmulqdq: Enable vpclmulqdq instructions
 vzeroupper: Should insert vzeroupper instructions
 waitpkg: Wait and pause enhancements
 wbnoinvd: Write Back No Invalidate
 x87: Enable X87 float instructions
 xop: Enable XOP instructions
 xsave: Support xsave instructions
 xsavec: Support xsavec instructions
 xsaveopt: Support xsaveopt instructions
 xsaves: Support xsaves instructions</code></pre>
    <p>
    Of course, this works for any architecture, not only x86_64.
    </p>
    <p>Thanks Noam Preil, Christine Dodrill, David Cao, and Layne Gustafson
    for related contributions.</p>
    {#header_close#}

    {#header_open|Miscellaneous Improvements#}
    <ul>
      <li>Add <code>-I</code> command line parameter.</li>
      <li>POSIX terminals now have a progress indicator when compilation takes a long time.
        Thanks to Luna for the initial implementation.</li>
      <li>Michael Dusan added linux XDG Base Directory integration to the cache system. #3573</li> 
      <li>Add compiler note for bad int coercion (#3724)</li>
      <li>Private linkage for unnamed internal constants.</li>
      <li>Vexu implemented better support for extern enums.</li>
      <li>LemonBoy added a compile error for @bitCast to enum types, preventing invalid enum values.</li>
      <li>David Cao added <code>--eh-frame-hdr</code> CLI option. (#3981)</li>
      <li>LemonBoy improved debug info type sizes, making debuggers happy
        and no longer report incorrect values for {#syntax#}bool{#endsyntax#}. (#2685)</li>
      <li>LemonBoy improved the compiler to not special case the {#syntax#}"builtin"{#endsyntax#}
        import with regards to {#syntax#}usingnamespace{#endsyntax#}.</li>
      <li>Michael Dusan improved the compiler to strip cwd from compile error paths. (#4138)</li>
      <li>Michael Dusan improved the BREAKPOINT util within the C++ compiler code to support
        non-x86 architectures.</li>
      <li>LemonBoy improved the C++ compiler code internal debugging utilities.</li>
      <li>There is no longer a <code>native_libc.txt</code> file in zig-cache, and thus
        there is no longer a possibility for this file to become stale and cause problems.
        The libc installation path detection code is always run when needed. (#3975, #4186, #4940)</li>
      <li>Michael Dusan improved the development process on POSIX to support <code>make</code> without
        being required to <code>make install</code>. On Windows the INSTALL target is still a
        required part of the development process.</li>
      <li>LemonBoy improved {#syntax#}@tagName{#endsyntax#} to work on enum literals. (#4214)</li>
      <li>Valentin Anger added support for code model selection.</li>
      <li>Michael Dusan improved debuggability of the compiler by showing "Const" IR instructions
          trailing after they are referenced. (#4511)</li>
      <li>LemonBoy implemented safety checks for shl/shr when the integer size is not a power-of-two. (#2096)</li>
      <li>daurnimator removed unused static_crt_dir field from <code>zig libc</code> config.</li>
      <li>Bodie Solomon improved Zig's cmake build script to use appropriate compiler flags when
      building with MSVC. (#4877)</li>
      <li>Michael Dusan added a compiler flag to Zig's C++ compiler code that makes accidental
        switch case fallthrough a compile error, which uncovered a bug in the tokenizer.</li>
      <li>The <code>zig BUILD_INFO</code> hack is removed. 
        Rather than stuffing configuration information into the Zig binary, the
        build script reads it from config.h. This solves a problem for package
        maintainers and improves the use case of deterministic builds. (#3758)</li>
      <li>libc installation detection can correctly detect MSVC libc even when the compiler is
        built using the gnu target triple (taking advantage of {#link|mingw|mingw-w64 7.0.0#}</li>
      <li>Tse contributed DragonFlyBSD Support.</li>
    </ul>
    {#header_close#}

    {#header_open|Bug Fixes#}
    <p>
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aclosed+is%3Aissue+label%3Abug+milestone%3A0.6.0+">Full list of bug reports closed during this release cycle</a>.
    Note: many bugs were both introduced and resolved within this release cycle.
    Listed below are fixed bugs that were not reported on the issue tracker.
    </p>
    <p>
    Special thanks to LemonBoy, who solved a sizeable chunk of those issues, in
    many different parts of the Zig project.
    </p>
    <ul>
      <li>Better debug info for integers. Now we use ABI size * 8 instead of size_in_bits which makes
        gdb work instead of hang for non-power-of-two integers.</li>
      <li>LemonBoy fixed user-defined function alignment not getting propagated to LLVM IR.</li>
      <li>LemonBoy fixed crash when generating constant unions with single field.</li>
      <li>Various fixes related to 32-bit architectures.</li>
      <li>Async function recursion is detected and compile error emitted.</li>
      <li>Brendan Hansknecht fixed parsing of {#syntax#}.*={#endsyntax#}.</li>
      <li>Vexu fixed NodeErrorSetDecl rendering.</li>
      <li>Timon Kruiper added a compile error for an empty switch on a integer.</li>
      <li>Quetzal Bradley implemented correct buffer wrapping logic in {#syntax#}std.event.Channel{#endsyntax#}.</li>
      <li>LemonBoy fixed WinMain not having its calling convention type-checked.</li>
      <li>xackus fixed integers parsed as floats.</li>
      <li>emekoi fixed Windows dynamic library loading and added loading for Darwin.</li>
      <li>ForLoveOfCats fixed a memory leak in {#syntax#}std.math.big.Int.toString{#endsyntax#}. (#3992)</li>
      <li>LemonBoy improved the compiler's type resolution phase to catch more errors.</li>
      <li>daurnimator fixed an off-by-one error in Windows process creation.</li>
      <li>LemonBoy added missing validation for {#syntax#}switch{#endsyntax#} range endpoints. (#4172)</li>
      <li>Vexu fixed a crash when parsing a multiline library name.</li>
      <li>Micha√´l Larouche fixed {#syntax#}std.child_process.ChildProcess.spawnWindows{#endsyntax#} when looking in {#syntax#}PATH{#endsyntax#} environment variable, it applied cwd+app_name instead of just using the app_name.</li>
      <li>daurnimator fixed bug in {#syntax#}std.http.headers{#endsyntax#} where .put captures user-held variable.</li>
      <li>Fixed automatically created local variables sometimes having incorrect alignment.</li>
      <li>LemonBoy fixed an edge case in {#syntax#}isAbsolute{#endsyntax#} path functions. Empty
      strings are no longer considered absolute paths. (#4382)</li>
      <li>Rocknest fixed a double close in {#syntax#}openElfDebugInfo{#endsyntax#}.</li>
      <li>Fixed not checking type of return pointers. (#3224, #3269, #3327, #3422, #3646)</li>
      <li>std lib updated to integrate with libc for environment variables, even
        when building a static library. (#3511)</li>
      <li>J.W fixed logic and index out of bounds in hashing algorithms.</li>
      <li>Exported variables now respect linkage.</li>
      <li>Alexandros Naskos fixed slicing of C pointers to no longer produce {#syntax#}allowzero{#endsyntax#} slices. Instead they insert a runtime assertion. (#4462)</li>
      <li>Alexandros Naskos improved made the std lib VDSO code more robust and it now operates successfully inside Windows Subsystem for Linux. (#3997)</li>
      <li>LemonBoy improved arrray subscripts to properly type coerce to {#syntax#}usize{#endsyntax#}. (#4169)</li>
      <li>LemonBoy implemented a compile error for comparison between enum literal and untagged enum. (#4770)</li>
      <li>xackus fixed an overflow in {#syntax#}std.fmt.parseFloat{#endsyntax#} (#4845)</li>
      <li>Micha√´l Larouche fixed adler32 returning incorrect value with large input.</li>
      <li>LemonBoy improved big-endian compatibility. (#4935)</li>
      <li>Zig no longer caches the results of native system libc detection into a native_libc.txt file.
          Instead, it always runs native libc detection when it needs to know native libc paths. (#4772)</li>
    </ul>

    {#header_open|This Release Contains Bugs#}
    <p>
    Zig has
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Abug">known bugs</a>
    and even some
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Amiscompilation">miscompilations</a>.
    </p>
    <p>Zig is immature. Even with Zig 0.6.0, working on a non-trivial project using Zig will
    likely require participating in the development process.</p>
    <p>The first release to ship with no known bugs will be 1.0.0.</p>
    {#header_close#}
    {#header_close#}

    {#header_open|Please Welcome Vexu to the Core Zig Team#}
    <p>I am pleased to announce our newest Zig team member, <a href="https://vexu.eu/">Vexu</a>.</p>
    <p>Vexu has shown continued dedication and discipline in contributions to the Zig
    programming language project. The quality of Vexu's work speaks for itself.</p>
    <p>
    In addition, Vexu has proven to be a steadfast community leader,
    setting an example for how to treat others with kindness and respect.
    </p>
    <p>I look forward to working with Vexu as we continue to push Zig toward 1.0.0 and beyond.</p>
    {#header_close#}

    {#header_open|Roadmap#}
    <p>
    According to the
    <a href="https://ziglang.org/download/0.5.0/release-notes.html#Roadmap">0.5.0 Roadmap</a>,
    the major theme of the 0.6.0 release was supposed to be {#link|Safety#}. I also wrote:
    </p>
    <blockquote>
    I expect to complete [{#link|Networking#}] along with at least an early prototype of the
    package manager during the next release cycle. 
    </blockquote>
    <p>
    Clearly, this release cycle went in a different direction than planned.
    I realized that {#link|stabilizing the language|Language Changes#} is a top priority that
    everything else rests on. I also prioritized merging pull requests (at the time of writing,
    there are only 21 open pull requests, with the oldest one 36 days old), and unblocking
    contributors from accomplishing their goals.
    </p>
    <p>
    The theme of the 0.7.0 release cycle will be <strong>stabilizing the language</strong>, 
    <strong>creating a first draft of the language specification</strong>, and
    <strong>self-hosting the compiler</strong>.
    </p>
    <p>
    It would be a major accomplishment if Zig 0.7.0 could ship with self-hosted instead of stage1.
    </p>

    {#header_open|Package Manager Status#}
    <p>
    Having a package manager built into the Zig compiler is a
    <a href="https://github.com/ziglang/zig/issues/943">long-anticipated feature</a>.
    Zig 0.6.0 does not have this feature.
    </p>
    <p>
    If the package manager works well, people will use it, which means building Zig projects
    will involve compiling more lines of Zig code, which means the Zig compiler must get faster,
    better at incremental compilation, and better at resource management.
    </p>
    <p>
    Therefore, the package manager depends on finishing the
    {#link|self-hosted compiler|Self-Hosted Compiler Progress#}, since it is planned to have these
    improved performance characteristics, while stage1 is not planned to have them.
    </p>
    {#header_close#}

    {#header_open|C Header File Generation Status#}
    <p>
    There were two improvements:
    </p>
    <ul>
      <li>Support for exporting variables (#3284).</li>
      <li>Properly generate header in separate folder, respecting -femit-* options.</li>
    </ul>
    <p>
    Thanks Sahnvour and mogud.
    </p>
    <p>
    However, C header file generation is now disabled by default. The proof-of-concept is
    complete; but now it's a maintenance burden to implement this feature both in stage1
    and in self-hosted.
    </p>
    <p>
    The plan is to implement this feature in the
    {#link|self-hosted compiler|Self-Hosted Compiler Progress#}, and then remove the feature
    from stage1, since it is not needed to {#link|bootstrap|Bootstrap Tarball#}.
    </p>
    {#header_close#}

    {#header_open|Accepted Proposals#}
    <p>Here are proposals that have been accepted during the 0.6.0 release cycle,
    to give you an idea of the upcoming changes to Zig:</p>
    <ul>
      <li>TODO</li>
    </ul>
    {#header_close#}
    {#header_close#}

    {#header_open|Active Open-Source Projects Using Zig#}
    <ul>
      <li>TODO</li>
    </ul>
    {#header_close#}

    {#header_open|Funding Status#}
    <p>
    The Zig project is financially sustainable. It currently supports one
    full-time developer - the creator of the language, Andrew Kelley.
    </p>
    <p>
    If you flip through the previous release notes, you can see the number of commits and
    number of contributors per release increasing super-linearly. Merging pull requests
    and providing troubleshooting, support, and moderation for the quickly-growing community
    creates a strong demand on time that is too much for just one person.
    </p>
    <p>
    That is why I decided to start the <strong>Zig Software Foundation</strong>,
    a non-profit organization with the mission of raising the bar of software standards,
    ethics, and quality, and paying open source contributors for their valuable time.
    </p>
    <p>
    I hope you will stay tuned for an official announcement about the ZSF, which I expect
    to happen within 6 months.
    </p>
    {#header_close#}

    {#header_open|Thank You Sponsors!#}
    <p>
    Special thanks to those who <a href="https://github.com/users/andrewrk/sponsorship">sponsor Zig</a>.
    Because of you, Zig is driven by the open source community, rather than the goal of making profit.
    In particular, these fine folks sponsor Zig for $15/month or more:
    </p>
    <ul style="columns: 3">
      <li><a href="https://skunkwerks.at/">SkunkWerks, GmbH</a></li>
      <li><a href="https://www.hryx.net/">Stevie Hryciw</a></li>
      <li><a href="https://github.com/karrick">Karrick McDermott</a></li>
      <li><a href="https://jowl.app/">Daniel Axelrod</a></li>
      <li><a href="https://github.com/dimenus">Ryan Saunderson</a></li>
      <li><a href="https://github.com/drfuchs">drfuchs</a></li>
      <li><a href="http://severnatazvezda.com/">Rickard Andersson</a></li>
      <li><a href="http://haze.cool/">haze</a></li>
      <li><a href="https://github.com/iohzrd">iohzrd</a></li>
      <li><a href="http://interviewessentials.com/">Jessica Hargis</a></li>
      <li><a href="https://ross.codes/">Ross Kilgariff</a></li>
      <li><a href="https://kristoff.it/">Loris Cro</a></li>
      <li><a href="https://github.com/overdew">Jeff Kelley</a></li>
      <li><a href="http://raytracer.me/">Christoph M√ºller</a></li>
      <li><a href="https://github.com/rsimmons">Russel Simmons</a></li>
      <li><a href="https://github.com/ryanworl">ryanworl</a></li>
      <li><a href="http://santiagoandaluz.com/">Santiago Andaluz</a></li>
      <li><a href="https://github.com/vchakrav">vchakrav</a></li>
      <li><a href="https://github.com/sit-fyi">Yurii Rashkovskii</a></li>
      <li><a href="https://burntsushi.net/">Andrew Gallant</a></li>
      <li><a href="https://github.com/cshenton">Charles Shenton</a></li>
      <li><a href="https://dawnarc.com/">Neil Wang</a></li>
      <li><a href="http://www.fengb.me/">Benjamin Feng</a></li>
      <li><a href="https://filippo.io/">Filippo Valsorda</a></li>
      <li><a href="https://jayschwa.net/">Jay Petacat</a></li>
      <li><a href="https://github.com/qbradley">Quetzal Bradley</a></li>
      <li><a href="https://github.com/quag">Jonathan Wright</a></li>
      <li><a href="https://github.com/rahulunair">Rahul Nair</a></li>
      <li><a href="https://bitsandhops.com/">Richard Bishop</a></li>
      <li><a href="https://www.embark-studios.com/">Johan Andersson</a></li>
      <li><a href="http://joshtob.in/">Josh Tobin</a></li>
      <li><a href="https://github.com/rui314">Rui Ueyama</a></li>
      <li><a href="https://github.com/Sticksman">Felix Yuan</a></li>
      <li><a href="http://espians.com/">tav</a></li>
      <li><a href="http://zfeldman.com/">Zach Feldman</a></li>
      <li>Arto Bendiken</li>
      <li>Simon Cruanes</li>
      <li>Champ Yen</li>
      <li>Clipsey</li>
      <li>Luke I. Wilson</li>
      <li>Dan Boykis</li>
      <li>Eric</li>
      <li>Felix Jankowski</li>
      <li>fuzzwizard</li>
      <li>Gilbert</li>
      <li>Chris Heyes</li>
      <li>Jimmi Holst Christensen</li>
      <li>Hong Shick Pak</li>
      <li>Isaac Yonemoto</li>
      <li>Jesse Meyer</li>
      <li>Jethro Nederhof</li>
      <li>Jason Merrill</li>
      <li>Jack Halford</li>
      <li>Jimmy Zelinskie</li>
      <li>Keith Chambers</li>
      <li>Alon Zakai</li>
      <li>kristianhasselknippe</li>
      <li>Stefano Casillo</li>
      <li>Luis Alfonso Higuera Gamboa</li>
      <li>Charles Palmer</li>
      <li>Michael Lehmann</li>
      <li>Mirek Rusin</li>
      <li>Micha√´l Larouche</li>
      <li>Johann Muszynski</li>
      <li>Omar Akkila</li>
      <li>Emily A. Bellows</li>
      <li>Guillermo Rauch</li>
      <li>redj</li>
      <li>Robinson Collado</li>
      <li>rtroberts</li>
      <li>John Schmidt</li>
      <li>Scott J Maddox</li>
      <li>Lukas Attridge</li>
      <li>Neil Henning</li>
      <li>Audun Wilhelmsen</li>
      <li>Steve Perkins</li>
      <li>Clement Rey</li>
      <li>Thomas Ballinger</li>
      <li>Brian Orr</li>
      <li>vegecode</li>
      <li>Yiu Ming Huynh</li>
      <li>Abdulrhman A. AlKhodiry</li>
    </ul>
    {#header_close#}
    </div>
  </body>
</html>
TODO convert std.foo.bar to foo.bar (and make hyperlinks?)
TODO search for "commit" as well as TODO
TODO the commits to master since aaf99371b22e816a4162391d799b9d22bba21120
TODO take a look at that wiki page by mike dusan, notable master branch commits
TODO hyperlinkify issue numbers
TODO run the html through the w3c validator to find html errors
