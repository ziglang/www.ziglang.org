<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>0.6.0 Release Notes &middot; The Zig Programming Language</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/favicon.png">
    <link rel="icon" href="/favicon.svg">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        line-height: 1.45;
        margin-left: 0;
        margin-right: 0;
      }
      p {
        margin: 0.8em 0;
      }

      h1, h2, h3, h4, h5 {
        margin: 0.5em 0 0.5em;
        line-height: 1.2;
        font-weight: bold;
        color: #666;
      }

      h1 a, h2 a, h3 a, h4 a, h5 a {
        text-decoration: none;
        color: #666;
      }

      h1 { font-size: 2.0em; }

      h2 { font-size: 1.5em; }

      h3 { font-size: 1.25em; }

      h4 { font-size: 1.0em; }

      a.hdr {
        visibility: hidden;
      }
      h1:hover > a.hdr, h2:hover > a.hdr, h3:hover > a.hdr, h4:hover > a.hdr, h5:hover > a.hdr {
        visibility: visible;
      }

      a {
        color: #2A6286;
      }

      a:not(:hover) {
        text-decoration: none;
      }

      th, td {
        padding: 0.6em;
        text-align: left;
      }

      td {
        font-size: 0.96em;
      }

      th {
        border-bottom: 2px solid #f2f3f3;
      }

      tr:nth-child(even) {
        background: #f2f3f3;
      }

      .t0_1, .t37, .t37_1 {
        font-weight: bold;
      }
      .t2_0 {
        color: grey;
      }
      .t31_1 {
        color: red;
      }
      .t32_1 {
        color: green;
      }
      .t36_1 {
        color: #0086b3;
      }
      .file {
        text-decoration: underline;
      }
      pre,code {
        font-size: 12pt;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        color: #333;
        background: #f8f8f8;
      }
      .table-wrapper {
        width: 100%;
        overflow-y: auto;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      #contents {
        max-width: 60em;
        margin: auto;
        padding: 0 0.2em;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background-color:#111;
            color: #bbb;
        }
        a {
            color: #88f;
        }
        table, th, td {
            border-color: grey;
        }
        tr:nth-child(even) {
          background: #1e1e1e;
        }
        .t2_0 {
            color: grey;
        }
        .t31_1 {
            color: red;
        }
        .t32_1 {
            color: green;
        }
        .t36_1 {
            color: #0086b3;
        }
        pre > code {
            color: #ccc;
            background: #222;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #e33;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
        h1, h2, h3, h4, h5 {
          color: #aaa;
        }
        h1 a, h2 a, h3 a, h4 a, h5 a {
            color: #aaa;
        }
      }
    </style>
  </head>
  <!--
                                 .m//oooo/:.```h``y +/```.:/+++/oyog
                               `:yNy+-``       h` s +/       ``-/yds:`g
                             -sdy/.            h` s +/            `:sho-g
                           :yh+.               h` o +/               `/yy-g
                         -yh/`                 h` + +/                 `-yy.g
                       `oh/........```         h` / +/           ``.....``:h+`g
                      .hNhyyyyysssoo++/-`      h` / +/      `.-:/+oooossssoomy.g
                     -mmdyyso+++++++o+++o/-`   h` : +/   `.:+/++++/////++oyyhNd-g
                    -myoso++/:::::-.....-/+/-  h` - +/  .:+/-.....-:::::/++ossdm.g
                   .ms-ysossyhyyyyhyyso:.``:+/`o+ .`y-`/o:` .:+syhhhhhhhyssooh/hd`g
                   yh-hshysshhdmmddhysyhy+-` :s:+o.y:-s/` .+yhyyhdmmmmmddhyyhsh/msg
                  :N.yshohNMMMNMMMMMMMmyohy+` `y//h:-h. `/yhyhmMMMMMMNMMMMMdshyy/N-g
                  hs:om+NMMMMMMMNMMMMMMMNsyh+` `d.``d- `+yhyNMMMMMMNNMMMMMMMMsdo/hsg
                 `N-/yomMMMMMMMMMNNMMMMMMM+hs+  os +y  /omoMMMMMMMNMMMMMMMMMMN+d//mg
                 -N :d/MMMMMMMMMMMMNMMMMMMm+do  /h oo  +ysmMMMMMNMMMMMMMMMMMMM+N/.N.g
                 :m :d+MMMMMMMMMMMMMMNMMMMhsy+``s+ :h``/ohhMMMNMMMMMMMMMMMMMMM+N:`N.g
                 -N :h+MMMMMMMMMMMMMMMMNMmodo-~/h`. y+~-ohsmNNMMMMMMMMMMMMMMMM+m:`N.g
                 `N..ssdMMMMMMMMMMMMMMMNhsho/:+y` / `so/:oyyhNMMMMMMMMMMMMMMMNoy~-m`g
                  h/ +moMMMMMMMMMMMMMMmsyso++so`  o   +s++oshymMMMMMMMMMMMMMMydo`+yg
                  /d :homMMMMMMMMMMMmyyyooosy:   .o.`  -ssoosyyymMMMMMMMMMMMN+d: d-g
                   d/ +m+mNMMMMMMNdyyysssss/`    :s/.    :ysssoyyyhNMMMMMMMN+do`+yg
                   .d-.ohshNNNNdyyyysyhsy+-`  ```+s+:`  ```:shsyyyhyyhNNNNd+hy..d.g
                   .+h..+dhyyhodyyydyhy/.~-` ..`.yss+``-.`. .+ohydhhyhshyyyho:.h:g
                    ./h- ++yydsmdmhh+/+..~-  -...yyd+  `.....+-~/sdmddydhy+:.:h:g
                   `..:hoo//:/.-:.:o+/++:-:- .~-:+/s+:-...:-:++/+:~-:-`/::+ohd..-`g
                       `smhsooososooo+++/::.~-.`   `  .::-:///+++sosoosssyhmo`g
                         :dmdmdhyysyoso+o/::`      /  `.-~/+ooosssyyhhddmNh-g
                          `/dMMmmhdyyyss/-         +     -:-/syshyddmNMMh:g
                            `:yNMNNmho/.           +      `-:::shmNMMNy-g
                               ./dh/.`             +         .::/omy/`g
                       ./o-      `++               +           `.y/         -o/.g
                  `-/+o+/d/+`      /y:/oy:     .///y///.     /yooo.`      `o/h/+++/.g
              `-/+o+//+::d`.+-   .sooooooh-  `o/:/:+:/:/+`  :hoooo+os`   -s. h:////+o+/-`g
          `-/+o+/+/:/+:/+y/ `+:  `hsooooooh. o-/hoyhyoh/:o -hoooooosy`  /o` /y+/:+/:///+o+:-`g
        -so+++:/+/://:/+:/d. `//  -doooooosy`h-oNyMMMyNo:h.yoooooood.  ++` `d/:+/://:/+::+++oo.g
        d+://://:/+/://:/+os  `sosdNdoooooosy+/:yhhdhhy:/+yooooooodNdsss`  so+/://://:/+/://:+yg
       .h///://:///://://:/y+ :NMMMMMhooooooss////+s+//+/ssoooooodMMMMMN/ +y/://://:///://://:hg
       `d+/:+/://:/+/://://:y/`mMMMMMNyooooooy+`-:/+/:-`oyoooooohMMMMMMN.:y///://:///://://:/+hg
        y////://://:///://:/+h::mMMMmhysooooooy/       +yooooooyyhmMMMm:-h+/://:///://://:////og
        -y/:/+/://://:///://:/h:.+:s: `ysooooooy      `hooooooys  /y/+.-h/://://:///://://::/y.g
         o+//:///://://:/+/:///y:  `s` `yss+/-.`  .-://+syyyoss` .y`  :y///://:/+/://://:///++g
         `y+:///://://:///://:/+y/  .o  `sh    ``.://+osyhNN~-` `y.  /y+/://:/+/://://:///:+s`g
          .y+/:///:+/://:/+/://:/so` //  +d-///////++++oydNd    +/ `oy/://:/+/://://:/+/:/+o`g
           .s///:/+/://://:/+/:+/:+s-`s` sh-:oy:-~-~-:+o~-yh   .y`-so://:/+::+/://:/+::///o`g
            .so:/+::+/://:/+:/+/:///o+y/ /s:mdo       .md-s/   +y+o///:/+:/+/://:/+:/+/:+o`g
             `+s+:/+::+/://:/+::+//+ooo.  `:yy+       /yy:`    -ooo+//+:/+/://:/+:/+/:+o/g
               -so+:/+/:+/:/+/+o+//-`       `+s-`o:`-/s+          `-//+o+/+/:/+:/+::+++.g
                 :oso//+/+so//-`              `-:::::-`                `-/+os//+//+o+:g
                   ./os+/-`                                                 `:/+s+:.
  -->
  <body>
    <div id="contents">
    <a href="https://ziglang.org/"><img alt="zig" src="https://ziglang.org/zig-logo.svg" style="width: 28em"></a>
    <h1>0.6.0 Release Notes</h1>
    <p>
    <a href="https://ziglang.org/download/">Download &amp; Documentation</a>
    </p>
    <p>
    Zig is a general-purpose programming language and toolchain for maintaining
    <strong>robust</strong>, <strong>optimal</strong>, and <strong>reusable</strong> software.
    With special thanks to
    <a href="https://github.com/users/andrewrk/sponsorship">many generous sponsors</a>,
    the Zig project is financially sustainable and currently supports
    <a href="https://andrewkelley.me/">one full-time developer</a>.
    Let's reboot systems programming.</p>
    <p>
    This release features <strong>6 months of work</strong> and
    changes from <strong>122 different contributors</strong>, spread among
    <strong>2527 commits</strong>.
    </p>

    {#header_open|Table of Contents#}
    {#nav#}
    {#header_close#}

    {#header_open|LLVM 10#}
    <p>
    This release of Zig upgrades to
    <a href="http://releases.llvm.org/10.0.0/docs/ReleaseNotes.html">LLVM 10</a>.
    Zig operates in lockstep with LLVM; Zig 0.6.0 is not compatible with LLVM 9.
    </p>
    <p>
    As far as Zig is concerned, the primary benefits of the new LLVM version are bug
    fixes, especially for {#link|ARM Support#}, {#link|MIPS Support#}, and {#link|RISC-V Support#}.
    </p>
    <p>
    This is the first release of <a href="https://lld.llvm.org/">LLD</a> that has all of Zig's patches
    merged upstream. Consequently, Zig's source repository no longer includes a fork of LLD sources.
    Amusingly, it also means that the source tarball
    <a href="https://ziglang.org/download/0.6.0/zig-0.6.0.tar.xz">zig-0.6.0.tar.xz</a>
    is 0.5 MiB smaller than
    <a href="https://ziglang.org/download/0.5.0/zig-0.5.0.tar.xz">zig-0.5.0.tar.xz</a>,
    since the deletion of LLD sources saved more space than all the rest of the changes made
    in this release cycle combined. Note that the new {#link|Bootstrap Tarball#}
    bundles all dependencies of the Zig compiler, which includes LLVM, LLD, and Clang.
    </p>
    <p>
    Thanks to LemonBoy for submitting patches to update Zig's codebase to LLVM 10, as well as
    submitting countless bug reports and patches upstream to LLVM and LLD, to get various
    cross-compiling issues sorted out.
    </p>
    {#header_close#}

    {#header_open|Bootstrap Tarball#}
    <p>With {#link|zig cc#} now available, the 0.6.0 release of Zig comes with a special new source tarball:
    <a href="https://ziglang.org/download/0.6.0/zig-bootstrap-0.6.0.tar.xz" style="white-space: nowrap">zig-bootstrap-0.6.0.tar.xz</a>
    </p>
    <p>
    This is made from the <a href="https://github.com/ziglang/bootstrap">ziglang/bootstrap</a>
    source repository, which contains unpatched LLVM, Clang, LLD, and Zig sources, and a
    <a href="https://github.com/ziglang/bootstrap/blob/0.6.0/build">simple build script with <strong>no branching logic</strong></a>.
    </p>
    <p>
    The purpose of the bootstrap tarball is to start with minimum system dependencies and end with
    a fully operational Zig compiler for any target. It does this in exactly 4 steps:
    </p>
    <ol>
      <li>Build LLVM, Clang, and LLD from source, for the native target, using the native C++ compiler.</li>
      <li>Build Zig from source for the native target, linking against LLVM, Clang, and LLD.</li>
      <li>Now we have Zig as a cross compiler. Use it to rebuild LLVM, Clang, and LLD for the specified target.</li>
      <li>Finally, use Zig to build itself, for the specified target.</li>
    </ol>
    <p>And thus, the <a href="https://github.com/ziglang/zig/issues/853">Grand Bootstrapping Plan</a>
    is fulfilled. The number of steps will always be these four, or less. Never more.</p>
    <p>
    This bootstrap process provides the five new binary builds available in this release, that were not
    available previously:
    </p>
    <ul>
      <li><a href="https://ziglang.org/download/0.6.0/zig-linux-armv7a-0.6.0.tar.xz">zig-linux-armv7a-0.6.0.tar.xz</a> (32-bit {#link|ARM|ARM Support#} Linux)</li>
      <li><a href="https://ziglang.org/download/0.6.0/zig-linux-armv6kz-0.6.0.tar.xz">zig-linux-armv6kz-0.6.0.tar.xz</a> (older 32-bit ARM that notably works on Raspberry Pi 1 and RPi Zero)</li>
      <li><a href="https://ziglang.org/download/0.6.0/zig-linux-i386-0.6.0.tar.xz">zig-linux-i386-0.6.0.tar.xz</a> ({#link|32-bit x86|32-bit x86 Support#} Linux)</li>
      <li><a href="https://ziglang.org/download/0.6.0/zig-linux-riscv64-0.6.0.tar.xz">zig-linux-riscv64-0.6.0.tar.xz</a> ({#link|RISC-V|RISC-V Support#} Linux)</li>
      <li><a href="https://ziglang.org/download/0.6.0/zig-windows-i386-0.6.0.zip">zig-windows-i386-0.6.0.zip</a> ({#link|32-bit x86 Windows|32-bit Windows Support#})</li>
    </ul>
    <p>
    See <a href="https://ziglang.org/download/">the download page</a> for a full list of
    tarballs.
    </p>
    <p>
    Thanks to Timon Kruiper and LemonBoy for contributions related to this.
    </p>
    {#header_close#}

    {#header_open|Support Table#}
    <p>
    Zig uses a {#link|Tier System#} to communicate the level of support for different targets.
    Notably, in this release:
    </p>
<table>
<thead>
<tr>
<th></th>
<th>free standing</th>
<th>Linux 3.16+</th>
<th>macOS 10.13+</th>
<th>Windows 8.1+</th>
<th>FreeBSD 12.0+</th>
<th>NetBSD 8.0+</th>
<th>UEFI</th>
</tr>
</thead>
<tbody>
<tr>
<td>x86_64</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td style="white-space: nowrap">{#link|Tier 2|Tier 2 Support#}</td>
</tr>
<tr>
<td>arm64</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>arm32</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>mips32 LE</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>i386</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
</tr>
<tr>
<td>riscv64</td>
<td>{#link|Tier 1|Tier 1 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
</tr>
<tr>
<td>bpf</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>hexagon</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>mips32 BE</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>mips64</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>amdgcn</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>sparc</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>s390x</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>lanai</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>powerpc32</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>powerpc64</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>avr</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>riscv32</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
<tr>
<td>xcore</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>nvptx</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>msp430</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>r600</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>arc</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>tce</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>le</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>amdil</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>hsail</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>spir</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>kalimba</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>shave</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
<tr>
<td>renderscript</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
<td>N/A</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>N/A</td>
</tr>
</tbody>
</table>

    {#header_open|WebAssembly Support#}
<table>
<thead>
<tr>
<th></th>
<th>free standing</th>
<th>emscripten</th>
<th>WASI</th>
</tr>
</thead>
<tbody>
<tr>
<td>wasm32</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
<td>{#link|Tier 3|Tier 3 Support#}</td>
<td>{#link|Tier 2|Tier 2 Support#}</td>
</tr>
<tr>
<td>wasm64</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
<td>{#link|Tier 4|Tier 4 Support#}</td>
</tr>
</tbody>
</table>

    <p>
    Thanks to Benjamin Feng and Colin Svingen's contributions:
    </p>
    <ul>
      <li>The WASI OS bits are audited and updated.</li>
      <li>{#syntax#}std.heap.page_allocator{#endsyntax#} gains a WebAssembly implementation.</li>
    </ul>
    {#header_close#}

    {#header_open|Tier System#}

    {#header_open|Tier 1 Support#}
    <ul>
      <li>Not only can Zig generate machine code for these targets, but the standard
   library cross-platform abstractions have implementations for these targets.
   Thus it is practical to write a pure Zig application with no dependency on
   libc.</li>
      <li>The CI server automatically tests these targets on every commit to master
      branch, and updates <a href="https://ziglang.org/download/">the download page</a>
      with links to pre-built binaries.</li>
      <li>These targets have debug info capabilities and therefore produce stack traces
        on failed assertions.</li>
      <li>libc is available for this target even when cross compiling.</li>
      <li>All the behavior tests and applicable standard library tests pass for this target.
          All language features are known to work correctly.</li>
    </ul>
    {#header_close#}

    {#header_open|Tier 2 Support#}
    <ul>
    <li>The standard library supports this target, but it's possible that some
      APIs will give an "Unsupported OS" compile error. One can link with libc or other
      libraries to fill in the gaps in the standard library.</li>
    <li>These targets are known to work, but may not be automatically tested, so there
      are occasional regressions.</li>
    <li>Some tests may be disabled for these targets as we work toward
      {#link|Tier 1 Support#}.
    </li>
    </ul>
    {#header_close#}

    {#header_open|Tier 3 Support#}
    <ul>
    <li>The standard library has little to no knowledge of the existence of this
        target.</li>
    <li>Because Zig is based on LLVM, it has the capability to build for these
      targets, and LLVM has the target enabled by default.</li>
    <li>These targets are not frequently tested; one will likely need to contribute
      to Zig in order to build for these targets.</li>
    <li>The Zig compiler might need to be updated with a few things such as<ul>
       <li>what sizes are the C integer types</li>
       <li>C ABI calling convention for this target</li>
       <li>bootstrap code and default panic handler</li>
     </ul>
     <li><code>zig targets</code> is guaranteed to include this target.</li>
    </ul>
    {#header_close#}

    {#header_open|Tier 4 Support#}
    <ul>
      <li>Support for these targets is entirely experimental.</li>
      <li>LLVM may have the target as an experimental target, which means that you
   need to use Zig-provided binaries for the target to be available, or
   build LLVM from source with special configure flags. <code>zig targets</code> will
   display the target if it is available.</li>
   <li>This target may be considered deprecated by an official party,
     <a href="https://support.apple.com/en-us/HT208436">such as macosx/i386</a> in which
     case this target will remain forever stuck in Tier 4.</li>
   <li>This target may only support <code>--emit asm</code> and cannot emit object files.</li>
    </ul>
    {#header_close#}
    {#header_close#}

    {#header_open|Windows Support#}
    <p>
    Zig's Windows support improved considerably in this release. Counterintuitively,
    in the {#link|Support Table#}, x86_64-windows went from
    {#link|Tier 1|Tier 1 Support#} =&gt; {#link|Tier 2|Tier 2 Support#},
    but this is due to more {#link|SIMD#} test coverage added, and it was
    discovered that vectors of {#syntax#}f16{#endsyntax#} are failing some behavior tests.
    This is the <a href="https://github.com/ziglang/zig/issues/4952">only issue</a>
    holding Windows (both 32-bit and 64-bit) back from {#link|Tier 1|Tier 1 Support#}.
    </p>
    <p>
    In this release, the minimum supported Windows version is bumped from 7+ to 8.1+, following the
    <a href="https://support.microsoft.com/en-us/help/13853/windows-lifecycle-fact-sheet">extended support lifecycle of Microsoft</a>.
    </p>
    <p>In addition:</p>
    <ul>
      <li>More cross compiling support for Windows system DLLs.</li>
      <li>{#syntax#}wWinMain{#endsyntax#}, {#syntax#}wWinMainCRTStartup{#endsyntax#},
        and {#syntax#}DllMain{#endsyntax#} are now recognized entrypoints. (<a href="https://github.com/ziglang/zig/issues/4376">#4376</a>)</li>
      <li>Improved {#link|Debug Info and Stack Traces#}</li>
      <li>The hack to disable native {#link|CPU Features#} on Windows is removed
          thanks to bug fixes in {#link|LLVM 10#}. (<a href="https://github.com/ziglang/zig/issues/508">#508</a>)</li>
    </ul>
    <p>
    Thanks Jared Miller, emekoi, syscall0, and LemonBoy for contributions related to this.
    </p>

    {#header_open|32-bit Windows Support#}
    <p>
    In this release, i386-windows goes from
    {#link|Tier 3|Tier 3 Support#} =&gt; {#link|Tier 2|Tier 2 Support#}.
    A {#link|pre-made .zip build of 32-bit Windows|Bootstrap Tarball#} is newly available.
    </p>
    <p>
    Thanks to LemonBoy's work on this:
    </p>
    <ul>
      <li>Support for Win32 Thread-Local Storage.</li>
      <li>Adding more lib32 .def files from {#link|mingw-w64|mingw-w64 7.0.0#}.</li>
      <li>Removing x86/Windows name mangling hack and properly generating
        correct .lib files from mingw-w64 sources, by adding dlltool functionality to Zig.</li>
      <li>Adding {#link|Test Coverage#} for i386-windows.</li>
      <li>Fixing stack-probe symbol redefinition.</li>
    </ul>
    <p>
    The only thing holding 32-bit Windows back from {#link|Tier 1 Support#} is enabling
    i386-windows CI builds of Zig that update the download page and the
    <a href="https://github.com/ziglang/zig/issues/4952">same f16 vector issue from 64-bit Windows</a>.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|RISC-V Support#}
    <p>
    RISC-V support in Zig is now excellent! We even have
    riscv64 binary tarballs now thanks to the {#link|Bootstrap Tarball#}.
    It does, however require
    <a href="https://github.com/ziglang/bootstrap/issues/4#issuecomment-608549353">one workaround</a>
    due to
    <a href="https://bugs.llvm.org/show_bug.cgi?id=45419">clang crashing when it tries to build itself for self-hosted riscv64</a>.
    </p>
    <p>riscv64-freestanding went from
    {#link|Tier 4|Tier 4 Support#} =&gt; {#link|Tier 1|Tier 1 Support#}.
    </p>
    <p>riscv64-linux went from {#link|Tier 4|Tier 4 Support#} =&gt; {#link|Tier 2|Tier 2 Support#}
    and is already nearing {#link|Tier 1|Tier 1 Support#}.</p>
    <p>
    {#link|Debug Info and Stack Traces#} on RISC-V is now working.
    </p>
    <p>
    The default ABI of riscv32-linux and riscv64-linux is changed to be
    ilp32d and lp64d, respectively. Likewise, the default ABI of non-linux riscv32 and riscv64
    are changed to be ilp32 and lp64. This matches Clang's behavior. (<a href="https://github.com/ziglang/zig/issues/4863">#4863</a>)
    </p>
    <p>
    Zig now has {#link|Test Coverage#} for riscv64 with no libc and riscv64 with
    {#link|musl|musl 1.2.0#} libc. The issue for Zig providing {#link|glibc|glibc 2.31#} for
    riscv64 is <a href="https://github.com/ziglang/zig/issues/3340">#3340</a>.
    </p>
    <p>
    Thanks to LemonBoy for contributions related to this, and to Lu√≠s Marques for fixing
    RISC-V issues upstream, which landed in {#link|LLVM 10#}.
    </p>
    {#header_close#}

    {#header_open|ARM Support#}
    <p>
    aarch64-linux is very nearly {#link|Tier 1|Tier 1 Support#}. The only thing preventing it is
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+label%3Aarch-arm64+label%3Abug">some behavior tests are disabled</a>.
    </p>
    <p>
    In this release, Zig gained CI {#link|Test Coverage#} for aarch64, and the download page
    is updated with every master branch commit with a binary tarball for aarch64.
    </p>
    <p>
    Thanks to the {#link|Bootstrap Tarball#} this release additionally gains a
    32-bit ARM binary available (armv7a), as well as another 32-bit slightly older ARM
    binary (armv6kz) which notably works on Raspberry Pi 1 and RPi 0.
    </p>
    <p>
    Thank you to Timon Kruiper and LemonBoy for working together to solve undefined behavior
    bugs revealed by building Zig with {#link|zig cc#}.
    </p>
    <ul>
      <li>Fix signedness for some fields in ARM stat definition</li>
      <li>C ABI support is partially implemented.</li>
      <li>Fix possible unaligned ptr from <code>getauxval</code>. This caused SIGILL on armv7a-linux. (<a href="https://github.com/ziglang/zig/issues/4796">#4796</a>)</li>
      <li>Fix multiplication overflow in <code>hash_const_val</code>. In some cases the compiler
        was actually emitting an 64 bit signed multiplication, instead of a 32 bit unsigned one.</li>
    </ul>
    {#header_close#}

    {#header_open|32-bit x86 Support#}
    <p>
    i386-linux went from {#link|Tier 3|Tier 3 Support#} =&gt; {#link|Tier 2|Tier 2 Support#},
    and is nearing {#link|Tier 1|Tier 1 Support#}.
    </p>
    <p>
    Thanks to the {#link|Bootstrap Tarball#} this release additionally gains a
    i386-linux binary available.
    </p>
    <p>Thanks LemonBoy for implementing i386 support during this cycle. (<a href="https://github.com/ziglang/zig/issues/3808">#3808</a>, <a href="https://github.com/ziglang/zig/issues/4408">#4408</a>)</p>
    {#header_close#}

    {#header_open|MIPS Support#}
    <p>LemonBoy contributed MIPS fixes:</p>
    <ul>
      <li>Correct signal bits for MIPS. Also enable the segfault handler for all the
        supported architectures beside MIPS.</li>
      <li>Fix pipe syscall for MIPS.</li>
      <li>Implement target_dynamic_linker for MIPS.</li>
    </ul>
    {#header_close#}

    {#header_open|NetBSD Support#}
    <p>
    LemonBoy contributed NetBSD fixes: (<a href="https://github.com/ziglang/zig/issues/4793">#4793</a>)
    </p>
    <ul>
      <li>Fixes some nasty errors in the threading code</li>
      <li>Makes Zig able to run all the tests (at least on x86-64) except the event ones</li>
      <li>Audits and corrects some defines for NetBSD</li>
    </ul>
    {#header_close#}

    {#header_open|UEFI Support#}
    <p>Nick Erdmann and Heppokoyuki contributed UEFI improvements:</p>
    <ul>
      <li>make the subsystem configurable in {#link|zig build#}</li>
      <li>fix con_in definition and add EFI_SIMPLE_TEXT_INPUT_PROTOCOL definition</li>
      <li>add file protocols and improvements</li>
      <li>add documentation</li>
      <li>loading images</li>
      <li>snp, mnp, ip6, and udp6 support</li>
      <li>protocol handling improvements</li>
      <li>boot services and runtime services improvements</li>
      <li>loaded image protocol improvements</li>
      <li>Add shell parameters protocol</li>
      <li>device path protocol improvements</li>
      <li>status reform</li>
    </ul>
    {#header_close#}

    {#header_open|macOS Support#}
    <p>
    In this release, x86_64-macos went from
    {#link|Tier 1|Tier 1 Support#} =&gt; {#link|Tier 2|Tier 2 Support#},
    however, this is not because Zig dropped any kind of support for macOS, but rather because
    the bar for meeting {#link|Tier 1|Tier 1 Support#} requirements was raised,
    to include "libc is available for this target even when cross-compiling."
    </p>
    {#header_close#}

    {#header_close#}

    {#header_open|Target Details#}
    <p>
    Zig's awareness of {#link|CPU model and features|CPU Features#} as well as
    {#link|operating system versions|OS Version Ranges#} has broadened.
    </p>
    <p>
    The standard library now has two distinct concepts:
    {#syntax#}std.Target{#endsyntax#} and {#syntax#}std.zig.CrossTarget{#endsyntax#}.
    </p>
    <p>
    CrossTarget is what Zig's command line options get parsed into. It contains the concept
    of "native" and "default". Once this structure is populated, it can be <em>resolved</em>
    into a Target.
    </p>
    <p>
    A Target has all the information available; the CPU, OS, and ABI are all populated.
    As an example, a CrossTarget might be set to "native", and then when it is resolved,
    it turns into a Target which has the triple <code>riscv64-linux-musl</code>.
    </p>
    <p>
    {#link|zig build#} scripts set the desired CrossTarget of a build artifact; the Zig
    code being compiled only has access to the resolved Target as {#syntax#}std.Target.current{#endsyntax#}.
    </p>
    <p>
    Zig now supports a more fine-grained sense of what is native and what is not.
    Some examples:
    </p>
    <p>This is now allowed:</p>
    <pre>-target native</pre>
    <p>Different OS but native CPU, default Windows C ABI:</p>
    <pre>-target native-windows</pre>
    <p>This could be useful for example when running in Wine.</p>

    <p>Different CPU but native OS, native C ABI.</p>
    <pre>-target x86_64-native -mcpu=skylake</pre>

    <p>Different C ABI but otherwise native target:</p>
    <pre>-target native-native-musl</pre>
    <pre>-target native-native-gnu</pre>

    <p>
    This is a <strong>breaking change</strong> to std lib APIs for checking the OS and CPU architecture.
    To update from 0.5.0 to 0.6.0:
    </p>
    <p>
    {#syntax#}builtin.os{#endsyntax#} =&gt; {#syntax#}builtin.os.tag{#endsyntax#}
    </p>
    <p>
    {#syntax#}builtin.arch{#endsyntax#} =&gt; {#syntax#}builtin.cpu.arch{#endsyntax#}
    </p>
    <p>{#syntax#}std.build.Builder.standardTargetOptions{#endsyntax#} is changed to accept its
    parameters as a struct with default values. It now has the ability to
    specify a whitelist of targets allowed, as well as the default target.
    Rather than two different ways of collecting the target, it's now always
    a string that is validated, and prints helpful diagnostics for invalid
    targets. This feature should now be actually useful, and contributions
    welcome to further improve the user experience.</p>
    <p>{#syntax#}std.build.LibExeObjStep.setTheTarget{#endsyntax#} is removed.
    {#syntax#}std.build.LibExeObjStep.setTarget{#endsyntax#} is updated to take a CrossTarget
    parameter.</p>
    <p>
    {#syntax#}std.build.LibExeObjStep.setTargetGLibC{#endsyntax#} is removed. glibc versions are
    handled in the CrossTarget API and can be specified with the <code>-target</code>
    triple.
    </p>
    <p>
    {#syntax#}std.builtin.Version{#endsyntax#} gains a {#syntax#}format{#endsyntax#} method.
    </p>
    <p>Thanks to Timon Kruiper for contributions related to this.</p>

    {#header_open|CPU Features#}
    <p>
    Zig now has a database of CPU models and CPU features for every architecture.
    Now that <code>zig targets</code> is {#link|self-hosted|Self-Hosted Compiler Progress#}
    and outputs JSON, the easiest way to see this is to pipe <code>zig targets</code> into a JSON
    file and inspect it with a graphical JSON viewer, such as Firefox.
    </p>
    <p>
    Here I will show you <code>zig targets | jq .native</code> on the laptop that I am typing
    these release notes on:
    </p>
    <pre><code>{
  "triple": "x86_64-linux.5.4.15...5.4.15-gnu.2.27",
  "cpu": {
    "arch": "x86_64",
    "name": "skylake",
    "features": [
      "64bit",
      "adx",
      "aes",
      "avx",
      "avx2",
      "bmi",
      "bmi2",
      "clflushopt",
      "cmov",
      "cx16",
      "cx8",
      "ermsb",
      "f16c",
      "false_deps_popcnt",
      "fast_gather",
      "fast_scalar_fsqrt",
      "fast_shld_rotate",
      "fast_variable_shuffle",
      "fast_vector_fsqrt",
      "fma",
      "fsgsbase",
      "fxsr",
      "idivq_to_divl",
      "invpcid",
      "lzcnt",
      "macrofusion",
      "merge_to_threeway_branch",
      "mmx",
      "movbe",
      "nopl",
      "pclmul",
      "popcnt",
      "prfchw",
      "rdrnd",
      "rdseed",
      "rtm",
      "sahf",
      "sgx",
      "slow_3ops_lea",
      "sse",
      "sse2",
      "sse3",
      "sse4_1",
      "sse4_2",
      "ssse3",
      "vzeroupper",
      "x87",
      "xsave",
      "xsavec",
      "xsaveopt",
      "xsaves"
    ]
  },
  "os": "linux",
  "abi": "gnu"
}</code></pre>
    <p>
    Here you can see the CPU model and set of CPU features Zig detected. The implementation
    of this is <strong>fully self-hosted</strong>. Although Zig properly informs LLVM about
    CPU features when it does code generation, the awareness of CPU features and detection of
    CPU features is all implemented in Zig code. Currently, only x86 CPU feature detection is
    implemented; Zig falls back to LLVM for detecting native CPU model and features on other
    architectures. <a href="https://github.com/ziglang/zig/issues/4591">Contributions welcome</a>!
    </p>
    <p>
    Zig now has the ability to parse CPU features as part of the target triple.
    </p>
    <p>Native architecture, OS, and ABI, but baseline CPU features:</p>
    <pre>-target native -mcpu=baseline</pre>
    <p>RISC-V 64-bit architecture, OS linux, default ABI, native CPU plus the rdpid feature, minus the sse3 feature:</p>
    <pre>-target riscv64-linux -mcpu=native+rdpid-sse3</pre>
    <p>Target the RPi Zero:</p>
    <pre>-target arm-linux-musleabi -mcpu=arm1176jzf_s</pre>
    <p>
    Now that it is possible to select what CPU features are enabled, freestanding no longer
    has SSE enabled by default.
    </p>
    <p>Thanks to Layne Gustafson for the initial exploration and implementation of
    this feature, and to alichay for the initial implementation of x86 CPU feature detection.
    </p>
    <p>Thanks to LemonBoy, Michael Dusan, and Noam Preil for related contributions.</p>
    {#header_close#}

    {#header_open|Removal of Sub-Architecture#}
    <p>
    The whole point of Zig is to re-examine the premises of system programming, and
    rework abstractions that have shown to be less than ideal. Naturally, once Zig
    gained CPU feature awareness, it raised the question, <em>what is the purpose of
    sub-architectures?</em>
    </p>
    <p>
    As it turns out, the answer is "none". Sub-architectures are rendered redundant by
    the existence of CPU features, and so they no longer exist in Zig.
    </p>
    <p>
    This has the happy consequence of making {#syntax#}std.Target.Cpu.Arch{#endsyntax#}
    an enum rather than a tagged union.
    </p>
    <p>Rather than:</p>
    <pre>-target armv7a-linux-gnu</pre>
    <p>Now it is:</p>
    <pre>-target arm-linux-gnu</pre>
    <p><code>v7a</code> is considered baseline, so to target a different sub-architecture such as
    v6kz, it would look like:</p>
    <pre>-target arm-linux-gnu -mcpu=generic+v6kz</pre>
    {#header_close#}

    {#header_open|OS Version Ranges#}
    <p>Operating System version ranges are now part of the target. This means that
    {#syntax#}comptime{#endsyntax#} code has access to exactly which version(s) of
    an OS are being targeted. You can see this by looking at the output of <code>zig builtin</code>,
    which displays the source code provided by {#syntax#}std.builtin{#endsyntax#}. Here's a snippet
    of the output on the computer I'm using to type release notes:</p>
    <pre>{#syntax#}// ...
pub const os = Os{
    .tag = .linux,
    .version_range = .{ .linux = .{
        .range = .{
            .min = .{
                .major = 5,
                .minor = 4,
                .patch = 15,
            },
            .max = .{
                .major = 5,
                .minor = 4,
                .patch = 15,
            },
        },
        .glibc = .{
            .major = 2,
            .minor = 27,
            .patch = 0,
        },
    }},
};
// ...{#endsyntax#}</pre>
    <p>Updated syntax for <code>-target</code> to take into account OS version ranges:</p>
    <pre><code># still valid. default version range
-target x86_64-windows-msvc

# minimum windows version: XP
# maximum windows version: 10
-target x86_64-windows.xp...win10-msvc

# minimum windows version: 7
# maximum windows version: latest
-target x86_64-windows.win7-msvc

# linux example
-target aarch64-linux.3.16...5.3.1-musl

# specifying glibc version
-target mipsel-linux.4.10-gnu.2.1</code></pre>
    <p>Here's what it will look like to populate a {#syntax#}CrossTarget{#endsyntax#}:</p>
    <pre><code>-        tc.target = tests.Target{
-            .Cross = .{
-                .arch = .x86_64,
-                .os = .linux,
-                .abi = .gnu,
-            },
+        tc.target = std.zig.CrossTarget{
+            .cpu_arch = .x86_64,
+            .os_tag = .linux,
+            .abi = .gnu,</code></pre>
    <p>Code that used {#syntax#}Target.parse{#endsyntax#} need not be updated.</p>
    <p>Checking for the OS when doing conditional compilation:</p>
    <pre><code>--- a/lib/std/build/run.zig
+++ b/lib/std/build/run.zig
@@ -82,7 +82,7 @@ pub const RunStep = struct {

         var key: []const u8 = undefined;
         var prev_path: ?[]const u8 = undefined;
-        if (builtin.os == .windows) {
+        if (builtin.os.tag == .windows) {
             key = "Path";
             prev_path = env_map.get(key);
             if (prev_path == null) {</code></pre>

    <p>{#syntax#}std.Target.getStandardDynamicLinkerPath{#endsyntax#} is renamed to
    {#syntax#}std.Target.standardDynamicLinkerPath{#endsyntax#} and no longer requires an allocator.</p>

    <p>
    Zig's method of detecting the native system ABI and dynamic linker is now simple but portable:
    it inspects the dynamic linker path of its own executable. If statically linked, Zig looks at the
    dynamic linker path of <code>/usr/bin/env</code>, which is ubiquitous due to its use in shebang
    lines. Based on the dynamic linker file name, the ABI can be deduced. The same static Zig build
    will correctly detect the native ABI and dynamic linker path on Debian, NixOS, and Apline Linux,
    for example.
    </p>

     <p>No more {#syntax#}std.os.foo.is_the_target{#endsyntax#}.
     It had the downside of running all the comptime blocks and resolving
     all the usingnamespaces of each system, when just trying to discover if
     the current system is a particular one.
     For Darwin, where it's nice to use {#syntax#}std.Target.current.isDarwin(){#endsyntax#}, this
     demonstrates the utility that the proposal #425 would provide.
     </p>
     <p>
     This change allowed the removal of special Darwin OS version min handling. Now it is integrated
     with Zig's target OS range. The command line options
     <code>-mios-version-min</code> and <code>-mmacosx-version-min</code>
     are removed.
     </p>
     <p>
     Thanks LemonBoy for contributing OS version detection implementations for Windows and OSX.
     </p>
    {#header_close#}

    {#header_close#}

    {#header_open|Language Changes#}
    <ul>
      <li>Improved names of error sets when using merge error sets operator ({#syntax#}||{#endsyntax#}).</li>
      <li>{#syntax#}pub{#endsyntax#} syntax for container fields is removed.</li>
      <li>Type coercion from {#syntax#}*[0]T{#endsyntax#} to {#syntax#}E![]const T{#endsyntax#} is now allowed. This is an unambiguous, safe cast.</li>
      <li>{#syntax#}asm{#endsyntax#} now accepts comptime-known values, rather than
        requiring string literal syntax.</li>
      <li>Removed compile error for peer result {#syntax#}?comptime_int{#endsyntax#} and
        {#syntax#}null{#endsyntax#}. (<a href="https://github.com/ziglang/zig/issues/2763">#2763</a>)</li>
      <li>Ability to pass {#syntax#}comptime{#endsyntax#} types and non {#syntax#}comptime{#endsyntax#} types to same parameter.</li>
      <li><code>@typeOf</code> is renamed to {#syntax#}@TypeOf{#endsyntax#}. {#link|zig fmt#} automatically performs the conversion, and the next release of Zig after this one will remove the automatic conversion.</li>
      <li>Ability to switch on pointer types. (<a href="https://github.com/ziglang/zig/issues/4074">#4074</a>)</li>
      <li>Multiline strings in test and library names are disallowed.</li>
      <li>Zig language no longer requires the expression {#syntax#}a else unreachable{#endsyntax#} with
        {#syntax#}comptime{#endsyntax#} {#syntax#}a{#endsyntax#} to produce a
        {#syntax#}comptime{#endsyntax#} result.</li>
      <li>Timon Kruiper implemented casting between {#syntax#}[*c]T{#endsyntax#} and {#syntax#}?[*:0]T{#endsyntax#} on {#syntax#}fn{#endsyntax#} parameter. (<a href="https://github.com/ziglang/zig/issues/4176">#4176</a>)</li>
      <li>Timon Kruiper improved {#syntax#}@typeInfo{#endsyntax#} to lazily resolve declarations.
        This way all the declarations in a namespace won't be resolved until the user actually
        uses the declarations slice in the builtin TypeInfo union. (<a href="https://github.com/ziglang/zig/issues/2594">#2594</a>, <a href="https://github.com/ziglang/zig/issues/3893">#3893</a>, <a href="https://github.com/ziglang/zig/issues/4435">#4435</a>)</li>
      <li>{#syntax#}@ptrCast{#endsyntax#} supports casting a slice to a pointer.</li>
      <li>LemonBoy implemented peer type resolution between {#syntax#}?[]T{#endsyntax#} and {#syntax#}*[N]T{#endsyntax#}. (<a href="https://github.com/ziglang/zig/issues/4767">#4767</a>)</li>
      <li>There is now peer type resolution between mixed-const {#syntax#}[]T{#endsyntax#} and {#syntax#}*[N]T{#endsyntax#}. (<a href="https://github.com/ziglang/zig/issues/4766">#4766</a>)</li>
    </ul>

    <p>
    Thanks to Vexu and LemonBoy for contributions related to the above list.
    </p>

    {#header_open|Type Coercion Syntax#}
    <p>
    <strong>Type coercion</strong> (previously called "implicit casting") is now
    performed with the {#syntax#}@as{#endsyntax#} builtin, rather than by calling
    a type as a function. (<a href="https://github.com/ziglang/zig/issues/1757">#1757</a>)
    </p>
    <p>
    While a bit more verbose, Zig now has the property that all function calls are
    always function calls and not type casts, and thus it is
    <strong>no longer required for
    someone reading Zig code to know the type to determine whether something is a
    type cast or a function call</strong>.
    </p>
    <p>Type coercion is now hooked up into the result location mechanism
    and additionally now hooked up to variable declarations; this maintains the property that:
    </p>
    <pre>{#syntax#}var a: T = b;{#endsyntax#}</pre>
    <p>is semantically equivalent to:</p>
    <pre>{#syntax#}var a = @as(T, b);{#endsyntax#}</pre>
    {#header_close#}

    {#header_open|Sentinel-Terminated Pointers#}
    <p>
    With this change, one feature was added to the language, and one feature was removed.
    </p>
    <p>
    There are no longer any C string literals such as <code>c"hello"</code>. Instead,
    the type of all string literals is changed from</p>
    <p>{#syntax#}[]const u8{#endsyntax#}</p>
    <p>to</p>
    <p>{#syntax#}*const [N:0]u8{#endsyntax#}</p>
    <p>Where N is the number of bytes in the string literal.</p>
    <p>
    Let's unpack that. Reading the type from left-to-right, they are a
    <strong>reference to: an immutable array of N elements that is followed by an element with value {#syntax#}0{#endsyntax#}, the element type is {#syntax#}u8{#endsyntax#}</strong>.
    </p>
    <p>
    Note that the sentinel value is <em>not counted in the length</em>.
    </p>
    <p>
    This type has the length encoded in multiple ways. This means that it can automatically
    coerce to both {#syntax#}[]const u8{#endsyntax#} (because the length is encoded in the type),
    and it can also automatically coerce to {#syntax#}[*:0]const u8{#endsyntax#} (because both types
    are null-terminated and with the help of {#link|Slicing with Comptime Indexes#}).
    </p>
    <p>
    With this change, Zig string literals now can be passed directly to both C functions which expect null-terminated
    strings and to Zig functions which accept slices.
    </p>
    {#code_begin|exe|sentinel_ptrs#}
    {#link_libc#}
const std = @import("std");

pub fn main() void {
    do_it_the_zig_way("world");
    do_it_the_c_way("world");
}

fn do_it_the_zig_way(arg: []const u8) void {
    std.debug.warn("hello {}\n", .{arg});
}

fn do_it_the_c_way(arg: [*:0]const u8) void {
    _ = std.c.printf("hello %s\n", arg);
}
    {#code_end#}
    <p>
    Additionally, slicing syntax now has a way to assert that a sentinel exists at a particular element:
    </p>
    {#code_begin|test|slice_sentinel#}
const std = @import("std");

test "slice with sentinel" {
    var array = [_]i32{ 'a', 'b', 'c', 'd', 'e' };
    const slice = array[1..3 :'d'];
    const result = foo(slice);
    std.testing.expect(result == 'b' + 'c');
}

fn foo(s: [*:'d']i32) i32 {
    var sum: i32 = 0;
    var index: usize = 0;
    while (s[index] != 'd') : (index += 1) {
        sum += s[index];
    }
    return sum;
}
    {#code_end#}
    <p>
    If the sentinel is incorrect, a safety check is activated:
    </p>
    {#code_begin|test_err|sentinel mismatch#}
test "slice with sentinel" {
    var array = [_]i32{ 'a', 'b', 'c', 'd', 'e' };
    const slice = array[1..3 :'f'];
}
    {#code_end#}
    <p>
    Thanks to LemonBoy, Raul Leal, daurnimator, and Michael Dusan for contributions
    related to this feature.
    </p>
    {#header_close#}

    {#header_open|Remove Array-to-Reference Type Coercion#}
    <p>
    Now that {#link|Sentinel-Terminated Pointers#} is done, the main motivation for type coercion
    from array values to slices is gone. It's a footgun for Zig to automatically convert a value
    into a pointer to that value; such an operation should be explicit.
    </p>
    {#code_begin|test_err|array literal requires#}
test "coerce array value to slice" {
    var array: []const i32 = [_]i32{ 1, 2, 3, 4 };
}
    {#code_end#}
    <p>
    How to upgrade code for these new semantics:
    </p>
    {#code_begin|test|coerce_array_ptr#}
test "coerce array pointer to slice" {
    var array: []const i32 = &[_]i32{ 1, 2, 3, 4 };
}
    {#code_end#}
    <p>This change to simplifies the result location semantics, which helps with reasoning about
    Zig code, as well as reducing the complexity of a Zig compiler.</p>
    {#header_close#}

    {#header_open|Numerical Comparisons#}
    <p>
    All numerical comparisons are now allowed no matter the type combinations.
    For example, small signed integers can be compared against large unsigned integers,
    and floats can be compared against integers.
    </p>
    <p>
    For a demonstration of this, you can look at the new {#syntax#}std.math.compare{#endsyntax#}
    function added to the {#link|Standard Library#} and the test cases for it:
    </p>
    {#code_begin|test|compare#}
const std = @import("std");
const expect = std.testing.expect;

/// See also `Order`.
pub const CompareOperator = enum {
    /// Less than (`<`)
    lt,

    /// Less than or equal (`<=`)
    lte,

    /// Equal (`==`)
    eq,

    /// Greater than or equal (`>=`)
    gte,

    /// Greater than (`>`)
    gt,

    /// Not equal (`!=`)
    neq,
};

/// This function does the same thing as comparison operators, however the
/// operator is a runtime-known enum value. Works on any operands that
/// support comparison operators.
pub fn compare(a: var, op: CompareOperator, b: var) bool {
    return switch (op) {
        .lt => a < b,
        .lte => a <= b,
        .eq => a == b,
        .neq => a != b,
        .gt => a > b,
        .gte => a >= b,
    };
}

test "compare between signed and unsigned" {
    expect(compare(@as(i8, -1), .lt, @as(u8, 255)));
    expect(compare(@as(i8, 2), .gt, @as(u8, 1)));
    expect(!compare(@as(i8, -1), .gte, @as(u8, 255)));
    expect(compare(@as(u8, 255), .gt, @as(i8, -1)));
    expect(!compare(@as(u8, 255), .lte, @as(i8, -1)));
    expect(compare(@as(i8, -1), .lt, @as(u9, 255)));
    expect(!compare(@as(i8, -1), .gte, @as(u9, 255)));
    expect(compare(@as(u9, 255), .gt, @as(i8, -1)));
    expect(!compare(@as(u9, 255), .lte, @as(i8, -1)));
    expect(compare(@as(i9, -1), .lt, @as(u8, 255)));
    expect(!compare(@as(i9, -1), .gte, @as(u8, 255)));
    expect(compare(@as(u8, 255), .gt, @as(i9, -1)));
    expect(!compare(@as(u8, 255), .lte, @as(i9, -1)));
    expect(compare(@as(u8, 1), .lt, @as(u8, 2)));
    expect(@bitCast(u8, @as(i8, -1)) == @as(u8, 255));
    expect(!compare(@as(u8, 255), .eq, @as(i8, -1)));
    expect(compare(@as(u8, 1), .eq, @as(u8, 1)));
}
    {#code_end#}
    <p>Thanks to Shawn Landden for the proposal.</p>
    {#header_close#}

    {#header_open|Anonymous Struct Literals#}
      <p>
      Zig now allows omitting the struct type of a literal. When the result is
      {#link|coerced|Type Coercion Syntax#},
      the struct literal will directly instantiate the result location, with no copy:
      </p>
      {#code_begin|test|struct_result#}
const std = @import("std");
const expect = std.testing.expect;

test "anonymous struct literal" {
    checkPoint(.{
        .x = 13,
        .y = 67,
    });
}

fn checkPoint(pt: struct {x: i32, y: i32}) void {
    expect(pt.x == 13);
    expect(pt.y == 67);
}
      {#code_end#}
      <p>
      The struct type can be inferred. Here the result location does not include a type, and
      so Zig infers the type:
      </p>
      {#code_begin|test|struct_anon#}
const std = @import("std");
const expect = std.testing.expect;

test "fully anonymous struct" {
    dump(.{
        .int = 1234,
        .float = 12.34,
        .b = true,
        .s = "hi",
    });
}

fn dump(args: var) void {
    expect(args.int == 1234);
    expect(args.float == 12.34);
    expect(args.b);
    expect(args.s[0] == 'h');
    expect(args.s[1] == 'i');
}
      {#code_end#}

      <p>This syntax can also be used to initialize unions without specifying the type:</p>
      {#code_begin|test|anon_union#}
const std = @import("std");
const expect = std.testing.expect;

const Number = union {
    int: i32,
    float: f64,
};

test "anonymous union literal syntax" {
    var i: Number = .{.int = 42};
    var f = makeNumber();
    expect(i.int == 42);
    expect(f.float == 12.34);
}

fn makeNumber() Number {
    return .{.float = 12.34};
}
      {#code_end#}

    <p>Thanks to Vexu, LemonBoy, dbandstra, and Alexander Naskos for
    contributing fixes related to this feature.</p>
    {#header_close#}

    {#header_open|Tuples Added, Var Args Removed#}
    <p>Similar to
    <a href="https://ziglang.org/documentation/0.6.0/#Enum-Literals">Anonymous Enum Literals</a>
    and {#link|Anonymous Struct Literals#}, the type can be omitted from array literals.
    In this example, tuple syntax directly populates the array elements:</p>
      {#code_begin|test|tuple#}
const std = @import("std");
const expect = std.testing.expect;

test "tuple syntax" {
    var array: [4]u8 = .{11, 22, 33, 44};
    expect(array[0] == 11);
    expect(array[1] == 22);
    expect(array[2] == 33);
    expect(array[3] == 44);
}
      {#code_end#}
      <p>
      A tuple is a {#syntax#}struct{#endsyntax#} with auto-numbered field names:
      </p>
      {#code_begin|test|infer_tuple#}
const std = @import("std");
const expect = std.testing.expect;

test "fully anonymous tuple" {
    dump(.{ @as(u32, 1234), @as(f64, 12.34), true, "hi"});
}

fn dump(args: var) void {
    expect(args.@"0" == 1234);
    expect(args.@"1" == 12.34);
    expect(args.@"2");
    expect(args.@"3"[0] == 'h');
    expect(args.@"3"[1] == 'i');
}
      {#code_end#}
    <p>
    However, the {#syntax#}@""{#endsyntax#} syntax is not needed, because
    although tuples are structs, they also have array-like qualities:
    </p>
    {#code_begin|test|tuples_are_array_like#}
const std = @import("std");
const expect = std.testing.expect;

test "tuples support element access and .len field" {
    var x: i32 = 1234;
    var y: i32 = 4567;
    var tup = .{ x, y };
    tup[0] += 1; // works as long as the indexes are comptime-known
    tup[1] -= 1;

    expect(tup[0] == 1235);
    expect(tup[1] == 4566);

    // now we iterate over the fields
    var sum: i32 = 0;
    comptime var index = 0;
    inline while (index < tup.len) : (index += 1) {
        sum += tup[index];
    }
    expect(sum == 1235 + 4566);
}

test "tuple concatenation" {
    var one = .{ "hi", true };
    var two = .{ 12.34, .ok };
    var combined = one ++ two;

    expect(combined[3] == .ok);
}
    {#code_end#}
    <p>
    Zig is determined to remain a small language.
    With the addition of tuples comes the removal of variadic parameter functions (<a href="https://github.com/ziglang/zig/issues/208">#208</a>).
    Printing and formatting are no exception. Formatted printing now uses tuples
    for the parameters to print, rather than var args:
    </p>
    {#code_begin|exe|hello#}
const std = @import("std");

pub fn main() void {
    std.debug.warn("Hello, {}\n", .{"World!"});
}
    {#code_end#}
    <p>
    Note: Zig still supports C ABI functions with var args. Nothing is changed there.
    </p>
    <p>
    Zig's var args design was flawed, with many issues such as
    <a href="https://github.com/ziglang/zig/issues/557">var args can't handle void or number literal arguments</a>. With tuples, these issues are resolved.
    Zig's Tuples are much more robust and generally useful than its var args ever was.
    </p>
    <p>
    <a href="https://github.com/ziglang/zig/issues/4335">It is planned to add tuple type declaration syntax</a>.
    </p>
    <p>Thanks to Vexu, LemonBoy, dbandstra, and Alexander Naskos for fixes related to this feature.</p>
    {#header_close#}

    {#header_open|SIMD#}
    <p>
    Zig's SIMD support in 0.6.0 is still far from complete, but significant progress has been made.
    </p>
    <p>
    Vectors gain element access syntax (<a href="https://github.com/ziglang/zig/issues/3575">#3575</a>, <a href="https://github.com/ziglang/zig/issues/3580">#3580</a>).
    This introduces the concept of vector index being part of a pointer
    type. This avoids vectors having well-defined in-memory layout, and
    allows vectors of any integer bit width to work the same way.
    </p>
    <p>
    When a vector is indexed with a scalar, this is vector element access,
    which is implemented in 0.6.0. When a vector is indexed with a vector,
    this is gather/scatter, which is not available in this release.
    </p>
    {#code_begin|test|vector_elem#}
const std = @import("std");
const expect = std.testing.expect;

test "vector element access" {
    var v: @Vector(4, i32) = [_]i32{ 1, 5, 3, undefined };

    v[2] = 42;
    expect(v[1] == 5);
    v[3] = -364;
    expect(v[2] == 42);
    expect(-364 == v[3]);

    storev(&v[0], 100);
    expect(v[0] == 100);
}
fn storev(ptr: var, x: i32) void {
    ptr.* = x;
}
    {#code_end#}
    <p>
    Vectors now support comparisons, which returns a vector of {#syntax#}bool{#endsyntax#}:
    </p>
    {#code_begin|test|vector_cmp#}
const std = @import("std");
const expect = std.testing.expect;
const mem = std.mem;

test "vector comparisons" {
    var v: @Vector(4, i32) = [4]i32{ 2147483647, -2, 30, 40 };
    var x: @Vector(4, i32) = [4]i32{ 1, 2147483647, 30, 4 };
    expect(mem.eql(bool, &@as([4]bool, v == x), &[4]bool{ false, false, true, false }));
    expect(mem.eql(bool, &@as([4]bool, v != x), &[4]bool{ true, true, false, true }));
    expect(mem.eql(bool, &@as([4]bool, v < x), &[4]bool{ false, true, false, false }));
    expect(mem.eql(bool, &@as([4]bool, v > x), &[4]bool{ true, false, false, true }));
    expect(mem.eql(bool, &@as([4]bool, v <= x), &[4]bool{ false, true, true, false }));
    expect(mem.eql(bool, &@as([4]bool, v >= x), &[4]bool{ true, false, true, true }));
}
    {#code_end#}
    <p>
    Floating-point vector operations were broken; now they are fixed and no
    longer require a type parameter (<a href="https://github.com/ziglang/zig/issues/4027">#4027</a>).
    </p>
    <p>
    Vector division is now supported, including with runtime-safety checks for integer overflow (<a href="https://github.com/ziglang/zig/issues/4737">#4737</a>):
    </p>
    {#code_begin|test_safety|integer overflow#}
const std = @import("std");

test "vector division safety" {
    var a: @Vector(4, i16) = [_]i16{ 1, 2, -32768, 4 };
    var b: @Vector(4, i16) = [_]i16{ 1, 2, -1, 4 };
    const x = div(a, b);
    if (x[2] == 32767) return error.Whatever;
}
fn div(a: @Vector(4, i16), b: @Vector(4, i16)) @Vector(4, i16) {
    return @divTrunc(a, b);
}
    {#code_end#}
    <p>See <a href="https://github.com/ziglang/zig/issues/903">#903</a> for more details.</p>
    <p>
    Thanks to Shawn Landden, data-man, and LemonBoy for contributions related to SIMD.
    </p>
    {#header_close#}

    {#header_open|@newStackCall Removed#}
    <p>
    The original purpose of {#syntax#}@newStackCall{#endsyntax#} was as an exploration
    for <a href="https://github.com/ziglang/zig/issues/1006">safe recursion</a>, but
    now the plan for safe recursion is via async functions.
    </p>
    <p>
    This plus the fact that this builtin had
    <a href="https://github.com/ziglang/zig/issues/3268">serious flaws</a>,
    it is now removed from the language.
    </p>
    <p>
    Whether this builtin will be revived before Zig 1.0 or permanently gone is yet
    to be determined. To update to Zig 0.6.0, users of this builtin will have to
    resort to inline assembly.
    </p>
    {#header_close#}

    {#header_open|@call#}
      <pre>{#syntax#}@call(options: std.builtin.CallOptions, function: var, args: var) var{#endsyntax#}</pre>
      <p>
      This new builtin calls a function, in the same way that invoking an expression with
      parentheses does, except the parameters are a {#link|tuple|Tuples Added, Var Args Removed#}:
      </p>
      {#code_begin|test|call#}
const assert = @import("std").debug.assert;

test "noinline function call" {
    assert(@call(.{}, add, .{3, 9}) == 12);
}

fn add(a: i32, b: i32) i32 {
    return a + b;
}
      {#code_end#}
      <p>
      {#syntax#}@call{#endsyntax#} allows more flexibility than normal function call syntax does. The
      {#syntax#}CallOptions{#endsyntax#} struct is reproduced here:
      </p>
      {#code_begin|syntax#}
pub const CallOptions = struct {
    modifier: Modifier = .auto,

    /// Only valid when `Modifier` is `Modifier.async_kw`.
    stack: ?[]align(std.Target.stack_align) u8 = null,

    pub const Modifier = enum {
        /// Equivalent to function call syntax.
        auto,

        /// Equivalent to async keyword used with function call syntax.
        async_kw,

        /// Prevents tail call optimization. This guarantees that the return
        /// address will point to the callsite, as opposed to the callsite's
        /// callsite. If the call is otherwise required to be tail-called
        /// or inlined, a compile error is emitted instead.
        never_tail,

        /// Guarantees that the call will not be inlined. If the call is
        /// otherwise required to be inlined, a compile error is emitted instead.
        never_inline,

        /// Asserts that the function call will not suspend. This allows a
        /// non-async function to call an async function.
        no_async,

        /// Guarantees that the call will be generated with tail call optimization.
        /// If this is not possible, a compile error is emitted instead.
        always_tail,

        /// Guarantees that the call will inlined at the callsite.
        /// If this is not possible, a compile error is emitted instead.
        always_inline,

        /// Evaluates the call at compile-time. If the call cannot be completed at
        /// compile-time, a compile error is emitted instead.
        compile_time,
    };
};
      {#code_end#}
      <p>
      The builtins <code>@noInlineCall</code> and <code>@inlineCall</code> are removed;
      instead {#syntax#}@call{#endsyntax#} supports {#syntax#}.modifier = .never_inline{#endsyntax#},
      and {#syntax#}.modifier = .always_inline{#endsyntax#}.
      </p>
      <p>
      Additionally, the {#syntax#}.never_tail{#endsyntax#} and {#syntax#}.always_tail{#endsyntax#}
      modifiers are available (<a href="https://github.com/ziglang/zig/issues/3732">#3732</a>). These are still experimental; proper compile errors are
      not implemented to detect when these modifiers are used incorrectly.
      </p>
      <p>
      For an explanation of {#syntax#}.no_async{#endsyntax#}, see {#link|noasync#}.
      </p>
    <p>
    Thanks to LemonBoy for contributions related to this feature.
    </p>
    {#header_close#}

    {#header_open|callconv#}
    <p>
    Old syntax for a function that has the C calling convention:
    </p>
    <pre>{#syntax#}extern fn foo() void {}{#endsyntax#}</pre>
    <p>
    New syntax:
    </p>
    {#code_begin|syntax#}
fn foo() callconv(.C) void {}
    {#code_end#}
    <p>
    In Zig 0.6.0, {#link|zig fmt#} automatically transforms the old syntax to the new syntax.
    In Zig 0.7.0, it will no longer do that.
    </p>
    <p>
    Similarly the keywords {#syntax#}stdcallcc{#endsyntax#} and {#syntax#}nakedcc{#endsyntax#}
    are obsoleted by {#syntax#}callconv(.Stdcall){#endsyntax#} and {#syntax#}callconv(.Naked){#endsyntax#}.
    </p>
    <p>
    The enum that {#syntax#}callconv{#endsyntax#} takes as a parameter is defined in
    {#syntax#}std.builtin.CallingConvention{#endsyntax#}:
    </p>
    {#code_begin|syntax#}
pub const CallingConvention = enum {
    Unspecified,
    C,
    Cold,
    Naked,
    Async,
    Interrupt,
    Signal,
    Stdcall,
    Fastcall,
    Vectorcall,
    Thiscall,
    APCS,
    AAPCS,
    AAPCSVFP,
};
    {#code_end#}
    <p>
    This allows the calling convention of a function to depend on
    {#syntax#}comptime{#endsyntax#} logic, which can be useful for dealing with
    code that works differently on different architectures.
    </p>
    <p>
    Thanks to LemonBoy for implementing this.
    </p>
    {#header_close#}

    {#header_open|Non-Exhaustive Enums#}
      <p>
      A Non-exhaustive enum can be created by adding a trailing '_' field.
      It must specify an integer tag type and may not consume every enumeration value.
      </p>
      <p>
      <a href="https://ziglang.org/documentation/0.6.0/#intToEnum">@intToEnum</a>
      on a non-exhaustive enum never fails.
      </p>
      <p>
      A switch on a non-exhaustive enum can include a '_' prong as an alternative to an
      {#syntax#}else{#endsyntax#} prong
      with the difference being that it makes it a compile error if all the known tag names
      are not handled by the switch.
      </p>
      {#code_begin|test|switch_non_exhaustive_enum#}
const std = @import("std");
const assert = std.debug.assert;

const Number = enum(u8) {
    One,
    Two,
    Three,
    _,
};

test "switch on non-exhaustive enum" {
    const number = Number.One;
    const result = switch (number) {
        .One => true,
        .Two,
        .Three => false,
        _ => false,
    };
    assert(result);
    const is_one = switch (number) {
        .One => true,
        else => false,
    };
    assert(is_one);
}
      {#code_end#}
      <p>
      Non-exhaustive enums are useful for future-proofing code, so that it will
      continue to work correctly even when encountering values that were not
      present at the time the code was written.
      </p>
      <p>
      Various bits in the {#link|Standard Library#} have been updated to use
      non-exhaustive enums rather than numerical constants.
      </p>
    <p>
    Thanks to Vexu, LemonBoy, and daurnimator for contributions related to this feature.
    </p>
    {#header_close#}

    {#header_open|Unicode Character Literals#}
    {#code_begin|test|unicode_char_lit#}
const std = @import("std");

test "utf8 character literal" {
    const x = 'üí©';
    std.testing.expect(x == 128169);
}
    {#code_end#}
    <p>This makes sense because Zig is defined to have
      <a href="https://ziglang.org/documentation/0.6.0/#Source-Encoding">UTF-8 Source Encoding</a>.
      A unicode character literal is a {#syntax#}comptime_int{#endsyntax#} with the value
      equal to the code point.
    </p>
    <p>Thanks to Nick Erdmann for implementing this feature.</p>
    {#header_close#}

    {#header_open|Atomics#}
    <p>
    Thanks to {#link|Vexu|Please Welcome Vexu to the Core Zig Team#}:
    </p>
    <ul>
      <li>Atomic operations additionally support enums, bools, non-power-of-two integers, and floats.</li>
      <li>There is a new {#syntax#}@atomicStore{#endsyntax#} builtin.</li>
      <li>{#syntax#}@cmpxchgWeak{#endsyntax#}, {#syntax#}@cmpxchgStrong{#endsyntax#}, and
        {#syntax#}@atomicRmw{#endsyntax#} now support being evaluated in
        {#syntax#}comptime{#endsyntax#} code.</li>
    </ul>
    {#header_close#}

    {#header_open|Container-Level Doc Comments#}
    {#code_begin|syntax#}
//! This is a container doc comment, which applies to the
//! entire file rather than the `foo` declaration below.

/// This is a declaration doc comment, which applies to
/// the `foo` declaration below.
const foo = bar;
    {#code_end#}
    <p>Thanks Marc Tiehuis for the proposal (<a href="https://github.com/ziglang/zig/issues/2288">#2288</a>) and
    Vexu for the implementation (<a href="https://github.com/ziglang/zig/issues/3697">#3697</a>).</p>
    {#header_close#}

    {#header_open|Comptime Struct Fields#}
    {#code_begin|test|comptime_struct_field#}
const std = @import("std");

const Foo = struct {
    a: i32,
    comptime b: i32 = 1234,
};

test "example" {
    var foo: Foo = undefined;
    comptime std.debug.assert(foo.b == 1234);
}
    {#code_end#}
    <p>
    A comptime struct field requires a default initialization value.
    Loads from a comptime struct field result in a comptime value of the
    default initialization value.
    Stores to a comptime struct field assert that the stored value is the
    default initialization value.
    </p>
    <p>
    Generally, one should use a global const instead of a comptime field.
    The reason for using a comptime field is when you want reflection over
    struct fields to find the data as a field. For example:
    </p>
    {#code_begin|exe|csf_example#}
const std = @import("std");

fn dump(args: var) void {
    inline for (std.meta.fields(@TypeOf(args))) |field| {
        std.debug.warn("{} = {}\n", .{field.name, @field(args, field.name)});
    }
}

pub fn main() void {
    var runtime_float: f32 = 12.34;
    dump(.{
        .int = 1234,
        .float = runtime_float,
        .b = true,
        .s = "hi",
        .T = [*]f32,
    });
}
    {#code_end#}
    <p>
    This will construct an anonymous struct with all comptime fields
    (except {#syntax#}float{#endsyntax#}) and pass it to {#syntax#}dump{#endsyntax#}.
    Each iteration in the for loop will evaluate the {#syntax#}@field(...){#endsyntax#}
    expression and produce a comptime value, except {#syntax#}float{#endsyntax#}, which will
    be a runtime value.
    </p>
    <p>
    This feature makes formatted printing, and {#link|tuples|Tuples Added, Var Args Removed#}
    in general, support mixed comptime and runtime values (<a href="https://github.com/ziglang/zig/issues/3677">#3677</a>).
    </p>
    {#header_close#}

    {#header_open|Untyped Struct Fields#}
    <p>
    It's now possible to omit the type from struct fields. This allows the field
    to have any value of any type. The catch is that it causes the entire struct
    to be required to be {#syntax#}comptime{#endsyntax#}-known.
    </p>
    {#code_begin|test|untyped_struct_fields#}
const std = @import("std");
const expect = std.testing.expect;

test "struct with var field" {
    const Point = struct {
        x: var,
        y: var,
    };
    comptime var pt = Point {
        .x = 1,
        .y = 2,
    };
    expect(pt.x == 1);
    expect(pt.y == 2);

    pt.x = true;
    pt.y = "hello";
    expect(pt.x);
    expect(std.mem.eql(u8, pt.y, "hello"));
}
    {#code_end#}
    <p>
    The motivation behind this feature is to expose default struct field initialization values
    and sentinel values in {#syntax#}@typeInfo{#endsyntax#}:
    </p>
    {#code_begin|syntax#}
pub const StructField = struct {
    name: []const u8,
    offset: ?comptime_int,
    field_type: type,
    default_value: var,
};
    {#code_end#}
    <p>
    With Zig 0.6.0, this works now:
    </p>
    {#code_begin|test|type_info_struct#}
const std = @import("std");
const expect = std.testing.expect;

test "access default initialization value" {
    const Foo = struct {
        x: i32 = 1234,
        y: i32,
    };
    const info = @typeInfo(Foo).Struct;
    expect(info.fields[0].default_value.? == 1234);
    expect(info.fields[1].default_value == null);
}
    {#code_end#}
    <p>
    Similarly, the {#syntax#}@typeInfo{#endsyntax#} for {#link|Sentinel-Terminated Pointers#}
    now exposes the sentinel value.
    </p>
    <p>
    <a href="https://github.com/ziglang/zig/issues/4820">It is planned to rename
    {#syntax#}var{#endsyntax#} to {#syntax#}anytype{#endsyntax#} in this context</a>,
    to disambiguate it from variable declarations.
    </p>
    <p>
    Thanks to LemonBoy for contributions related to this feature.
    </p>
    {#header_close#}

    {#header_open|Pointer Arithmetic and Alignment#}
    <p>
    Pointer arithmetic now appropriately modifies the alignment of a pointer type:
    </p>
    {#code_begin|test|ptr_arith_align#}
const std = @import("std");
const expect = std.testing.expect;

test "pointer math alignment" {
    var arr: [10]u8 align(4) = undefined;
    var runtime_known_2: usize = 2;

    const ptr: [*]u8 = &arr;
    const ptr2 = ptr + 1;
    const ptr3 = ptr + 2;
    const ptr4 = ptr + runtime_known_2;

    comptime {
        expect(@TypeOf(ptr) == [*]align(4) u8);
        expect(@TypeOf(ptr2) == [*]u8);
        expect(@TypeOf(ptr3) == [*]align(2) u8);
        expect(@TypeOf(ptr4) == [*]u8);
    }
}
    {#code_end#}
    <p>
    Thanks to LemonBoy for implementing this (<a href="https://github.com/ziglang/zig/issues/1528">#1528</a>).
    </p>
    {#header_close#}

    {#header_open|@export#}
    <pre>{#syntax#}@export(target: var, comptime options: std.builtin.ExportOptions) void{#endsyntax#}</pre>
    <p>
    {#syntax#}@export{#endsyntax#} now uses {#syntax#}std.builtin.ExportOptions{#endsyntax#}
    to accept its parameters:
    </p>
    {#code_begin|syntax#}
pub const ExportOptions = struct {
    name: []const u8,
    linkage: GlobalLinkage = .Strong,
    section: ?[]const u8 = null,
};
    {#code_end#}
    <p>
    The {#syntax#}section{#endsyntax#} option is new; it is now possible to specify the
    {#syntax#}linksection{#endsyntax#} using {#syntax#}@export{#endsyntax#}.
    </p>
    <p>
    Thanks LemonBoy for implementing this (<a href="https://github.com/ziglang/zig/issues/2679">#2679</a>).
    </p>
    {#header_close#}

    {#header_open|@bitSizeOf#}
    <pre>{#syntax#}@bitSizeOf(comptime T: type) comptime_int{#endsyntax#}</pre>
    <p>
    This function returns the number of bits it takes to store {#syntax#}T{#endsyntax#} in memory.
    The result is a target-specific compile time constant.
    </p>
    <p>
    This function measures the size allocated at runtime. For types that are disallowed at runtime,
    such as {#syntax#}comptime_int{#endsyntax#} and {#syntax#}type{#endsyntax#}, the result is
    {#syntax#}0{#endsyntax#}.
    </p>
    <p>
    Note that this value does not necessarily equal {#syntax#}@sizeOf(T) * 8{#endsyntax#}.
    For example, {#syntax#}@bitSizeOf(u7){#endsyntax#} is {#syntax#}7{#endsyntax#}, but
    {#syntax#}@sizeOf(u7){#endsyntax#} is {#syntax#}1{#endsyntax#}.
    </p>
    <p>
    When the
    <a href="https://github.com/ziglang/zig/issues/3802">accepted proposal for align(0) fields</a>
    is implemented, {#syntax#}@bitSizeOf{#endsyntax#} measures how many bits a type would take up
    in a struct if all fields were {#syntax#}align(0){#endsyntax#}.
    </p>
    <p>
    Thanks to Vexu for the implementation of this.
    </p>
    {#header_close#}

    {#header_open|No More Capture Aliasing#}
    <p>
    Captured payloads from optionals and tagged-unions are no longer aliases to
    the same memory of the optional or tagged-union. The (unwrapped) payloads are
    copies.
    </p>
    {#code_begin|test|no_capture_aliasing#}
const std = @import("std");
const expect = std.testing.expect;

test "no capture value aliasing" {
    // In Zig 0.5.0, foo() returns 5678.
    expect(foo() == 1234);
}

fn foo() i32 {
    var optional_x: ?i32 = 1234;

    if (optional_x) |x| {
        optional_x = 5678;
        return x;
    }

    unreachable;
}
    {#code_end#}
    <p>
    There are two competing proposals for non-copyable data structures:
    <a href="https://github.com/ziglang/zig/issues/3803">#3803</a>
    <a href="https://github.com/ziglang/zig/issues/3804">#3804</a>
    </p>
    <p>
    When one of these is accepted, it will be a compile error to copy some types.
    To avoid copying, one can denote the capture value to make it a pointer:
    </p>
    {#code_begin|test|capture_aliasing#}
const std = @import("std");
const expect = std.testing.expect;

test "capture value aliasing" {
    expect(foo() == 5678);
}

fn foo() i32 {
    var optional_x: ?i32 = 1234;

    if (optional_x) |*x| {
        optional_x = 5678;
        return x.*;
    }

    unreachable;
}
    {#code_end#}
    <p>
    Thanks to LemonBoy for implementing this.
    </p>
    {#header_close#}

    {#header_open|noasync#}
    <p>
    {#syntax#}noasync{#endsyntax#}, similar to {#syntax#}comptime{#endsyntax#}, creates a scope
    in which the programmer asserts there will be no suspension points.
    </p>
    <p>
    Normally, async function calls and awaiting an async function frame introduce a
    <strong>suspension point</strong> at the callsite, causing the containing function
    to have the {#syntax#}async{#endsyntax#} calling convention.
    However, inside a {#syntax#}noasync{#endsyntax#} scope, async function calls and
    awaiting async function frames do not cause a suspension point. Instead, the code
    asserts that the callee never suspends, or in the case of {#syntax#}await{#endsyntax#},
    that the function frame already has the result completed.
    </p>
    <p>
    This allows a non-async function to call an async function:
    </p>
    {#code_begin|test|noasync#}
const std = @import("std");
const expect = std.testing.expect;

test "noasync function call" {
    const result = noasync add(50, 100);
    expect(result == 150);
}

fn add(a: i32, b: i32) i32 {
    if (a > 100) {
        suspend;
    }
    return a + b;
}
    {#code_end#}
    <p>
    This is especially useful for {#syntax#}main(){#endsyntax#} to set up
    async functions initially:
    </p>
    {#code_begin|exe|async_main#}
const std = @import("std");
const expect = std.testing.expect;

var global_frame_1: anyframe = undefined;
var global_frame_2: anyframe = undefined;

pub fn main() void {
    var main_frame = async asyncMain();
    resume global_frame_1;
    resume global_frame_2;
    const result = noasync await main_frame;
    std.debug.warn("result: {}\n", .{result});
}

fn asyncMain() i32 {
    var a = async foo();
    var b = async bar();
    return await a + await b;
}

fn foo() i32 {
    global_frame_1 = @frame();
    suspend;
    return 1;
}

fn bar() i32 {
    global_frame_2 = @frame();
    suspend;
    return 2;
}
    {#code_end#}
    <p>
    Notice that the function {#syntax#}asyncMain{#endsyntax#} is able to participate in the
    async/await abstraction without having to care about the setup and teardown happening
    in {#syntax#}main{#endsyntax#}.
    </p>
    <p>
    For {#link|Async I/O#} in the {#link|Standard Library#}, Zig handles this setup and teardown
    in the {#link|Start Code#} that calls {#syntax#}main{#endsyntax#}.
    </p>
    <p>
    Now, watch what happens when we remove {#syntax#}noasync{#endsyntax#} from the above example:
    </p>
    {#code_begin|exe_build_err|oops_await#}
const std = @import("std");
const expect = std.testing.expect;

var global_frame_1: anyframe = undefined;
var global_frame_2: anyframe = undefined;

pub fn main() void {
    var main_frame = async asyncMain();
    resume global_frame_1;
    resume global_frame_2;
    const result = await main_frame;
    std.debug.warn("result: {}\n", .{result});
}

fn asyncMain() i32 {
    var a = async foo();
    var b = async bar();
    return await a + await b;
}

fn foo() i32 {
    global_frame_1 = @frame();
    suspend;
    return 1;
}

fn bar() i32 {
    global_frame_2 = @frame();
    suspend;
    return 2;
}
    {#code_end#}
    <p>
    Here, the {#syntax#}await{#endsyntax#} inside {#syntax#}main{#endsyntax#} is a
    suspension point, which causes {#syntax#}main{#endsyntax#} to have the
    async calling convention, which has a cascading effect, causing {#syntax#}_start{#endsyntax#}
    to have the async calling convention. But {#syntax#}_start{#endsyntax#} already has the
    "naked" calling convention, because it is the entry point from the kernel!
    </p>
    <p>
    We can use {#syntax#}noasync{#endsyntax#} to create a "seam" between async code and blocking
    code, because in this example, we know that {#syntax#}main_frame{#endsyntax#} has already
    completed by the time we call {#syntax#}await{#endsyntax#}.
    </p>
    <p>
    Thanks to Vexu for contributions related to this feature.
    </p>
    {#header_close#}

    {#header_open|Deprecated Builtins Removed#}
    <p>
    Many deprecated builtins have been removed.
    </p>
    <p>
    Thanks to Maciej Walczak for removing these and implementing the corresponding std lib functions:
    </p>
    <ul>
      <li>{#syntax#}@bytesToSlice{#endsyntax#} becomes {#syntax#}mem.bytesAsSlice{#endsyntax#}</li>
      <li>{#syntax#}@sliceToBytes{#endsyntax#} becomes {#syntax#}mem.sliceAsBytes{#endsyntax#}</li>
    </ul>
    <p>
    Thanks to Vexu for removing these:
    </p>
    <ul>
      <li>{#syntax#}@typeId{#endsyntax#} becomes {#syntax#}@typeInfo{#endsyntax#} tag-type</li>
      <li>{#syntax#}@memberCount{#endsyntax#} becomes {#syntax#}std.meta.fields(T).len{#endsyntax#}</li>
      <li>{#syntax#}@memberName{#endsyntax#} becomes {#syntax#}std.meta.fields(T)[i].name{#endsyntax#}</li>
      <li>{#syntax#}@memberType{#endsyntax#} becomes {#syntax#}std.meta.fields(T)[i].field_type{#endsyntax#}</li>
      <li>{#syntax#}@ArgType{#endsyntax#} becomes {#syntax#}@typeInfo(T).Fn.args[i].arg_type.?{#endsyntax#}</li>
      <li>{#syntax#}@IntType{#endsyntax#} becomes {#syntax#}std.meta.IntType{#endsyntax#}</li>
    </ul>
    {#header_close#}

    {#header_open|Allow Empty Inferred Error Sets#}
    <p>
    The body of functions returning inferred error sets are no longer required
    to return any possible errors.
    </p>
    {#code_begin|test|empty_inferred_error_set#}
fn foo() !void {}

test "" {
    foo() catch |err| switch (err) {};
}
    {#code_end#}
    <p>
    Thanks to LemonBoy for implementing this.
    </p>
    {#header_close#}

    {#header_open|@TypeOf Supports Multiple Parameters#}
    <p>
    Multiple parameters can now be specified with {#syntax#}@TypeOf{#endsyntax#} in cases where
    <a href="https://ziglang.org/documentation/0.6.0/#Peer-Type-Resolution">Peer Type Resolution</a>
    is needed.
    </p>
    {#code_begin|syntax#}
// std.math.max
pub fn max(x: var, y: var) @TypeOf(x, y) {
    return if (x > y) x else y;
}
    {#code_end#}
    <p>
    Thanks to Josh Wolfe for proposal and LemonBoy for implementing this.
    </p>
    {#header_close#}

    {#header_open|Underscore Separators in Number Literals#}
    <p>
    Underscores may be placed between two digits as a visual separator.
    Consecutive underscores are not allowed.
    </p>
    {#code_begin|syntax#}
fn digits() void {
    _ = 1_234_567;
    _ = 0xff00_00ff;
    _ = 0b10000000_10101010;
    _ = 0b1000_0000_1010_1010;
    _ = 0x123_190.109_038_018p102;
    _ = 3.14159_26535_89793;
}
    {#code_end#}
    <p>
    Thanks to Marc Tiehuis for original proposal and momumi for making a strong case
    to re-open the proposal, and for implementing it.
    </p>
    {#header_close#}

    {#header_open|Slicing with Comptime Indexes#}
    <p>
    When slicing where the length is comptime-known, the expression type is now
    a single-item pointer to array {#syntax#}*[N]T{#endsyntax#} .
    Prior to this change an error-prone {#syntax#}@ptrCast{#endsyntax#} was required.
    </p>
    {#code_begin|test|slice_comptime_indexes#}
const std = @import("std");
const assert = std.debug.assert;

test "slicing with comptime indexes" {
    var a = "abcdefgh".*;
    assert(@TypeOf(a) == [8:0]u8);

    // both indices are comptime, thus length is comptime
    var b = a[3..6];
    assert(@TypeOf(b) == *[3]u8);

    // length is runtime
    var runtime_i: usize = 3;
    var c = a[runtime_i..6];
    assert(@TypeOf(c) == []u8);

    // copy array
    a[0..3].* = a[5..8].*;
    assert(std.mem.eql(u8, &a, "fghdefgh"));
}
    {#code_end#}
    <p>
    Thanks to Jimmi Holst Christensen for proposing this.
    </p>
    {#header_close#}

    {#header_open|errdefer Payload#}
    <p>
    {#syntax#}errdefer{#endsyntax#} now provides syntax to access the in-flight error.
    </p>
    {#code_begin|test|errdefer_payload#}
const std = @import("std");

fn perform() !void {
    errdefer |err| std.debug.assert(err == error.Overflow);
    _ = try std.math.add(u8, 255, 1);
}

test "errdefer with payload" {
    perform() catch return;
    unreachable;
}
    {#code_end#}
    <p>
    Thanks to Byron Heads for the proposal and LemonBoy for implementing this.
    </p>
    <p>Follow-up proposal: <a href="https://github.com/ziglang/zig/issues/5018">errdefer with unreachable should allow function type to not have an error union</a></p>
    {#header_close#}

    {#header_close#}

    {#header_open|Standard Library#}
    <p>
    There are so many breaking changes that it is not feasible to list them all here. Instead,
    the release notes will cover contributions and high-level topics. In the future, it should
    be possible to use the same backend of {#link|Documentation Generation#} to make a tool
    that detects all API changes - additions, removals, and modifications.
    </p>
    <ul>
      <li>Various contributors updated the standard library to use newer Zig syntax, such as
      anonymous enum literals, and to fix regressions from breaking language changes.</li>
      <li>LemonBoy added support for the statx syscall.</li>
      <li>Jonathan Marler fixed accept function API.</li>
      <li>std.os.accept4: improve docs and integrate with evented I/O</li>
      <li>Jonathan Marler improved TTY detection to take into account TERM=dumb.</li>
      <li>{#syntax#}std.os.dup2{#endsyntax#} makes EBADF more obvious in stack traces.</li>
      <li>daurnimator updated the standard library OS bits to Linux 5.6, added missing OS bits,
        organized declarations, and swapped constants for {#link|Non-Exhaustive Enums#}.</li>
      <li>Brendan Hansknecht improved big ints to use the more efficient karatsuba algorithm
        for multiplication.</li>
      <li>daurnimator contributed LinearFifo which is useful for buffers. schroffl and Tetralux
        contributed improvements.</li>
      <li>{#syntax#}std.ChildProcess.spawn{#endsyntax#} now has a consistent error set across targets.</li>
      <li>{#syntax#}std.io.getStdOut{#endsyntax#} and related functions no longer can error.
        Thanks to the
        <a href="https://en.wikipedia.org/wiki/Process_Environment_Block">Windows Process Environment Block</a>,
        it is possible to obtain handles
      to the standard input, output, and error streams without the possibility of failure.</li>
      <li>dbandstra added {#syntax#}std.math.tau{#endsyntax#} constant (equivalent to {#syntax#}2 * pi{#endsyntax#}).</li>
      <li>Johan Bolmsj√∂ improved {#syntax#}std.testing.expectEqual{#endsyntax#} to show differing pointer values, avoiding confusion when the values pointed to are the same.</li>
      <li>{#syntax#}std.heap.direct_allocator{#endsyntax#} is renamed to {#syntax#}std.heap.page_allocator{#endsyntax#}, to make it more clear that this is not an appropriate general-purpose allocator.</li>
      <li>Benjamin Feng size-optimized the std.sort internal binary search algorithm.</li>
      <li>LemonBoy added {#syntax#}std.sort.binarySearch{#endsyntax#}. (<a href="https://github.com/ziglang/zig/issues/4337">#4337</a>)</li>
      <li>{#syntax#}std.elf{#endsyntax#} API updated to remove redundant namespacing, and
        integrate with {#syntax#}std.Target.Arch{#endsyntax#}.</li>
      <li>Felix Quei√üner implemented {#syntax#}std.testing.expectEqual{#endsyntax#} for tagged unions. (<a href="https://github.com/ziglang/zig/issues/3773">#3773</a>)
      </li>
      <li>{#syntax#}std.math{#endsyntax#}: remove constants that should be expressions. There were
        four cases where the value can be represented in fewer characters with
        expressions, which will be guaranteed to happen at compile-time, and
        have the same or better precision.
      </li>
      <li>Robin Voetter made improvements to {#syntax#}std.sort{#endsyntax#}:<ul>
          <li>Added {#syntax#}isSorted{#endsyntax#}.</li>
          <li>Updated {#syntax#}max{#endsyntax#} to accept const slices, and added tests.</li>
          <li>Updated {#syntax#}min{#endsyntax#} and {#syntax#}max{#endsyntax#} to return {#syntax#}?T{#endsyntax#}.</li>
          <li>Added {#syntax#}argMax{#endsyntax#} and {#syntax#}argMin{#endsyntax#} which return indexes rather than values.</li>
        </ul>
      </li>
      <li>{#syntax#}std.fmt.ParseUnsignedError{#endsyntax#} is now public.</li>
      <li>frmdstryr put in a hot path for {#syntax#}std.io.BufferedInStream.readByte{#endsyntax#},
      speeding it up by ~75% (<a href="https://github.com/ziglang/zig/issues/3858">#3858</a>).</li>
      <li>Dynamic library loading API functions are improved to follow the standard conventions
          with regards to filename parameters.</li>
      <li>LemonBoy improved {#syntax#}std.ChildProcess{#endsyntax#} to use eventfds on Linux
        rather than pipe for communicating an error from child to parent process. (<a href="https://github.com/ziglang/zig/issues/819">#819</a>)</li>
      <li>Dmitry Atamanov and daurnimator improved
        {#syntax#}std.unicode.utf8ToUtf16Le{#endsyntax#} to support surrogate pairs. (<a href="https://github.com/ziglang/zig/issues/3923">#3923</a>)</li>
      <li>daurnimator improved the performance of unicode functions. (<a href="https://github.com/ziglang/zig/issues/3987">#3987</a>)</li>
      <li>daurnimator updated {#syntax#}std.meta.TagPayloadType{#endsyntax#} to take the tag type of the union.</li>
      <li>lukechampine implemented ChaCha20-Poly1305 AEAD. (<a href="https://github.com/ziglang/zig/issues/4011">#4011</a>)</li>
      <li>Luna added {#syntax#}std.os.memfd_create{#endsyntax#}. (<a href="https://github.com/ziglang/zig/issues/3687">#3687</a>)</li>
      <li>data-man added {#syntax#}std.os.getrusage{#endsyntax#}. (<a href="https://github.com/ziglang/zig/issues/3854">#3854</a>)</li>
      <li>Nathan Michaels added removeIndex function to PriorityQueue. (<a href="https://github.com/ziglang/zig/issues/4070">#4070</a>)</li>
      <li>Jonathan Marler added {#syntax#}std.os.windows.WaitForSingleObject{#endsyntax#}.</li>
      <li>Hersh Krishna added {#syntax#}std.math.clamp{#endsyntax#}.</li>
      <li>Shawn Landden made breaking changes to {#syntax#}std.rb{#endsyntax#} to make it thread-safe.</li>
      <li>daurnimator updated {#syntax#}std.mem.Allocator{#endsyntax#} interface to set
        memory to undefined when freed (<a href="https://github.com/ziglang/zig/issues/4087">#4087</a>). However note that it is
        <a href="https://github.com/ziglang/zig/issues/4298">planned to revert this and implement this as part of allocator implementations rather than the interface</a>.
      </li>
      <li>LemonBoy made {#syntax#}writeByteNTimes{#endsyntax#} faster and leaner.</li>
      <li>nofmal added a basic Linux termios implementation.</li>
      <li>Felix (xq) Quei√üner made {#syntax#}std.heap.ArenaAllocator.deinit{#endsyntax#} not require a mutable reference.</li>
      <li>Implement {#syntax#}std.os.faccessat{#endsyntax#} for Windows.</li>
      <li>Support the concept of a target not having a dynamic linker.</li>
      <li>Improved handling of environment variables on Windows.<ul>
          <li>
            std.os.getenv and std.os.getenvZ have nice compile errors when not linking
            libc and using Windows.
          </li>
          <li>
            std.os.getenvW is provided as a Windows-only API that does not require
            an allocator. It uses the Process Environment Block.
            std.process.getEnvVarOwned is improved to be a simple wrapper on top of
            std.os.getenvW.
          </li>
          <li>
            std.process.getEnvMap is improved to use the Process Environment Block
            rather than calling GetEnvironmentVariableW.
          </li>
          <li>
            std.zig.system.NativePaths uses process.getEnvVarOwned instead of
            std.os.getenvZ, which works on Windows as well as POSIX.
          </li>
        </ul>
      </li>
      <li>Heide Onas Auri improved {#syntax#}std.time.Timer.lap{#endsyntax#} to only
      read system time once. (<a href="https://github.com/ziglang/zig/issues/4533">#4533</a>)</li>
      <li>{#syntax#}std.Thread.cpuCount{#endsyntax#} on Windows uses the PEB,
        rather than calling GetSystemInfo from kernel32.dll. Also remove OutOfMemory
        from the error set.</li>
      <li>Jared Miller implemented {#syntax#}std.unicode.utf8ToUtf16LeStringLiteral{#endsyntax#}
        which can be used to provide convenient "wide string literals": {#syntax#}w("foo"){#endsyntax#}
      </li>
      <li>LemonBoy added {#syntax#}std.os.fnctl{#endsyntax#}</li>
      <li>Joachim Schmidt improved bigint comparison code to use {#syntax#}math.Order{#endsyntax#} rather than {#syntax#}i8{#endsyntax#} (<a href="https://github.com/ziglang/zig/issues/4791">#4791</a>)</li>
      <li>Ilmari Autio improved {#syntax#}std.os.getenv{#endsyntax#} and related functions to be
        ascii-case-insensitive on Windows. (<a href="https://github.com/ziglang/zig/issues/4608">#4608</a>)</li>
      <li>joachimschmidt557 moved {#syntax#}std.big.rational.gcd{#endsyntax#} to {#syntax#}std.big.int.gcd{#endsyntax#}</li>
      <li>Phil Schumann improved {#syntax#}std.zig.parseStringLiteral{#endsyntax#} to support
        hex and unicode escapes. (<a href="https://github.com/ziglang/zig/issues/4678">#4678</a>)</li>
      <li>
        {#syntax#}std.io.readLine{#endsyntax#} is removed.
        <br><br>
        This was deceptive. It was always meant to be sort of a "GNU readline"
        sort of thing where it provides a Command Line Interface to input text.
        However that functionality did not exist and it was basically a red
        herring for people trying to read line-delimited input from a stream.
        (See {#link|I/O Streams#} for that.) The API is now deleted, so that
        people can find the proper API more easily.
        <br><br>
        A CLI text input abstraction would be useful but may not even need to be
        in the standard library. The guess_number CLI game example gets by just
        fine by using {#syntax#}std.fs.File.read{#endsyntax#}.
      </li>
      <li>
        {#syntax#}std.os.execvpe{#endsyntax#} related functions support optionally expanding argv[0] into the absolute
        path based on the PATH environment variable. This can be useful to work around a third
        party program which improperly uses {#syntax#}argv[0]{#endsyntax#} to find the path to its own executable.
      </li>
      <li>
        {#syntax#}std.os.execve{#endsyntax#} had the wrong name; it should have been
        {#syntax#}std.os.execvpe{#endsyntax#}. This is now corrected. It is also
        improved to handle {#syntax#}ENOTDIR{#endsyntax#} (<a href="https://github.com/ziglang/zig/issues/3415">#3415</a>).
      </li>
      <li>
        Introduce {#syntax#}std.os.execveZ{#endsyntax#} which does not look at PATH, and uses
        null terminated parameters, matching POSIX ABIs. It does not require an allocator.
      </li>
      <li>
        Introduce {#syntax#}std.os.execvpeZ{#endsyntax#}, which is like {#syntax#}execvpe{#endsyntax#}
        except it uses null terminated parameters, matching POSIX ABIs, and thus
        does not require an allocator.
      </li>
      <li>
        Sebastian Keller added std.math constants such as log2e and sqrt2.
        Note that with <a href="https://github.com/ziglang/zig/issues/425">#425</a> solved these would not be needed, and would be removed.
      </li>
    </ul>

    {#header_open|Async I/O#}
    <p>
    Async I/O in 0.6.0 is still experimental, but rapidly approaching usable.
    </p>
    <p>
    kprotty contributed significant improvements to synchronization primitives. kprotty writes:
    </p>
    <p>{#syntax#}std.Mutex{#endsyntax#} uses a simple locking scheme for Linux,
    relies on CriticalSection for Windows and falls back to spinlocking on other platforms.
    There are two parts towards improving it:</p>
    <p><strong>1) Adaptive Locking</strong></p>
    <p>
    For high contention cases, eager blocking mutexes incur a penalty of a syscall when they
    may not need to. In order to address this, the mutex can spin for a little bit trying to
    acquire the lock similar to a spinlock before deciding to block. This improves performance
    when the time spent in the critical section is minimal and acquiring/releasing is done
    frequently. The implementation chosen for this was that of lock_futex.go from Golang 1.13
    as it provides a nice balance between spinning and deciding to block (another possibility
    could be rust/webkit <code>parking_lot</code>). Because this implementation only needs a futex interface,
    it can be reused:
    </p>
    <p><strong>2) Parker API</strong></p>
    <p>
    Most synchronization primitives such as Mutexes, RwLocks, Condvars, Events and Semaphores
    can be built upon atomic instructions and futexes for handling blocking. Another point of
    this change was to setup a cross-platform futex (Parker) interface in which other primitives
    as listed above could be built off of. The default one provided is
    {#syntax#}ThreadParker{#endsyntax#} which differs from the current blocking implementation scheme:
    </p>
    <ul>
      <li>On Windows, it detects at runtime whether to use WaitOnAddress
        (supported since Win8+ and most similar to linux futex) or NT Keyed Events
        (supported since WinXP+ and is the inner backing of CriticalSection).
        This allows the distinction between std.Mutex and std.StaticallyInitializedMutex to
        dissapear as it can now be initialized statically
      </li>
      <li>On POSIX platforms, it uses {#syntax#}pthread_cond_t{#endsyntax#} for synchronization
        which also supports static initialization. This fares better for longer blocking
        critical sections compared to the spinlock default of the current std.Mutex implementation.
      </li>
      <li>On Linux, it still uses {#syntax#}linux_futex{#endsyntax#} so not many improvements
        besides adaptive spinning there
      </li>
    </ul>
    <p><strong>Results &amp; Future Implications</strong></p>
    <p>
    Because the Parker now has a standardized interface, one could replace
    {#syntax#}ThreadParker{#endsyntax#} with something like {#syntax#}AsyncParker{#endsyntax#}
    and reuse the synchronization primitive code for {#syntax#}std.event{#endsyntax#}
    synchronization objects. In order to demonstrate this, kprotty provided some example
    code for {#syntax#}AsyncParker{#endsyntax#} as well as a naive benchmark to test
    the performance of {#syntax#}std.Mutex{#endsyntax#} in comparison to this new adaptive
    mutex: <a href="https://github.com/kprotty/zig-adaptive-lock/">zig-adaptive-lock</a>
    </p>
    <p>
    The results for high contended, small critical section cases are promising:
    </p>
    <ul>
      <li>Windows 10: 7-8x speedup</li>
      <li>MacOSX: 19-22x speedup</li>
      <li>Linux (Pthread): 2x speedup</li>
      <li>Linux (Futex): 2x speedup</li>
    </ul>
    <p>
    These synchronization primitives are building blocks for an <strong>event loop</strong>,
    which is what drives async I/O.
    </p>
    <p>
    In 0.6.0, you can start to see the ideas behind the standard library's event loop
    coming together. Notably, {#link|Start Code#} will set up an event loop before
    calling main(), when the root source file defines:
    </p>
    {#code_begin|syntax#}
pub const io_mode = .evented;
    {#code_end#}
    <p>
    This means that
    <em>main() is now allowed to use {#syntax#}await{#endsyntax#}</em>.
    Same with tests, and <code>zig test</code> supports
    <code>--test-evented-io</code> which affects whether the test runner sets
    {#syntax#}io_mode{#endsyntax#} to evented or blocking.
    </p>
    <p>
    The standard library's async I/O integration, together with {#link|I/O Streams#} improvements, are
    now capable of passing behavior tests with <code>--test-evented-io</code> enabled.
    Standard library tests are now compiling successfully with evented I/O mode, but the
    event loop implementation needs to be improved in order for tests to pass. Additionally,
    "glue" code is needed to be added to the event loop implementation to support more
    operating systems. It's not quite stable enough to be added to CI {#link|Test Coverage#}.
    </p>
    <p>
    In previous versions of Zig, there was a {#syntax#}std.event{#endsyntax#} namespace for APIs
    that only applied to evented I/O, but in this release, many of these APIs have been removed,
    superceded by normal APIs integrating properly into async I/O. For example,
    {#syntax#}std.event.fs{#endsyntax#} is removed and all the normal {#syntax#}std.fs{#endsyntax#}
    ({#link|Filesystem#}) APIs work correctly for both blocking and evented I/O modes.
    </p>
    <p>
    Here is an example of a simple program that writes to a file:
    </p>
    {#code_begin|exe|write_file_blocking#}
const std = @import("std");

pub fn main() anyerror!void {
    const file = try std.fs.cwd().createFile("hello.txt", .{});
    defer file.close();

    try file.writeAll("hello\n");
}
    {#code_end#}
    <p>
    Looking at the strace, we can see it is quite simple:
    </p>
    <pre><code>arch_prctl(ARCH_SET_FS, 0x233190)       = 0
rt_sigaction(SIGSEGV, {sa_handler=0x22a8d0, sa_mask=[], sa_flags=SA_RESTORER|SA_RESTART|SA_RESETHAND|SA_SIGINFO, sa_restorer=0x204310}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
rt_sigaction(SIGILL, {sa_handler=0x22a8d0, sa_mask=[], sa_flags=SA_RESTORER|SA_RESTART|SA_RESETHAND|SA_SIGINFO, sa_restorer=0x204310}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
rt_sigaction(SIGBUS, {sa_handler=0x22a8d0, sa_mask=[], sa_flags=SA_RESTORER|SA_RESTART|SA_RESETHAND|SA_SIGINFO, sa_restorer=0x204310}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
openat(AT_FDCWD, "hello.txt", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 3
write(3, "hello\n", 6)                  = 6
close(3)                                = 0
exit_group(0)                           = ?</code></pre>
    <p>
    Set up thread-local storage, attach some signal handlers for
    {#link|debugging|Debug Info and Stack Traces#}, openat, write, close, done.
    Now we enable evented I/O:
    </p>
    {#code_begin|exe|write_file_evented#}
const std = @import("std");

pub const io_mode = .evented;

pub fn main() anyerror!void {
    const file = try std.fs.cwd().createFile("hello.txt", .{});
    defer file.close();

    try file.writeAll("hello\n");
}
    {#code_end#}
    <p>
    I can't paste the full strace output here, because it is too long, but I'll highlight some
    of the interesting parts:
    </p>
    <pre><code>clone(child_stack=0x7fe36dbdeff8, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID|0x400000strace: Process 8891 attached
, parent_tid=[8891], tls=0x7fe36dbdf028, child_tidptr=0x7fe36dbdf000) = 8891
futex(0x7fe36dbdf000, FUTEX_WAIT, 8891, NULL &lt;unfinished ...&gt;
[pid  8891] futex(0x260b50, FUTEX_WAIT, 0, NULL &lt;unfinished ...&gt;
[pid  8891] &lt;... futex resumed&gt;)        = 0
[pid  8891] openat(AT_FDCWD, "hello.txt", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 20
[pid  8891] epoll_ctl(18, EPOLL_CTL_ADD, 17, {EPOLLIN|EPOLLOUT|EPOLLONESHOT|EPOLLET, {u32=1841168864, u64=140614775472608}}) = 0
[pid  8891] futex(0x260b50, FUTEX_WAIT, 0, NULL &lt;unfinished ...&gt;
[pid  8891] &lt;... futex resumed&gt;)        = 0
[pid  8891] write(20, "hello\n", 6)     = 6
[pid  8891] epoll_ctl(18, EPOLL_CTL_MOD, 17, {EPOLLIN|EPOLLOUT|EPOLLONESHOT|EPOLLET, {u32=1841168864, u64=140614775472608}}) = 0
[pid  8891] futex(0x260b50, FUTEX_WAIT, 0, NULL &lt;unfinished ...&gt;
[pid  8891] &lt;... futex resumed&gt;)        = -1 EAGAIN (Resource temporarily unavailable)
[pid  8891] close(20 &lt;unfinished ...&gt;
[pid  8891] &lt;... close resumed&gt;)        = 0
[pid  8891] exit(0 &lt;unfinished ...&gt;
[pid  8891] &lt;... exit resumed&gt;)         = ?
&lt;... futex resumed&gt;)                    = -1 EAGAIN (Resource temporarily unavailable)
exit_group(0)                           = ?</code></pre>
    <p>
    Here we can see that a separate thread is created, which ends up doing the file system I/O.
    Some operating systems such as Linux do not have async file system support, and so the technique
    used by evented I/O libraries is to have a thread pool for doing blocking operations. In this way,
    you can make anything async by giving the task to another thread.
    </p>
    <p>
    Now that Linux has <code>io_uring</code>, this could be improved. With Zig's
    {#link|OS Version Ranges#}, the event loop code could be improved to detect if io_uring is
    within the target OS version range, and take advantage of it if so. If the minimum OS version
    is high enough, the non-io_uring code could be omitted, and if the maximum OS version is low
    enough, the io_uring code could be omitted. If the OS version range includes both, then the
    code should try io_uring, and fall back at runtime to a non-io_uring strategy.
    </p>
    <p>
    Anyway, the point here is that because evented I/O is enabled, it now becomes meaningful
    to express concurrency:
    </p>
    {#code_begin|exe|concurrent#}
const std = @import("std");

pub const io_mode = .evented;

pub fn main() anyerror!void {
    var a_frame = async doA();
    var b_frame = async doB();

    try await a_frame;
    try await b_frame;
}

fn doA() !void {
    const file = try std.fs.cwd().createFile("a.txt", .{});
    defer file.close();

    try file.writeAll("A\n");
}

fn doB() !void {
    const file = try std.fs.cwd().createFile("b.txt", .{});
    defer file.close();

    try file.writeAll("B\n");
}
    {#code_end#}
    <p>
    I'll refrain from pasting more strace output here, but now we can start to see
    things happening in parallel (depending on the OS support for async file system I/O, or
    the file system thread pool size).
    </p>
    <p>
    Finally, I want to point out one crucial point about Zig's async I/O.
    <strong>It still works if you switch back to blocking I/O</strong>:
    </p>
    {#code_begin|exe|async_blocking#}
    {#code_release_fast#}
const std = @import("std");

pub fn main() anyerror!void {
    var a_frame = async doA();
    var b_frame = async doB();

    try await a_frame;
    try await b_frame;
}

fn doA() !void {
    const file = try std.fs.cwd().createFile("a.txt", .{});
    defer file.close();

    try file.writeAll("A\n");
}

fn doB() !void {
    const file = try std.fs.cwd().createFile("b.txt", .{});
    defer file.close();

    try file.writeAll("B\n");
}
    {#code_end#}
    <p>
    This time I will show the strace since it's very short:
    </p>
    <pre><code>arch_prctl(ARCH_SET_FS, 0x203cf0)       = 0
openat(AT_FDCWD, "a.txt", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 3
write(3, "A\n", 2)                      = 2
close(3)                                = 0
openat(AT_FDCWD, "b.txt", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 3
write(3, "B\n", 2)                      = 2
close(3)                                = 0
exit_group(0)                           = ?</code></pre>
    <p>
    You can see that the async stuff folded into simple, linear, blocking code.
    </p>
    <p>
    This is a big deal. It means that Zig code can express concurrency, yet
    be reusable in both a blocking I/O and an evented I/O environment. There is no
    "async-std".
    <em>The Zig Standard Library supports both async and blocking I/O with the same codebase</em>.
    </p>
    <p>
    Thanks to Benjamin Feng, Vexu, daurnimator, and Timon Kruiper for contributions related to this feature.
    </p>

    {#header_close#}

    {#header_open|Debug Info and Stack Traces#}
    <p>LemonBoy made a number of improvements to Zig's debug info code:</p>
    <ul>
      <li>Fix stack iteration stop condition, and further improve the frame-walking strategy.
        The code is now stable enough not to cause panics during the call frame walking.</li>
      <li>Make the {#syntax#}leb{#endsyntax#} module available to non-std code</li>
      <li>Don't generate any type info for void return types. Closely matches what the LLVM debug emitter expects, the generated DWARF infos are now standard-compliant.</li>
      <li>Show a nice error message on SIGBUS.</li>
      <li>Support handling DWARF version 3.</li>
      <li>Properly handle multiple threads panicking at the same time. Instead of walking all
          over each other, both stack traces will be printed sequentially.</li>
    </ul>
    <p>Additionally, Rocknest brought Windows segfault handler code on par with POSIX. (<a href="https://github.com/ziglang/zig/issues/4319">#4319</a>)</p>
    {#header_close#}

    {#header_open|Formatted Printing#}
    <p>
    Formatted printing is now
    <a href="https://ziglang.org/documentation/0.6.0/std/#std;fmt.format">documented fairly well</a>
    thanks to Felix Quei√üner (<a href="https://github.com/ziglang/zig/issues/3474">#3474</a>).
    </p>
    <p>
    {#syntax#}std.fmt.format{#endsyntax#} is modified for the new {#link|I/O Streams#} API,
    and because of {#link|Tuples Added, Var Args Removed#}. It now operates cleanly with
    {#link|Async I/O#}.
    </p>
    <p>Formatting capabilities were improved:</p>
    <ul>
      <li>Ability to format enum-literals</li>
      <li>Handle {s} format for {#link|Sentinel-Terminated Pointers#}. (<a href="https://github.com/ziglang/zig/issues/4219">#4219</a>)</li>
      <li>Ability to format {#link|vectors|SIMD#}</li>
      <li>Ability to format {#link|Non-Exhaustive Enums#}</li>
      <li>Ability to format contents of sentinel terminated many pointers</li>
      <li>Format decmial 0.0 with no precision as just 0</li>
    </ul>
    <p>
    <a href="https://github.com/ziglang/zig/issues/1358">An API overhaul is still planned</a>.
    </p>
    <p>
    Thanks to daurnimator, LemonBoy, Benjamin Feng, Felix Quei√üner, Michael Dusan,
    Nathan Michaels, data-man, frmdstryr, markfirmware, shiimizu, and vegecode for
    contributions related to this feature.
    </p>
    {#header_close#}

    {#header_open|I/O Streams#}
    <p>
    The bad news: there were breaking changes to I/O streams and you have to
    update your code.
    </p>
    <p>
    The good news:
    </p>
    <ul>
      <li>The new API is simpler and more ergonomic.</li>
      <li>Empirically, it produces significantly faster runtime code.</li>
      <li>It works cleanly with {#link|Async I/O#}.</li>
    </ul>
    <p>
    Example code using the old streams API (lifted from my
    <a href="https://github.com/andrewrk/advent-of-code">advent-of-code</a> repository):
    </p>
    <pre>{#syntax#}const std = @import("std");

pub fn main() anyerror!void {
    var stdin_unbuf = std.io.getStdIn().inStream();
    // damn that is pretty painful, isn't it?
    const in = &std.io.BufferedInStream(@TypeOf(stdin_unbuf).Error).init(&stdin_unbuf.stream).stream;

    var sum: u64 = 0;
    var line_buf: [50]u8 = undefined;
    while (try in.readUntilDelimiterOrEof(&line_buf, '\n')) |line| {
        if (line.len == 0) break;
        const module_mass = try std.fmt.parseInt(u64, line, 10);
        const fuel_required = (module_mass / 3) - 2;
        sum += fuel_required;
    }

    const out = &std.io.getStdOut().outStream().stream;
    try out.print("{}\n", .{sum});
}{#endsyntax#}</pre>
    <p>
    New streams API:
    </p>
    {#code_begin|syntax#}
const std = @import("std");

pub fn main() anyerror!void {
    const in = std.io.bufferedInStream(std.io.getStdIn().inStream()).inStream();

    var sum: u64 = 0;
    var line_buf: [50]u8 = undefined;
    while (try in.readUntilDelimiterOrEof(&line_buf, '\n')) |line| {
        if (line.len == 0) break;
        const module_mass = try std.fmt.parseInt(u64, line, 10);
        const fuel_required = (module_mass / 3) - 2;
        sum += fuel_required;
    }

    const out = std.io.getStdOut().outStream();
    try out.print("{}\n", .{sum});
}
    {#code_end#}
    <p>
    And unlike before, it works if you utilize {#link|Async I/O#} with:
    </p>
    {#code_begin|syntax#}
pub const io_mode = .evented;
    {#code_end#}
    <p>
    InStream, OutStream, and SeekableStream were already generic
    across error sets; it's not really worse to make them generic across the
    vtable as well, which is what this change did.
    </p>
    <p>
    See <a href="https://github.com/ziglang/zig/issues/764">#764</a> for the open issue acknowledging that using generics for these
    abstractions is a design flaw.
    </p>
    <p>
    See <a href="https://github.com/ziglang/zig/issues/130">#130</a> for the efforts to make these abstractions non-generic.
    </p>
    <p>
    This also changes the OutStream API so that {#syntax#}write{#endsyntax#} returns
    number of bytes written, and {#syntax#}writeAll{#endsyntax#} is the one that loops until the
    whole buffer is written.
    </p>
    {#header_close#}

    {#header_open|Filesystem#}
    <p>
    The file system APIs are starting to come together. I think this is an
    area where Zig really shines.
    </p>
    <p>
    There were many breaking changes during this release cycle, however they are
    all working directly towards a clear vision:
    </p>
    <ul>
      <li>Operations which are relative to a directory, should be methods of the
        {#syntax#}std.fs.Dir{#endsyntax#} namespace.</li>
      <li>Filesystem functions should not take unnecessary Allocator parameters.</li>
    </ul>
    <p>
    These goals go hand-in-hand. By avoiding string manipulation of paths, Zig code
    simultaneously avoids the need for allocators, prevents {#syntax#}error.NameTooLong{#endsyntax#}
    errors from the kernel, and avoids
    <a href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use">TOCTOU</a> bugs.
    </p>
    <p>
    Here is an example from {#link|zig build#} of what it looks like to
    "install" all the files from a source directory into a destination directory:
    </p>
    <pre>{#syntax#}var src_dir = try std.fs.cwd().openDir(build_output_dir, .{ .iterate = true });
defer src_dir.close();

var dest_dir = try std.fs.cwd().openDir(output_dir, .{});
defer dest_dir.close();

var it = src_dir.iterate();
while (try it.next()) |entry| {
    _ = try src_dir.updateFile(entry.name, dest_dir, entry.name, .{});
}{#endsyntax#}</pre>
    <p>
    No allocator needed. Resource management is trivial. Works correctly when
    the file paths are so deeply nested that they would be longer than PATH_MAX.
    Avoids copying the file when
    the destination is already up-to-date. When a file copy does happen, it uses
    {#syntax#}sendfile{#endsyntax#} if supported, so that the file copy happens in the kernel.
    The ignored return value there is whether or not the destination file was found to be
    out-of-date, so that the code could know which files were fresh and which were stale.
    </p>
    <p>
    When upgrading your filesystem code to Zig 0.6.0, you should ask yourself the question,
    <em>can I rework the logic to avoid path manipulation?</em>
    </p>
    <p>
    I won't list all the functions added, removed, and changed here because it is too many,
    but I will highlight some notable changes:
    </p>
    <ul>
      <li>sendfile support. File system implementations which copy files now use this when possible.</li>
      <li>Better support for writev, readv, pwritev, preadv, etc.</li>
      <li>Various APIs and implementations improved to take advantage of directory handles.</li>
      <li>Error sets of various functions are improved to no longer have some kinds of errors, such
        as {#syntax#}error.OutOfMemory{#endsyntax#}, or in the case of deleting a file, {#syntax#}error.NoSpaceLeft{#endsyntax#}.</li>
      <li>The new convention for APIs with null-terminated path parameters is a 'Z' suffix rather than a 'C' suffix.</li>
      <li>Some APIs are modified to take "options" structs which have default field values.</li>
      <li>inode number / file index is exposed in File.Stat.</li>
      <li>Cross-platform file locking flags are supported.</li>
      <li>fs.File supports setEndPos to grow/shrink the file size as needed. (<a href="https://github.com/ziglang/zig/issues/4716">#4716</a>)</li>
      <li>Filesystem APIs now integrate with {#link|Async I/O#}, including automatically performing
        operations on a file system thread pool to avoid blocking.</li>
    </ul>
     <p>
     Thank you to contributors LeRoyce Pearson, Jonathan S, daurnimator,
     LemonBoy, Terin Stock, dimenus, and stratact.
     </p>
    {#header_close#}

    {#header_open|Networking#}
    <p>
    The basics of networking are starting to come together, at least on POSIX.
    </p>
    <p>Added {#syntax#}std.net.getAddressList{#endsyntax#} - basic DNS address resolution.</p>
    <p>Added {#syntax#}std.net.StreamServer{#endsyntax#}.</p>
    <p>Added {#syntax#}std.net.tcpConnectToHost{#endsyntax#}.</p>
    <p>Added {#syntax#}std.net.tcpConnectToAddress{#endsyntax#}.</p>
    <p>Added {#syntax#}std.net.Address.parseIp{#endsyntax#} which supports IPv4 and IPv6.</p>
    <p>Added {#syntax#}std.net.Address.parseExpectingFamily{#endsyntax#} which additionally
    accepts a family parameter.</p>
    <p>std.os IPPROTO constants are canonicalized.</p>
    <p>
    <a href="https://gist.github.com/andrewrk/34c21bdc1600b0884a3ab9fa9aa485b8">Example of a simple TCP chat server</a> using {#link|Async I/O#}.
    </p>
    <p>
    Thank you to contributors Luna, Vexu, Jonathan Marler, Sebastian,
    frmdstryr, and LemonBoy.
    </p>
    {#header_close#}

    {#header_open|JSON#}
    <ul>
      <li>Added {#syntax#}std.json.WriteStream.writeJson{#endsyntax#}.</li>
      <li>std.json.Value: added dumpStream(), utilize WriteStream for dump().</li>
      <li>std.json.Token is now a {#syntax#}union(enum){#endsyntax#}.</li>
      <li>Improve json.unescapeString to no longer take an allocator</li>
      <li>Add json.stringify to encode arbitrary values to JSON</li>
      <li>Add json.parse to automatically decode json into a struct</li>
      <li>Add json.WriteStream.stringify</li>
      <li>Disallow overlong and out-of-range UTF-8</li>
      <li>Support unescaping JSON strings</li>
      <li>Surrogate pair support</li>
      <li>Implement copy_strings=false</li>
    </ul>
    <p>
    Here is an example of parsing into an arbitrary struct:
    </p>
    {#code_begin|test|json_parse_struct#}
const std = @import("std");
const json = std.json;

test "parse into struct with misc fields" {
    @setEvalBranchQuota(10000);
    const options = json.ParseOptions{ .allocator = std.testing.allocator };
    const T = struct {
        int: i64,
        float: f64,
        @"with\\escape": bool,
        @"withƒÖunicodeüòÇ": bool,
        language: []const u8,
        optional: ?bool,
        default_field: i32 = 42,
        static_array: [3]f64,
        dynamic_array: []f64,

        const Bar = struct {
            nested: []const u8,
        };
        complex: Bar,

        const Baz = struct {
            foo: []const u8,
        };
        veryComplex: []Baz,

        const Union = union(enum) {
            x: u8,
            float: f64,
            string: []const u8,
        };
        a_union: Union,
    };
    const r = try json.parse(T, &json.TokenStream.init(
        \\{
        \\  "int": 420,
        \\  "float": 3.14,
        \\  "with\\escape": true,
        \\  "with\u0105unicode\ud83d\ude02": false,
        \\  "language": "zig",
        \\  "optional": null,
        \\  "static_array": [66.6, 420.420, 69.69],
        \\  "dynamic_array": [66.6, 420.420, 69.69],
        \\  "complex": {
        \\    "nested": "zig"
        \\  },
        \\  "veryComplex": [
        \\    {
        \\      "foo": "zig"
        \\    }, {
        \\      "foo": "rocks"
        \\    }
        \\  ],
        \\  "a_union": 100000
        \\}
    ), options);
    defer json.parseFree(T, r, options);
    std.testing.expectEqual(@as(i64, 420), r.int);
    std.testing.expectEqual(@as(f64, 3.14), r.float);
    std.testing.expectEqual(true, r.@"with\\escape");
    std.testing.expectEqual(false, r.@"withƒÖunicodeüòÇ");
    std.testing.expectEqualSlices(u8, "zig", r.language);
    std.testing.expectEqual(@as(?bool, null), r.optional);
    std.testing.expectEqual(@as(i32, 42), r.default_field);
    std.testing.expectEqual(@as(f64, 66.6), r.static_array[0]);
    std.testing.expectEqual(@as(f64, 420.420), r.static_array[1]);
    std.testing.expectEqual(@as(f64, 69.69), r.static_array[2]);
    std.testing.expectEqual(@as(usize, 3), r.dynamic_array.len);
    std.testing.expectEqual(@as(f64, 66.6), r.dynamic_array[0]);
    std.testing.expectEqual(@as(f64, 420.420), r.dynamic_array[1]);
    std.testing.expectEqual(@as(f64, 69.69), r.dynamic_array[2]);
    std.testing.expectEqualSlices(u8, r.complex.nested, "zig");
    std.testing.expectEqualSlices(u8, "zig", r.veryComplex[0].foo);
    std.testing.expectEqualSlices(u8, "rocks", r.veryComplex[1].foo);
    std.testing.expectEqual(T.Union{ .float = 100000 }, r.a_union);
}
    {#code_end#}
    <p>
    Thank you daurnimator, Sebastian Keller, xackus, hryx, and Lachlan Easton
    for related contributions.
    </p>
    {#header_close#}

    {#header_open|Bring-Your-Own-OS Abstraction Layer#}
    <p>In the previous release of Zig (0.5.0), the {#syntax#}std.Target.Os{#endsyntax#} enum recognized
    the following operating systems:</p>
    <pre><code>  freestanding
  ananas
  cloudabi
  dragonfly
  freebsd
  fuchsia
  ios
  kfreebsd
  linux
  lv2
  macosx
  netbsd
  openbsd
  solaris
  windows
  haiku
  minix
  rtems
  nacl
  cnk
  aix
  cuda
  nvcl
  amdhsa
  ps4
  elfiamcu
  tvos
  watchos
  mesa3d
  contiki
  amdpal
  hermit
  hurd
  wasi
  emscripten
  zen
  uefi</code></pre>
    <p>This list was the list of targets that LLVM supported +
    <a href="https://github.com/AndreaOrru/zen">zen</a> (a hobby OS not maintained for over 1 year) +
    UEFI.
    </p>
    <p>
    It doesn't make sense to put every hobby OS into this list, but it does make sense to support them!
    It should be possible for people to take advantage of Zig's cross platform abstractions without
    having to get support for their hobby OS upstreamed into Zig.
    </p>
    <p>
    Zig 0.6.0 does two things:
    </p>
    <ul>
      <li>Add an {#syntax#}other{#endsyntax#} tag to std.Target.Os</li>
      <li>Support an OS layer struct exposed in the root source file (next to {#syntax#}pub fn main(){#endsyntax#})</li>
    </ul>
    <p>
    This allows hobby OS developers to maintain a zig package that makes the Zig
    {#link|Standard Library#} support their OS. Application developers could use it like this:
    </p>
    <pre>{#syntax#}pub const os = @import("my_hobby_os_package");

pub fn main() void {
    // ...
}{#endsyntax#}</pre>
    <p>
    Next, standard library abstractions will detect when they should utilize this.
    If the operating system is POSIX compliant, then many things will Just Work.
    For example, {#syntax#}std.os.read{#endsyntax#} was defined like this:
    </p>
    {#code_begin|syntax#}
/// Returns the number of bytes that were read, which can be less than
/// buf.len. If 0 bytes were read, that means EOF.
/// If the application has a global event loop enabled, EAGAIN is handled
/// via the event loop. Otherwise EAGAIN results in error.WouldBlock.
pub fn read(fd: fd_t, buf: []u8) ReadError!usize {
    if (builtin.os == .windows) {
        return windows.ReadFile(fd, buf);
    }

    if (builtin.os == .wasi and !builtin.link_libc) {
        const iovs = [1]iovec{iovec{
            .iov_base = buf.ptr,
            .iov_len = buf.len,
        }};

        var nread: usize = undefined;
        switch (wasi.fd_read(fd, &iovs, iovs.len, &nread)) {
            0 => return nread,
            else => |err| return unexpectedErrno(err),
        }
    }

    while (true) {
        const rc = system.read(fd, buf.ptr, buf.len);
        switch (errno(rc)) {
            0 => return @intCast(usize, rc),
            EINTR => continue,
            EINVAL => unreachable,
            EFAULT => unreachable,
            EAGAIN => if (std.event.Loop.instance) |loop| {
                loop.waitUntilFdReadable(fd);
                continue;
            } else {
                return error.WouldBlock;
            },
            EBADF => unreachable, // Always a race condition.
            EIO => return error.InputOutput,
            EISDIR => return error.IsDir,
            ENOBUFS => return error.SystemResources,
            ENOMEM => return error.SystemResources,
            ECONNRESET => return error.ConnectionResetByPeer,
            else => |err| return unexpectedErrno(err),
        }
    }
    return index;
}
    {#code_end#}
    <p>
    Where {#syntax#}system{#endsyntax#} referred to:
    </p>
    {#code_begin|syntax#}
/// When linking libc, this is the C API. Otherwise, it is the OS-specific system interface.
pub const system = if (builtin.link_libc) std.c else switch (builtin.os) {
    .macosx, .ios, .watchos, .tvos => darwin,
    .freebsd => freebsd,
    .linux => linux,
    .netbsd => netbsd,
    .dragonfly => dragonfly,
    .wasi => wasi,
    .windows => windows,
    .zen => zen,
    else => struct {},
};
    {#code_end#}
    <p>
    Now, {#syntax#}else => struct{}{#endsyntax#} is modified to look for
    {#syntax#}@import("root").os{#endsyntax#} if it is provided.
    With this modification, as long as the OS package defines all the constants (such as
    {#syntax#}fd_t{#endsyntax#} and {#syntax#}EISDIR{#endsyntax#}), then
    {#syntax#}std.os.write{#endsyntax#} would end up calling the write function from the hobby OS
    package, and everything Just Works.
    </p>
    <p>
    Some abstractions do not work so smoothly; in this case there is code that looks
    something like this:
    </p>
    {#code_begin|syntax#}
fn doTheOsThing() void {
    if (@hasDecl(root, "os") and @hasDecl(root.os, "doTheOsThing")) {
        return @import("root").os.doTheOsThing();
    }
}
    {#code_end#}
    <p>
    Note there is not even a check for "other" here. Allowing applications to override fundamental OS
    functions is useful on any operating system.
    </p>
    <p>
    Now that this is implemented, Zig has first class support for all operating systems.
    The main difference between upstream-recognized OSes and "other" OSes would be where the support
    is maintained: in zig's std lib, or in a third party "OS layer" package.
    </p>
    <p>
    With this new feature, upstream support for Zen hobby OS is removed.
    This has the additional benefit of clearing up some confusion, since
    there is already a <a href="http://zenlang.sourceforge.net/">Zen programming language</a>.
    </p>
    <p>
    This feature is still experimental, and contributions are welcome if you need to tweak the
    std lib to get it working for your hobby OS use case.
    </p>
    <p>
    Thanks Christine Dodrill and Noam Preil for related contributions.
    </p>
    <p>
    Follow-up proposal: <a href="https://github.com/ziglang/zig/issues/4166">BYO os should work at the zig level</a>
    </p>
    {#header_close#}

    {#header_open|ArrayList#}
    <p>Apologies - when I first created the ArrayList API, I got it backwards.
    I made {#syntax#}items{#endsyntax#} the slice of allocated memory, and
    you had to call a function to get the slice of valid objects.</p>
    <p>
    Now, the {#syntax#}items{#endsyntax#} field is safe to use directly, and is
    always the slice of valid objects, and the capacity is maintained separately.
    </p>
    <p>
    This breaks callsites of ArrayList but it removes a footgun from this API.
    It also allows removing a bunch of no-longer-needed API.
    </p>
    <p>Iterator API is removed from std.ArrayList, since it is now possible to use
    a {#syntax#}for{#endsyntax#} loop on the {#syntax#}items{#endsyntax#} field.
    </p>
    <p>
    Additionally:
    </p>
    <ul>
      <li>There is now a function {#syntax#}appendNTimes{#endsyntax#} (<a href="https://github.com/ziglang/zig/issues/4460">#4460</a>).</li>
      <li>Many functions are deprecated, such as {#syntax#}toSlice{#endsyntax#} and
        {#syntax#}toSliceConst{#endsyntax#}, and {#syntax#}at{#endsyntax#}. Instead,
        access the {#syntax#}items{#endsyntax#} slice directly.</li>
      <li>Added {#syntax#}outStream{#endsyntax#} - creates a stream to append to the ArrayList.</li>
    </ul>
    <p>
    Thanks daurnimator, xackus, Bas, MCRusher, and Benoit Giannangeli
    for related contributions.
    </p>
    <p>
    Special thanks to daurnimator for making the case to rename {#syntax#}std.Buffer{#endsyntax#}
    to {#syntax#}std.ArrayListSentineled{#endsyntax#}, and replace usages of that API with
    usages to {#syntax#}ArrayList{#endsyntax#} where applicable.
    </p>
    {#header_close#}

    {#header_open|Memory#}
    <ul>
      <li>{#syntax#}std.mem.len{#endsyntax#} no longer takes a type parameter, and
        uses {#link|Sentinel-Terminated Pointers#}.</li>
      <li>Added {#syntax#}std.mem.span{#endsyntax#}.</li>
      <li>Added {#syntax#}std.mem.spanZ{#endsyntax#}.</li>
      <li>Added {#syntax#}std.mem.zeroes{#endsyntax#} which zero-initializes types which have
        well-defined memory layouts. (<a href="https://github.com/ziglang/zig/issues/4544">#4544</a>)</li>
      <li>Added {#syntax#}std.mem.Allocator.allocSentinel{#endsyntax#}.</li>
      <li>Added {#syntax#}std.mem.indexOfSentinel{#endsyntax#}.</li>
      <li>Rename {#syntax#}std.mem.separate{#endsyntax#} to {#syntax#}std.mem.split{#endsyntax#}.</li>
      <li>Rename {#syntax#}std.mem.Compare{#endsyntax#} to {#syntax#}std.math.Order{#endsyntax#}.</li>
      <li>Rename {#syntax#}std.mem.compare{#endsyntax#} to {#syntax#}std.mem.order{#endsyntax#}.</li>
      <li>Added {#syntax#}std.math.order{#endsyntax#}.</li>
      <li>Deprecated {#syntax#}std.mem.toSlice{#endsyntax#}.</li>
      <li>Deprecated {#syntax#}std.mem.toSliceConst{#endsyntax#}.</li>
    </ul>
    <p>
    Thanks to Bas van den Berg, Emeka Nkurumeh, Jonathan Marler, Micha√´l Larouche,
    Sebastian, Timon Kruiper, daurnimator, and xackus for related contributions.
    </p>
    {#header_close#}

    {#header_open|Crypto#}
    <p>lukechampine added an AES implementation to {#syntax#}std.crypto{#endsyntax#}.
    data-man improved the code, replacing variables with constants. lukechampine
    additionally added support for AES-CTR.</p>
    <p>daurnimator added a Gimli based PRNG to {#syntax#}std.rand{#endsyntax#}, added
    gimli to the crypto hash benchmark, and added AEAD modes for Gimli. (<a href="https://github.com/ziglang/zig/issues/4369">#4369</a>)</p>
    <p>Jay Petacat added a BLAKE3 hashing algorithm (<a href="https://github.com/ziglang/zig/issues/4366">#4366</a>). Jay writes:</p>
    <p>
    This is a translation of the
    <a href="https://github.com/BLAKE3-team/BLAKE3">official reference implementation</a>
    with few other changes. The bad news is that the reference implementation is
    designed for simplicity and not speed, so there's a lot of room for
    performance improvement. The good news is that, according to the crypto
    benchmark, the implementation is still fast relative to the other
    hashing algorithms:
    </p>
    <pre><code>             md5: 430 MiB/s
            sha1: 386 MiB/s
          sha256: 191 MiB/s
          sha512: 275 MiB/s
        sha3-256: 233 MiB/s
        sha3-512: 137 MiB/s
         blake2s: 464 MiB/s
         blake2b: 526 MiB/s
          blake3: 576 MiB/s
        poly1305: 1479 MiB/s
        hmac-md5: 653 MiB/s
       hmac-sha1: 553 MiB/s
     hmac-sha256: 222 MiB/s
          x25519: 8685 exchanges/s</code></pre>
    <p>
    J.W fixed index out of bounds logic in some hashing algorithms.
    </p>
    {#header_close#}

    {#header_open|Start Code#}
    <p>Logic involving startup code has been moved from being hard-coded in the compiler to
    {#syntax#}comptime{#endsyntax#} logic inside the
    <a href="https://github.com/ziglang/zig/blob/0.6.0/lib/std/start.zig">start.zig</a>
    file from the standard library.
    </p>
    <p>
    Additionally, the startup code is un-special-cased.
    </p>
    <p>
    Previously, the compiler had special logic to determine whether to
    include the startup code, which was in <code>std/special/start.zig</code>. Now,
    the file is moved to <code>std/start.zig</code>, and there is no special logic
    in the compiler. Instead, the standard library unconditionally imports
    the <code>start.zig</code> file, which then has a <code>comptime</code> block that does the
    logic of determining what, if any, start symbols to export. Instead of
    <code>start.zig</code> being in its own special package, it is just another normal
    file that is part of the standard library.
    </p>
    <p>
    <code>std.builtin.TestFn</code> is now part of the standard library rather than
    specially generated by the compiler.
    </p>
    <p>
    Additionally, some minor changes to Thread-Local Storage handling (<a href="https://github.com/ziglang/zig/issues/4807">#4807</a>):
    </p>
    <ul>
      <li>Always allocate an info block per-thread so that libc can store important stuff there.</li>
      <li>Respect ABI-mandated alignment in more places.</li>
      <li>Nicer code, use slices/pointers instead of raw addresses whenever possible.</li>
    </ul>
    <p>Thanks to LemonBoy, Vexu, Jared Miller, and Nick Erdmann for contributions related to this.</p>
    {#header_close#}

    {#header_close#}

    {#header_open|Documentation#}
    <ul>
      <li>Language reference updated to take into account {#link|Language Changes#}.</li>
      <li>Language reference makes it more obvious that {#syntax#}if{#endsyntax#} is an expression.</li>
      <li>New section: <a href="https://ziglang.org/documentation/0.6.0/#Function-Parameter-Type-Inference">Function Parameter Type Inference</a></li>
      <li>Clarify {#syntax#}allowzero{#endsyntax#} interaction with optional pointers.</li>
      <li>Language reference has table of contents in a separate column on large displays.</li>
    </ul>
    <p>
    Thanks to Vexu, xackus, LemonBoy, data-man, Benjamin Feng, Emilio G. Cota,
    Jonathan Marler, MateuszOkulus, Matt Keeter, Maximilian Hunt, Nathan Michaels,
    Nick Erdmann, Robin Voetter, Shritesh, hryx, momumi, and yvt for contributions
    to the language reference.
    </p>

    {#header_open|Documentation Generation#}
    <p>This feature is still experimental.</p>
    <p>There is a new <code>-fdump-analysis</code> command line option, which creates
    a <code>$NAME-analysis.json</code> file with all of the finished
    semantic analysis that the stage1 compiler produced.
    It contains types, packages, declarations, and files.</p>
    <p>
    This feature can be used to power IDE integration features until such time
    as the self-hosted compiler is available and supports such features more directly.
    </p>
    <p>
    Additionally, there is a proof-of-concept documentation generation feature (<a href="https://github.com/ziglang/zig/issues/21">#21</a>):
    </p>
    <p>The new <code>-femit-docs</code> CLI option outputs:
    <ul>
      <li>doc/index.html</li>
      <li>doc/data.js</li>
      <li>doc/main.js</li>
    </ul>
    <p>
    In this strategy, we have 1 static html page and 1 static javascript
    file, which loads the semantic analysis dump directly and renders it
    using DOM manipulation.
    </p>
    <p>
    There is now
    <a href="https://ziglang.org/documentation/0.6.0/std/">experimental std lib documentation</a>.
    </p>
    <p>
    There are still some missing features. For example, it does not handle generic types ideally,
    multiple packages are not handled well, and some URLs are broken. Additionally, the
    <a href="https://github.com/ziglang/zig/blob/0.6.0/tools/merge_anal_dumps.zig">merge_anal_dumps tool</a>
    is not yet complete, so generated documentation can only apply to a single build configuration.
    For example, if the generated docs targeted Windows, then Linux-only functions will not be
    shown in the documentation, and vice-versa. Due to Zig's lazy analysis many declarations
    are not semantically analyzed, causing them to be omitted in the generated documentation.
    These are all open issues to be addressed.
    </p>
    <p>
    Despite the flaws it can still be a useful way to explore the {#link|Standard Library#}.
    It has motivated some contributions to improve doc comments to various APIs:
    </p>
    <ul>
      <li>Felix Quei√üner added documentation for std.fmt.format grammar and customization. (<a href="https://github.com/ziglang/zig/issues/3474">#3474</a>)</li>
      <li>Nathan Michaels added docs for ArrayList, failing_allocator, and Allocator. (<a href="https://github.com/ziglang/zig/issues/3540">#3540</a>)</li>
      <li>Nathan Michaels documented std.Mutex.</li>
      <li>Nathan Michaels documented PriorityQueue.</li>
      <li>Josh Wolfe added documentation for mutable HashMap KV pointers.</li>
      <li>Felix (xq) Quei√üner added documentation to {#syntax#}std.atomic.Queue{#endsyntax#}.</li>
    </ul>
    <p>
    Thank you Rocknest, Timon Kruiper, Henry Wu, Felix Quei√üner, Vexu, dtw-waleee,
    pfg, and xackus for related contributions.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|Safety#}
    <p>
    Related to {#link|Async I/O#}, resuming non-suspended functions now has runtime safety (<a href="https://github.com/ziglang/zig/issues/3469">#3469</a>):
    </p>
    {#code_begin|exe_err|bad_resume#}
const std = @import("std");

fn foo() void {
    var f = async bar(@frame());
    std.process.exit(0);
}

fn bar(frame: anyframe) void {
    suspend {
        resume frame;
    }
    std.process.exit(0);
}

pub fn main() void {
    _ = async foo();
}
    {#code_end#}
    <p>
    Additionally the following safety checks have been added:
    </p>
    <ul>
      <li>Slicing operator with a {#link|sentinel|Sentinel-Terminated Pointers#} mismatch.</li>
      <li>Shifting by an amount greater than the type size (for non-power-of-two integers).</li>
      <li>{#syntax#}@intToPtr{#endsyntax#} with misaligned address.</li>
      <li>Slicing a null C pointer.</li>
    </ul>
    <p>
    Thanks LemonBoy, Alexandros Naskos, and xackus for related contributions.
    </p>
    <p>
    <a href="https://github.com/ziglang/zig/projects/3">Much more safety is planned</a>.
    This was a relatively quiet release cycle as far as
    safety is concerned, {#link|despite the ambitions of the 0.5.0 roadmap|Roadmap#}.
    </p>
    {#header_close#}

    {#header_open|zig build#}
    <p>
    <code>zig build</code> is still in an experimental, proof-of-concept phase, and will remain
    that way until at least the {#link|package manager|Package Manager Status#} is complete.
    Nonetheless, there were plenty of improvements to <code>zig build</code> this release cycle:
    </p>
    <p>
    The most notable changes to zig build have to do with the new {#link|Target Details#}.
    See that section for how to use the new {#syntax#}setTarget{#endsyntax#} API.
    </p>
    <p>
    One new trick that may be useful to Windows developers is to set the default target to be
    <code>native-native-gnu</code>. This will use the native
    {#link|OS and version range|OS Version Ranges#} as well as the
    {#link|native CPU|CPU Features#}, but take advantage of
    {#link|mingw-w64|mingw-w64 7.0.0#} rather than trying to integrate with system MSVC.
    This is more likely to "just work" for all your project contributors,
    because it eliminates a problematic system dependency.
    </p>
    <p>
    Additionally the following improvements were made:
    </p>
    <ul>
      <li>Bumped default max exec output size to 400 KB. (<a href="https://github.com/ziglang/zig/issues/3415">#3415</a>)</li>
      <li>{#syntax#}addIncludeDir{#endsyntax#} does <code>-I</code> instead of <code>-isystem</code>.</li>
      <li>Initial support for using vcpkg libraries. However it is
        <a href="https://github.com/ziglang/zig/issues/4510">not integrated automatically yet</a>.</li>
      <li>Fixed failure to recognize the PATH environment variable due to
          incorrectly treating the environment variable as case sensitive on Windows.</li>
      <li>Rework and improve some of the zig build steps<ul>
          <li> RunStep gains ability to compare
       output and exit code against expected values. Multiple redundant
       locations in the test harness code are replaced to use RunStep.</li>
       <li> WriteFileStep gains
       ability to write more than one file into the cache directory, for
       when the files need to be relative to each other. This makes
       usage of WriteFileStep no longer problematic when parallelizing
       zig build.</li>
       <li> Added CheckFileStep, which can be used to validate that the output
       of another step produced a valid file. Multiple redundant locations
       in the test harness code are replaced to use CheckFileStep.</li>
       <li> Added TranslateCStep. This exposes zig translate-c to the build
       system, which is likely to be rarely useful by most Zig users;
       however Zig's own test suite uses it both for translate-c tests and
       for run-translated-c tests.</li>
       <li> Refactored ad-hoc code to handle source files coming from multiple
         kinds of sources, into std.build.FileSource.</li>
       <li> Added std.build.Builder.addExecutableFromWriteFileStep.</li>
       <li> Added std.build.Builder.addExecutableSource.</li>
       <li> Added std.build.Builder.addWriteFiles.</li>
       <li> Added std.build.Builder.addTranslateC.</li>
       <li> Added std.build.LibExeObjStep.addCSourceFileSource.</li>
       <li> Added std.build.LibExeObjStep.addAssemblyFileFromWriteFileStep.</li>
       <li> Added std.build.LibExeObjStep.addAssemblyFileSource.</li>
      </ul></li>
      <li><code>--</code> can be used to pass args to zig build commands.</li>
      <li><code>-D</code> now supports "list" type options.</li>
      <li>Nesting package dependencies is now supported.</li>
      <li>InstallRawStep is available to do a similar job to objcopy. It can be
        used with {#syntax#}exe.installRaw("kernel.bin");{#endsyntax#} where exe is a LibExeObjStep. (<a href="https://github.com/ziglang/zig/issues/2826">#2826</a>)</li>
      <li>zig build now correctly handles multiple output artifacts (<a href="https://github.com/ziglang/zig/issues/4733">#4733</a>, <a href="https://github.com/ziglang/zig/issues/4735">#4735</a>)<br>
    Previously the zig build system incorrectly assumed that the only build
    artifact was a binary. Now, when you enable the cache, only the output
    dir is printed to stdout, and the zig build system iterates over the
    files in that directory, copying them to the output directory.</li>
      <li>-ffunction-sections switch exposed to zig build scripts.</li>
      <li>The default stdin behavior of RunStep is now .Inherit. Since this is a breaking change,
        previous behavior can be restored by doing: {#syntax#}RunStep.stdin_behavior = .Ignore{#endsyntax#}.</li>
      <li>Configuring the subsystem is exposed to build scripts.</li>
    </ul>
    <p>
    Thanks to Benjamin Feng, David Cao, Layne Gustafson, LemonBoy, Michael Dusan,
    Micha√´l Larouche, Nick Erdmann, Noam Preil, Sahnvour, Timon Kruiper,
    Valentin Anger, dbandstra, emekoi, frmdstryr, meme, mogud, pwzk, stratact,
    syscall0, and xackus for related contributions.
    </p>
    {#header_close#}

    {#header_open|zig fmt#}
    <p>
    In this release, <code>zig fmt</code> performs a few automatic syntax upgrades for you,
    for example, renaming {#syntax#}@typeOf{#endsyntax#} to {#syntax#}@TypeOf{#endsyntax#},
    as well as updating to the new {#link|callconv#} syntax.
    </p>
    <ul>
      <li>Updates to support {#link|Language Changes#}.</li>
      <li>Trailing comma is respected for builtin calls, field declarations, and error set declarations.</li>
      <li>Handle declarations in line with the opening brace.</li>
      <li>Allow single newline before doc comments.</li>
    </ul>
    <p>
    Thanks to LemonBoy, Vexu, Robin Voetter, Brendan Hansknecht, Michael Raymond, and xackus
    for contributions to <code>zig fmt</code>.
    </p>
    {#header_close#}

    {#header_open|zig cc#}
    <p>
    Many people discovered this feature from the blog post,
    <a href="https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html">`zig cc`: a Powerful Drop-In Replacement for GCC/Clang</a>.
    </p>
    <p>
    In summary, since Zig links against libclang, Zig has the ability
    to act as a C compiler. And since Zig ships with {#link|libc#}, it has the ability to act as a
    cross-compiling C compiler. <a href="https://ziglang.org/download/0.4.0/release-notes.html#Zig-is-also-a-C-Compiler">This feature has been available since 0.4.0</a>, however, what's new is the
    sub-command, <code>zig cc</code>, which has the ability to parse C compiler flags.
    </p>
    <p>
    In this release, <code>zig cc</code> has full compatibility with
    <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">Clang's command line options</a>.
    Clang is not invoked directly; some components are replaced with Zig's own.
    For example, Zig provides all the include paths for libc, and acts as the linker driver.
    Zig translates the semantics of the arguments to its own internal build logic.
    Clang options that Zig is not aware of are forwarded to Clang directly.
    Some parameters are handled specially.
    </p>
    <p>
    Since the writing of the blog post a few weeks ago, this feature has been further improved
    with more flag integration, as well as the ability to provide <code>-lc++</code>.
    The sub-command <code>zig c++</code> is added for convenience.
    </p>
    <p>
    Yes, that's right, <strong>Zig now acts as a C++ cross-compiler as well</strong>.
    </p>
    <p class="file">hello.cpp</p>
    <pre><code>#include &lt;iostream&gt;

int main() {
    std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl;
    return 0;
}</code></pre>
    <p>My host is currently x86-64 linux, but I'll build it for {#link|Windows|Windows Support#}
    as well as
    {#link|RISC-V|RISC-V Support#}:</p>
<pre><code>$ zig c++ -o hello hello.cpp -lc
$ ./hello
Hello World!
$ zig c++ -o hello hello.cpp -lc -target x86_64-windows-gnu
$ wine64 hello.exe
Hello World!
$ zig c++ -o hello hello.cpp -lc -target riscv64-linux
$ qemu-riscv64 ./hello
Hello World!</code></pre>
    <p>
    Thanks to this new ability, Zig is now able to {#link|bootstrap itself|Bootstrap Tarball#}.
    Bootstrapping is not to be confused with {#link|self-hosting|Self-Hosted Compiler Progress#}.
    </p>
    <p>
    I forgot to mention in the blog post that when you don't pass any optimization flags to
    <code>zig cc</code>, Zig determines that
    <a href="https://ziglang.org/documentation/0.6.0/#Debug">Debug Mode</a> is appropriate,
    and enables <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">Clang's UBSAN</a>.
    </p>
    <p>
    People are finding out now that their C code has undefined behavior: <a href="https://github.com/ziglang/zig/issues/4830">#4830</a> <a href="https://github.com/ziglang/zig/issues/4965">#4965</a>
    </p>
    <p>
    zig cc is intentionally an interface to the Zig compiler, a bit higher level than using Clang
    directly.
    With no optimization flags specified, zig cc infers debug mode.
    As you know from writing Zig code, debug mode has safety checks to prevent undefined behavior
    at runtime. This applies for C code as well, taking advantage of clang's UBSAN.
    The fact that debug mode is "default" is entirely intentional.
    I expect this to identify many bugs in existing codebases as people use zig cc out of
    convenience or curiosity and their code gets vetted by UBSAN for the first time.
    </p>
    <p>
    Note that the presence of -O2,-O3 will cause zig to select release-fast,
    -Os will cause zig to select release-small, and optimization flags plus
    -fsanitize=undefined will cause zig to select release-safe.
    </p>
    <p>
    I wrote a FAQ entry so that people can easily link to it to help explain when this situation
    comes up:
    <a href="https://github.com/ziglang/zig/wiki/FAQ#why-do-i-get-illegal-instruction-when-using-with-zig-cc-to-build-c-code">Why do I get illegal instruction when using with zig cc to build C code?</a>
    </p>
    <p>
    So - is it production ready?
    </p>
    <p>As long as you are aware of
    <a href="https://github.com/ziglang/zig/labels/zig%20cc">the open issues</a>,
    and you have tested <code>zig cc</code> for your use case, and it successfully builds
    your project, then it should be safe to use <code>zig cc</code> with 0.6.0.
    It's not expected for this feature to change much; it is already very nearly in its
    final form.
    </p>
    <p>
    However, this is not a guarantee. Until Zig 1.0, the project
    reserves the right to make breaking changes as necessary.
    </p>
    <p>
    <a href="https://github.com/nim-lang/Nim/pull/13757">Nim has added zig cc as one of the C compiler backend options</a>.
    </p>
    <p>
    Thank you to Michael Dusan and Ryan Liptak for contributions related to this feature.
    </p>
    {#header_close#}

    {#header_open|libc#}
    <p>Because cross-compiling is a first-class use case, Zig provides libc whenever possible, rather
    than depending on the host libc.</p>

    {#header_open|musl 1.2.0#}
    <p>
    Zig ships with the source code to <a href="https://www.musl-libc.org/">musl</a>.
    When the musl C ABI is selected, Zig builds musl from source for the selected target.
    </p>
    <p>
    This release updates the bundled musl source code to
    <a href="https://musl.libc.org/releases.html">v1.2.0</a>.
    </p>
    <p>
    With this release, Zig no longer has any patches against upstream.
    </p>
    {#header_close#}

    {#header_open|glibc 2.31#}
    <p>
    Zig gains the ability to target
    <a href="https://sourceware.org/legacy-ml/libc-announce/2020/msg00001.html">glibc 2.31</a>
    in addition to the other 41 glibc versions.
    </p>
    <p>
    In this release, Zig's glibc support is improved to additionally provide <code>-lutil</code>
    and symbols provided by the dynamic linker. (<a href="https://github.com/ziglang/zig/issues/4748">#4748</a>)
    </p>
    {#header_close#}

    {#header_open|mingw-w64 7.0.0#}
    <p>
    Zig ships with the source code to <a href="https://mingw-w64.org/">mingw-w64</a>.
    When targeting *-windows-gnu and linking against libc, Zig builds mingw-w64 from source
    for the selected target.
    </p>
    <p>
    This release updates the bundled mingw-w64 source code to
    <a href="https://sourceforge.net/p/mingw-w64/mailman/message/36804945/">v7.0.0</a>.
    </p>
    <p>Additionally:</p>
    <ul>
      <li>Linking is now aware -lm is provided by mingw-w64.</li>
      <li>Zig additionally provides -lpsapi, -luuid, and -lshlwapi. (<a href="https://github.com/ziglang/zig/issues/3711">#3711</a>)</li>
    </ul>
    {#header_close#}
    {#header_close#}

    {#header_open|C Translation#}
    <p>
    During this release cycle, all of the Clang C++ API that Zig's translate-c feature relies on
    has been extracted into:
    </p>
    <ul>
      <li><code>zig_clang.h</code> (C)</li>
      <li><code>zig_clang.cpp</code> (C++)</li>
    </ul>
    <p>
    Next, <code>zig_clang.zig</code> was added to match the zig_clang.h C ABI.
    </p>
    <p>
    Once translate_c.cpp was fully updated to use zig_clang.h instead of the C++ includes,
    compilation of that source file went from 5 seconds to 0.5 seconds.
    </p>
    <p>
    At this point the self-hosting effort began. I started
    <code>src-self-hosted/translate-c.zig</code> and hooked up the translate-c test suite
    to support adding cases that are intended to pass in the new implementation.
    </p>
    <p>
    Slowly the contributions started coming in and gradually improving self-hosted translate-c,
    and it started passing more and more test cases.
    </p>
    <p>
    After a few individual contributions,
    {#link|Vexu|Please Welcome Vexu to the Core Zig Team#} got the hang of things, and
    <em>finished the entire self-hosted implementation of translate-c</em>,
    ultimately deleting the 5,000 line C++ implementation in one final blow.
    </p>
    <p>
    All the previous test cases pass now, plus new ones, and there is even a new kind
    of test, <code>zig build test-run-translated-c</code>, which attempts to compile and
    run the Zig code that was translated from C code.
    </p>
    <p>
    Vexu didn't stop there. He implemented a full C tokenizer and a partial C AST parser,
    which are both now available in the
    {#link|Standard Library#} in the {#syntax#}std.c{#endsyntax#} namespace. As a result,
    Zig's support for macro translation is much improved in 0.6.0.
    </p>
    <p>
    This is as big deal for {#link|Self-Hosted Compiler Progress#}, because it means that
    contributions to Zig's translate-c feature apply not only to the stage1 compiler, but
    to the (incomplete) self-hosted compiler as well.
    </p>
    <p>
    I won't list translate-c improvements or bug fixes because they are too numerous, but
    the following things stick out:
    </p>
    <ul>
      <li>There is now a {#link|zig build#} step for translate-c.</li>
      <li>{#syntax#}@cImport{#endsyntax#} now automatically caches results, so subsequent builds are fast.</li>
      <li>There is now an <a href="https://github.com/ziglang/zig/blob/0.6.0/CONTRIBUTING.md#improving-translate-c">Improving Translate-C</a>
        section in CONTRIBUTING.md, to help contributors get started.</li>
    </ul>
    <p>
    Additional thanks to LemonBoy, Merlyn Morgan-Graham, Feix Weiglhofer,
    Josh Wolfe, Lachlan Easton, Layne Gustafson, Michael Dusan, Rocknest,
    Tadeo Kondrak, frmdstryr, travisstaloch, and via for contributions
    related to this feature.
    </p>

    {#header_close#}

    {#header_open|Self-Hosted Compiler Progress#}
    <p>
    Although there has been no progress during this release cycle directly on
    self-hosted semantic analysis and code generation, there has been significant
    progress towards self-hosting in other areas:
    </p>
    <ul>
      <li>{#link|C Translation#} is now self-hosted. To be clear, it still uses
        libclang to parse C code, however, 5,000 lines of C++ code were deleted
        in favor of a zig implementation.
      </li>
      <li><code>zig targets</code> is now self-hosted, and outputs JSON.</li>
      <li>Native system {#link|libc#} detection is now self-hosted.</li>
      <li>Native system dynamic linker detection is now self-hosted.</li>
      <li>Native system include search path detection is now self-hosted.</li>
      <li>Native system {#link|CPU Features#} detection is now self-hosted for x86
        (<a href="https://github.com/ziglang/zig/issues/4591">contributions welcome for other architectures</a>).</li>
    </ul>
    <p>
    More and more of the compiler is moving to be implemented in Zig rather than in C++.
    The C++ percent is shrinking and Zig percent is increasing. However,
    {#link|bootstrapping|Bootstrap Tarball#} remains forever a fixed, four-step process.
    </p>
    {#header_close#}

    {#header_open|compiler-rt#}
    <p>
    compiler-rt is the library that provides, for example, 64-bit integer multiplication for
    32-bit architectures which do not have a machine code instruction for it.
    In the <a href="https://gcc.gnu.org/">GNU</a> world, it's called libgcc.
    </p>
    <p>
    Unlike most compilers, which depend on a binary build of compiler-rt being installed alongside
    the compiler, Zig builds compiler-rt on-the-fly, from source, as needed for the target platform.
    This release saw some improvements to Zig's compiler-rt implementation.
    </p>
    <p>
    LemonBoy spent two days on an epic bug sleuthing quest, which was only reproducible
    inside docker, on AArch64, and finally managed to
    <a href="https://github.com/ziglang/zig/pull/4832">solve the problem</a>.
    An unrelated change to compiler-rt had exposed a latent bug, where
    {#syntax#}__floatunditf{#endsyntax#} was accidentally defined with
    parameter type {#syntax#}u128{#endsyntax#} rather than {#syntax#}u64{#endsyntax#}.
    Typos on the ABI boundary are especially nasty!
    </p>
    <p>In addition to that, LemonBoy contributed most of the improvements to compiler-rt
    during this release cycle.</p>
    <ul>
      <li>compiler_rt and freestanding libc are always built with optimizations, even
      when used by Debug Mode Zig code.</li>
      <li>Fix __stack_chk_guard emitted even when not linking libc.</li>
      <li>Add __clzsi2 - it is required for using std.fmt.format on some ARM architecture.</li>
      <li>Add clear_cache for aarch64, arm32-linux, and more.</li>
      <li>Remove x86/Windows name mangling hack</li>
      <li>Fix stack-probe symbol redefinition</li>
      <li>Add more compiler-rt functions for ARM platform</li>
      <li>Use the correct calling convention for AEABI intrinsics</li>
      <li>Fix div builtins to use the correct calling convention</li>
      <li>Remove useless wrappers around f32/f64 aeabi builtins</li>
      <li>Export MSVC builtins unconditionally</li>
      <li>Port __mulsi3 builtin</li>
      <li>Export the AEABI builtins when targeting thumb</li>
      <li>Add __divtf3</li>
      <li>Fix __floatunditf</li>
      <li>Implement all the shift builtins</li>
      <li>Add the __atomic family of builtins</li>
      <li>Separate max size allowed for load/store and CAS</li>
    </ul>
    <p>
    With Zig 0.6.0, compiler-rt is much more complete, but not fully. There are some
    <a href="https://github.com/ziglang/zig/issues/1290">missing functions</a>,
    and it's planned to do <a href="https://github.com/ziglang/zig/issues/1504">an audit</a>
    before 1.0.
    </p>
    <p>
    Additional thanks to Michael Dusan, daurnimator, Micha√´l Larouche, and Timon Kruiper
    for related contributions.
    </p>
    {#header_close#}

    {#header_open|Test Coverage#}
    <p>
    Zig uses a Continuous-Integration system to run Zig's test suite in various environments.
    In this release cycle, the system gained more test coverage:
    </p>
    <ul>
      <li>Full Aarch64 CI test coverage using Drone CI. This includes non-libc, musl, and glibc.</li>
      <li>QEMU test coverage for i386-linux-none behavior tests and standard library tests.</li>
      <li>QEMU test coverage for i386-linux-musl behavior tests and standard library tests.</li>
      <li>QEMU test coverage for mipsel-linux-none behavior tests and standard library tests.</li>
      <li>QEMU test coverage for mipsel-linux-musl behavior tests and standard library tests.</li>
      <li>QEMU test coverage for riscv64-linux-none behavior tests and standard library tests.</li>
      <li>QEMU test coverage for riscv64-linux-musl behavior tests and standard library tests.</li>
      <li>The Azure Windows CI server additionally runs i386-windows-msvc behavior tests and
        standard library tests.</li>
      <li>The Azure Windows CI server additionally runs i386-windows-gnu (building and linking
        mingw-w64) behavior tests and standard library tests.</li>
      <li>The Azure Windows CI server additionally runs x86_64-windows-gnu (building and linking
        mingw-w64) behavior tests and standard library tests.</li>
      <li>CI tests that building in a mingw-w64 environment succeeds. Thanks emekoi</li>
    </ul>
    <p>
    Thanks to Michael Dusan for getting
    <a href="https://github.com/ziglang/qemu-static">QEMU building statically</a>
    into a nice tarball that the CI server can download, extract, and run. This allows us to use
    a newer QEMU version than available in the Ubuntu repositories, on which {#link|SIMD#} tests pass.
    </p>
    <p>
    During this release cycle, many bugs were discovered to have been fixed as a side-effect
    of other changes. Rather than simply closing these bug reports, regression test cases were
    added for them.
    </p>
    <p>
    {#link|C Translation#} now has a new category of test: "run-translated-c"
    </p>
    <p>
    Benjamin Feng moved {#syntax#}std.debug.global_allocator{#endsyntax#} to
    {#syntax#}std.testing.allocator{#endsyntax#}, and improved it to add
    leak checking. This caught several leaks in the {#link|Standard Library#}.
    daurnimator helped migrate more tests to use {#syntax#}std.testing.allocator{#endsyntax#}.
    </p>
    <p>
    More FreeBSD tests are now passing (<a href="https://github.com/ziglang/zig/issues/3210">#3210</a>, <a href="https://github.com/ziglang/zig/issues/4455">#4455</a>).
    </p>
    <p>
    More {#link|RISC-V|RISC-V Support#} tests are now passing (<a href="https://github.com/ziglang/zig/issues/3338">#3338</a>).
    </p>
    <p>
    More tests are now passing since upgrading to {#link|LLVM 10#} (<a href="https://github.com/ziglang/zig/issues/4492">#4492</a>, <a href="https://github.com/ziglang/zig/issues/4724">#4724</a>).
    </p>
    {#header_close#}

    {#header_open|Memory Usage Reduction#}
    <p>
    The large portion of Zig compiler that is (currently) implemented in C++ is memory
    hungry and our continuous-integration process exacerbates the issue to the point
    where the RAM/VRAM sizes of open-source CI providers are sometimes insufficient.
    Additionally as we add more features and tests, yet more memory pressure is applied.
    </p>
    <p>
    The following bits are related to reducing the max RSS footprint of the compiler.
    Implementations by Andrew Kelley (ak) and Michael Dusan (md).
    </p>
    <ul>
      <li>(ak)
        Zig driver built with <code>-DZIG_ENABLE_MEM_PROFILE</code> accepts
        command-line option -fmem-report to produce a list of objects
        allocated by compiler code. Some useful invocations:
        <ul>
            <li><code>./zig test ../lib/std/std.zig --cache off -fmem-report</code></li>
            <li><code>/usr/bin/time -v ./zig test ../lib/std/std.zig --cache off -fmem-report</code></li>
        </ul>
        Reduce the size of <code>IrInstruction</code> by 8 bytes on 64 bit targets.
        (<a href="https://github.com/ziglang/zig/issues/3482">#3482</a>) RSS savings of ~3%
      </li>
      <li>(md)
        Unembed <code>ZigValue</code> from <code>IrInstruction</code>.
        Add const interning for 1-possible-value types.
        (<a href="https://github.com/ziglang/zig/issues/3502">#3502</a>) RSS savings of ~6%
      </li>
      <li>(ak)
        Sometimes free stuff from Zig IR pass 1.
        RSS savings of ~6%
      </li>
      <li>(ak)
        Inline <code>ConstGlobalRefs</code> into <code>ZigValue</code>.
        (<a href="https://github.com/ziglang/zig/issues/3817">#3817</a>) RSS savings of ~1.1%
      </li>
      <li>(ak)
        Free <code>IrAnalyze</code> sometimes.
        RSS savings of ~1%
      </li>
      <li>(ak)
        Split <code>IrInstruction</code> into <code>IrInst</code>, <code>IrInstSrc</code>, <code>IrInstGen</code>.
        This makes it so that less memory is used for IR instructions, as well
        as catching bugs when one expected one kind of instruction and received
        the other.
        (<a href="https://github.com/ziglang/zig/issues/4290">#4290</a>)
      </li>
      <li>(md)
        Overhaul C++ memory allocation:
        <ul>
          <li>new <code>mem::Allocator</code> interface</li>
          <li>new <code>heap::CAllocator</code> impl with global <code>heap::c_allocator</code></li>
          <li>new <code>heap::ArenaAllocator</code> impl</li>
          <li>new <code>mem::List</code> takes explicit <code>Allocator&</code> parameter</li>
          <li>new <code>mem::HashMap</code> takes explicit <code>Allocator&</code> parameter</li>
          <li>add <code>Codegen.pass1_arena</code> and use for all <code>ZigValue</code> allocs</li>
          <li>deinit <code>Codegen.pass1_arena</code> early in <code>zig_llvm_emit_output()</code></li>
        </ul>
        (<a href="https://github.com/ziglang/zig/issues/4389">#4389</a>) RSS savings of ~13-15%
      </li>
      <li>(md)
        Free more heap after analysis.
        (<a href="https://github.com/ziglang/zig/issues/4515">#4515</a>) RSS savings of ~5.5-6.3%
      </li>
    </ul>
    <p>
    The main goal of memory usage reduction is to ensure that
    {#link|bootstrapping|Bootstrap Tarball#} takes 3.5 GiB or less
    on the host system (<a href="https://github.com/ziglang/zig/issues/471">#471</a>).
    </p>
    {#header_close#}

    {#header_open|Advanced IR Debugging#}
    Andrew added native-debug helper functions for the Zig compiler.
    <p>
    Print triplet of (source:line:col) by calling member function <code>src()</code> for types
    <code>IrExecutable{Src,Gen}</code>,
    <code>AstNode</code>,
    <code>IrInst</code>,
    <code>IrInst{Src,Gen}</code> .
    </p>
    <p>
    Dump IR segment by calling member function <code>dump()</code> for types
    <code>IrExecutable{Src,Gen}</code>,
    <code>AstNode</code>,
    <code>IrInst</code>,
    <code>IrInst{Src,Gen}</code> .
    </p>
    <p>
    Dump <code>ZigValue</code> type-as-string by calling member function <code>dump</code> .
    </p>
    <p>
    When <code>--verbose-ir</code> is enabled,
    call <code>dbg_ir_break(src_file_zig, line)</code> to breakpoint inside <code>ir_analyze()</code> .
    </p>
    <p>
    Call <code>dbg_ir_clear()</code> to clear all breakpoints.
    </p>
    {#header_close#}

    {#header_open|Command Line Interface#}
    <p><strong>Added:</strong></p>
    <ul>
      <li><code>--eh-frame-hdr</code> - enable C++ exception handling by passing --eh-frame-hdr to link</li>
      <li><code>-fsanitize-c</code> - enable C undefined behavior detection in unsafe builds</li>
      <li><code>-fno-sanitize-c</code> - disable C undefined behavior detection in safe builds</li>
      <li><code>-fmem-report</code> - print {#link|memory usage|Memory Usage Reduction#} diagnostics</li>
      <li><code>-fdump-analysis</code> - write analysis.json file with type information</li>
      <li><code>-femit-docs</code> - create a docs/ dir with {#link|html documentation|Documentation Generation#}</li>
      <li><code>-fno-emit-docs</code> - do not produce docs/ dir with html documentation</li>
      <li><code>-femit-bin</code> - (default) output machine code</li>
      <li><code>-fno-emit-bin</code> - do not output machine code</li>
      <li><code>-femit-asm</code> - output .s (assembly code)</li>
      <li><code>-fno-emit-asm</code> - (default) do not output .s (assembly code)</li>
      <li><code>-femit-llvm-ir</code> - produce a .ll file with LLVM IR</li>
      <li><code>-fno-emit-llvm-ir</code> - (default) do not produce a .ll file with LLVM IR</li>
      <li><code>-femit-h</code> -  generate a C header file (.h)</li>
      <li><code>-fno-emit-h</code> - (default) do not generate a C header file (.h)</li>
      <li><code>--verbose-llvm-cpu-features</code> - enable compiler debug output for LLVM CPU features</li>
      <li><code>-I[dir]</code> - add directory to include search path</li>
      <li><code>-mcpu [cpu]</code> - specify {#link|target CPU and feature set|CPU Features#}</li>
      <li><code>-code-model [default|tiny|small|kernel|medium|large]</code> - set target code model</li>
      <li><code>--test-evented-io</code> - runs the test in {#link|evented I/O mode|Async I/O#}</li>
    </ul>
    <p><strong>Removed:</strong></p>
    <ul>
      <li><code>-target-glibc [version]</code> - now specified as part of {#link|target triple|Target Details#}</li>
      <li><code>-mios-version-min [ver]</code> - obsoleted by {#link|OS Version Ranges#}</li>
      <li><code>-mmacosx-version-min [ver]</code> - obsoleted by {#link|OS Version Ranges#}</li>
    </ul>
    <p><strong>Deprecated:</strong></p>
    <ul>
      <li><code>--emit [asm|bin|llvm-ir]</code> - prefer the new -femit-* or -fno-emit* options above.</li>
    </ul>
    <p>This will be removed once <a href="https://godbolt.org/">Compiler Explorer</a>
    updates to the new CLI.</p>
    <p>
    The command line interface now supports detecting native system headers and libraries
    (include/ and lib/ search paths). The implementation of this is {#link|self-hosted|Self-Hosted Compiler Progress#} (<a href="https://github.com/ziglang/zig/issues/2041">#2041</a>).
    </p>
    <p>The error output is improved when an invalid CPU model or CPU feature is specified:</p>
    <pre><code>andy@ark ~&gt; zig build-exe hello.zig -mcpu=bogus
Unknown CPU: 'bogus'
Available CPUs for architecture 'x86_64':
 amdfam10
 athlon
 athlon_4
 athlon_fx
 athlon_mp
 athlon_tbird
 athlon_xp
 athlon64
 athlon64_sse3
 atom
 barcelona
 bdver1
 bdver2
 bdver3
 bdver4
 bonnell
 broadwell
 btver1
 btver2
 c3
 c3_2
 cannonlake
 cascadelake
 cooperlake
 core_avx_i
 core_avx2
 core2
 corei7
 corei7_avx
 generic
 geode
 goldmont
 goldmont_plus
 haswell
 _i386
 _i486
 _i586
 _i686
 icelake_client
 icelake_server
 ivybridge
 k6
 k6_2
 k6_3
 k8
 k8_sse3
 knl
 knm
 lakemont
 nehalem
 nocona
 opteron
 opteron_sse3
 penryn
 pentium
 pentium_m
 pentium_mmx
 pentium2
 pentium3
 pentium3m
 pentium4
 pentium4m
 pentiumpro
 prescott
 sandybridge
 silvermont
 skx
 skylake
 skylake_avx512
 slm
 tigerlake
 tremont
 westmere
 winchip_c6
 winchip2
 x86_64
 yonah
 znver1
 znver2
andy@ark ~&gt; zig build-exe hello.zig -mcpu=x86_64+bogus
Unknown CPU feature: 'bogus'
Available CPU features for architecture 'x86_64':
 3dnow: Enable 3DNow! instructions
 3dnowa: Enable 3DNow! Athlon instructions
 64bit: Support 64-bit instructions
 adx: Support ADX instructions
 aes: Enable AES instructions
 avx: Enable AVX instructions
 avx2: Enable AVX2 instructions
 avx512bf16: Support bfloat16 floating point
 avx512bitalg: Enable AVX-512 Bit Algorithms
 avx512bw: Enable AVX-512 Byte and Word Instructions
 avx512cd: Enable AVX-512 Conflict Detection Instructions
 avx512dq: Enable AVX-512 Doubleword and Quadword Instructions
 avx512er: Enable AVX-512 Exponential and Reciprocal Instructions
 avx512f: Enable AVX-512 instructions
 avx512ifma: Enable AVX-512 Integer Fused Multiple-Add
 avx512pf: Enable AVX-512 PreFetch Instructions
 avx512vbmi: Enable AVX-512 Vector Byte Manipulation Instructions
 avx512vbmi2: Enable AVX-512 further Vector Byte Manipulation Instructions
 avx512vl: Enable AVX-512 Vector Length eXtensions
 avx512vnni: Enable AVX-512 Vector Neural Network Instructions
 avx512vp2intersect: Enable AVX-512 vp2intersect
 avx512vpopcntdq: Enable AVX-512 Population Count Instructions
 bmi: Support BMI instructions
 bmi2: Support BMI2 instructions
 branchfusion: CMP/TEST can be fused with conditional branches
 cldemote: Enable Cache Demote
 clflushopt: Flush A Cache Line Optimized
 clwb: Cache Line Write Back
 clzero: Enable Cache Line Zero
 cmov: Enable conditional move instructions
 cx16: 64-bit with cmpxchg16b
 cx8: Support CMPXCHG8B instructions
 enqcmd: Has ENQCMD instructions
 ermsb: REP MOVS/STOS are fast
 f16c: Support 16-bit floating point conversion instructions
 false_deps_lzcnt_tzcnt: LZCNT/TZCNT have a false dependency on dest register
 false_deps_popcnt: POPCNT has a false dependency on dest register
 fast_11bytenop: Target can quickly decode up to 11 byte NOPs
 fast_15bytenop: Target can quickly decode up to 15 byte NOPs
 fast_bextr: Indicates that the BEXTR instruction is implemented as a single uop with good throughput
 fast_gather: Indicates if gather is reasonably fast
 fast_hops: Prefer horizontal vector math instructions (haddp, phsub, etc.) over normal vector instructions with shuffles
 fast_lzcnt: LZCNT instructions are as fast as most simple integer ops
 fast_scalar_fsqrt: Scalar SQRT is fast (disable Newton-Raphson)
 fast_scalar_shift_masks: Prefer a left/right scalar logical shift pair over a shift+and pair
 fast_shld_rotate: SHLD can be used as a faster rotate
 fast_variable_shuffle: Shuffles with variable masks are fast
 fast_vector_fsqrt: Vector SQRT is fast (disable Newton-Raphson)
 fast_vector_shift_masks: Prefer a left/right vector logical shift pair over a shift+and pair
 fma: Enable three-operand fused multiple-add
 fma4: Enable four-operand fused multiple-add
 fsgsbase: Support FS/GS Base instructions
 fxsr: Support fxsave/fxrestore instructions
 gfni: Enable Galois Field Arithmetic Instructions
 idivl_to_divb: Use 8-bit divide for positive values less than 256
 idivq_to_divl: Use 32-bit divide for positive values less than 2^32
 invpcid: Invalidate Process-Context Identifier
 lea_sp: Use LEA for adjusting the stack pointer
 lea_uses_ag: LEA instruction needs inputs at AG stage
 lwp: Enable LWP instructions
 lzcnt: Support LZCNT instruction
 macrofusion: Various instructions can be fused with conditional branches
 merge_to_threeway_branch: Merge branches to a three-way conditional branch
 mmx: Enable MMX instructions
 movbe: Support MOVBE instruction
 movdir64b: Support movdir64b instruction
 movdiri: Support movdiri instruction
 mpx: Deprecated. Support MPX instructions
 mwaitx: Enable MONITORX/MWAITX timer functionality
 nopl: Enable NOPL instruction
 pad_short_functions: Pad short functions
 pclmul: Enable packed carry-less multiplication instructions
 pconfig: platform configuration instruction
 pku: Enable protection keys
 popcnt: Support POPCNT instruction
 prefer_128_bit: Prefer 128-bit AVX instructions
 prefer_256_bit: Prefer 256-bit AVX instructions
 prefer_mask_registers: Prefer AVX512 mask registers over PTEST/MOVMSK
 prefetchwt1: Prefetch with Intent to Write and T1 Hint
 prfchw: Support PRFCHW instructions
 ptwrite: Support ptwrite instruction
 rdpid: Support RDPID instructions
 rdrnd: Support RDRAND instruction
 rdseed: Support RDSEED instruction
 retpoline: Remove speculation of indirect branches from the generated code, either by avoiding them entirely or lowering them with a speculation blocking construct
 retpoline_external_thunk: When lowering an indirect call or branch using a `retpoline`, rely on the specified user provided thunk rather than emitting one ourselves. Only has effect when combined with some other retpoline feature
 retpoline_indirect_branches: Remove speculation of indirect branches from the generated code
 retpoline_indirect_calls: Remove speculation of indirect calls from the generated code
 rtm: Support RTM instructions
 sahf: Support LAHF and SAHF instructions
 sgx: Enable Software Guard Extensions
 sha: Enable SHA instructions
 shstk: Support CET Shadow-Stack instructions
 slow_3ops_lea: LEA instruction with 3 ops or certain registers is slow
 slow_incdec: INC and DEC instructions are slower than ADD and SUB
 slow_lea: LEA instruction with certain arguments is slow
 slow_pmaddwd: PMADDWD is slower than PMULLD
 slow_pmulld: PMULLD instruction is slow
 slow_shld: SHLD instruction is slow
 slow_two_mem_ops: Two memory operand instructions are slow
 slow_unaligned_mem_16: Slow unaligned 16-byte memory access
 slow_unaligned_mem_32: Slow unaligned 32-byte memory access
 soft_float: Use software floating point features
 sse: Enable SSE instructions
 sse_unaligned_mem: Allow unaligned memory operands with SSE instructions
 sse2: Enable SSE2 instructions
 sse3: Enable SSE3 instructions
 sse4_1: Enable SSE 4.1 instructions
 sse4_2: Enable SSE 4.2 instructions
 sse4a: Support SSE 4a instructions
 ssse3: Enable SSSE3 instructions
 tbm: Enable TBM instructions
 use_aa: Use alias analysis during codegen
 use_glm_div_sqrt_costs: Use Goldmont specific floating point div/sqrt costs
 vaes: Promote selected AES instructions to AVX512/AVX registers
 vpclmulqdq: Enable vpclmulqdq instructions
 vzeroupper: Should insert vzeroupper instructions
 waitpkg: Wait and pause enhancements
 wbnoinvd: Write Back No Invalidate
 x87: Enable X87 float instructions
 xop: Enable XOP instructions
 xsave: Support xsave instructions
 xsavec: Support xsavec instructions
 xsaveopt: Support xsaveopt instructions
 xsaves: Support xsaves instructions</code></pre>
    <p>
    Of course, this works for any architecture, not only x86_64.
    </p>
    <p>Thanks Noam Preil, Christine Dodrill, David Cao, and Layne Gustafson
    for related contributions.</p>
    {#header_close#}

    {#header_open|Miscellaneous Improvements#}
    <ul>
      <li>Add <code>-I</code> command line parameter.</li>
      <li>POSIX terminals now have a progress indicator when compilation takes a long time.
        Thanks to Luna for the initial implementation.</li>
      <li>Michael Dusan added linux XDG Base Directory integration to the cache system. <a href="https://github.com/ziglang/zig/issues/3573">#3573</a></li>
      <li>Add compiler note for bad int coercion (<a href="https://github.com/ziglang/zig/issues/3724">#3724</a>)</li>
      <li>Private linkage for unnamed internal constants.</li>
      <li>Vexu implemented better support for extern enums.</li>
      <li>LemonBoy added a compile error for @bitCast to enum types, preventing invalid enum values.</li>
      <li>David Cao added <code>--eh-frame-hdr</code> CLI option. (<a href="https://github.com/ziglang/zig/issues/3981">#3981</a>)</li>
      <li>LemonBoy improved debug info type sizes, making debuggers happy
        and no longer report incorrect values for {#syntax#}bool{#endsyntax#}. (<a href="https://github.com/ziglang/zig/issues/2685">#2685</a>)</li>
      <li>LemonBoy improved the compiler to not special case the {#syntax#}"builtin"{#endsyntax#}
        import with regards to {#syntax#}usingnamespace{#endsyntax#}.</li>
      <li>Michael Dusan improved the compiler to strip cwd from compile error paths. (<a href="https://github.com/ziglang/zig/issues/4138">#4138</a>)</li>
      <li>Michael Dusan improved the BREAKPOINT util within the C++ compiler code to support
        non-x86 architectures.</li>
      <li>LemonBoy improved the C++ compiler code internal debugging utilities.</li>
      <li>There is no longer a <code>native_libc.txt</code> file in zig-cache, and thus
        there is no longer a possibility for this file to become stale and cause problems.
        The libc installation path detection code is always run when needed. (<a href="https://github.com/ziglang/zig/issues/3975">#3975</a>, <a href="https://github.com/ziglang/zig/issues/4186">#4186</a>, <a href="https://github.com/ziglang/zig/issues/4940">#4940</a>)</li>
      <li>Michael Dusan improved the development process on POSIX to support <code>make</code> without
        being required to <code>make install</code>. On Windows the INSTALL target is still a
        required part of the development process.</li>
      <li>LemonBoy improved {#syntax#}@tagName{#endsyntax#} to work on enum literals. (<a href="https://github.com/ziglang/zig/issues/4214">#4214</a>)</li>
      <li>Valentin Anger added support for code model selection.</li>
      <li>Michael Dusan improved debuggability of the compiler by showing "Const" IR instructions
          trailing after they are referenced. (<a href="https://github.com/ziglang/zig/issues/4511">#4511</a>)</li>
      <li>LemonBoy implemented safety checks for shl/shr when the integer size is not a power-of-two. (<a href="https://github.com/ziglang/zig/issues/2096">#2096</a>)</li>
      <li>daurnimator removed unused static_crt_dir field from <code>zig libc</code> config.</li>
      <li>Bodie Solomon improved Zig's cmake build script to use appropriate compiler flags when
      building with MSVC. (<a href="https://github.com/ziglang/zig/issues/4877">#4877</a>)</li>
      <li>Michael Dusan added a compiler flag to Zig's C++ compiler code that makes accidental
        switch case fallthrough a compile error, which uncovered a bug in the tokenizer.</li>
      <li>The <code>zig BUILD_INFO</code> hack is removed.
        Rather than stuffing configuration information into the Zig binary, the
        build script reads it from config.h. This solves a problem for package
        maintainers and improves the use case of deterministic builds. (<a href="https://github.com/ziglang/zig/issues/3758">#3758</a>)</li>
      <li>libc installation detection can correctly detect MSVC libc even when the compiler is
        built using the gnu target triple (taking advantage of {#link|mingw|mingw-w64 7.0.0#}</li>
      <li>Tse contributed DragonFlyBSD Support.</li>
    </ul>
    {#header_close#}

    {#header_open|Bug Fixes#}
    <p>
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aclosed+is%3Aissue+label%3Abug+milestone%3A0.6.0+">Full list of bug reports closed during this release cycle</a>.
    Note: many bugs were both introduced and resolved within this release cycle.
    Listed below are fixed bugs that were not reported on the issue tracker.
    </p>
    <p>
    Special thanks to LemonBoy, who solved a sizeable chunk of those issues, in
    many different parts of the Zig project.
    </p>
    <ul>
      <li>Better debug info for integers. Now we use ABI size * 8 instead of size_in_bits which makes
        gdb work instead of hang for non-power-of-two integers.</li>
      <li>LemonBoy fixed user-defined function alignment not getting propagated to LLVM IR.</li>
      <li>LemonBoy fixed crash when generating constant unions with single field.</li>
      <li>Various fixes related to 32-bit architectures.</li>
      <li>Async function recursion is detected and compile error emitted.</li>
      <li>Brendan Hansknecht fixed parsing of {#syntax#}.*={#endsyntax#}.</li>
      <li>Vexu fixed NodeErrorSetDecl rendering.</li>
      <li>Timon Kruiper added a compile error for an empty switch on a integer.</li>
      <li>Quetzal Bradley implemented correct buffer wrapping logic in {#syntax#}std.event.Channel{#endsyntax#}.</li>
      <li>LemonBoy fixed WinMain not having its calling convention type-checked.</li>
      <li>xackus fixed integers parsed as floats.</li>
      <li>emekoi fixed Windows dynamic library loading and added loading for Darwin.</li>
      <li>ForLoveOfCats fixed a memory leak in {#syntax#}std.math.big.Int.toString{#endsyntax#}. (<a href="https://github.com/ziglang/zig/issues/3992">#3992</a>)</li>
      <li>LemonBoy improved the compiler's type resolution phase to catch more errors.</li>
      <li>daurnimator fixed an off-by-one error in Windows process creation.</li>
      <li>LemonBoy added missing validation for {#syntax#}switch{#endsyntax#} range endpoints. (<a href="https://github.com/ziglang/zig/issues/4172">#4172</a>)</li>
      <li>Vexu fixed a crash when parsing a multiline library name.</li>
      <li>Micha√´l Larouche fixed {#syntax#}std.child_process.ChildProcess.spawnWindows{#endsyntax#} when looking in {#syntax#}PATH{#endsyntax#} environment variable, it applied cwd+app_name instead of just using the app_name.</li>
      <li>daurnimator fixed bug in {#syntax#}std.http.headers{#endsyntax#} where .put captures user-held variable.</li>
      <li>Fixed automatically created local variables sometimes having incorrect alignment.</li>
      <li>LemonBoy fixed an edge case in {#syntax#}isAbsolute{#endsyntax#} path functions. Empty
      strings are no longer considered absolute paths. (<a href="https://github.com/ziglang/zig/issues/4382">#4382</a>)</li>
      <li>Rocknest fixed a double close in {#syntax#}openElfDebugInfo{#endsyntax#}.</li>
      <li>Fixed not checking type of return pointers. (<a href="https://github.com/ziglang/zig/issues/3224">#3224</a>, <a href="https://github.com/ziglang/zig/issues/3269">#3269</a>, <a href="https://github.com/ziglang/zig/issues/3327">#3327</a>, <a href="https://github.com/ziglang/zig/issues/3422">#3422</a>, <a href="https://github.com/ziglang/zig/issues/3646">#3646</a>)</li>
      <li>std lib updated to integrate with libc for environment variables, even
        when building a static library. (<a href="https://github.com/ziglang/zig/issues/3511">#3511</a>)</li>
      <li>J.W fixed logic and index out of bounds in hashing algorithms.</li>
      <li>Exported variables now respect linkage.</li>
      <li>Alexandros Naskos fixed slicing of C pointers to no longer produce {#syntax#}allowzero{#endsyntax#} slices. Instead they insert a runtime assertion. (<a href="https://github.com/ziglang/zig/issues/4462">#4462</a>)</li>
      <li>Alexandros Naskos improved made the std lib VDSO code more robust and it now operates successfully inside Windows Subsystem for Linux. (<a href="https://github.com/ziglang/zig/issues/3997">#3997</a>)</li>
      <li>LemonBoy improved array subscripts to properly type coerce to {#syntax#}usize{#endsyntax#}. (<a href="https://github.com/ziglang/zig/issues/4169">#4169</a>)</li>
      <li>LemonBoy implemented a compile error for comparison between enum literal and untagged enum. (<a href="https://github.com/ziglang/zig/issues/4770">#4770</a>)</li>
      <li>xackus fixed an overflow in {#syntax#}std.fmt.parseFloat{#endsyntax#} (<a href="https://github.com/ziglang/zig/issues/4845">#4845</a>)</li>
      <li>Micha√´l Larouche fixed adler32 returning incorrect value with large input.</li>
      <li>LemonBoy improved big-endian compatibility. (<a href="https://github.com/ziglang/zig/issues/4935">#4935</a>)</li>
      <li>Zig no longer caches the results of native system libc detection into a native_libc.txt file.
          Instead, it always runs native libc detection when it needs to know native libc paths. (<a href="https://github.com/ziglang/zig/issues/4772">#4772</a>)</li>
    </ul>

    {#header_open|This Release Contains Bugs#}
    <p>
    Zig has
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Abug">known bugs</a>
    and even some
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Amiscompilation">miscompilations</a>.
    </p>
    <p>Zig is immature. Even with Zig 0.6.0, working on a non-trivial project using Zig will
    likely require participating in the development process.</p>
    <p>The first release to ship with no known bugs will be 1.0.0.</p>
    {#header_close#}
    {#header_close#}

    {#header_open|Please Welcome Vexu to the Core Zig Team#}
    <p>I am pleased to announce our newest Zig team member, <a href="https://vexu.eu/">Vexu</a>.</p>
    <p>Vexu has shown continued dedication and discipline in contributions to the Zig
    programming language project. The quality of Vexu's work speaks for itself.</p>
    <p>
    In addition, Vexu has proven to be a steadfast community leader,
    setting an example for how to treat others with kindness and respect.
    </p>
    <p>I look forward to working with Vexu as we continue to push Zig toward 1.0.0 and beyond.</p>
    {#header_close#}

    {#header_open|Roadmap#}
    <p>
    According to the
    <a href="https://ziglang.org/download/0.5.0/release-notes.html#Roadmap">0.5.0 Roadmap</a>,
    the major theme of the 0.6.0 release was supposed to be {#link|Safety#}. I also wrote:
    </p>
    <blockquote>
    I expect to complete [{#link|Networking#}] along with at least an early prototype of the
    package manager during the next release cycle.
    </blockquote>
    <p>
    Clearly, this release cycle went in a different direction than planned.
    I realized that {#link|stabilizing the language|Language Changes#} is a top priority that
    everything else rests on. I also prioritized merging pull requests (at the time of writing,
    there are only 21 open pull requests, with the oldest one 36 days old), and unblocking
    contributors from accomplishing their goals.
    </p>
    <p>
    The theme of the 0.7.0 release cycle will be <strong>stabilizing the language</strong>,
    <strong>creating a first draft of the language specification</strong>, and
    <strong>self-hosting the compiler</strong>.
    </p>
    <p>
    It would be a major accomplishment if Zig 0.7.0 could ship with self-hosted instead of stage1.
    </p>

    {#header_open|Package Manager Status#}
    <p>
    Having a package manager built into the Zig compiler is a
    <a href="https://github.com/ziglang/zig/issues/943">long-anticipated feature</a>.
    Zig 0.6.0 does not have this feature.
    </p>
    <p>
    If the package manager works well, people will use it, which means building Zig projects
    will involve compiling more lines of Zig code, which means the Zig compiler must get faster,
    better at incremental compilation, and better at resource management.
    </p>
    <p>
    Therefore, the package manager depends on finishing the
    {#link|self-hosted compiler|Self-Hosted Compiler Progress#}, since it is planned to have these
    improved performance characteristics, while stage1 is not planned to have them.
    </p>
    {#header_close#}

    {#header_open|C Header File Generation Status#}
    <p>
    There were two improvements:
    </p>
    <ul>
      <li>Support for exporting variables (<a href="https://github.com/ziglang/zig/issues/3284">#3284</a>).</li>
      <li>Properly generate header in separate folder, respecting -femit-* options.</li>
    </ul>
    <p>
    Thanks Sahnvour and mogud.
    </p>
    <p>
    However, C header file generation is now disabled by default. The proof-of-concept is
    complete; but now it's a maintenance burden to implement this feature both in stage1
    and in self-hosted.
    </p>
    <p>
    The plan is to implement this feature in the
    {#link|self-hosted compiler|Self-Hosted Compiler Progress#}, and then remove the feature
    from stage1, since it is not needed to {#link|bootstrap|Bootstrap Tarball#}.
    </p>
    {#header_close#}

    {#header_open|Accepted Proposals#}
    <p>
    If you want more of a sense of the direction Zig is heading, you can look at
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Aaccepted">the set of accepted proposals</a>.
    </p>
    {#header_close#}
    {#header_close#}

    {#header_open|Active Open-Source Projects Using Zig#}
    <ul>
      <li><a href="https://github.com/wendigojaeger/ZigGBA">ZigGBA</a> - Work in Progress SDK to write Game Boy Advance in Zig</li>
      <li><a href="https://github.com/TM35-Metronome">TM35-Metronome</a> - Tools for modifying and randomizing Pok√©mon games.</li>
      <li><a href="https://github.com/SamTebbs33/pluto">pluto</a> - An x86 kernel, with plans to port it to x86_64, arm and aarch64.</li>
      <li><a href="https://gitdab.com/luna/scritcher">scritcher</a> - Glitch art scripting language</li>
      <li><a href="https://github.com/shakesoda/tinyfx">tinyfx</a> - Mid-level OpenGL rendering library in C with Zig wrapper.</li>
      <li><a href="https://hg.sr.ht/~dermetfan/embed-dir">embed-dir</a> - A small Zig library for embedding directory trees with {#syntax#}@embedFile{#endsyntax#}.</li>
      <li><a href="https://github.com/fengb/fundude">Fundude</a> - Gameboy emulator running in wasm</li>
      <li><a href="https://github.com/ifreund/river">river</a> - A dynamic wayland compositor.</li>
      <li><a href="https://github.com/fengb/wazm">wazm</a> - wasm interpreter</li>
      <li><a href="https://github.com/user00e00/sudokuinzig">sudokuinzig</a> - A basic sudoku solver</li>
      <li><a href="https://github.com/Vexu/bog">bog</a> - Embeddable scripting language written in Zig</li>
      <li><a href="https://github.com/mlarouche/zigimg">zigimg</a> - Library to read (and soon write) image files.</li>
      <li><a href="https://github.com/dbandstra/oxid">oxid</a> - arcade-style game where you fight waves of monsters in a fixed-screen maze</li>
      <li><a href="https://github.com/masterQ32/LoLa-Native">LoLa</a> - Script language written in Zig and C++</li>
    </ul>
    {#header_close#}

    {#header_open|Funding Status#}
    <p>
    The Zig project is financially sustainable. It currently supports one
    full-time developer - yours truly, Andrew Kelley.
    </p>
    <p>
    If you flip through the previous release notes, you can see the number of commits and
    number of contributors per release increasing super-linearly.
    </p>
    <p>
    The project is succeeding!
    </p>
    <p>Consequently, merging pull requests
    and providing troubleshooting, support, and moderation for the quickly-growing community
    creates a strong demand on time that is too much for just one person.
    </p>
    <p>
    That is why I decided to start the <strong>Zig Software Foundation</strong>,
    a non-profit organization with the mission of raising the bar of software standards,
    ethics, and quality, and paying open source contributors for their valuable time.
    </p>
    <p>
    I hope you will stay tuned for an official announcement about the ZSF, which I expect
    to happen within 6 months.
    </p>
    {#header_close#}

    {#header_open|Thank You Sponsors!#}
    <p>
    Special thanks to those who <a href="https://github.com/users/andrewrk/sponsorship">sponsor Zig</a>.
    Because of you, Zig is driven by the open source community, rather than the goal of making profit.
    In particular, these fine folks sponsor Zig for $15/month or more:
    </p>
    <ul style="columns: 3">
      <li><a href="https://skunkwerks.at/">SkunkWerks, GmbH</a></li>
      <li><a href="https://www.hryx.net/">Stevie Hryciw</a></li>
      <li><a href="https://github.com/karrick">Karrick McDermott</a></li>
      <li><a href="https://jowl.app/">Daniel Axelrod</a></li>
      <li><a href="https://github.com/dimenus">Ryan Saunderson</a></li>
      <li><a href="https://github.com/drfuchs">drfuchs</a></li>
      <li><a href="http://severnatazvezda.com/">Rickard Andersson</a></li>
      <li><a href="http://haze.cool/">haze</a></li>
      <li><a href="https://github.com/iohzrd">iohzrd</a></li>
      <li><a href="http://interviewessentials.com/">Jessica Hargis</a></li>
      <li><a href="https://ross.codes/">Ross Kilgariff</a></li>
      <li><a href="https://kristoff.it/">Loris Cro</a></li>
      <li><a href="https://github.com/overdew">Jeff Kelley</a></li>
      <li><a href="http://raytracer.me/">Christoph M√ºller</a></li>
      <li><a href="https://github.com/rsimmons">Russel Simmons</a></li>
      <li><a href="https://github.com/ryanworl">ryanworl</a></li>
      <li><a href="http://santiagoandaluz.com/">Santiago Andaluz</a></li>
      <li><a href="https://github.com/vchakrav">vchakrav</a></li>
      <li><a href="https://github.com/sit-fyi">Yurii Rashkovskii</a></li>
      <li><a href="https://burntsushi.net/">Andrew Gallant</a></li>
      <li><a href="https://github.com/cshenton">Charles Shenton</a></li>
      <li><a href="https://dawnarc.com/">Neil Wang</a></li>
      <li><a href="http://www.fengb.me/">Benjamin Feng</a></li>
      <li><a href="https://filippo.io/">Filippo Valsorda</a></li>
      <li><a href="https://jayschwa.net/">Jay Petacat</a></li>
      <li><a href="https://github.com/qbradley">Quetzal Bradley</a></li>
      <li><a href="https://github.com/quag">Jonathan Wright</a></li>
      <li><a href="https://github.com/rahulunair">Rahul Nair</a></li>
      <li><a href="https://bitsandhops.com/">Richard Bishop</a></li>
      <li><a href="https://www.embark-studios.com/">Johan Andersson</a></li>
      <li><a href="http://joshtob.in/">Josh Tobin</a></li>
      <li><a href="https://github.com/rui314">Rui Ueyama</a></li>
      <li><a href="https://github.com/Sticksman">Felix Yuan</a></li>
      <li><a href="http://espians.com/">tav</a></li>
      <li><a href="http://zfeldman.com/">Zach Feldman</a></li>
      <li><a href="https://github.com/mschwaig">Martin Schwaighofer</a></li>
      <li>tschaei</li>
      <li>Arto Bendiken</li>
      <li>Simon Cruanes</li>
      <li>Champ Yen</li>
      <li>Clipsey</li>
      <li>Luke I. Wilson</li>
      <li>Dan Boykis</li>
      <li>Eric</li>
      <li>Felix Jankowski</li>
      <li>fuzzwizard</li>
      <li>Gilbert</li>
      <li>Chris Heyes</li>
      <li>Jimmi Holst Christensen</li>
      <li>Hong Shick Pak</li>
      <li>Isaac Yonemoto</li>
      <li>Jesse Meyer</li>
      <li>Jethro Nederhof</li>
      <li>Jason Merrill</li>
      <li>Jack Halford</li>
      <li>Jimmy Zelinskie</li>
      <li>Keith Chambers</li>
      <li>Alon Zakai</li>
      <li>kristianhasselknippe</li>
      <li>Stefano Casillo</li>
      <li>Luis Alfonso Higuera Gamboa</li>
      <li>Charles Palmer</li>
      <li>Michael Lehmann</li>
      <li>Mirek Rusin</li>
      <li>Micha√´l Larouche</li>
      <li>Johann Muszynski</li>
      <li>Omar Akkila</li>
      <li>Emily A. Bellows</li>
      <li>Guillermo Rauch</li>
      <li>redj</li>
      <li>Robinson Collado</li>
      <li>rtroberts</li>
      <li>John Schmidt</li>
      <li>Scott J Maddox</li>
      <li>Lukas Attridge</li>
      <li>Neil Henning</li>
      <li>Audun Wilhelmsen</li>
      <li>Steve Perkins</li>
      <li>Clement Rey</li>
      <li>Thomas Ballinger</li>
      <li>Brian Orr</li>
      <li>vegecode</li>
      <li>Yiu Ming Huynh</li>
      <li>Abdulrhman A. AlKhodiry</li>
    </ul>
    {#header_close#}
    </div>
  </body>
</html>
