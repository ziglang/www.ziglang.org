<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Documentation - The Zig Programming Language</title>
    <style type="text/css">
.hljs{display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:bold}.hljs-number,.hljs-literal,.hljs-variable,.hljs-template-variable,.hljs-tag .hljs-attr{color:#008080}.hljs-string,.hljs-doctag{color:#d14}.hljs-title,.hljs-section,.hljs-selector-id{color:#900;font-weight:bold}.hljs-subst{font-weight:normal}.hljs-type,.hljs-class .hljs-title{color:#458;font-weight:bold}.hljs-tag,.hljs-name,.hljs-attribute{color:#000080;font-weight:normal}.hljs-regexp,.hljs-link{color:#009926}.hljs-symbol,.hljs-bullet{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:bold}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:bold}
    </style>
    <style type="text/css">
      table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
      }
      th, td {
        padding: 0.1em;
      }
      .t0_1, .t37, .t37_1 {
        font-weight: bold;
      }
      .t2_0 {
        color: grey;
      }
      .t31_1 {
        color: red;
      }
      .t32_1 {
        color: green;
      }
      .t36_1 {
        color: #0086b3;
      }
      .file {
        text-decoration: underline;
      }
      code {
        font-size: 12pt;
      }
      pre > code {
        display: block;
        overflow: auto;
      }
      .table-wrapper {
        width: 100%;
        overflow-y: auto;
      }
      /* Desktop */
      @media screen and (min-width: 56.25em) {
        #nav {
          width: 20em;
          height: 100%;
          position: fixed;
          overflow-y: scroll;
          left: 0;
          top: 2em;
          padding-left: 1em;
        }
        #contents {
          max-width: 60em;
          padding-left: 22em;
          padding: 1em;
          padding-left: 24em;
        }
      }
      /* Mobile */
      @media screen and (max-width: 56.25em) {
        body, code {
          font-size: small;
        }
        #nav {
          border-bottom: 1px solid grey;
        }
      }
    </style>
  </head>
  <body>
<a href="https://ziglang.org/documentation/0.1.1">0.1.1</a> |
0.2.0 |
<a href="https://ziglang.org/documentation/0.3.0">0.3.0</a> |
<a href="https://ziglang.org/documentation/0.4.0">0.4.0</a> |
<a href="https://ziglang.org/documentation/0.5.0">0.5.0</a> |
<a href="https://ziglang.org/documentation/0.6.0">0.6.0</a> |
<a href="https://ziglang.org/documentation/0.7.1">0.7.1</a> |
<a href="https://ziglang.org/documentation/0.8.1">0.8.1</a> |
<a href="https://ziglang.org/documentation/0.9.0">0.9.0</a> |
<a href="https://ziglang.org/documentation/master">master</a>
    <div id="nav">
      <h3>Index</h3>
      

    <ul>
        <li><a href="#Introduction">Introduction</a></li>
        <li><a href="#Hello-World">Hello World</a></li>
        <li><a href="#Values">Values</a>
        <ul>
            <li><a href="#Primitive-Types">Primitive Types</a></li>
            <li><a href="#Primitive-Values">Primitive Values</a></li>
            <li><a href="#String-Literals">String Literals</a>
            <ul>
                <li><a href="#Escape-Sequences">Escape Sequences</a></li>
                <li><a href="#Multiline-String-Literals">Multiline String Literals</a></li>
            </ul></li>
            <li><a href="#Assignment">Assignment</a></li>
        </ul></li>
        <li><a href="#Integers">Integers</a>
        <ul>
            <li><a href="#Integer-Literals">Integer Literals</a></li>
            <li><a href="#Runtime-Integer-Values">Runtime Integer Values</a></li>
        </ul></li>
        <li><a href="#Floats">Floats</a>
        <ul>
            <li><a href="#Float-Literals">Float Literals</a></li>
            <li><a href="#Floating-Point-Operations">Floating Point Operations</a></li>
        </ul></li>
        <li><a href="#Operators">Operators</a>
        <ul>
            <li><a href="#Table-of-Operators">Table of Operators</a></li>
            <li><a href="#Precedence">Precedence</a></li>
        </ul></li>
        <li><a href="#Arrays">Arrays</a></li>
        <li><a href="#Pointers">Pointers</a>
        <ul>
            <li><a href="#Alignment">Alignment</a></li>
            <li><a href="#Type-Based-Alias-Analysis">Type Based Alias Analysis</a></li>
        </ul></li>
        <li><a href="#Slices">Slices</a></li>
        <li><a href="#struct">struct</a></li>
        <li><a href="#enum">enum</a>
        <ul>
            <li><a href="#extern-enum">extern enum</a></li>
        </ul></li>
        <li><a href="#union">union</a></li>
        <li><a href="#switch">switch</a></li>
        <li><a href="#while">while</a></li>
        <li><a href="#for">for</a></li>
        <li><a href="#if">if</a></li>
        <li><a href="#defer">defer</a></li>
        <li><a href="#unreachable">unreachable</a>
        <ul>
            <li><a href="#Basics">Basics</a></li>
            <li><a href="#At-Compile-Time">At Compile-Time</a></li>
        </ul></li>
        <li><a href="#noreturn">noreturn</a></li>
        <li><a href="#Functions">Functions</a>
        <ul>
            <li><a href="#Pass-by-value-Parameters">Pass-by-value Parameters</a></li>
            <li><a href="#Function-Reflection">Function Reflection</a></li>
        </ul></li>
        <li><a href="#Errors">Errors</a>
        <ul>
            <li><a href="#Error-Set-Type">Error Set Type</a>
            <ul>
                <li><a href="#The-Global-Error-Set">The Global Error Set</a></li>
            </ul></li>
            <li><a href="#Error-Union-Type">Error Union Type</a>
            <ul>
                <li><a href="#Inferred-Error-Sets">Inferred Error Sets</a></li>
            </ul></li>
            <li><a href="#Error-Return-Traces">Error Return Traces</a></li>
        </ul></li>
        <li><a href="#Nullables">Nullables</a>
        <ul>
            <li><a href="#Nullable-Type">Nullable Type</a></li>
        </ul></li>
        <li><a href="#Casting">Casting</a></li>
        <li><a href="#void">void</a></li>
        <li><a href="#this">this</a></li>
        <li><a href="#comptime">comptime</a>
        <ul>
            <li><a href="#Introducing-the-Compile-Time-Concept">Introducing the Compile-Time Concept</a>
            <ul>
                <li><a href="#Compile-Time-Parameters">Compile-Time Parameters</a></li>
                <li><a href="#Compile-Time-Variables">Compile-Time Variables</a></li>
                <li><a href="#Compile-Time-Expressions">Compile-Time Expressions</a></li>
            </ul></li>
            <li><a href="#Generic-Data-Structures">Generic Data Structures</a></li>
            <li><a href="#Case-Study-printf-in-Zig">Case Study: printf in Zig</a></li>
        </ul></li>
        <li><a href="#inline">inline</a></li>
        <li><a href="#Assembly">Assembly</a></li>
        <li><a href="#Atomics">Atomics</a></li>
        <li><a href="#Builtin-Functions">Builtin Functions</a>
        <ul>
            <li><a href="#addWithOverflow">@addWithOverflow</a></li>
            <li><a href="#ArgType">@ArgType</a></li>
            <li><a href="#atomicRmw">@atomicRmw</a></li>
            <li><a href="#bitCast">@bitCast</a></li>
            <li><a href="#breakpoint">@breakpoint</a></li>
            <li><a href="#alignCast">@alignCast</a></li>
            <li><a href="#alignOf">@alignOf</a></li>
            <li><a href="#cDefine">@cDefine</a></li>
            <li><a href="#cImport">@cImport</a></li>
            <li><a href="#cInclude">@cInclude</a></li>
            <li><a href="#cUndef">@cUndef</a></li>
            <li><a href="#canImplicitCast">@canImplicitCast</a></li>
            <li><a href="#clz">@clz</a></li>
            <li><a href="#cmpxchg">@cmpxchg</a></li>
            <li><a href="#compileError">@compileError</a></li>
            <li><a href="#compileLog">@compileLog</a></li>
            <li><a href="#ctz">@ctz</a></li>
            <li><a href="#divExact">@divExact</a></li>
            <li><a href="#divFloor">@divFloor</a></li>
            <li><a href="#divTrunc">@divTrunc</a></li>
            <li><a href="#embedFile">@embedFile</a></li>
            <li><a href="#export">@export</a></li>
            <li><a href="#tagName">@tagName</a></li>
            <li><a href="#TagType">@TagType</a></li>
            <li><a href="#errorName">@errorName</a></li>
            <li><a href="#errorReturnTrace">@errorReturnTrace</a></li>
            <li><a href="#fence">@fence</a></li>
            <li><a href="#fieldParentPtr">@fieldParentPtr</a></li>
            <li><a href="#frameAddress">@frameAddress</a></li>
            <li><a href="#import">@import</a></li>
            <li><a href="#inlineCall">@inlineCall</a></li>
            <li><a href="#intToPtr">@intToPtr</a></li>
            <li><a href="#IntType">@IntType</a></li>
            <li><a href="#maxValue">@maxValue</a></li>
            <li><a href="#memberCount">@memberCount</a></li>
            <li><a href="#memberName">@memberName</a></li>
            <li><a href="#memberType">@memberType</a></li>
            <li><a href="#memcpy">@memcpy</a></li>
            <li><a href="#memset">@memset</a></li>
            <li><a href="#minValue">@minValue</a></li>
            <li><a href="#mod">@mod</a></li>
            <li><a href="#mulWithOverflow">@mulWithOverflow</a></li>
            <li><a href="#noInlineCall">@noInlineCall</a></li>
            <li><a href="#offsetOf">@offsetOf</a></li>
            <li><a href="#OpaqueType">@OpaqueType</a></li>
            <li><a href="#panic">@panic</a></li>
            <li><a href="#ptrCast">@ptrCast</a></li>
            <li><a href="#ptrToInt">@ptrToInt</a></li>
            <li><a href="#rem">@rem</a></li>
            <li><a href="#returnAddress">@returnAddress</a></li>
            <li><a href="#setAlignStack">@setAlignStack</a></li>
            <li><a href="#setCold">@setCold</a></li>
            <li><a href="#setRuntimeSafety">@setRuntimeSafety</a></li>
            <li><a href="#setEvalBranchQuota">@setEvalBranchQuota</a></li>
            <li><a href="#setFloatMode">@setFloatMode</a></li>
            <li><a href="#setGlobalLinkage">@setGlobalLinkage</a></li>
            <li><a href="#setGlobalSection">@setGlobalSection</a></li>
            <li><a href="#shlExact">@shlExact</a></li>
            <li><a href="#shlWithOverflow">@shlWithOverflow</a></li>
            <li><a href="#shrExact">@shrExact</a></li>
            <li><a href="#sizeOf">@sizeOf</a></li>
            <li><a href="#subWithOverflow">@subWithOverflow</a></li>
            <li><a href="#truncate">@truncate</a></li>
            <li><a href="#typeId">@typeId</a></li>
            <li><a href="#typeName">@typeName</a></li>
            <li><a href="#typeOf">@typeOf</a></li>
        </ul></li>
        <li><a href="#Build-Mode">Build Mode</a>
        <ul>
            <li><a href="#Debug">Debug</a></li>
            <li><a href="#ReleaseFast">ReleaseFast</a></li>
            <li><a href="#ReleaseSafe">ReleaseSafe</a></li>
        </ul></li>
        <li><a href="#Undefined-Behavior">Undefined Behavior</a>
        <ul>
            <li><a href="#Reaching-Unreachable-Code">Reaching Unreachable Code</a></li>
            <li><a href="#Index-out-of-Bounds">Index out of Bounds</a></li>
            <li><a href="#Cast-Negative-Number-to-Unsigned-Integer">Cast Negative Number to Unsigned Integer</a></li>
            <li><a href="#Cast-Truncates-Data">Cast Truncates Data</a></li>
            <li><a href="#Integer-Overflow">Integer Overflow</a>
            <ul>
                <li><a href="#Default-Operations">Default Operations</a></li>
                <li><a href="#Standard-Library-Math-Functions">Standard Library Math Functions</a></li>
                <li><a href="#Builtin-Overflow-Functions">Builtin Overflow Functions</a></li>
                <li><a href="#Wrapping-Operations">Wrapping Operations</a></li>
            </ul></li>
            <li><a href="#Exact-Left-Shift-Overflow">Exact Left Shift Overflow</a></li>
            <li><a href="#Exact-Right-Shift-Overflow">Exact Right Shift Overflow</a></li>
            <li><a href="#Division-by-Zero">Division by Zero</a></li>
            <li><a href="#Remainder-Division-by-Zero">Remainder Division by Zero</a></li>
            <li><a href="#Exact-Division-Remainder">Exact Division Remainder</a></li>
            <li><a href="#Slice-Widen-Remainder">Slice Widen Remainder</a></li>
            <li><a href="#Attempt-to-Unwrap-Null">Attempt to Unwrap Null</a></li>
            <li><a href="#Attempt-to-Unwrap-Error">Attempt to Unwrap Error</a></li>
            <li><a href="#Invalid-Error-Code">Invalid Error Code</a></li>
            <li><a href="#Invalid-Enum-Cast">Invalid Enum Cast</a></li>
            <li><a href="#Incorrect-Pointer-Alignment">Incorrect Pointer Alignment</a></li>
            <li><a href="#Wrong-Union-Field-Access">Wrong Union Field Access</a></li>
        </ul></li>
        <li><a href="#Memory">Memory</a></li>
        <li><a href="#Compile-Variables">Compile Variables</a></li>
        <li><a href="#Root-Source-File">Root Source File</a></li>
        <li><a href="#Zig-Test">Zig Test</a></li>
        <li><a href="#Zig-Build-System">Zig Build System</a></li>
        <li><a href="#C">C</a>
        <ul>
            <li><a href="#C-Type-Primitives">C Type Primitives</a></li>
            <li><a href="#C-String-Literals">C String Literals</a></li>
            <li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
            <li><a href="#Mixing-Object-Files">Mixing Object Files</a></li>
            <li><a href="#Terminal">Terminal</a></li>
        </ul></li>
        <li><a href="#Targets">Targets</a></li>
        <li><a href="#Style-Guide">Style Guide</a>
        <ul>
            <li><a href="#Whitespace">Whitespace</a></li>
            <li><a href="#Names">Names</a></li>
            <li><a href="#Examples">Examples</a></li>
        </ul></li>
        <li><a href="#Source-Encoding">Source Encoding</a></li>
        <li><a href="#Grammar">Grammar</a></li>
        <li><a href="#Zen">Zen</a></li>
    </ul>

    </div>
    <div id="contents">
      <h1 id="Introduction">Introduction</h1>

      <p>
      Zig is an open-source programming language designed for <strong>robustness</strong>,
      <strong>optimality</strong>, and <strong>clarity</strong>.
      </p>
      <ul>
        <li><strong>Robust</strong> - behavior is correct even for edge cases such as out of memory.</li>
        <li><strong>Optimal</strong> - write programs the best way they can behave and perform.</li>
        <li><strong>Clear</strong> - precisely communicate your intent to the compiler and other programmers. The language imposes a low overhead to reading code.</li>
      </ul>
      <p>
      Often the most efficient way to learn something new is to see examples, so
      this documentation shows how to use each of Zig's features. It is
      all on one page so you can search with your browser's search tool.
      </p>
      <p>
      The code samples in this document are compiled and tested as part of the main test suite of Zig.
      This HTML document depends on no external files, so you can use it offline.
      </p>
      
      <h1 id="Hello-World">Hello World</h1>


      <p class="file">hello.zig</p><pre><code class="zig">const std = @import(&quot;std&quot;);

pub fn main() !void {
    // If this program is run without stdout attached, exit with an error.
    var stdout_file = try std.io.getStdOut();
    // If this program encounters pipe failure when printing to stdout, exit
    // with an error.
    try stdout_file.write(&quot;Hello, world!\n&quot;);
}</code></pre><pre><code class="shell">$ zig build-exe hello.zig
$ ./hello
Hello, world!
</code></pre>

      <p>
      Usually you don't want to write to stdout. You want to write to stderr. And you
      don't care if it fails. It's more like a <em>warning message</em> that you want
      to emit. For that you can use a simpler API:
      </p>
      <p class="file">hello.zig</p><pre><code class="zig">const warn = @import(&quot;std&quot;).debug.warn;

pub fn main() void {
    warn(&quot;Hello, world!\n&quot;);
}</code></pre><pre><code class="shell">$ zig build-exe hello.zig
$ ./hello
Hello, world!
</code></pre>

      <p>
      Note that we also left off the <code class="zig">!</code> from the return type.
      In Zig, if your main function cannot fail, you must use the <code class="zig">void</code> return type.
      </p>
      <p>See also:</p><ul>
<li><a href="#Values">Values</a></li>
<li><a href="#import">@import</a></li>
<li><a href="#Errors">Errors</a></li>
<li><a href="#Root-Source-File">Root Source File</a></li>
</ul>

      
      <h1 id="Values">Values</h1>

      <p class="file">values.zig</p><pre><code class="zig">const std = @import(&quot;std&quot;);
const warn = std.debug.warn;
const os = std.os;
const assert = std.debug.assert;

pub fn main() void {
    // integers
    const one_plus_one: i32 = 1 + 1;
    warn(&quot;1 + 1 = {}\n&quot;, one_plus_one);

    // floats
    const seven_div_three: f32 = 7.0 / 3.0;
    warn(&quot;7.0 / 3.0 = {}\n&quot;, seven_div_three);

    // boolean
    warn(&quot;{}\n{}\n{}\n&quot;,
        true and false,
        true or false,
        !true);
    
    // nullable
    var nullable_value: ?[]const u8 = null;
    assert(nullable_value == null);

    warn(&quot;\nnullable 1\ntype: {}\nvalue: {}\n&quot;,
        @typeName(@typeOf(nullable_value)), nullable_value);

    nullable_value = &quot;hi&quot;;
    assert(nullable_value != null);

    warn(&quot;\nnullable 2\ntype: {}\nvalue: {}\n&quot;,
        @typeName(@typeOf(nullable_value)), nullable_value);

    // error union
    var number_or_error: error!i32 = error.ArgNotFound;

    warn(&quot;\nerror union 1\ntype: {}\nvalue: {}\n&quot;,
        @typeName(@typeOf(number_or_error)), number_or_error);
 
    number_or_error = 1234;

    warn(&quot;\nerror union 2\ntype: {}\nvalue: {}\n&quot;,
        @typeName(@typeOf(number_or_error)), number_or_error);
}</code></pre><pre><code class="shell">$ zig build-exe values.zig
$ ./values
1 + 1 = 2
7.0 / 3.0 = 2.33333325
false
true
false

nullable 1
type: ?[]const u8
value: null

nullable 2
type: ?[]const u8
value: hi

error union 1
type: error!i32
value: error.ArgNotFound

error union 2
type: error!i32
value: 1234
</code></pre>

      <h2 id="Primitive-Types">Primitive Types</h2>

      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Name
          </th>
          <th>
            C Equivalent
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td><code>i2</code></td>
          <td><code>(none)</code></td>
          <td>signed 2-bit integer</td>
        </tr>
        <tr>
          <td><code>u2</code></td>
          <td><code>(none)</code></td>
          <td>unsigned 2-bit integer</td>
        </tr>
        <tr>
          <td><code>i3</code></td>
          <td><code>(none)</code></td>
          <td>signed 3-bit integer</td>
        </tr>
        <tr>
          <td><code>u3</code></td>
          <td><code>(none)</code></td>
          <td>unsigned 3-bit integer</td>
        </tr>
        <tr>
          <td><code>i4</code></td>
          <td><code>(none)</code></td>
          <td>signed 4-bit integer</td>
        </tr>
        <tr>
          <td><code>u4</code></td>
          <td><code>(none)</code></td>
          <td>unsigned 4-bit integer</td>
        </tr>
        <tr>
          <td><code>i5</code></td>
          <td><code>(none)</code></td>
          <td>signed 5-bit integer</td>
        </tr>
        <tr>
          <td><code>u5</code></td>
          <td><code>(none)</code></td>
          <td>unsigned 5-bit integer</td>
        </tr>
        <tr>
          <td><code>i6</code></td>
          <td><code>(none)</code></td>
          <td>signed 6-bit integer</td>
        </tr>
        <tr>
          <td><code>u6</code></td>
          <td><code>(none)</code></td>
          <td>unsigned 6-bit integer</td>
        </tr>
        <tr>
          <td><code>i7</code></td>
          <td><code>(none)</code></td>
          <td>signed 7-bit integer</td>
        </tr>
        <tr>
          <td><code>u7</code></td>
          <td><code>(none)</code></td>
          <td>unsigned 7-bit integer</td>
        </tr>
        <tr>
          <td><code>i8</code></td>
          <td><code>int8_t</code></td>
          <td>signed 8-bit integer</td>
        </tr>
        <tr>
          <td><code>u8</code></td>
          <td><code>uint8_t</code></td>
          <td>unsigned 8-bit integer</td>
        </tr>
        <tr>
          <td><code>i16</code></td>
          <td><code>int16_t</code></td>
          <td>signed 16-bit integer</td>
        </tr>
        <tr>
          <td><code>u16</code></td>
          <td><code>uint16_t</code></td>
          <td>unsigned 16-bit integer</td>
        </tr>
        <tr>
          <td><code>i32</code></td>
          <td><code>int32_t</code></td>
          <td>signed 32-bit integer</td>
        </tr>
        <tr>
          <td><code>u32</code></td>
          <td><code>uint32_t</code></td>
          <td>unsigned 32-bit integer</td>
        </tr>
        <tr>
          <td><code>i64</code></td>
          <td><code>int64_t</code></td>
          <td>signed 64-bit integer</td>
        </tr>
        <tr>
          <td><code>u64</code></td>
          <td><code>uint64_t</code></td>
          <td>unsigned 64-bit integer</td>
        </tr>
        <tr>
          <td><code>i128</code></td>
          <td><code>__int128</code></td>
          <td>signed 128-bit integer</td>
        </tr>
        <tr>
          <td><code>u128</code></td>
          <td><code>unsigned __int128</code></td>
          <td>unsigned 128-bit integer</td>
        </tr>
        <tr>
          <td><code>isize</code></td>
          <td><code>intptr_t</code></td>
          <td>signed pointer sized integer</td>
        </tr>
        <tr>
          <td><code>usize</code></td>
          <td><code>uintptr_t</code></td>
          <td>unsigned pointer sized integer</td>
        </tr>

        <tr>
          <td><code>c_short</code></td>
          <td><code>short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_ushort</code></td>
          <td><code>unsigned short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_int</code></td>
          <td><code>int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_uint</code></td>
          <td><code>unsigned int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_long</code></td>
          <td><code>long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_ulong</code></td>
          <td><code>unsigned long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_longlong</code></td>
          <td><code>long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_ulonglong</code></td>
          <td><code>unsigned long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_longdouble</code></td>
          <td><code>long double</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_void</code></td>
          <td><code>void</code></td>
          <td>for ABI compatibility with C</td>
        </tr>

        <tr>
          <td><code>f32</code></td>
          <td><code>float</code></td>
          <td>32-bit floating point (23-bit mantissa)</td>
        </tr>
        <tr>
          <td><code>f64</code></td>
          <td><code>double</code></td>
          <td>64-bit floating point (52-bit mantissa)</td>
        </tr>
        <tr>
          <td><code>f128</code></td>
          <td>(none)</td>
          <td>128-bit floating point (112-bit mantissa)</td>
        </tr>
        <tr>
          <td><code>bool</code></td>
          <td><code>bool</code></td>
          <td><code>true</code> or <code>false</code></td>
        </tr>
        <tr>
          <td><code>void</code></td>
          <td>(none)</td>
          <td>0 bit type</td>
        </tr>
        <tr>
          <td><code>noreturn</code></td>
          <td>(none)</td>
          <td>the type of <code>break</code>, <code>continue</code>, <code>return</code>, <code>unreachable</code>, and <code>while (true) {}</code></td>
        </tr>
        <tr>
          <td><code>type</code></td>
          <td>(none)</td>
          <td>the type of types</td>
        </tr>
        <tr>
          <td><code>error</code></td>
          <td>(none)</td>
          <td>an error code</td>
        </tr>
      </table>
      </div>
      <p>See also:</p><ul>
<li><a href="#Integers">Integers</a></li>
<li><a href="#Floats">Floats</a></li>
<li><a href="#void">void</a></li>
<li><a href="#Errors">Errors</a></li>
</ul>

      
      <h2 id="Primitive-Values">Primitive Values</h2>

      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Name
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td><code>true</code> and <code>false</code></td>
          <td><code>bool</code> values</td>
        </tr>
        <tr>
          <td><code>null</code></td>
          <td>used to set a nullable type to <code>null</code></td>
        </tr>
        <tr>
          <td><code>undefined</code></td>
          <td>used to leave a value unspecified</td>
        </tr>
        <tr>
          <td><code>this</code></td>
          <td>refers to the thing in immediate scope</td>
        </tr>
      </table>
      </div>
      <p>See also:</p><ul>
<li><a href="#Nullables">Nullables</a></li>
<li><a href="#this">this</a></li>
</ul>

      
      <h2 id="String-Literals">String Literals</h2>

      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;
const mem = @import(&quot;std&quot;).mem;

test &quot;string literals&quot; {
    // In Zig a string literal is an array of bytes.
    const normal_bytes = &quot;hello&quot;;
    assert(@typeOf(normal_bytes) == [5]u8);
    assert(normal_bytes.len == 5);
    assert(normal_bytes[1] == 'e');
    assert('e' == '\x65');
    assert(mem.eql(u8, &quot;hello&quot;, &quot;h\x65llo&quot;));

    // A C string literal is a null terminated pointer.
    const null_terminated_bytes = c&quot;hello&quot;;
    assert(@typeOf(null_terminated_bytes) == &amp;const u8);
    assert(null_terminated_bytes[5] == 0);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 string literals...OK
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Arrays">Arrays</a></li>
<li><a href="#Zig-Test">Zig Test</a></li>
</ul>

      <h3 id="Escape-Sequences">Escape Sequences</h3>

      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Escape Sequence
          </th>
          <th>
            Name
          </th>
        </tr>
        <tr>
          <td><code>\n</code></td>
          <td>Newline</td>
        </tr>
        <tr>
          <td><code>\r</code></td>
          <td>Carriage Return</td>
        </tr>
        <tr>
          <td><code>\t</code></td>
          <td>Tab</td>
        </tr>
        <tr>
          <td><code>\\</code></td>
          <td>Backslash</td>
        </tr>
        <tr>
          <td><code>\'</code></td>
          <td>Single Quote</td>
        </tr>
        <tr>
          <td><code>\"</code></td>
          <td>Double Quote</td>
        </tr>
        <tr>
          <td><code>\xNN</code></td>
          <td>hexadecimal 8-bit character code (2 digits)</td>
        </tr>
        <tr>
          <td><code>\uNNNN</code></td>
          <td>hexadecimal 16-bit Unicode character code UTF-8 encoded (4 digits)</td>
        </tr>
        <tr>
          <td><code>\UNNNNNN</code></td>
          <td>hexadecimal 24-bit Unicode character code UTF-8 encoded (6 digits)</td>
        </tr>
      </table>
      </div>
      <p>Note that the maximum valid Unicode point is <code>0x10ffff</code>.</p>
      
      <h3 id="Multiline-String-Literals">Multiline String Literals</h3>

      <p>
      Multiline string literals have no escapes and can span across multiple lines.
      To start a multiline string literal, use the <code>\\</code> token. Just like a comment,
      the string literal goes until the end of the line. The end of the line is
      not included in the string literal.
      However, if the next line begins with <code>\\</code> then a newline is appended and
      the string literal continues.
      </p>
      <pre><code class="zig">const hello_world_in_c =
    \\#include &lt;stdio.h&gt;
    \\
    \\int main(int argc, char **argv) {
    \\    printf(&quot;hello world\n&quot;);
    \\    return 0;
    \\}
;</code></pre>
      <p>
      For a multiline C string literal, prepend <code>c</code> to each <code>\\</code>:
      </p>
      <pre><code class="zig">const c_string_literal =
    c\\#include &lt;stdio.h&gt;
    c\\
    c\\int main(int argc, char **argv) {
    c\\    printf(&quot;hello world\n&quot;);
    c\\    return 0;
    c\\}
;</code></pre>
      <p>
      In this example the variable <code>c_string_literal</code> has type <code>&amp;const char</code> and
      has a terminating null byte.
      </p>
      <p>See also:</p><ul>
<li><a href="#embedFile">@embedFile</a></li>
</ul>

      
      
      <h2 id="Assignment">Assignment</h2>

      <p>Use <code>const</code> to assign a value to an identifier:</p>
      <p class="file">test.zig</p><pre><code class="zig">const x = 1234;

fn foo() void {
    // It works at global scope as well as inside functions.
    const y = 5678;

    // Once assigned, an identifier cannot be changed.
    y += 1;
}

test &quot;assignment&quot; {
    foo();
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:8:7: </span><span class="t31_1">error:</span><span class="t0_1"> cannot assign to constant</span>
    y += 1;
      <span class="t32_1">^</span>
</code></pre>

      <p>If you need a variable that you can modify, use <code>var</code>:</p>
      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

test &quot;var&quot; {
    var y: i32 = 5678;

    y += 1;

    assert(y == 5679);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 var...OK
</code></pre>

      <p>Variables must be initialized:</p>
      <p class="file">test.zig</p><pre><code class="zig">test &quot;initialization&quot; {
    var x: i32;

    x = 1;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:5: </span><span class="t31_1">error:</span><span class="t0_1"> variables must be initialized</span>
    var x: i32;
    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:5: </span><span class="t31_1">error:</span><span class="t0_1"> use of undeclared identifier 'x'</span>
    x = 1;
    <span class="t32_1">^</span>
</code></pre>

      <p>Use <code>undefined</code> to leave variables uninitialized:</p>
      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

test &quot;init with undefined&quot; {
    var x: i32 = undefined;
    x = 1;
    assert(x == 1);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 init with undefined...OK
</code></pre>

      
      
      <h1 id="Integers">Integers</h1>

      <h2 id="Integer-Literals">Integer Literals</h2>

      <pre><code class="zig">const decimal_int = 98222;
const hex_int = 0xff;
const another_hex_int = 0xFF;
const octal_int = 0o755;
const binary_int = 0b11110000;</code></pre>
      
      <h2 id="Runtime-Integer-Values">Runtime Integer Values</h2>

      <p>
      Integer literals have no size limitation, and if any undefined behavior occurs,
      the compiler catches it.
      </p>
      <p>
      However, once an integer value is no longer known at compile-time, it must have a
      known size, and is vulnerable to undefined behavior.
      </p>
      <pre><code class="zig">fn divide(a: i32, b: i32) i32 {
    return a / b;
}</code></pre>
      <p>
      In this function, values <code>a</code> and <code>b</code> are known only at runtime,
      and thus this division operation is vulnerable to both integer overflow and
      division by zero.
      </p>
      <p>
      Operators such as <code>+</code> and <code>-</code> cause undefined behavior on
      integer overflow. Also available are operations such as <code>+%</code> and
      <code>-%</code> which are defined to have wrapping arithmetic on all targets.
      </p>
      <p>See also:</p><ul>
<li><a href="#Integer-Overflow">Integer Overflow</a></li>
<li><a href="#Division-by-Zero">Division by Zero</a></li>
<li><a href="#Wrapping-Operations">Wrapping Operations</a></li>
</ul>

      
      
      <h1 id="Floats">Floats</h1>

      <h2 id="Float-Literals">Float Literals</h2>

      <pre><code class="zig">const floating_point = 123.0E+77;
const another_float = 123.0;
const yet_another = 123.0e+77;

const hex_floating_point = 0x103.70p-5;
const another_hex_float = 0x103.70;
const yet_another_hex_float = 0x103.70P-5;</code></pre>
      
      <h2 id="Floating-Point-Operations">Floating Point Operations</h2>

      <p>By default floating point operations use <code>Optimized</code> mode,
      but you can switch to <code>Strict</code> mode on a per-block basis:</p>
      <p class="file">foo.zig</p><pre><code class="zig">const builtin = @import(&quot;builtin&quot;);
const big = f64(1 &lt;&lt; 40);

export fn foo_strict(x: f64) f64 {
    @setFloatMode(this, builtin.FloatMode.Strict);
    return x + big - big;
}

export fn foo_optimized(x: f64) f64 {
    return x + big - big;
}</code></pre><pre><code class="shell">$ zig build-obj foo.zig --release-fast</code></pre>

      <p>For this test we have to separate code into two object files -
      otherwise the optimizer figures out all the values at compile-time,
      which operates in strict mode.</p>
      <p class="file">float_mode.zig</p><pre><code class="zig">const warn = @import(&quot;std&quot;).debug.warn;

extern fn foo_strict(x: f64) f64;
extern fn foo_optimized(x: f64) f64;

pub fn main() void {
    const x = 0.001;
    warn(&quot;optimized = {}\n&quot;, foo_optimized(x));
    warn(&quot;strict = {}\n&quot;, foo_strict(x));
}</code></pre><pre><code class="shell">$ zig build-exe float_mode.zig --object foo.o
$ ./float_mode
optimized = 1.0e-3
strict = 9.765625e-4
</code></pre>

      <p>See also:</p><ul>
<li><a href="#setFloatMode">@setFloatMode</a></li>
<li><a href="#Division-by-Zero">Division by Zero</a></li>
</ul>

      
      
      <h1 id="Operators">Operators</h1>

      <h2 id="Table-of-Operators">Table of Operators</h2>

      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Syntax
          </th>
          <th>
            Relevant Types
          </th>
          <th>
            Description
          </th>
          <th>
            Example
          </th>
        </tr>
        <tr>
          <td><pre><code class="zig">a + b
a += b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>Addition.
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">2 + 5 == 7</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a +% b
a +%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Wrapping Addition.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">u32(@maxValue(u32)) +% 1 == 0</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a - b
a -= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>Subtraction.
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">2 - 5 == -3</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a -% b
a -%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Wrapping Subtraction.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">u32(0) -% 1 == @maxValue(u32)</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">-a<code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            Negation.
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">-1 == 0 - 1</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">-%a<code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            Wrapping Negation.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">-%i32(@minValue(i32)) == @minValue(i32)</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a * b
a *= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>Multiplication.
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">2 * 5 == 10</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a *% b
a *%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Wrapping Multiplication.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">u8(200) *% 2 == 144</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a / b
a /= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>Divison.
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for integers.</li>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for floats in <a href="#Floating-Point-Operations">FloatMode.Optimized Mode</a>.</li>
              <li>For non-compile-time-known signed integers, must use
                <a href="#divTrunc">@divTrunc</a>,
                <a href="#divFloor">@divFloor</a>, or
                <a href="#divExact">@divExact</a> instead of <code>/</code>.
              </li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">10 / 5 == 2</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a % b
a %= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>Remainder Division.
            <ul>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for integers.</li>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for floats in <a href="#Floating-Point-Operations">FloatMode.Optimized Mode</a>.</li>
              <li>For non-compile-time-known signed integers, must use
                <a href="#rem">@rem</a> or
                <a href="#mod">@mod</a> instead of <code>%</code>.
              </li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">10 % 3 == 1</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &lt;&lt; b
a &lt;&lt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Bit Shift Left.
            <ul>
              <li>See also <a href="#shlExact">@shlExact</a>.</li>
              <li>See also <a href="#shlWithOverflow">@shlWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">1 &lt;&lt; 8 == 256</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &gt;&gt; b
a &gt;&gt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Bit Shift Right.
            <ul>
              <li>See also <a href="#shrExact">@shrExact</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">10 &gt;&gt; 1 == 5</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &amp; b
a &amp;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Bitwise AND.
          </td>
          <td>
            <pre><code class="zig">0b011 &amp; 0b101 == 0b001</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a | b
a |= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Bitwise OR.
          </td>
          <td>
            <pre><code class="zig">0b010 | 0b100 == 0b110</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a ^ b
a ^= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Bitwise XOR.
          </td>
          <td>
            <pre><code class="zig">0b011 ^ 0b101 == 0b110</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">~a<code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            Bitwise NOT.
          </td>
          <td>
            <pre><code class="zig">~u8(0b0101111) == 0b1010000</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a ?? b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Nullables">Nullables</a></li>
            </ul>
          </td>
          <td>If <code>a</code> is <code>null</code>,
            returns <code>b</code> ("default value"),
            otherwise returns the unwrapped value of <code>a</code>.
            Note that <code>b</code> may be a value of type <a href="#noreturn">noreturn</a>.
          </td>
          <td>
            <pre><code class="zig">const value: ?u32 = null;
const unwrapped = value ?? 1234;
unwrapped == 1234</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">??a</code></pre></td>
          <td>
            <ul>
              <li><a href="#Nullables">Nullables</a></li>
            </ul>
          </td>
          <td>
            Equivalent to:
            <pre><code class="zig">a ?? unreachable</code></pre>
          </td>
          <td>
            <pre><code class="zig">const value: ?u32 = 5678;
??value == 5678</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a catch b
a catch |err| b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Errors">Error Unions</a></li>
            </ul>
          </td>
          <td>If <code>a</code> is an <code>error</code>,
            returns <code>b</code> ("default value"),
            otherwise returns the unwrapped value of <code>a</code>.
            Note that <code>b</code> may be a value of type <a href="#noreturn">noreturn</a>.
            <code>err</code> is the <code>error</code> and is in scope of the expression <code>b</code>.
          </td>
          <td>
            <pre><code class="zig">const value: error!u32 = error.Broken;
const unwrapped = value catch 1234;
unwrapped == 1234</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a and b<code></pre></td>
          <td>
            <ul>
              <li><a href="#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td>
            If <code>a</code> is <code>false</code>, returns <code>false</code>
            without evaluating <code>b</code>. Otherwise, retuns <code>b</code>.
          </td>
          <td>
            <pre><code class="zig">false and true == false</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a or b<code></pre></td>
          <td>
            <ul>
              <li><a href="#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td>
            If <code>a</code> is <code>true</code>, returns <code>true</code>
            without evaluating <code>b</code>. Otherwise, retuns <code>b</code>.
          </td>
          <td>
            <pre><code class="zig">false or true == true</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">!a<code></pre></td>
          <td>
            <ul>
              <li><a href="#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td>
            Boolean NOT.
          </td>
          <td>
            <pre><code class="zig">!false == true</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a == b<code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
              <li><a href="#Primitive-Types">bool</a></li>
              <li><a href="#Primitive-Types">type</a></li>
            </ul>
          </td>
          <td>
            Returns <code>true</code> if a and b are equal, otherwise returns <code>false</code>.
          </td>
          <td>
            <pre><code class="zig">(1 == 1) == true</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a == null<code></pre></td>
          <td>
            <ul>
              <li><a href="#Nullables">Nullables</a></li>
            </ul>
          </td>
          <td>
            Returns <code>true</code> if a is <code>null</code>, otherwise returns <code>false</code>.
          </td>
          <td>
            <pre><code class="zig">const value: ?u32 = null;
value == null</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a != b<code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
              <li><a href="#Primitive-Types">bool</a></li>
              <li><a href="#Primitive-Types">type</a></li>
            </ul>
          </td>
          <td>
            Returns <code>false</code> if a and b are equal, otherwise returns <code>true</code>.
          </td>
          <td>
            <pre><code class="zig">(1 != 1) == false</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &gt; b<code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            Returns <code>true</code> if a is greater than b, otherwise returns <code>false</code>.
          </td>
          <td>
            <pre><code class="zig">(2 &gt; 1) == true</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &gt;= b<code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            Returns <code>true</code> if a is greater than or equal to b, otherwise returns <code>false</code>.
          </td>
          <td>
            <pre><code class="zig">(2 &gt;= 1) == true</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &lt; b<code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            Returns <code>true</code> if a is less than b, otherwise returns <code>false</code>.
          </td>
          <td>
            <pre><code class="zig">(1 &lt; 2) == true</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &lt;= b<code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            Returns <code>true</code> if a is less than or equal to b, otherwise returns <code>false</code>.
          </td>
          <td>
            <pre><code class="zig">(1 &lt;= 2) == true</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a ++ b<code></pre></td>
          <td>
            <ul>
              <li><a href="#Arrays">Arrays</a></li>
            </ul>
          </td>
          <td>
            Array concatenation.
            <ul>
              <li>Only available when <code>a</code> and <code>b</code> are <a href="#comptime">compile-time known</a>.
            </ul>
          </td>
          <td>
            <pre><code class="zig">const mem = @import("std").mem;
const array1 = []u32{1,2};
const array2 = []u32{3,4};
const together = array1 ++ array2;
mem.eql(u32, together, []u32{1,2,3,4})</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a ** b<code></pre></td>
          <td>
            <ul>
              <li><a href="#Arrays">Arrays</a></li>
            </ul>
          </td>
          <td>
            Array multiplication.
            <ul>
              <li>Only available when <code>a</code> and <code>b</code> are <a href="#comptime">compile-time known</a>.
            </ul>
          </td>
          <td>
            <pre><code class="zig">const mem = @import("std").mem;
const pattern = "ab" ** 3;
mem.eql(u8, pattern, "ababab")</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">*a<code></pre></td>
          <td>
            <ul>
              <li><a href="#Pointers">Pointers</a></li>
            </ul>
          </td>
          <td>
            Pointer dereference.
          </td>
          <td>
            <pre><code class="zig">const x: u32 = 1234;
const ptr = &amp;x;
*x == 1234</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">&amp;a<code></pre></td>
          <td>
            All types
          </td>
          <td>
            Address of.
          </td>
          <td>
            <pre><code class="zig">const x: u32 = 1234;
const ptr = &amp;x;
*x == 1234</code></pre>
          </td>
        </tr>
      </table>
      </div>
      
      <h2 id="Precedence">Precedence</h2>

      <pre><code>x() x[] x.y
a!b
!x -x -%x ~x *x &amp;x ?x ??x
x{}
! * / % ** *%
+ - ++ +% -%
&lt;&lt; &gt;&gt;
&amp;
^
|
== != &lt; &gt; &lt;= &gt;=
and
or
?? catch
= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</code></pre>
      
      
      <h1 id="Arrays">Arrays</h1>

      <p class="file">arrays.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;
const mem = @import(&quot;std&quot;).mem;

// array literal
const message = []u8{'h', 'e', 'l', 'l', 'o'};

// get the size of an array
comptime {
    assert(message.len == 5);
}

// a string literal is an array literal
const same_message = &quot;hello&quot;;

comptime {
    assert(mem.eql(u8, message, same_message));
    assert(@typeOf(message) == @typeOf(same_message));
}

test &quot;iterate over an array&quot; {
    var sum: usize = 0;
    for (message) |byte| {
        sum += byte;
    }
    assert(sum == usize('h') + usize('e') + usize('l') * 2 + usize('o'));
}

// modifiable array
var some_integers: [100]i32 = undefined;

test &quot;modify an array&quot; {
    for (some_integers) |*item, i| {
        *item = i32(i);
    }
    assert(some_integers[10] == 10);
    assert(some_integers[99] == 99);
}

// array concatenation works if the values are known
// at compile time
const part_one = []i32{1, 2, 3, 4};
const part_two = []i32{5, 6, 7, 8};
const all_of_it = part_one ++ part_two;
comptime {
    assert(mem.eql(i32, all_of_it, []i32{1,2,3,4,5,6,7,8}));
}

// remember that string literals are arrays
const hello = &quot;hello&quot;;
const world = &quot;world&quot;;
const hello_world = hello ++ &quot; &quot; ++ world;
comptime {
    assert(mem.eql(u8, hello_world, &quot;hello world&quot;));
}

// ** does repeating patterns
const pattern = &quot;ab&quot; ** 3;
comptime {
    assert(mem.eql(u8, pattern, &quot;ababab&quot;));
}

// initialize an array to zero
const all_zero = []u16{0} ** 10;

comptime {
    assert(all_zero.len == 10);
    assert(all_zero[5] == 0);
}

// use compile-time code to initialize an array
var fancy_array = init: {
    var initial_value: [10]Point = undefined;
    for (initial_value) |*pt, i| {
        *pt = Point {
            .x = i32(i),
            .y = i32(i) * 2,
        };
    }
    break :init initial_value;
};
const Point = struct {
    x: i32,
    y: i32,
};

test &quot;compile-time array initalization&quot; {
    assert(fancy_array[4].x == 4);
    assert(fancy_array[4].y == 8);
}

// call a function to initialize an array
var more_points = []Point{makePoint(3)} ** 10;
fn makePoint(x: i32) Point {
    return Point {
        .x = x,
        .y = x * 2,
    };
}
test &quot;array initialization with function calls&quot; {
    assert(more_points[4].x == 3);
    assert(more_points[4].y == 6);
    assert(more_points.len == 10);
}</code></pre><pre><code class="shell">$ zig test arrays.zig
Test 1/4 iterate over an array...OK
Test 2/4 modify an array...OK
Test 3/4 compile-time array initalization...OK
Test 4/4 array initialization with function calls...OK
</code></pre>

      <p>See also:</p><ul>
<li><a href="#for">for</a></li>
<li><a href="#Slices">Slices</a></li>
</ul>

      
      <h1 id="Pointers">Pointers</h1>

      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

test &quot;address of syntax&quot; {
    // Get the address of a variable:
    const x: i32 = 1234;
    const x_ptr = &amp;x;

    // Deference a pointer:
    assert(*x_ptr == 1234);

    // When you get the address of a const variable, you get a const pointer.
    assert(@typeOf(x_ptr) == &amp;const i32);

    // If you want to mutate the value, you'd need an address of a mutable variable:
    var y: i32 = 5678;
    const y_ptr = &amp;y;
    assert(@typeOf(y_ptr) == &amp;i32);
    *y_ptr += 1;
    assert(*y_ptr == 5679);
}

test &quot;pointer array access&quot; {
    // Pointers do not support pointer arithmetic. If you
    // need such a thing, use array index syntax:

    var array = []u8{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    const ptr = &amp;array[1];

    assert(array[2] == 3);
    ptr[1] += 1;
    assert(array[2] == 4);
}

test &quot;pointer slicing&quot; {
    // In Zig, we prefer using slices over null-terminated pointers.
    // You can turn a pointer into a slice using slice syntax:
    var array = []u8{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    const ptr = &amp;array[1];
    const slice = ptr[1..3];

    assert(slice.ptr == &amp;ptr[1]);
    assert(slice.len == 2);

    // Slices have bounds checking and are therefore protected
    // against this kind of undefined behavior. This is one reason
    // we prefer slices to pointers.
    assert(array[3] == 4);
    slice[1] += 1;
    assert(array[3] == 5);
}

comptime {
    // Pointers work at compile-time too, as long as you don't use
    // @ptrCast.
    var x: i32 = 1;
    const ptr = &amp;x;
    *ptr += 1;
    x += 1;
    assert(*ptr == 3);
}

test &quot;@ptrToInt and @intToPtr&quot; {
    // To convert an integer address into a pointer, use @intToPtr:
    const ptr = @intToPtr(&amp;i32, 0xdeadbeef);

    // To convert a pointer to an integer, use @ptrToInt:
    const addr = @ptrToInt(ptr);

    assert(@typeOf(addr) == usize);
    assert(addr == 0xdeadbeef);
}

comptime {
    // Zig is able to do this at compile-time, as long as
    // ptr is never dereferenced.
    const ptr = @intToPtr(&amp;i32, 0xdeadbeef);
    const addr = @ptrToInt(ptr);
    assert(@typeOf(addr) == usize);
    assert(addr == 0xdeadbeef);
}

test &quot;volatile&quot; {
    // In Zig, loads and stores are assumed to not have side effects.
    // If a given load or store should have side effects, such as
    // Memory Mapped Input/Output (MMIO), use `volatile`:
    const mmio_ptr = @intToPtr(&amp;volatile u8, 0x12345678);

    // Now loads and stores with mmio_ptr are guaranteed to all happen
    // and in the same order as in source code.
    assert(@typeOf(mmio_ptr) == &amp;volatile u8);
}

test &quot;nullable pointers&quot; {
    // Pointers cannot be null. If you want a null pointer, use the nullable
    // prefix `?` to make the pointer type nullable.
    var ptr: ?&amp;i32 = null;

    var x: i32 = 1;
    ptr = &amp;x;

    assert(*??ptr == 1);

    // Nullable pointers are the same size as normal pointers, because pointer
    // value 0 is used as the null value.
    assert(@sizeOf(?&amp;i32) == @sizeOf(&amp;i32));
}

test &quot;pointer casting&quot; {
    // To convert one pointer type to another, use @ptrCast. This is an unsafe
    // operation that Zig cannot protect you against. Use @ptrCast only when other
    // conversions are not possible.
    const bytes align(@alignOf(u32)) = []u8{0x12, 0x12, 0x12, 0x12};
    const u32_ptr = @ptrCast(&amp;const u32, &amp;bytes[0]);
    assert(*u32_ptr == 0x12121212);

    // Even this example is contrived - there are better ways to do the above than
    // pointer casting. For example, using a slice narrowing cast:
    const u32_value = ([]const u32)(bytes[0..])[0];
    assert(u32_value == 0x12121212);

    // And even another way, the most straightforward way to do it:
    assert(@bitCast(u32, bytes) == 0x12121212);
}

test &quot;pointer child type&quot; {
    // pointer types have a `child` field which tells you the type they point to.
    assert((&amp;u32).Child == u32);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/8 address of syntax...OK
Test 2/8 pointer array access...OK
Test 3/8 pointer slicing...OK
Test 4/8 @ptrToInt and @intToPtr...OK
Test 5/8 volatile...OK
Test 6/8 nullable pointers...OK
Test 7/8 pointer casting...OK
Test 8/8 pointer child type...OK
</code></pre>

      <h2 id="Alignment">Alignment</h2>

      <p>
      Each type has an <strong>alignment</strong> - a number of bytes such that,
      when a value of the type is loaded from or stored to memory,
      the memory address must be evenly divisible by this number. You can use
      <a href="#alignOf">@alignOf</a> to find out this value for any type.
      </p>
      <p>
      Alignment depends on the CPU architecture, but is always a power of two, and
      less than <code>1 &lt;&lt; 29</code>.
      </p>
      <p>
      In Zig, a pointer type has an alignment value. If the value is equal to the
      alignment of the underlying type, it can be omitted from the type:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;
const builtin = @import(&quot;builtin&quot;);

test &quot;variable alignment&quot; {
    var x: i32 = 1234;
    const align_of_i32 = @alignOf(@typeOf(x));
    assert(@typeOf(&amp;x) == &amp;i32);
    assert(&amp;i32 == &amp;align(align_of_i32) i32);
    if (builtin.arch == builtin.Arch.x86_64) {
        assert((&amp;i32).alignment == 4);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 variable alignment...OK
</code></pre>

      <p>In the same way that a <code>&amp;i32</code> can be implicitly cast to a
      <code>&amp;const i32</code>, a pointer with a larger alignment can be implicitly
      cast to a pointer with a smaller alignment, but not vice versa.
      </p>
      <p>
      You can specify alignment on variables and functions. If you do this, then
      pointers to them get the specified alignment:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

var foo: u8 align(4) = 100;

test &quot;global variable alignment&quot; {
    assert(@typeOf(&amp;foo).alignment == 4);
    assert(@typeOf(&amp;foo) == &amp;align(4) u8);
    const slice = (&amp;foo)[0..1];
    assert(@typeOf(slice) == []align(4) u8);
}

fn derp() align(@sizeOf(usize) * 2) i32 { return 1234; }
fn noop1() align(1) void {}
fn noop4() align(4) void {}

test &quot;function alignment&quot; {
    assert(derp() == 1234);
    assert(@typeOf(noop1) == fn() align(1) void);
    assert(@typeOf(noop4) == fn() align(4) void);
    noop1();
    noop4();
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/2 global variable alignment...OK
Test 2/2 function alignment...OK
</code></pre>

      <p>
      If you have a pointer or a slice that has a small alignment, but you know that it actually
      has a bigger alignment, use <a href="#alignCast">@alignCast</a> to change the
      pointer into a more aligned pointer. This is a no-op at runtime, but inserts a
      <a href="#Incorrect-Pointer-Alignment">safety check</a>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

test &quot;pointer alignment safety&quot; {
    var array align(4) = []u32{0x11111111, 0x11111111};
    const bytes = ([]u8)(array[0..]);
    assert(foo(bytes) == 0x11111111);
}
fn foo(bytes: []u8) u32 {
    const slice4 = bytes[1..5];
    const int_slice = ([]u32)(@alignCast(4, slice4));
    return int_slice[0];
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 pointer alignment safety...incorrect alignment
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:10:45</span>: <span class="t2_0">0x203973 in ??? (test)</span>
    const int_slice = ([]u32)(@alignCast(4, slice4));
                                            <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:6:15</span>: <span class="t2_0">0x2036d6 in ??? (test)</span>
    assert(foo(bytes) == 0x11111111);
              <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/test_runner.zig:11:25</span>: <span class="t2_0">0x21d638 in ??? (test)</span>
        try test_fn.func();
                        <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:85:22</span>: <span class="t2_0">0x21d43b in ??? (test)</span>
            root.main() catch |err| {
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:62:20</span>: <span class="t2_0">0x21d39b in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:52:39</span>: <span class="t2_0">0x21d22c in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:39:5</span>: <span class="t2_0">0x21d1b0 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>

Tests failed. Use the following command to reproduce the failure:
./zig-cache/test
</code></pre>

      
      <h2 id="Type-Based-Alias-Analysis">Type Based Alias Analysis</h2>

      <p>Zig uses Type Based Alias Analysis (also known as Strict Aliasing) to
      perform some optimizations. This means that pointers of different types must
      not alias the same memory, with the exception of <code>u8</code>. Pointers to
      <code>u8</code> can alias any memory.
      </p>
      <p>As an example, this code produces undefined behavior:</p>
      <pre><code class="zig">*@ptrCast(&amp;u32, f32(12.34))</code></pre>
      <p>Instead, use <a href="#bitCast">@bitCast</a>:
      <pre><code class="zig">@bitCast(u32, f32(12.34))</code></pre>
      <p>As an added benefit, the <code>@bitcast</code> version works at compile-time.</p>
      <p>See also:</p><ul>
<li><a href="#Slices">Slices</a></li>
<li><a href="#Memory">Memory</a></li>
</ul>

      
      
      <h1 id="Slices">Slices</h1>

      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

test &quot;basic slices&quot; {
    var array = []i32{1, 2, 3, 4};
    // A slice is a pointer and a length. The difference between an array and
    // a slice is that the array's length is part of the type and known at
    // compile-time, whereas the slice's length is known at runtime.
    // Both can be accessed with the `len` field.
    const slice = array[0..array.len];
    assert(slice.ptr == &amp;array[0]);
    assert(slice.len == array.len);

    // Slices have array bounds checking. If you try to access something out
    // of bounds, you'll get a safety check failure:
    slice[10] += 1;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 basic slices...index out of bounds
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:15:10</span>: <span class="t2_0">0x20372b in ??? (test)</span>
    slice[10] += 1;
         <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/test_runner.zig:11:25</span>: <span class="t2_0">0x21d568 in ??? (test)</span>
        try test_fn.func();
                        <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:85:22</span>: <span class="t2_0">0x21d36b in ??? (test)</span>
            root.main() catch |err| {
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:62:20</span>: <span class="t2_0">0x21d2cb in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:52:39</span>: <span class="t2_0">0x21d15c in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:39:5</span>: <span class="t2_0">0x21d0e0 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>

Tests failed. Use the following command to reproduce the failure:
./zig-cache/test
</code></pre>

      <p>This is one reason we prefer slices to pointers.</p>
      <p class="file">slices.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;
const mem = @import(&quot;std&quot;).mem;
const fmt = @import(&quot;std&quot;).fmt;

test &quot;using slices for strings&quot; {
    // Zig has no concept of strings. String literals are arrays of u8, and
    // in general the string type is []u8 (slice of u8).
    // Here we implicitly cast [5]u8 to []const u8
    const hello: []const u8 = &quot;hello&quot;;
    const world: []const u8 = &quot;世界&quot;;

    var all_together: [100]u8 = undefined;
    // You can use slice syntax on an array to convert an array into a slice.
    const all_together_slice = all_together[0..];
    // String concatenation example.
    const hello_world = try fmt.bufPrint(all_together_slice, &quot;{} {}&quot;, hello, world);

    // Generally, you can use UTF-8 and not worry about whether something is a
    // string. If you don't need to deal with individual characters, no need
    // to decode.
    assert(mem.eql(u8, hello_world, &quot;hello 世界&quot;));
}

test &quot;slice pointer&quot; {
    var array: [10]u8 = undefined;
    const ptr = &amp;array[0];

    // You can use slicing syntax to convert a pointer into a slice:
    const slice = ptr[0..5];
    slice[2] = 3;
    assert(slice[2] == 3);
    // The slice is mutable because we sliced a mutable pointer.
    assert(@typeOf(slice) == []u8);

    // You can also slice a slice:
    const slice2 = slice[2..3];
    assert(slice2.len == 1);
    assert(slice2[0] == 3);
}

test &quot;slice widening&quot; {
    // Zig supports slice widening and slice narrowing. Cast a slice of u8
    // to a slice of anything else, and Zig will perform the length conversion.
    const array align(@alignOf(u32)) = []u8{0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13};
    const slice = ([]const u32)(array[0..]);
    assert(slice.len == 2);
    assert(slice[0] == 0x12121212);
    assert(slice[1] == 0x13131313);
}</code></pre><pre><code class="shell">$ zig test slices.zig
Test 1/3 using slices for strings...OK
Test 2/3 slice pointer...OK
Test 3/3 slice widening...OK
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Pointers">Pointers</a></li>
<li><a href="#for">for</a></li>
<li><a href="#Arrays">Arrays</a></li>
</ul>

      
      <h1 id="struct">struct</h1>

      <p class="file">structs.zig</p><pre><code class="zig">// Declare a struct.
// Zig gives no guarantees about the order of fields and whether or
// not there will be padding.
const Point = struct {
    x: f32,
    y: f32,
};

// Maybe we want to pass it to OpenGL so we want to be particular about
// how the bytes are arranged.
const Point2 = packed struct {
    x: f32,
    y: f32,
};


// Declare an instance of a struct.
const p = Point {
    .x = 0.12,
    .y = 0.34,
};

// Maybe we're not ready to fill out some of the fields.
var p2 = Point {
    .x = 0.12,
    .y = undefined,
};

// Structs can have methods
// Struct methods are not special, they are only namespaced
// functions that you can call with dot syntax.
const Vec3 = struct {
    x: f32,
    y: f32,
    z: f32,

    pub fn init(x: f32, y: f32, z: f32) Vec3 {
        return Vec3 {
            .x = x,
            .y = y,
            .z = z,
        };
    }

    pub fn dot(self: &amp;const Vec3, other: &amp;const Vec3) f32 {
        return self.x * other.x + self.y * other.y + self.z * other.z;
    }
};

const assert = @import(&quot;std&quot;).debug.assert;
test &quot;dot product&quot; {
    const v1 = Vec3.init(1.0, 0.0, 0.0);
    const v2 = Vec3.init(0.0, 1.0, 0.0);
    assert(v1.dot(v2) == 0.0);

    // Other than being available to call with dot syntax, struct methods are
    // not special. You can reference them as any other declaration inside
    // the struct:
    assert(Vec3.dot(v1, v2) == 0.0);
}

// Structs can have global declarations.
// Structs can have 0 fields.
const Empty = struct {
    pub const PI = 3.14;
};
test &quot;struct namespaced variable&quot; {
    assert(Empty.PI == 3.14);
    assert(@sizeOf(Empty) == 0);

    // you can still instantiate an empty struct
    const does_nothing = Empty {};
}

// struct field order is determined by the compiler for optimal performance.
// however, you can still calculate a struct base pointer given a field pointer:
fn setYBasedOnX(x: &amp;f32, y: f32) void {
    const point = @fieldParentPtr(Point, &quot;x&quot;, x);
    point.y = y;
}
test &quot;field parent pointer&quot; {
    var point = Point {
        .x = 0.1234,
        .y = 0.5678,
    };
    setYBasedOnX(&amp;point.x, 0.9);
    assert(point.y == 0.9);
}

// You can return a struct from a function. This is how we do generics
// in Zig:
fn LinkedList(comptime T: type) type {
    return struct {
        pub const Node = struct {
            prev: ?&amp;Node,
            next: ?&amp;Node,
            data: T,
        };

        first: ?&amp;Node,
        last:  ?&amp;Node,
        len:   usize,
    };
}

test &quot;linked list&quot; {
    // Functions called at compile-time are memoized. This means you can
    // do this:
    assert(LinkedList(i32) == LinkedList(i32));

    var list = LinkedList(i32) {
        .first = null,
        .last = null,
        .len = 0,
    };
    assert(list.len == 0);

    // Since types are first class values you can instantiate the type
    // by assigning it to a variable:
    const ListOfInts = LinkedList(i32);
    assert(ListOfInts == LinkedList(i32));

    var node = ListOfInts.Node {
        .prev = null,
        .next = null,
        .data = 1234,
    };
    var list2 = LinkedList(i32) {
        .first = &amp;node,
        .last = &amp;node,
        .len = 1,
    };
    assert((??list2.first).data == 1234);
}</code></pre><pre><code class="shell">$ zig test structs.zig
Test 1/4 dot product...OK
Test 2/4 struct namespaced variable...OK
Test 3/4 field parent pointer...OK
Test 4/4 linked list...OK
</code></pre>

      <p>See also:</p><ul>
<li><a href="#comptime">comptime</a></li>
<li><a href="#fieldParentPtr">@fieldParentPtr</a></li>
</ul>

      
      <h1 id="enum">enum</h1>

      <p class="file">enums.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;
const mem = @import(&quot;std&quot;).mem;

// Declare an enum.
const Type = enum {
    Ok,
    NotOk,
};

// Declare a specific instance of the enum variant.
const c = Type.Ok;

// If you want access to the ordinal value of an enum, you
// can specify the tag type.
const Value = enum(u2) {
    Zero,
    One,
    Two,
};

// Now you can cast between u2 and Value.
// The ordinal value starts from 0, counting up for each member.
test &quot;enum ordinal value&quot; {
    assert(u2(Value.Zero) == 0);
    assert(u2(Value.One) == 1);
    assert(u2(Value.Two) == 2);
}

// You can override the ordinal value for an enum.
const Value2 = enum(u32) {
    Hundred = 100,
    Thousand = 1000,
    Million = 1000000,
};
test &quot;set enum ordinal value&quot; {
    assert(u32(Value2.Hundred) == 100);
    assert(u32(Value2.Thousand) == 1000);
    assert(u32(Value2.Million) == 1000000);
}

// Enums can have methods, the same as structs and unions.
// Enum methods are not special, they are only namespaced
// functions that you can call with dot syntax.
const Suit = enum {
    Clubs,
    Spades,
    Diamonds,
    Hearts,

    pub fn isClubs(self: Suit) bool {
        return self == Suit.Clubs;
    }
};
test &quot;enum method&quot; {
    const p = Suit.Spades;
    assert(!p.isClubs());
}

// An enum variant of different types can be switched upon.
const Foo = enum {
    String,
    Number,
    None,
};
test &quot;enum variant switch&quot; {
    const p = Foo.Number;
    const what_is_it = switch (p) {
        Foo.String =&gt; &quot;this is a string&quot;,
        Foo.Number =&gt; &quot;this is a number&quot;,
        Foo.None =&gt; &quot;this is a none&quot;,
    };
    assert(mem.eql(u8, what_is_it, &quot;this is a number&quot;));
}

// @TagType can be used to access the integer tag type of an enum.
const Small = enum {
    One,
    Two,
    Three,
    Four,
};
test &quot;@TagType&quot; {
    assert(@TagType(Small) == u2);
}

// @memberCount tells how many fields an enum has:
test &quot;@memberCount&quot; {
    assert(@memberCount(Small) == 4);
}

// @memberName tells the name of a field in an enum:
test &quot;@memberName&quot; {
    assert(mem.eql(u8, @memberName(Small, 1), &quot;Two&quot;));
}

// @tagName gives a []const u8 representation of an enum value:
test &quot;@tagName&quot; {
    assert(mem.eql(u8, @tagName(Small.Three), &quot;Three&quot;));
}</code></pre><pre><code class="shell">$ zig test enums.zig
Test 1/8 enum ordinal value...OK
Test 2/8 set enum ordinal value...OK
Test 3/8 enum method...OK
Test 4/8 enum variant switch...OK
Test 5/8 @TagType...OK
Test 6/8 @memberCount...OK
Test 7/8 @memberName...OK
Test 8/8 @tagName...OK
</code></pre>

      <h2 id="extern-enum">extern enum</h2>

      <p>
      By default, enums are not guaranteed to be compatible with the C ABI:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const Foo = enum { A, B, C };
export fn entry(foo: Foo) void { }</code></pre><pre><code class="shell">$ zig build-obj test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:22: </span><span class="t31_1">error:</span><span class="t0_1"> parameter of type 'Foo' not allowed in function with calling convention 'ccc'</span>
export fn entry(foo: Foo) void { 
                     <span class="t32_1">^</span>

</code></pre>
</code></pre>

      <p>
      For a C-ABI-compatible enum, use <code class="zig">extern enum</code>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const Foo = extern enum { A, B, C };
export fn entry(foo: Foo) void { }</code></pre><pre><code class="shell">$ zig build-obj test.zig</code></pre>

      
      <p>TODO packed enum</p>
      <p>See also:</p><ul>
<li><a href="#memberName">@memberName</a></li>
<li><a href="#memberCount">@memberCount</a></li>
<li><a href="#tagName">@tagName</a></li>
</ul>

      
      <h1 id="union">union</h1>

      <p class="file">union.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;
const mem = @import(&quot;std&quot;).mem;

// A union has only 1 active field at a time.
const Payload = union {
    Int: i64,
    Float: f64,
    Bool: bool,
};
test &quot;simple union&quot; {
    var payload = Payload {.Int = 1234};
    // payload.Float = 12.34; // ERROR! field not active
    assert(payload.Int == 1234);
    // You can activate another field by assigning the entire union.
    payload = Payload {.Float = 12.34};
    assert(payload.Float == 12.34);
}

// Unions can be given an enum tag type:
const ComplexTypeTag = enum { Ok, NotOk }; 
const ComplexType = union(ComplexTypeTag) {
    Ok: u8,
    NotOk: void,
};

// Declare a specific instance of the union variant.
test &quot;declare union value&quot; {
    const c = ComplexType { .Ok = 0 };
    assert(ComplexTypeTag(c) == ComplexTypeTag.Ok);
}

// @TagType can be used to access the enum tag type of a union.
test &quot;@TagType&quot; {
    assert(@TagType(ComplexType) == ComplexTypeTag);
}

// Unions can be made to infer the enum tag type.
const Foo = union(enum) {
    String: []const u8,
    Number: u64,

    // void can be omitted when inferring enum tag type.
    None,
};
test &quot;union variant switch&quot; {
    const p = Foo { .Number = 54 };
    const what_is_it = switch (p) {
        // Capture by reference
        Foo.String =&gt; |*x| blk: {
            break :blk &quot;this is a string&quot;;
        },

        // Capture by value
        Foo.Number =&gt; |x| blk: {
            assert(x == 54);
            break :blk &quot;this is a number&quot;;
        },

        Foo.None =&gt; blk: {
            break :blk &quot;this is a none&quot;;
        },
    };
    assert(mem.eql(u8, what_is_it, &quot;this is a number&quot;));
}

// TODO union methods


const Small = union {
    A: i32,
    B: bool,
    C: u8,
};

// @memberCount tells how many fields a union has:
test &quot;@memberCount&quot; {
    assert(@memberCount(Small) == 3);
}

// @memberName tells the name of a field in an enum:
test &quot;@memberName&quot; {
    assert(mem.eql(u8, @memberName(Small, 1), &quot;B&quot;));
}

// @tagName gives a []const u8 representation of an enum value,
// but only if the union has an enum tag type.
const Small2 = union(enum) {
    A: i32,
    B: bool,
    C: u8,
};
test &quot;@tagName&quot; {
    assert(mem.eql(u8, @tagName(Small2.C), &quot;C&quot;));
}</code></pre><pre><code class="shell">$ zig test union.zig
Test 1/7 simple union...OK
Test 2/7 declare union value...OK
Test 3/7 @TagType...OK
Test 4/7 union variant switch...OK
Test 5/7 @memberCount...OK
Test 6/7 @memberName...OK
Test 7/7 @tagName...OK
</code></pre>

      <p>
      Unions with an enum tag are generated as a struct with a tag field and union field. Zig
      sorts the order of the tag and union field by the largest alignment.
      </p>
      
      <h1 id="switch">switch</h1>

      <p class="file">switch.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;
const builtin = @import(&quot;builtin&quot;);

test &quot;switch simple&quot; {
    const a: u64 = 10;
    const zz: u64 = 103;

    // All branches of a switch expression must be able to be coerced to a
    // common type.
    //
    // Branches cannot fallthrough. If fallthrough behavior is desired, combine
    // the cases and use an if.
    const b = switch (a) {
        // Multiple cases can be combined via a ','
        1, 2, 3 =&gt; 0,

        // Ranges can be specified using the ... syntax. These are inclusive
        // both ends.
        5 ... 100 =&gt; 1,

        // Branches can be arbitrarily complex.
        101 =&gt; blk: {
            const c: u64 = 5;
            break :blk c * 2 + 1;
        },

        // Switching on arbitrary expressions is allowed as long as the
        // expression is known at compile-time.
        zz =&gt; zz,
        comptime blk: {
            const d: u32 = 5;
            const e: u32 = 100;
            break :blk d + e;
        } =&gt; 107,

        // The else branch catches everything not already captured.
        // Else branches are mandatory unless the entire range of values
        // is handled.
        else =&gt; 9,
    };

    assert(b == 1);
}

test &quot;switch enum&quot; {
    const Item = union(enum) {
        A: u32,
        C: struct { x: u8, y: u8 },
        D,
    };

    var a = Item { .A = 3 };

    // Switching on more complex enums is allowed.
    const b = switch (a) {
        // A capture group is allowed on a match, and will return the enum
        // value matched.
        Item.A =&gt; |item| item,

        // A reference to the matched value can be obtained using `*` syntax.
        Item.C =&gt; |*item| blk: {
            (*item).x += 1;
            break :blk 6;
        },

        // No else is required if the types cases was exhaustively handled
        Item.D =&gt; 8,
    };

    assert(b == 3);
}

// Switch expressions can be used outside a function:
const os_msg = switch (builtin.os) {
    builtin.Os.linux =&gt; &quot;we found a linux user&quot;,
    else =&gt; &quot;not a linux user&quot;,
};

// Inside a function, switch statements implicitly are compile-time
// evaluated if the target expression is compile-time known.
test &quot;switch inside function&quot; {
    switch (builtin.os) {
        builtin.Os.fuchsia =&gt; {
            // On an OS other than fuchsia, block is not even analyzed,
            // so this compile error is not triggered.
            // On fuchsia this compile error would be triggered.
            @compileError(&quot;windows not supported&quot;);
        },
        else =&gt; {},
    }
}</code></pre><pre><code class="shell">$ zig test switch.zig
Test 1/3 switch simple...OK
Test 2/3 switch enum...OK
Test 3/3 switch inside function...OK
</code></pre>

      <p>See also:</p><ul>
<li><a href="#comptime">comptime</a></li>
<li><a href="#enum">enum</a></li>
<li><a href="#compileError">@compileError</a></li>
<li><a href="#Compile-Variables">Compile Variables</a></li>
</ul>

      
      <h1 id="while">while</h1>

      <p class="file">while.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

test &quot;while basic&quot; {
    // A while loop is used to repeatedly execute an expression until
    // some condition is no longer true.
    var i: usize = 0;
    while (i &lt; 10) {
        i += 1;
    }
    assert(i == 10);
}

test &quot;while break&quot; {
    // You can use break to exit a while loop early.
    var i: usize = 0;
    while (true) {
        if (i == 10)
            break;
        i += 1;
    }
    assert(i == 10);
}

test &quot;while continue&quot; {
    // You can use continue to jump back to the beginning of the loop.
    var i: usize = 0;
    while (true) {
        i += 1;
        if (i &lt; 10)
            continue;
        break;
    }
    assert(i == 10);
}

test &quot;while loop continuation expression&quot; {
    // You can give an expression to the while loop to execute when
    // the loop is continued. This is respected by the continue control flow.
    var i: usize = 0;
    while (i &lt; 10) : (i += 1) {}
    assert(i == 10);
}

test &quot;while loop continuation expression, more complicated&quot; {
    // More complex blocks can be used as an expression in the loop continue
    // expression.
    var i1: usize = 1;
    var j1: usize = 1;
    while (i1 * j1 &lt; 2000) : ({ i1 *= 2; j1 *= 3; }) {
        const my_ij1 = i1 * j1;
        assert(my_ij1 &lt; 2000);
    }
}

test &quot;while else&quot; {
    assert(rangeHasNumber(0, 10, 5));
    assert(!rangeHasNumber(0, 10, 15));
}

fn rangeHasNumber(begin: usize, end: usize, number: usize) bool {
    var i = begin;
    // While loops are expressions. The result of the expression is the
    // result of the else clause of a while loop, which is executed when
    // the condition of the while loop is tested as false.
    return while (i &lt; end) : (i += 1) {
        if (i == number) {
            // break expressions, like return expressions, accept a value
            // parameter. This is the result of the while expression.
            // When you break from a while loop, the else branch is not
            // evaluated.
            break true;
        }
    } else false;
}

test &quot;while null capture&quot; {
    // Just like if expressions, while loops can take a nullable as the
    // condition and capture the payload. When null is encountered the loop
    // exits.
    var sum1: u32 = 0;
    numbers_left = 3;
    while (eventuallyNullSequence()) |value| {
        sum1 += value;
    }
    assert(sum1 == 3);

    // The else branch is allowed on nullable iteration. In this case, it will
    // be executed on the first null value encountered.
    var sum2: u32 = 0;
    numbers_left = 3;
    while (eventuallyNullSequence()) |value| {
        sum2 += value;
    } else {
        assert(sum1 == 3);
    }

    // Just like if expressions, while loops can also take an error union as
    // the condition and capture the payload or the error code. When the
    // condition results in an error code the else branch is evaluated and
    // the loop is finished.
    var sum3: u32 = 0;
    numbers_left = 3;
    while (eventuallyErrorSequence()) |value| {
        sum3 += value;
    } else |err| {
        assert(err == error.ReachedZero);
    }
}

var numbers_left: u32 = undefined;
fn eventuallyNullSequence() ?u32 {
    return if (numbers_left == 0) null else blk: {
        numbers_left -= 1;
        break :blk numbers_left;
    };
}

fn eventuallyErrorSequence() error!u32 {
    return if (numbers_left == 0) error.ReachedZero else blk: {
        numbers_left -= 1;
        break :blk numbers_left;
    };
}

test &quot;inline while loop&quot; {
    // While loops can be inlined. This causes the loop to be unrolled, which
    // allows the code to do some things which only work at compile time,
    // such as use types as first class values.
    comptime var i = 0;
    var sum: usize = 0;
    inline while (i &lt; 3) : (i += 1) {
        const T = switch (i) {
            0 =&gt; f32,
            1 =&gt; i8,
            2 =&gt; bool,
            else =&gt; unreachable,
        };
        sum += typeNameLength(T);
    }
    assert(sum == 9);
}

fn typeNameLength(comptime T: type) usize {
    return @typeName(T).len;
}</code></pre><pre><code class="shell">$ zig test while.zig
Test 1/8 while basic...OK
Test 2/8 while break...OK
Test 3/8 while continue...OK
Test 4/8 while loop continuation expression...OK
Test 5/8 while loop continuation expression, more complicated...OK
Test 6/8 while else...OK
Test 7/8 while null capture...OK
Test 8/8 inline while loop...OK
</code></pre>

      <p>See also:</p><ul>
<li><a href="#if">if</a></li>
<li><a href="#Nullables">Nullables</a></li>
<li><a href="#Errors">Errors</a></li>
<li><a href="#comptime">comptime</a></li>
<li><a href="#unreachable">unreachable</a></li>
</ul>

      
      <h1 id="for">for</h1>

      <p class="file">for.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

test &quot;for basics&quot; {
    const items = []i32 { 4, 5, 3, 4, 0 };
    var sum: i32 = 0;

    // For loops iterate over slices and arrays.
    for (items) |value| {
        // Break and continue are supported.
        if (value == 0) {
            continue;
        }
        sum += value;
    }
    assert(sum == 16);

    // To iterate over a portion of a slice, reslice.
    for (items[0..1]) |value| {
        sum += value;
    }
    assert(sum == 20);

    // To access the index of iteration, specify a second capture value.
    // This is zero-indexed.
    var sum2: i32 = 0;
    for (items) |value, i| {
        assert(@typeOf(i) == usize);
        sum2 += i32(i);
    }
    assert(sum2 == 10);
}

test &quot;for reference&quot; {
    var items = []i32 { 3, 4, 2 };

    // Iterate over the slice by reference by
    // specifying that the capture value is a pointer.
    for (items) |*value| {
        *value += 1;
    }

    assert(items[0] == 4);
    assert(items[1] == 5);
    assert(items[2] == 3);
}

test &quot;for else&quot; {
    // For allows an else attached to it, the same as a while loop.
    var items = []?i32 { 3, 4, null, 5 };

    // For loops can also be used as expressions.
    var sum: i32 = 0;
    const result = for (items) |value| {
        if (value == null) {
            break 9;
        } else {
            sum += ??value;
        }
    } else blk: {
        assert(sum == 7);
        break :blk sum;
    };
}


test &quot;inline for loop&quot; {
    const nums = []i32{2, 4, 6};
    // For loops can be inlined. This causes the loop to be unrolled, which
    // allows the code to do some things which only work at compile time,
    // such as use types as first class values.
    // The capture value and iterator value of inlined for loops are
    // compile-time known.
    var sum: usize = 0;
    inline for (nums) |i| {
        const T = switch (i) {
            2 =&gt; f32,
            4 =&gt; i8,
            6 =&gt; bool,
            else =&gt; unreachable,
        };
        sum += typeNameLength(T);
    }
    assert(sum == 9);
}

fn typeNameLength(comptime T: type) usize {
    return @typeName(T).len;
}</code></pre><pre><code class="shell">$ zig test for.zig
Test 1/4 for basics...OK
Test 2/4 for reference...OK
Test 3/4 for else...OK
Test 4/4 inline for loop...OK
</code></pre>

      <p>See also:</p><ul>
<li><a href="#while">while</a></li>
<li><a href="#comptime">comptime</a></li>
<li><a href="#Arrays">Arrays</a></li>
<li><a href="#Slices">Slices</a></li>
</ul>

      
      <h1 id="if">if</h1>

      <p class="file">if.zig</p><pre><code class="zig">// If expressions have three uses, corresponding to the three types:
// * bool
// * ?T
// * error!T

const assert = @import(&quot;std&quot;).debug.assert;

test &quot;if boolean&quot; {
    // If expressions test boolean conditions.
    const a: u32 = 5;
    const b: u32 = 4;
    if (a != b) {
        assert(true);
    } else if (a == 9) {
        unreachable;
    } else {
        unreachable;
    }

    // If expressions are used instead of a ternary expression.
    const result = if (a != b) 47 else 3089;
    assert(result == 47);
}

test &quot;if nullable&quot; {
    // If expressions test for null.

    const a: ?u32 = 0;
    if (a) |value| {
        assert(value == 0);
    } else {
        unreachable;
    }

    const b: ?u32 = null;
    if (b) |value| {
        unreachable;
    } else {
        assert(true);
    }

    // The else is not required.
    if (a) |value| {
        assert(value == 0);
    }

    // To test against null only, use the binary equality operator.
    if (b == null) {
        assert(true);
    }

    // Access the value by reference using a pointer capture.
    var c: ?u32 = 3;
    if (c) |*value| {
        *value = 2;
    }

    if (c) |value| {
        assert(value == 2);
    } else {
        unreachable;
    }
}

test &quot;if error union&quot; {
    // If expressions test for errors.
    // Note the |err| capture on the else.

    const a: error!u32 = 0;
    if (a) |value| {
        assert(value == 0);
    } else |err| {
        unreachable;
    }

    const b: error!u32 = error.BadValue;
    if (b) |value| {
        unreachable;
    } else |err| {
        assert(err == error.BadValue);
    }

    // The else and |err| capture is strictly required.
    if (a) |value| {
        assert(value == 0);
    } else |_| {}

    // To check only the error value, use an empty block expression.
    if (b) |_| {} else |err| {
        assert(err == error.BadValue);
    }

    // Access the value by reference using a pointer capture.
    var c: error!u32 = 3;
    if (c) |*value| {
        *value = 9;
    } else |err| {
        unreachable;
    }

    if (c) |value| {
        assert(value == 9);
    } else |err| {
        unreachable;
    }
}</code></pre><pre><code class="shell">$ zig test if.zig
Test 1/3 if boolean...OK
Test 2/3 if nullable...OK
Test 3/3 if error union...OK
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Nullables">Nullables</a></li>
<li><a href="#Errors">Errors</a></li>
</ul>

      
      <h1 id="defer">defer</h1>

      <p class="file">defer.zig</p><pre><code class="zig">const std = @import(&quot;std&quot;);
const assert = std.debug.assert;
const warn = std.debug.warn;

// defer will execute an expression at the end of the current scope.
fn deferExample() usize {
    var a: usize = 1;

    {
        defer a = 2;
        a = 1;
    }
    assert(a == 2);

    a = 5;
    return a;
}

test &quot;defer basics&quot; {
    assert(deferExample() == 5);
}

// If multiple defer statements are specified, they will be executed in
// the reverse order they were run.
fn deferUnwindExample() void {
    warn(&quot;\n&quot;);

    defer {
        warn(&quot;1 &quot;);
    }
    defer {
        warn(&quot;2 &quot;);
    }
    if (false) {
        // defers are not run if they are never executed.
        defer {
            warn(&quot;3 &quot;);
        }
    }
}

test &quot;defer unwinding&quot; {
    deferUnwindExample();
}

// The errdefer keyword is similar to defer, but will only execute if the
// scope returns with an error.
//
// This is especially useful in allowing a function to clean up properly
// on error, and replaces goto error handling tactics as seen in c.
fn deferErrorExample(is_error: bool) !void {
    warn(&quot;\nstart of function\n&quot;);

    // This will always be executed on exit
    defer {
        warn(&quot;end of function\n&quot;);
    }

    errdefer {
        warn(&quot;encountered an error!\n&quot;);
    }

    if (is_error) {
        return error.DeferError;
    }
}

test &quot;errdefer unwinding&quot; {
    _ = deferErrorExample(false);
    _ = deferErrorExample(true);
}</code></pre><pre><code class="shell">$ zig test defer.zig
Test 1/3 defer basics...OK
Test 2/3 defer unwinding...
2 1 OK
Test 3/3 errdefer unwinding...
start of function
end of function

start of function
encountered an error!
end of function
OK
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Errors">Errors</a></li>
</ul>

      
      <h1 id="unreachable">unreachable</h1>

      <p>
      In <code>Debug</code> and <code>ReleaseSafe</code> mode, and when using <code>zig test</code>,
      <code>unreachable</code> emits a call to <code>panic</code> with the message <code>reached unreachable code</code>.
      </p>
      <p>
      In <code>ReleaseFast</code> mode, the optimizer uses the assumption that <code>unreachable</code> code
      will never be hit to perform optimizations. However, <code>zig test</code> even in <code>ReleaseFast</code> mode
      still emits <code>unreachable</code> as calls to <code>panic</code>.
      </p>
      <h2 id="Basics">Basics</h2>

      <p class="file">test.zig</p><pre><code class="zig">// unreachable is used to assert that control flow will never happen upon a
// particular location:
test &quot;basic math&quot; {
    const x = 1;
    const y = 2;
    if (x + y != 3) {
        unreachable;
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 basic math...OK
</code></pre>

      <p>In fact, this is how assert is implemented:</p>
      <p class="file">test.zig</p><pre><code class="zig">fn assert(ok: bool) void {
    if (!ok) unreachable; // assertion failure
}

// This test will fail because we hit unreachable.
test &quot;this will fail&quot; {
    assert(false);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 this will fail...reached unreachable code
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:14</span>: <span class="t2_0">0x203839 in ??? (test)</span>
    if (!ok) unreachable; // assertion failure
             <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:7:11</span>: <span class="t2_0">0x20365b in ??? (test)</span>
    assert(false);
          <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/test_runner.zig:11:25</span>: <span class="t2_0">0x21d488 in ??? (test)</span>
        try test_fn.func();
                        <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:85:22</span>: <span class="t2_0">0x21d28b in ??? (test)</span>
            root.main() catch |err| {
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:62:20</span>: <span class="t2_0">0x21d1eb in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:52:39</span>: <span class="t2_0">0x21d07c in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:39:5</span>: <span class="t2_0">0x21d000 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>

Tests failed. Use the following command to reproduce the failure:
./zig-cache/test
</code></pre>

      
      <h2 id="At-Compile-Time">At Compile-Time</h2>

      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

test &quot;type of unreachable&quot; {
    comptime {
        // The type of unreachable is noreturn.

        // However this assertion will still fail because
        // evaluating unreachable at compile-time is a compile error.

        assert(@typeOf(unreachable) == noreturn);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:10:16: </span><span class="t31_1">error:</span><span class="t0_1"> unreachable code</span>
        assert(@typeOf(unreachable) == noreturn);
               <span class="t32_1">^</span>
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Zig-Test">Zig Test</a></li>
<li><a href="#Build-Mode">Build Mode</a></li>
<li><a href="#comptime">comptime</a></li>
</ul>

      
      
      <h1 id="noreturn">noreturn</h1>

      <p>
      <code>noreturn</code> is the type of:
      </p>
      <ul>
        <li><code>break</code></li>
        <li><code>continue</code></li>
        <li><code>return</code></li>
        <li><code>unreachable</code></li>
        <li><code>while (true) {}</code></li>
      </ul>
      <p>When resolving types together, such as <code>if</code> clauses or <code>switch</code> prongs,
      the <code>noreturn</code> type is compatible with every other type. Consider:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">fn foo(condition: bool, b: u32) void {
    const a = if (condition) b else return;
    @panic(&quot;do something with a&quot;);
}
test &quot;noreturn&quot; {
    foo(false, 1);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 noreturn...OK
</code></pre>

      <p>Another use case for <code>noreturn</code> is the <code>exit</code> function:</p>
      <p class="file">test.zig</p><pre><code class="zig">pub extern &quot;kernel32&quot; stdcallcc fn ExitProcess(exit_code: c_uint) noreturn;

test &quot;foo&quot; {
    const value = bar() catch ExitProcess(1);
    assert(value == 1234);
}

fn bar() error!u32 {
    return 1234;
}

const assert = @import(&quot;std&quot;).debug.assert;</code></pre><pre><code class="shell">$ zig test test.zig
Created ./zig-cache/test.exe but skipping execution because it is non-native.
</code></pre>

      
      <h1 id="Functions">Functions</h1>

      <p class="file">functions.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

// Functions are declared like this
fn add(a: i8, b: i8) i8 {
    if (a == 0) {
        // You can still return manually if needed.
        return b;
    }

    return a + b;
}

// The export specifier makes a function externally visible in the generated
// object file, and makes it use the C ABI.
export fn sub(a: i8, b: i8) i8 { return a - b; }

// The extern specifier is used to declare a function that will be resolved
// at link time, when linking statically, or at runtime, when linking
// dynamically.
// The stdcallcc specifier changes the calling convention of the function.
extern &quot;kernel32&quot; stdcallcc fn ExitProcess(exit_code: u32) noreturn;
extern &quot;c&quot; fn atan2(a: f64, b: f64) f64;

// The @setCold builtin tells the optimizer that a function is rarely called.
fn abort() noreturn {
    @setCold(true);
    while (true) {}
}

// nakedcc makes a function not have any function prologue or epilogue.
// This can be useful when integrating with assembly.
nakedcc fn _start() noreturn {
    abort();
}

// The pub specifier allows the function to be visible when importing.
// Another file can use @import and call sub2
pub fn sub2(a: i8, b: i8) i8 { return a - b; }

// Functions can be used as values and are equivalent to pointers.
const call2_op = fn (a: i8, b: i8) i8;
fn do_op(fn_call: call2_op, op1: i8, op2: i8) i8 {
    return fn_call(op1, op2);
}

test &quot;function&quot; {
    assert(do_op(add, 5, 6) == 11);
    assert(do_op(sub2, 5, 6) == -1);
}</code></pre><pre><code class="shell">$ zig test functions.zig
Test 1/1 function...OK
</code></pre>

      <p>Function values are like pointers:</p>
      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

comptime {
    assert(@typeOf(foo) == fn()void);
    assert(@sizeOf(fn()void) == @sizeOf(?fn()void));
}

fn foo() void { }</code></pre><pre><code class="shell">$ zig build-obj test.zig</code></pre>

      <h2 id="Pass-by-value-Parameters">Pass-by-value Parameters</h2>

      <p>
      In Zig, structs, unions, and enums with payloads cannot be passed by value
      to a function.
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const Foo = struct {
    x: i32,
};

fn bar(foo: Foo) void {}

test &quot;pass aggregate type by value to function&quot; {
    bar(Foo {.x = 12,});
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:13: </span><span class="t31_1">error:</span><span class="t0_1"> type 'Foo' is not copyable; cannot pass by value</span>
fn bar(foo: Foo) void {}
            <span class="t32_1">^</span>
</code></pre>

      <p>
      Instead, one must use <code>&amp;const</code>. Zig allows implicitly casting something
      to a const pointer to it:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const Foo = struct {
    x: i32,
};

fn bar(foo: &amp;const Foo) void {}

test &quot;implicitly cast to const pointer&quot; {
    bar(Foo {.x = 12,});
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 implicitly cast to const pointer...OK
</code></pre>

      <p>
      However,
      the C ABI does allow passing structs and unions by value. So functions which
      use the C calling convention may pass structs and unions by value.
      </p>
      
      <h2 id="Function-Reflection">Function Reflection</h2>

      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

test &quot;fn reflection&quot; {
    assert(@typeOf(assert).ReturnType == void);
    assert(@typeOf(assert).is_var_args == false);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 fn reflection...OK
</code></pre>

      
      
      <h1 id="Errors">Errors</h1>

      <h2 id="Error-Set-Type">Error Set Type</h2>

      <p>
      An error set is like an <a href="#enum">enum</a>.
      However, each error name across the entire compilation gets assigned an unsigned integer
      greater than 0. You are allowed to declare the same error name more than once, and if you do, it
      gets assigned the same integer value.
      </p>
      <p>
      The number of unique error values across the entire compilation should determine the size of the error set type.
      However right now it is hard coded to be a <code>u16</code>. See <a href="https://github.com/zig-lang/zig/issues/786">#768</a>.
      </p>
      <p>
      You can implicitly cast an error from a subset to its superset:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const std = @import(&quot;std&quot;);

const FileOpenError = error {
    AccessDenied,
    OutOfMemory,
    FileNotFound,
};

const AllocationError = error {
    OutOfMemory,
};

test &quot;implicit cast subset to superset&quot; {
    const err = foo(AllocationError.OutOfMemory);
    std.debug.assert(err == FileOpenError.OutOfMemory);
}

fn foo(err: AllocationError) FileOpenError {
    return err;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 implicit cast subset to superset...OK
</code></pre>

      <p>
      But you cannot implicitly cast an error from a superset to a subset:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const FileOpenError = error {
    AccessDenied,
    OutOfMemory,
    FileNotFound,
};

const AllocationError = error {
    OutOfMemory,
};

test &quot;implicit cast superset to subset&quot; {
    foo(FileOpenError.OutOfMemory) catch {};
}

fn foo(err: FileOpenError) AllocationError {
    return err;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:16:12: </span><span class="t31_1">error:</span><span class="t0_1"> expected 'AllocationError', found 'FileOpenError'</span>
    return err;
           <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:5: </span><span class="t36_1">note:</span><span class="t0_1"> 'error.AccessDenied' not a member of destination error set</span>
    AccessDenied,
    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:5: </span><span class="t36_1">note:</span><span class="t0_1"> 'error.FileNotFound' not a member of destination error set</span>
    FileNotFound,
    <span class="t32_1">^</span>
</code></pre>

      <p>
      There is a shortcut for declaring an error set with only 1 value, and then getting that value:
      </p>
      <pre><code class="zig">const err = error.FileNotFound;</code></pre>
      <p>This is equivalent to:</p>
      <pre><code class="zig">const err = (error {FileNotFound}).FileNotFound;</code></pre>
      <p>
      This becomes useful when using <a href="#Inferred-Error-Sets">Inferred Error Sets</a>.
      </p>
      <h3 id="The-Global-Error-Set">The Global Error Set</h3>

      <p><code>error</code> refers to the global error set.
      This is the error set that contains all errors in the entire compilation unit.
      It is a superset of all other error sets and a subset of none of them.
      </p>
      <p>
      You can implicitly cast any error set to the global one, and you can explicitly
      cast an error of global error set to a non-global one. This inserts a language-level
      assert to make sure the error value is in fact in the destination error set.
      </p>
      <p>
      The global error set should generally be avoided when possible, because it prevents
      the compiler from knowing what errors are possible at compile-time. Knowing
      the error set at compile-time is better for generated documentationt and for
      helpful error messages such as forgetting a possible error value in a <a href="#switch">switch</a>.
      </p>
      
      
      <h2 id="Error-Union-Type">Error Union Type</h2>

      <p>
      Most of the time you will not find yourself using an error set type. Instead,
      likely you will be using the error union type. This is when you take an error set
      and a normal type, and create an error union with the <code>!</code> binary operator.
      </p>
      <p>
      Here is a function to parse a string into a 64-bit integer:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">pub fn parseU64(buf: []const u8, radix: u8) !u64 {
    var x: u64 = 0;

    for (buf) |c| {
        const digit = charToDigit(c);

        if (digit &gt;= radix) {
            return error.InvalidChar;
        }

        // x *= radix
        if (@mulWithOverflow(u64, x, radix, &amp;x)) {
            return error.Overflow;
        }

        // x += digit
        if (@addWithOverflow(u64, x, digit, &amp;x)) {
            return error.Overflow;
        }
    }

    return x;
}

fn charToDigit(c: u8) u8 {
    return switch (c) {
        '0' ... '9' =&gt; c - '0',
        'A' ... 'Z' =&gt; c - 'A' + 10,
        'a' ... 'z' =&gt; c - 'a' + 10,
        else =&gt; @maxValue(u8),
    };
}

test &quot;parse u64&quot; {
    const result = try parseU64(&quot;1234&quot;, 10);
    @import(&quot;std&quot;).debug.assert(result == 1234);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 parse u64...OK
</code></pre>

      <p>
      Notice the return type is <code>!u64</code>. This means that the function
      either returns an unsigned 64 bit integer, or an error. We left off the error set
      to the left of the <code>!</code>, so the error set is inferred.
      </p>
      <p>
      Within the function definition, you can see some return statements that return
      an error, and at the bottom a return statement that returns a <code>u64</code>.
      Both types implicitly cast to <code>error!u64</code>.
      </p>
      <p>
      What it looks like to use this function varies depending on what you're
      trying to do. One of the following:
      </p>
      <ul>
        <li>You want to provide a default value if it returned an error.</li>
        <li>If it returned an error then you want to return the same error.</li>
        <li>You know with complete certainty it will not return an error, so want to unconditionally unwrap it.</li>
        <li>You want to take a different action for each possible error.</li>
      </ul>
      <p>If you want to provide a default value, you can use the <code>catch</code> binary operator:</p>
      <pre><code class="zig">fn doAThing(str: []u8) void {
    const number = parseU64(str, 10) catch 13;
    // ...
}</code></pre>
      <p>
      In this code, <code>number</code> will be equal to the successfully parsed string, or
      a default value of 13. The type of the right hand side of the binary <code>catch</code> operator must
      match the unwrapped error union type, or be of type <code>noreturn</code>.
      </p>
      <p>Let's say you wanted to return the error if you got one, otherwise continue with the
      function logic:</p>
      <pre><code class="zig">fn doAThing(str: []u8) !void {
    const number = parseU64(str, 10) catch |err| return err;
    // ...
}</code></pre>
      <p>
        There is a shortcut for this. The <code>try</code> expression:
      </p>
      <pre><code class="zig">fn doAThing(str: []u8) !void {
    const number = try parseU64(str, 10);
    // ...
}</code></pre>
      <p>
      <code>try</code> evaluates an error union expression. If it is an error, it returns
      from the current function with the same error. Otherwise, the expression results in
      the unwrapped value.
      </p>
      <p>
        Maybe you know with complete certainty that an expression will never be an error.
        In this case you can do this:
      </p>
      <pre><code class="zig">const number = parseU64(&quot;1234&quot;, 10) catch unreachable;</code></pre>
      <p>
      Here we know for sure that "1234" will parse successfully. So we put the
      <code>unreachable</code> value on the right hand side. <code>unreachable</code> generates
      a panic in Debug and ReleaseSafe modes and undefined behavior in ReleaseFast mode. So, while we're debugging the
      application, if there <em>was</em> a surprise error here, the application would crash
      appropriately.
      </p>
      <p>
      Finally, you may want to take a different action for every situation. For that, we combine
      the <code>if</code> and <code>switch</code> expression:
      </p>
      <pre><code class="zig">fn doAThing(str: []u8) void {
    if (parseU64(str, 10)) |number| {
        doSomethingWithNumber(number);
    } else |err| switch (err) {
        error.Overflow =&gt; {
            // handle overflow...
        },
        // we promise that InvalidChar won't happen (or crash in debug mode if it does)
        error.InvalidChar =&gt; unreachable,
    }
}</code></pre>
      <p>
      The other component to error handling is defer statements.
      In addition to an unconditional <code>defer</code>, Zig has <code>errdefer</code>,
      which evaluates the deferred expression on block exit path if and only if
      the function returned with an error from the block.
      </p>
      <p>
      Example:
      </p>
      <pre><code class="zig">fn createFoo(param: i32) !Foo {
    const foo = try tryToAllocateFoo();
    // now we have allocated foo. we need to free it if the function fails.
    // but we want to return it if the function succeeds.
    errdefer deallocateFoo(foo);

    const tmp_buf = allocateTmpBuffer() ?? return error.OutOfMemory;
    // tmp_buf is truly a temporary resource, and we for sure want to clean it up
    // before this block leaves scope
    defer deallocateTmpBuffer(tmp_buf);

    if (param &gt; 1337) return error.InvalidParam;

    // here the errdefer will not run since we're returning success from the function.
    // but the defer will run!
    return foo;
}</code></pre>
      <p>
      The neat thing about this is that you get robust error handling without
      the verbosity and cognitive overhead of trying to make sure every exit path
      is covered. The deallocation code is always directly following the allocation code.
      </p>
      <p>
      A couple of other tidbits about error handling:
      </p>
      <ul>
        <li>These primitives give enough expressiveness that it's completely practical
            to have failing to check for an error be a compile error. If you really want
            to ignore the error, you can add <code>catch unreachable</code> and
            get the added benefit of crashing in Debug and ReleaseSafe modes if your assumption was wrong.
        </li>
        <li>
          Since Zig understands error types, it can pre-weight branches in favor of
          errors not occuring. Just a small optimization benefit that is not available
          in other languages.
        </li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#defer">defer</a></li>
<li><a href="#if">if</a></li>
<li><a href="#switch">switch</a></li>
</ul>


      <p>An error union is created with the <code>!</code> binary operator.
      You can use compile-time reflection to access the child type of an error union:</p>
      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

test &quot;error union&quot; {
    var foo: error!i32 = undefined;

    // Implicitly cast from child type of an error union:
    foo = 1234;

    // Implicitly cast from an error set:
    foo = error.SomeError;

    // Use compile-time reflection to access the payload type of an error union:
    comptime assert(@typeOf(foo).Payload == i32);

    // Use compile-time reflection to access the error set type of an error union:
    comptime assert(@typeOf(foo).ErrorSet == error);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 error union...OK
</code></pre>

      <p>TODO the <code>||</code> operator for error sets</p>
      <h3 id="Inferred-Error-Sets">Inferred Error Sets</h3>

      <p>TODO</p>
      
      
      <h2 id="Error-Return-Traces">Error Return Traces</h2>

      <p>TODO</p>
      
      
      <h1 id="Nullables">Nullables</h1>

      <p>
      One area that Zig provides safety without compromising efficiency or
      readability is with the nullable type.
      </p>
      <p>
      The question mark symbolizes the nullable type. You can convert a type to a nullable
      type by putting a question mark in front of it, like this:
      </p>
      <pre><code class="zig">// normal integer
const normal_int: i32 = 1234;

// nullable integer
const nullable_int: ?i32 = 5678;</code></pre>
      <p>
      Now the variable <code>nullable_int</code> could be an <code>i32</code>, or <code>null</code>.
      </p>
      <p>
      Instead of integers, let's talk about pointers. Null references are the source of many runtime
      exceptions, and even stand accused of being
      <a href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/">the worst mistake of computer science</a>.
      </p>
      <p>Zig does not have them.</p>
      <p>
      Instead, you can use a nullable pointer. This secretly compiles down to a normal pointer,
      since we know we can use 0 as the null value for the nullable type. But the compiler
      can check your work and make sure you don't assign null to something that can't be null.
      </p>
      <p>
      Typically the downside of not having null is that it makes the code more verbose to
      write. But, let's compare some equivalent C code and Zig code.
      </p>
      <p>
      Task: call malloc, if the result is null, return null.
      </p>
      <p>C code</p>
      <pre><code class="cpp">// malloc prototype included for reference
void *malloc(size_t size);

struct Foo *do_a_thing(void) {
    char *ptr = malloc(1234);
    if (!ptr) return NULL;
    // ...
}</code></pre>
      <p>Zig code</p>
      <pre><code class="zig">// malloc prototype included for reference
extern fn malloc(size: size_t) ?&amp;u8;

fn doAThing() ?&amp;Foo {
    const ptr = malloc(1234) ?? return null;
    // ...
}</code></pre>
      <p>
        Here, Zig is at least as convenient, if not more, than C. And, the type of "ptr"
        is <code>&u8</code> <em>not</em> <code>?&u8</code>. The <code>??</code> operator
        unwrapped the nullable type and therefore <code>ptr</code> is guaranteed to be non-null everywhere
        it is used in the function.
      </p>
      <p>
        The other form of checking against NULL you might see looks like this:
      </p>
      <pre><code class="cpp">void do_a_thing(struct Foo *foo) {
    // do some stuff

    if (foo) {
        do_something_with_foo(foo);
    }

    // do some stuff
}</code></pre>
      <p>
        In Zig you can accomplish the same thing:
      </p>
      <pre><code class="zig">fn doAThing(nullable_foo: ?&amp;Foo) void {
    // do some stuff

    if (nullable_foo) |foo| {
      doSomethingWithFoo(foo);
    }

    // do some stuff
}</code></pre>
      <p>
      Once again, the notable thing here is that inside the if block,
      <code>foo</code> is no longer a nullable pointer, it is a pointer, which
      cannot be null.
      </p>
      <p>
      One benefit to this is that functions which take pointers as arguments can
      be annotated with the "nonnull" attribute - <code>__attribute__((nonnull))</code> in
      <a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html">GCC</a>.
      The optimizer can sometimes make better decisions knowing that pointer arguments
      cannot be null.
      </p>
      <h2 id="Nullable-Type">Nullable Type</h2>

      <p>A nullable is created by putting <code>?</code> in front of a type. You can use compile-time
      reflection to access the child type of a nullable:</p>
      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

test &quot;nullable type&quot; {
    // Declare a nullable and implicitly cast from null:
    var foo: ?i32 = null;

    // Implicitly cast from child type of a nullable
    foo = 1234;

    // Use compile-time reflection to access the child type of the nullable:
    comptime assert(@typeOf(foo).Child == i32);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 nullable type...OK
</code></pre>

      
      
      <h1 id="Casting">Casting</h1>

      <p>TODO: explain implicit vs explicit casting</p>
      <p>TODO: resolve peer types builtin</p>
      <p>TODO: truncate builtin</p>
      <p>TODO: bitcast builtin</p>
      <p>TODO: int to ptr builtin</p>
      <p>TODO: ptr to int builtin</p>
      <p>TODO: ptrcast builtin</p>
      <p>TODO: explain number literals vs concrete types</p>
      
      <h1 id="void">void</h1>

      <p>TODO: assigning void has no codegen</p>
      <p>TODO: hashmap with void becomes a set</p>
      <p>TODO: difference between c_void and void</p>
      <p>TODO: void is the default return value of functions</p>
      <p>TODO: functions require assigning the return value</p>
      
      <h1 id="this">this</h1>

      <p>TODO: example of this referring to Self struct</p>
      <p>TODO: example of this referring to recursion function</p>
      <p>TODO: example of this referring to basic block for @setRuntimeSafety</p>
      
      <h1 id="comptime">comptime</h1>

      <p>
      Zig places importance on the concept of whether an expression is known at compile-time.
      There are a few different places this concept is used, and these building blocks are used
      to keep the language small, readable, and powerful.
      </p>
      <h2 id="Introducing-the-Compile-Time-Concept">Introducing the Compile-Time Concept</h2>

      <h3 id="Compile-Time-Parameters">Compile-Time Parameters</h3>

      <p>
      Compile-time parameters is how Zig implements generics. It is compile-time duck typing.
      </p>
      <pre><code class="zig">fn max(comptime T: type, a: T, b: T) T {
    return if (a &gt; b) a else b;
}
fn gimmeTheBiggerFloat(a: f32, b: f32) f32 {
    return max(f32, a, b);
}
fn gimmeTheBiggerInteger(a: u64, b: u64) u64 {
    return max(u64, a, b);
}</code></pre>
      <p>
      In Zig, types are first-class citizens. They can be assigned to variables, passed as parameters to functions,
      and returned from functions. However, they can only be used in expressions which are known at <em>compile-time</em>,
      which is why the parameter <code>T</code> in the above snippet must be marked with <code>comptime</code>.
      </p>
      <p>
      A <code>comptime</code> parameter means that:
      </p>
      <ul>
        <li>At the callsite, the value must be known at compile-time, or it is a compile error.</li>
        <li>In the function definition, the value is known at compile-time.</li>
      </ul>
      <p>
      </p>
      <p>
      For example, if we were to introduce another function to the above snippet:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">fn max(comptime T: type, a: T, b: T) T {
    return if (a &gt; b) a else b;
}
test &quot;try to pass a runtime type&quot; {
    foo(false);
}
fn foo(condition: bool) void {
    const result = max(
        if (condition) f32 else u64,
        1234,
        5678);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:9:9: </span><span class="t31_1">error:</span><span class="t0_1"> unable to evaluate constant expression</span>
        if (condition) f32 else u64,
        <span class="t32_1">^</span>
</code></pre>

      <p>
      This is an error because the programmer attempted to pass a value only known at run-time
      to a function which expects a value known at compile-time.
      </p>
      <p>
      Another way to get an error is if we pass a type that violates the type checker when the
      function is analyzed. This is what it means to have <em>compile-time duck typing</em>.
      </p>
      <p>
      For example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">fn max(comptime T: type, a: T, b: T) T {
    return if (a &gt; b) a else b;
}
test &quot;try to compare bools&quot; {
    _ = max(bool, true, false);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:18: </span><span class="t31_1">error:</span><span class="t0_1"> operator not allowed for type 'bool'</span>
    return if (a &gt; b) a else b;
                 <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:12: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    _ = max(bool, true, false);
           <span class="t32_1">^</span>
</code></pre>

      <p>
      On the flip side, inside the function definition with the <code>comptime</code> parameter, the
      value is known at compile-time. This means that we actually could make this work for the bool type
      if we wanted to:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">fn max(comptime T: type, a: T, b: T) T {
    if (T == bool) {
        return a or b;
    } else if (a &gt; b) {
        return a;
    } else {
        return b;
    }
}
test &quot;try to compare bools&quot; {
    @import(&quot;std&quot;).debug.assert(max(bool, false, true) == true);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 try to compare bools...OK
</code></pre>

      <p>
      This works because Zig implicitly inlines <code>if</code> expressions when the condition
      is known at compile-time, and the compiler guarantees that it will skip analysis of
      the branch not taken.
      </p>
      <p>
      This means that the actual function generated for <code>max</code> in this situation looks like
      this:
      </p>
      <pre><code class="zig">fn max(a: bool, b: bool) bool {
    return a or b;
}</code></pre>
      <p>
      All the code that dealt with compile-time known values is eliminated and we are left with only
      the necessary run-time code to accomplish the task.
      </p>
      <p>
      This works the same way for <code>switch</code> expressions - they are implicitly inlined
      when the target expression is compile-time known.
      </p>
      
      <h3 id="Compile-Time-Variables">Compile-Time Variables</h3>

      <p>
      In Zig, the programmer can label variables as <code>comptime</code>. This guarantees to the compiler
      that every load and store of the variable is performed at compile-time. Any violation of this results in a
      compile error.
      </p>
      <p>
      This combined with the fact that we can <code>inline</code> loops allows us to write
      a function which is partially evaluated at compile-time and partially at run-time.
      </p>
      <p>
      For example:
      </p>
      <p class="file">comptime_vars.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

const CmdFn = struct {
    name: []const u8,
    func: fn(i32) i32,
};

const cmd_fns = []CmdFn{
    CmdFn {.name = &quot;one&quot;, .func = one},
    CmdFn {.name = &quot;two&quot;, .func = two},
    CmdFn {.name = &quot;three&quot;, .func = three},
};
fn one(value: i32) i32 { return value + 1; }
fn two(value: i32) i32 { return value + 2; }
fn three(value: i32) i32 { return value + 3; }

fn performFn(comptime prefix_char: u8, start_value: i32) i32 {
    var result: i32 = start_value;
    comptime var i = 0;
    inline while (i &lt; cmd_fns.len) : (i += 1) {
        if (cmd_fns[i].name[0] == prefix_char) {
            result = cmd_fns[i].func(result);
        }
    }
    return result;
}

test &quot;perform fn&quot; {
    assert(performFn('t', 1) == 6);
    assert(performFn('o', 0) == 1);
    assert(performFn('w', 99) == 99);
}</code></pre><pre><code class="shell">$ zig test comptime_vars.zig
Test 1/1 perform fn...OK
</code></pre>

      <p>
      This example is a bit contrived, because the compile-time evaluation component is unnecessary;
      this code would work fine if it was all done at run-time. But it does end up generating
      different code. In this example, the function <code>performFn</code> is generated three different times,
      for the different values of <code>prefix_char</code> provided:
      </p>
      <pre><code class="zig">// From the line:
// assert(performFn('t', 1) == 6);
fn performFn(start_value: i32) i32 {
    var result: i32 = start_value;
    result = two(result);
    result = three(result);
    return result;
}</code></pre>
      <pre><code class="zig">// From the line:
// assert(performFn('o', 0) == 1);
fn performFn(start_value: i32) i32 {
    var result: i32 = start_value;
    result = one(result);
    return result;
}</code></pre>
      <pre><code class="zig">// From the line:
// assert(performFn('w', 99) == 99);
fn performFn(start_value: i32) i32 {
    var result: i32 = start_value;
    return result;
}</code></pre>
      <p>
      Note that this happens even in a debug build; in a release build these generated functions still
      pass through rigorous LLVM optimizations. The important thing to note, however, is not that this
      is a way to write more optimized code, but that it is a way to make sure that what <em>should</em> happen
      at compile-time, <em>does</em> happen at compile-time. This catches more errors and as demonstrated
      later in this article, allows expressiveness that in other languages requires using macros,
      generated code, or a preprocessor to accomplish.
      </p>
      
      <h3 id="Compile-Time-Expressions">Compile-Time Expressions</h3>

      <p>
      In Zig, it matters whether a given expression is known at compile-time or run-time. A programmer can
      use a <code>comptime</code> expression to guarantee that the expression will be evaluated at compile-time.
      If this cannot be accomplished, the compiler will emit an error. For example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">extern fn exit() noreturn;

test &quot;foo&quot; {
    comptime {
        exit();
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:9: </span><span class="t31_1">error:</span><span class="t0_1"> unable to evaluate constant expression</span>
        exit();
        <span class="t32_1">^</span>
</code></pre>

      <p>
      It doesn't make sense that a program could call <code>exit()</code> (or any other external function)
      at compile-time, so this is a compile error. However, a <code>comptime</code> expression does much
      more than sometimes cause a compile error.
      </p>
      <p>
      Within a <code>comptime</code> expression:
      </p>
      <ul>
        <li>All variables are <code>comptime</code> variables.</li>
        <li>All <code>if</code>, <code>while</code>, <code>for</code>, and <code>switch</code>
          expressions are evaluated at compile-time, or emit a compile error if this is not possible.</li>
        <li>All function calls cause the compiler to interpret the function at compile-time, emitting a
          compile error if the function tries to do something that has global run-time side effects.</li>
      </ul>
      <p>
      This means that a programmer can create a function which is called both at compile-time and run-time, with
      no modification to the function required.
      </p>
      <p>
      Let's look at an example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

fn fibonacci(index: u32) u32 {
    if (index &lt; 2) return index;
    return fibonacci(index - 1) + fibonacci(index - 2);
}

test &quot;fibonacci&quot; {
    // test fibonacci at run-time
    assert(fibonacci(7) == 13);

    // test fibonacci at compile-time
    comptime {
        assert(fibonacci(7) == 13);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 fibonacci...OK
</code></pre>

      <p>
      Imagine if we had forgotten the base case of the recursive function and tried to run the tests:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

fn fibonacci(index: u32) u32 {
    //if (index &lt; 2) return index;
    return fibonacci(index - 1) + fibonacci(index - 2);
}

test &quot;fibonacci&quot; {
    comptime {
        assert(fibonacci(7) == 13);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:28: </span><span class="t31_1">error:</span><span class="t0_1"> operation caused overflow</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                           <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:10:25: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
        assert(fibonacci(7) == 13);
                        <span class="t32_1">^</span>
</code></pre>

      <p>
      The compiler produces an error which is a stack trace from trying to evaluate the
      function at compile-time.
      </p>
      <p>
      Luckily, we used an unsigned integer, and so when we tried to subtract 1 from 0, it triggered
      undefined behavior, which is always a compile error if the compiler knows it happened.
      But what would have happened if we used a signed integer?
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

fn fibonacci(index: i32) i32 {
    //if (index &lt; 2) return index;
    return fibonacci(index - 1) + fibonacci(index - 2);
}

test &quot;fibonacci&quot; {
    comptime {
        assert(fibonacci(7) == 13);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t31_1">error:</span><span class="t0_1"> evaluation exceeded 1000 backwards branches</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
</code></pre>

      <p>
      The compiler noticed that evaluating this function at compile-time took a long time,
      and thus emitted a compile error and gave up. If the programmer wants to increase
      the budget for compile-time computation, they can use a built-in function called
      <a href="#setEvalBranchQuota">@setEvalBranchQuota</a> to change the default number 1000 to something else.
      </p>
      <p>
      What if we fix the base case, but put the wrong value in the <code>assert</code> line?
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

fn fibonacci(index: i32) i32 {
    if (index &lt; 2) return index;
    return fibonacci(index - 1) + fibonacci(index - 2);
}

test &quot;fibonacci&quot; {
    comptime {
        assert(fibonacci(7) == 99999);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/build/lib/zig/std/debug/index.zig:84:13: </span><span class="t31_1">error:</span><span class="t0_1"> encountered @panic at compile-time</span>
            @panic(&quot;assertion failure&quot;);
            <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:10:15: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
        assert(fibonacci(7) == 99999);
              <span class="t32_1">^</span>
</code></pre>

      <p>
      What happened is Zig started interpreting the <code>assert</code> function with the
      parameter <code>ok</code> set to <code>false</code>. When the interpreter hit
      <code>unreachable</code> it emitted a compile error, because reaching unreachable
      code is undefined behavior, and undefined behavior causes a compile error if it is detected
      at compile-time.
      </p>

      <p>
      In the global scope (outside of any function), all expressions are implicitly
      <code>comptime</code> expressions. This means that we can use functions to
      initialize complex static data. For example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const first_25_primes = firstNPrimes(25);
const sum_of_first_25_primes = sum(first_25_primes);

fn firstNPrimes(comptime n: usize) [n]i32 {
    var prime_list: [n]i32 = undefined;
    var next_index: usize = 0;
    var test_number: i32 = 2;
    while (next_index &lt; prime_list.len) : (test_number += 1) {
        var test_prime_index: usize = 0;
        var is_prime = true;
        while (test_prime_index &lt; next_index) : (test_prime_index += 1) {
            if (test_number % prime_list[test_prime_index] == 0) {
                is_prime = false;
                break;
            }
        }
        if (is_prime) {
            prime_list[next_index] = test_number;
            next_index += 1;
        }
    }
    return prime_list;
}

fn sum(numbers: []const i32) i32 {
    var result: i32 = 0;
    for (numbers) |x| {
        result += x;
    }
    return result;
}

test &quot;variable values&quot; {
    @import(&quot;std&quot;).debug.assert(sum_of_first_25_primes == 1060);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 variable values...OK
</code></pre>

      <p>
      When we compile this program, Zig generates the constants
      with the answer pre-computed. Here are the lines from the generated LLVM IR:
      </p>
      <pre><code class="llvm">@0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97]
@1 = internal unnamed_addr constant i32 1060</code></pre>
      <p>
      Note that we did not have to do anything special with the syntax of these functions. For example,
      we could call the <code>sum</code> function as is with a slice of numbers whose length and values were
      only known at run-time.
      </p>
      
      
      <h2 id="Generic-Data-Structures">Generic Data Structures</h2>

      <p>
      Zig uses these capabilities to implement generic data structures without introducing any
      special-case syntax. If you followed along so far, you may already know how to create a
      generic data structure.
      </p>
      <p>
      Here is an example of a generic <code>List</code> data structure, that we will instantiate with
      the type <code>i32</code>. In Zig we refer to the type as <code>List(i32)</code>.
      </p>
      <pre><code class="zig">fn List(comptime T: type) type {
    return struct {
        items: []T,
        len: usize,
    };
}</code></pre>
      <p>
      That's it. It's a function that returns an anonymous <code>struct</code>. For the purposes of error messages
      and debugging, Zig infers the name <code>"List(i32)"</code> from the function name and parameters invoked when creating
      the anonymous struct.
      </p>
      <p>
      To keep the language small and uniform, all aggregate types in Zig are anonymous. To give a type
      a name, we assign it to a constant:
      </p>
      <pre><code class="zig">const Node = struct {
    next: &amp;Node,
    name: []u8,
};</code></pre>
      <p>
      This works because all top level declarations are order-independent, and as long as there isn't
      an actual infinite regression, values can refer to themselves, directly or indirectly. In this case,
      <code>Node</code> refers to itself as a pointer, which is not actually an infinite regression, so
      it works fine.
      </p>
      
      <h2 id="Case-Study-printf-in-Zig">Case Study: printf in Zig</h2>

      <p>
      Putting all of this together, let's see how <code>printf</code> works in Zig.
      </p>
      <p class="file">printf.zig</p><pre><code class="zig">const warn = @import(&quot;std&quot;).debug.warn;

const a_number: i32 = 1234;
const a_string = &quot;foobar&quot;;

pub fn main() void {
    warn(&quot;here is a string: '{}' here is a number: {}\n&quot;, a_string, a_number);
}</code></pre><pre><code class="shell">$ zig build-exe printf.zig
$ ./printf
here is a string: 'foobar' here is a number: 1234
</code></pre>


      <p>
      Let's crack open the implementation of this and see how it works:
      </p>

      <pre><code class="zig">/// Calls print and then flushes the buffer.
pub fn printf(self: &amp;OutStream, comptime format: []const u8, args: ...) error!void {
    const State = enum {
        Start,
        OpenBrace,
        CloseBrace,
    };

    comptime var start_index: usize = 0;
    comptime var state = State.Start;
    comptime var next_arg: usize = 0;

    inline for (format) |c, i| {
        switch (state) {
            State.Start =&gt; switch (c) {
                '{' =&gt; {
                    if (start_index &lt; i) try self.write(format[start_index..i]);
                    state = State.OpenBrace;
                },
                '}' =&gt; {
                    if (start_index &lt; i) try self.write(format[start_index..i]);
                    state = State.CloseBrace;
                },
                else =&gt; {},
            },
            State.OpenBrace =&gt; switch (c) {
                '{' =&gt; {
                    state = State.Start;
                    start_index = i;
                },
                '}' =&gt; {
                    try self.printValue(args[next_arg]);
                    next_arg += 1;
                    state = State.Start;
                    start_index = i + 1;
                },
                else =&gt; @compileError(&quot;Unknown format character: &quot; ++ c),
            },
            State.CloseBrace =&gt; switch (c) {
                '}' =&gt; {
                    state = State.Start;
                    start_index = i;
                },
                else =&gt; @compileError(&quot;Single '}' encountered in format string&quot;),
            },
        }
    }
    comptime {
        if (args.len != next_arg) {
            @compileError(&quot;Unused arguments&quot;);
        }
        if (state != State.Start) {
            @compileError(&quot;Incomplete format string: &quot; ++ format);
        }
    }
    if (start_index &lt; format.len) {
        try self.write(format[start_index..format.len]);
    }
    try self.flush();
}</code></pre>
      <p>
      This is a proof of concept implementation; the actual function in the standard library has more
      formatting capabilities.
      </p>
      <p>
      Note that this is not hard-coded into the Zig compiler; this is userland code in the standard library.
      </p>
      <p>
      When this function is analyzed from our example code above, Zig partially evaluates the function
      and emits a function that actually looks like this:
      </p>
      <pre><code class="zig">pub fn printf(self: &amp;OutStream, arg0: i32, arg1: []const u8) !void {
    try self.write(&quot;here is a string: '&quot;);
    try self.printValue(arg0);
    try self.write(&quot;' here is a number: &quot;);
    try self.printValue(arg1);
    try self.write(&quot;\n&quot;);
    try self.flush();
}</code></pre>
      <p>
      <code>printValue</code> is a function that takes a parameter of any type, and does different things depending
      on the type:
      </p>
      <pre><code class="zig">pub fn printValue(self: &amp;OutStream, value: var) !void {
    const T = @typeOf(value);
    if (@isInteger(T)) {
        return self.printInt(T, value);
    } else if (@isFloat(T)) {
        return self.printFloat(T, value);
    } else if (@canImplicitCast([]const u8, value)) {
        const casted_value = ([]const u8)(value);
        return self.write(casted_value);
    } else {
        @compileError(&quot;Unable to print type '&quot; ++ @typeName(T) ++ &quot;'&quot;);
    }
}</code></pre>
      <p>
      And now, what happens if we give too many arguments to <code>printf</code>?
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const warn = @import(&quot;std&quot;).debug.warn;

const a_number: i32 = 1234;
const a_string = &quot;foobar&quot;;

test &quot;printf too many arguments&quot; {
    warn(&quot;here is a string: '{}' here is a number: {}\n&quot;,
        a_string, a_number, a_number);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/build/lib/zig/std/fmt/index.zig:183:13: </span><span class="t31_1">error:</span><span class="t0_1"> Unused arguments</span>
            @compileError(&quot;Unused arguments&quot;);
            <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/build/lib/zig/std/io.zig:236:34: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
            return std.fmt.format(self, Error, self.writeFn, format, args);
                                 <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/build/lib/zig/std/debug/index.zig:22:17: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    stderr.print(fmt, args) catch return;
                <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:7:9: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    warn(&quot;here is a string: '{}' here is a number: {}\n&quot;,
        <span class="t32_1">^</span>
</code></pre>

      <p>
      Zig gives programmers the tools needed to protect themselves against their own mistakes.
      </p>
      <p>
      Zig doesn't care whether the format argument is a string literal,
      only that it is a compile-time known value that is implicitly castable to a <code>[]const u8</code>:
      </p>
      <p class="file">printf.zig</p><pre><code class="zig">const warn = @import(&quot;std&quot;).debug.warn;

const a_number: i32 = 1234;
const a_string = &quot;foobar&quot;;
const fmt = &quot;here is a string: '{}' here is a number: {}\n&quot;;

pub fn main() void {
    warn(fmt, a_string, a_number);
}</code></pre><pre><code class="shell">$ zig build-exe printf.zig
$ ./printf
here is a string: 'foobar' here is a number: 1234
</code></pre>

      <p>
      This works fine.
      </p>
      <p>
      Zig does not special case string formatting in the compiler and instead exposes enough power to accomplish this
      task in userland. It does so without introducing another language on top of Zig, such as
      a macro language or a preprocessor language. It's Zig all the way down.
      </p>
      <p>TODO: suggestion to not use inline unless necessary</p>
      
      
      <h1 id="inline">inline</h1>

      <p>TODO: inline while</p>
      <p>TODO: inline for</p>
      <p>TODO: suggestion to not use inline unless necessary</p>
      
      <h1 id="Assembly">Assembly</h1>

      <p>TODO: example of inline assembly</p>
      <p>TODO: example of module level assembly</p>
      <p>TODO: example of using inline assembly return value</p>
      <p>TODO: example of using inline assembly assigning values to variables</p>
      
      <h1 id="Atomics">Atomics</h1>

      <p>TODO: @fence()</p>
      <p>TODO: @atomic rmw</p>
      <p>TODO: builtin atomic memory ordering enum</p>
      
      <h1 id="Builtin-Functions">Builtin Functions</h1>

      <p>
      Builtin functions are provided by the compiler and are prefixed with <code>@</code>.
      The <code>comptime</code> keyword on a parameter means that the parameter must be known
      at compile time.
      </p>
      <h2 id="addWithOverflow">@addWithOverflow</h2>

      <pre><code class="zig">@addWithOverflow(comptime T: type, a: T, b: T, result: &T) -&gt; bool</code></pre>
      <p>
      Performs <code>*result = a + b</code>. If overflow or underflow occurs,
      stores the overflowed bits in <code>result</code> and returns <code>true</code>.
      If no overflow or underflow occurs, returns <code>false</code>.
      </p>
      
      <h2 id="ArgType">@ArgType</h2>

      <p>TODO</p>
      
      <h2 id="atomicRmw">@atomicRmw</h2>

      <pre><code class="zig">@atomicRmw(comptime T: type, ptr: &amp;T, comptime op: builtin.AtomicRmwOp, operand: T, comptime ordering: builtin.AtomicOrder) -&gt; T</code></pre>
      <p>
      This builtin function atomically modifies memory and then returns the previous value.
      </p>
      <p>
      <code>T</code> must be a pointer type, a <code>bool</code>,
      or an integer whose bit count meets these requirements:
      </p>
      <ul>
          <li>At least 8</li>
          <li>At most the same as usize</li>
          <li>Power of 2</li>
      </ul>
      <p>
      TODO right now bool is not accepted. Also I think we could make non powers of 2 work fine, maybe
      we can remove this restriction
      </p>
      
      <h2 id="bitCast">@bitCast</h2>

      <pre><code class="zig">@bitCast(comptime DestType: type, value: var) -&gt; DestType</code></pre>
      <p>
      Converts a value of one type to another type.
      </p>
      <p>
      Asserts that <code>@sizeOf(@typeOf(value)) == @sizeOf(DestType)</code>.
      </p>
      <p>
      Asserts that <code>@typeId(DestType) != @import("builtin").TypeId.Pointer</code>. Use <code>@ptrCast</code> or <code>@intToPtr</code> if you need this.
      </p>
      <p>
      Can be used for these things for example:
      </p>
      <ul>
        <li>Convert <code>f32</code> to <code>u32</code> bits</li>
        <li>Convert <code>i32</code> to <code>u32</code> preserving twos complement</li>
      </ul>
      <p>
      Works at compile-time if <code>value</code> is known at compile time. It's a compile error to bitcast a struct to a scalar type of the same size since structs have undefined layout. However if the struct is packed then it works.
      </p>
      
      <h2 id="breakpoint">@breakpoint</h2>

      <pre><code class="zig">@breakpoint()</code></pre>
      <p>
      This function inserts a platform-specific debug trap instruction which causes
      debuggers to break there.
      </p>
      <p>
      This function is only valid within function scope.
      </p>

      
      <h2 id="alignCast">@alignCast</h2>

      <pre><code class="zig">@alignCast(comptime alignment: u29, ptr: var) -&gt; var</code></pre>
      <p>
      <code>ptr</code> can be <code>&amp;T</code>, <code>fn()</code>, <code>?&amp;T</code>,
      <code>?fn()</code>, or <code>[]T</code>. It returns the same type as <code>ptr</code>
      except with the alignment adjusted to the new value.
      </p>
      <p>A <a href="#Incorrect-Pointer-Alignment">pointer alignment safety check</a> is added
      to the generated code to make sure the pointer is aligned as promised.</p>

      
      <h2 id="alignOf">@alignOf</h2>

      <pre><code class="zig">@alignOf(comptime T: type) -&gt; (number literal)</code></pre>
      <p>
      This function returns the number of bytes that this type should be aligned to
      for the current target to match the C ABI. When the child type of a pointer has
      this alignment, the alignment can be omitted from the type.
      </p>
      <pre><code class="zig">const assert = @import("std").debug.assert;
comptime {
    assert(&u32 == &align(@alignOf(u32)) u32);
}</code></pre>
      <p>
      The result is a target-specific compile time constant. It is guaranteed to be
      less than or equal to <a href="#sizeOf">@sizeOf(T)</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Alignment">Alignment</a></li>
</ul>

      
      <h2 id="cDefine">@cDefine</h2>

      <pre><code class="zig">@cDefine(comptime name: []u8, value)</code></pre>
      <p>
      This function can only occur inside <code>@cImport</code>.
      </p>
      <p>
      This appends <code>#define $name $value</code> to the <code>@cImport</code>
      temporary buffer.
      </p>
      <p>
      To define without a value, like this:
      </p>
      <pre><code class="c">#define _GNU_SOURCE</code></pre>
      <p>
      Use the void value, like this:
      </p>
      <pre><code class="zig">@cDefine("_GNU_SOURCE", {})</code></pre>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cInclude">@cInclude</a></li>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cUndef">@cUndef</a></li>
<li><a href="#void">void</a></li>
</ul>

      
      <h2 id="cImport">@cImport</h2>

      <pre><code class="zig">@cImport(expression) -&gt; (namespace)</code></pre>
      <p>
      This function parses C code and imports the functions, types, variables, and
      compatible macro definitions into the result namespace.
      </p>
      <p>
      <code>expression</code> is interpreted at compile time. The builtin functions
      <code>@cInclude</code>, <code>@cDefine</code>, and <code>@cUndef</code> work
      within this expression, appending to a temporary buffer which is then parsed as C code.
      </p>
      <p>
      Usually you should only have one <code>@cImport</code> in your entire application, because it saves the compiler
      from invoking clang multiple times, and prevents inline functions from being duplicated.
      </p>
      <p>
      Reasons for having multiple <code>@cImport</code> expressions would be:
      </p>
      <ul>
        <li>To avoid a symbol collision, for example if foo.h and bar.h both <code>#define CONNECTION_COUNT</code></li>
        <li>To analyze the C code with different preprocessor defines</li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cInclude">@cInclude</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cUndef">@cUndef</a></li>
</ul>

      
      <h2 id="cInclude">@cInclude</h2>

      <pre><code class="zig">@cInclude(comptime path: []u8)</code></pre>
      <p>
      This function can only occur inside <code>@cImport</code>.
      </p>
      <p>
      This appends <code>#include <$path>\n</code> to the <code>c_import</code>
      temporary buffer.
      </p>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cUndef">@cUndef</a></li>
</ul>

      
      <h2 id="cUndef">@cUndef</h2>

      <pre><code class="zig">@cUndef(comptime name: []u8)</code></pre>
      <p>
      This function can only occur inside <code>@cImport</code>.
      </p>
      <p>
      This appends <code>#undef $name</code> to the <code>@cImport</code>
      temporary buffer.
      </p>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cInclude">@cInclude</a></li>
</ul>

      
      <h2 id="canImplicitCast">@canImplicitCast</h2>

      <pre><code class="zig">@canImplicitCast(comptime T: type, value) -&gt; bool</code></pre>
      <p>
      Returns whether a value can be implicitly casted to a given type.
      </p>
      
      <h2 id="clz">@clz</h2>

      <pre><code class="zig">@clz(x: T) -&gt; U</code></pre>
      <p>
      This function counts the number of leading zeroes in <code>x</code> which is an integer
      type <code>T</code>.
      </p>
      <p>
      The return type <code>U</code> is an unsigned integer with the minimum number
      of bits that can represent the value <code>T.bit_count</code>.
      </p>
      <p>
      If <code>x</code> is zero, <code>@clz</code> returns <code>T.bit_count</code>.
      </p>

      
      <h2 id="cmpxchg">@cmpxchg</h2>

      <pre><code class="zig">@cmpxchg(ptr: &T, cmp: T, new: T, success_order: AtomicOrder, fail_order: AtomicOrder) -&gt; bool</code></pre>
      <p>
      This function performs an atomic compare exchange operation.
      </p>
      <p>
      <code>AtomicOrder</code> can be found with <code>@import("builtin").AtomicOrder</code>.
      </p>
      <p><code>@typeOf(ptr).alignment</code> must be <code>&gt;= @sizeOf(T).</code></p>
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
</ul>

      
      <h2 id="compileError">@compileError</h2>

      <pre><code class="zig">@compileError(comptime msg: []u8)</code></pre>
      <p>
      This function, when semantically analyzed, causes a compile error with the
      message <code>msg</code>.
      </p>
      <p>
      There are several ways that code avoids being semantically checked, such as
      using <code>if</code> or <code>switch</code> with compile time constants,
      and <code>comptime</code> functions.
      </p>
      
      <h2 id="compileLog">@compileLog</h2>

      <pre><code class="zig">@compileLog(args: ...)</code></pre>
      <p>
      This function prints the arguments passed to it at compile-time.
      </p>
      <p>
      To prevent accidentally leaving compile log statements in a codebase,
      a compilation error is added to the build, pointing to the compile
      log statement. This error prevents code from being generated, but
      does not otherwise interfere with analysis.
      </p>
      <p>
      This function can be used to do "printf debugging" on
      compile-time executing code.
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const warn = @import(&quot;std&quot;).debug.warn;

const num1 = blk: {
    var val1: i32 = 99;
    @compileLog(&quot;comptime val1 = &quot;, val1); 
    val1 = val1 + 1;
    break :blk val1;
};

test &quot;main&quot; {
    @compileLog(&quot;comptime in main&quot;); 

    warn(&quot;Runtime in main, num1 = {}.\n&quot;, num1);
}</code></pre><pre><code class="shell">$ zig test test.zig
| &quot;comptime in main&quot;
| &quot;comptime val1 = &quot;, 99
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:11:5: </span><span class="t31_1">error:</span><span class="t0_1"> found compile log statement</span>
    @compileLog(&quot;comptime in main&quot;); 
    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:5: </span><span class="t31_1">error:</span><span class="t0_1"> found compile log statement</span>
    @compileLog(&quot;comptime val1 = &quot;, val1); 
    <span class="t32_1">^</span>
</code></pre>

      </p>
      <p>
      will ouput:
      </p>
      <p>
      If all <code>@compileLog</code> calls are removed or 
      not encountered by analysis, the
      program compiles successfully and the generated executable prints:
      </p>  
      <p class="file">test.zig</p><pre><code class="zig">const warn = @import(&quot;std&quot;).debug.warn;

const num1 = blk: {
    var val1: i32 = 99;
    val1 = val1 + 1;
    break :blk val1;
};

test &quot;main&quot; {
    warn(&quot;Runtime in main, num1 = {}.\n&quot;, num1);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 main...Runtime in main, num1 = 100.
OK
</code></pre>

      
      <h2 id="ctz">@ctz</h2>

      <pre><code class="zig">@ctz(x: T) -&gt; U</code></pre>
      <p>
      This function counts the number of trailing zeroes in <code>x</code> which is an integer
      type <code>T</code>.
      </p>
      <p>
      The return type <code>U</code> is an unsigned integer with the minimum number
      of bits that can represent the value <code>T.bit_count</code>.
      </p>
      <p>
      If <code>x</code> is zero, <code>@ctz</code> returns <code>T.bit_count</code>.
      </p>
      
      <h2 id="divExact">@divExact</h2>

      <pre><code class="zig">@divExact(numerator: T, denominator: T) -&gt; T</code></pre>
      <p>
      Exact division. Caller guarantees <code>denominator != 0</code> and
      <code>@divTrunc(numerator, denominator) * denominator == numerator</code>.
      </p>
      <ul>
        <li><code>@divExact(6, 3) == 2</code></li>
        <li><code>@divExact(a, b) * b == a</code></li>
      </ul>
      <p>For a function that returns a possible error code, use <code>@import("std").math.divExact</code>.</p>
      <p>See also:</p><ul>
<li><a href="#divTrunc">@divTrunc</a></li>
<li><a href="#divFloor">@divFloor</a></li>
</ul>

      
      <h2 id="divFloor">@divFloor</h2>

      <pre><code class="zig">@divFloor(numerator: T, denominator: T) -&gt; T</code></pre>
      <p>
      Floored division. Rounds toward negative infinity. For unsigned integers it is
      the same as <code>numerator / denominator</code>. Caller guarantees <code>denominator != 0</code> and
      <code>!(@typeId(T) == builtin.TypeId.Int and T.is_signed and numerator == @minValue(T) and denominator == -1)</code>.
      </p>
      <ul>
        <li><code>@divFloor(-5, 3) == -2</code></li>
        <li><code>@divFloor(a, b) + @mod(a, b) == a</code></li>
      </ul>
      <p>For a function that returns a possible error code, use <code>@import("std").math.divFloor</code>.</p>
      <p>See also:</p><ul>
<li><a href="#divTrunc">@divTrunc</a></li>
<li><a href="#divExact">@divExact</a></li>
</ul>

      
      <h2 id="divTrunc">@divTrunc</h2>

      <pre><code class="zig">@divTrunc(numerator: T, denominator: T) -&gt; T</code></pre>
      <p>
      Truncated division. Rounds toward zero. For unsigned integers it is
      the same as <code>numerator / denominator</code>. Caller guarantees <code>denominator != 0</code> and
      <code>!(@typeId(T) == builtin.TypeId.Int and T.is_signed and numerator == @minValue(T) and denominator == -1)</code>.
      </p>
      <ul>
        <li><code>@divTrunc(-5, 3) == -1</code></li>
        <li><code>@divTrunc(a, b) + @rem(a, b) == a</code></li>
      </ul>
      <p>For a function that returns a possible error code, use <code>@import("std").math.divTrunc</code>.</p>
      <p>See also:</p><ul>
<li><a href="#divFloor">@divFloor</a></li>
<li><a href="#divExact">@divExact</a></li>
</ul>

      
      <h2 id="embedFile">@embedFile</h2>

      <pre><code class="zig">@embedFile(comptime path: []const u8) -&gt; [X]u8</code></pre>
      <p>
      This function returns a compile time constant fixed-size array with length
      equal to the byte count of the file given by <code>path</code>. The contents of the array
      are the contents of the file.
      </p>
      <p>
      <code>path</code> is absolute or relative to the current file, just like <code>@import</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#import">@import</a></li>
</ul>

      
      <h2 id="export">@export</h2>

      <pre><code class="zig">@export(comptime name: []const u8, target: var, linkage: builtin.GlobalLinkage) -&gt; []const u8</code></pre>
      <p>
      Creates a symbol in the output object file.
      </p>
      
      <h2 id="tagName">@tagName</h2>

      <pre><code class="zig">@tagName(value: var) -&gt; []const u8</code></pre>
      <p>
      Converts an enum value or union value to a slice of bytes representing the name.
      </p>
      
      <h2 id="TagType">@TagType</h2>

      <pre><code class="zig">@TagType(T: type) -&gt; type</code></pre>
      <p>
      For an enum, returns the integer type that is used to store the enumeration value.
      </p>
      <p>
      For a union, returns the enum type that is used to store the tag value.
      </p>
      
      <h2 id="errorName">@errorName</h2>

      <pre><code class="zig">@errorName(err: error) -&gt; []u8</code></pre>
      <p>
      This function returns the string representation of an error. If an error
      declaration is:
      </p>
      <pre><code class="zig">error OutOfMem</code></pre>
      <p>
      Then the string representation is <code>"OutOfMem"</code>.
      </p>
      <p>
      If there are no calls to <code>@errorName</code> in an entire application,
      or all calls have a compile-time known value for <code>err</code>, then no
      error name table will be generated.
      </p>
      
      <h2 id="errorReturnTrace">@errorReturnTrace</h2>

      <pre><code class="zig">@errorReturnTrace() -&gt; ?&builtin.StackTrace</code></pre>
      <p>
      If the binary is built with error return tracing, and this function is invoked in a
      function that calls a function with an error or error union return type, returns a
      stack trace object. Otherwise returns `null`.
      </p>
      
      <h2 id="fence">@fence</h2>

      <pre><code class="zig">@fence(order: AtomicOrder)</code></pre>
      <p>
      The <code>fence</code> function is used to introduce happens-before edges between operations.
      </p>
      <p>
      <code>AtomicOrder</code> can be found with <code>@import("builtin").AtomicOrder</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
</ul>

      
      <h2 id="fieldParentPtr">@fieldParentPtr</h2>

      <pre><code class="zig">@fieldParentPtr(comptime ParentType: type, comptime field_name: []const u8,
    field_ptr: &T) -&gt; &ParentType</code></pre>
      <p>
      Given a pointer to a field, returns the base pointer of a struct.
      </p>
      
      <h2 id="frameAddress">@frameAddress</h2>

      <pre><code class="zig">@frameAddress()</code></pre>
      <p>
      This function returns the base pointer of the current stack frame.
      </p>
      <p>
      The implications of this are target specific and not consistent across all
      platforms. The frame address may not be available in release mode due to
      aggressive optimizations.
      </p>
      <p>
      This function is only valid within function scope.
      </p>
      
      <h2 id="import">@import</h2>

      <pre><code class="zig">@import(comptime path: []u8) -&gt; (namespace)</code></pre>
      <p>
      This function finds a zig file corresponding to <code>path</code> and imports all the
      public top level declarations into the resulting namespace.
      </p>
      <p>
      <code>path</code> can be a relative or absolute path, or it can be the name of a package.
      If it is a relative path, it is relative to the file that contains the <code>@import</code>
      function call.
      </p>
      <p>
      The following packages are always available:
      </p>
      <ul>
        <li><code>@import("std")</code> - Zig Standard Library</li>
        <li><code>@import("builtin")</code> - Compiler-provided types and variables</li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
<li><a href="#embedFile">@embedFile</a></li>
</ul>

      
      <h2 id="inlineCall">@inlineCall</h2>

      <pre><code class="zig">@inlineCall(function: X, args: ...) -&gt; Y</code></pre>
      <p>
      This calls a function, in the same way that invoking an expression with parentheses does:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

test &quot;inline function call&quot; {
    assert(@inlineCall(add, 3, 9) == 12);
}

fn add(a: i32, b: i32) i32 { return a + b; }</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 inline function call...OK
</code></pre>

      <p>
      Unlike a normal function call, however, <code>@inlineCall</code> guarantees that the call
      will be inlined. If the call cannot be inlined, a compile error is emitted.
      </p>
      <p>See also:</p><ul>
<li><a href="#noInlineCall">@noInlineCall</a></li>
</ul>

      
      <h2 id="intToPtr">@intToPtr</h2>

      <pre><code class="zig">@intToPtr(comptime DestType: type, int: usize) -&gt; DestType</code></pre>
      <p>
      Converts an integer to a pointer. To convert the other way, use <a href="#ptrToInt">@ptrToInt</a>.
      </p>
      
      <h2 id="IntType">@IntType</h2>

      <pre><code class="zig">@IntType(comptime is_signed: bool, comptime bit_count: u8) -&gt; type</code></pre>
      <p>
      This function returns an integer type with the given signness and bit count.
      </p>
      
      <h2 id="maxValue">@maxValue</h2>

      <pre><code class="zig">@maxValue(comptime T: type) -&gt; (number literal)</code></pre>
      <p>
      This function returns the maximum value of the integer type <code>T</code>.
      </p>
      <p>
      The result is a compile time constant.
      </p>
      
      <h2 id="memberCount">@memberCount</h2>

      <pre><code class="zig">@memberCount(comptime T: type) -&gt; (number literal)</code></pre>
      <p>
      This function returns the number of members in a struct, enum, or union type.
      </p>
      <p>
      The result is a compile time constant.
      </p>
      <p>
      It does not include functions, variables, or constants.
      </p>
      
      <h2 id="memberName">@memberName</h2>

      <pre><code class="zig">@memberName(comptime T: type, comptime index: usize) -&gt; [N]u8</code></pre>
      <p>Returns the field name of a struct, union, or enum.</p>
      <p>
      The result is a compile time constant.
      </p>
      <p>
      It does not include functions, variables, or constants.
      </p>
      
      <h2 id="memberType">@memberType</h2>

      <pre><code class="zig">@memberType(comptime T: type, comptime index: usize) -&gt; type</code></pre>
      <p>Returns the field type of a struct or union.</p>
      
      <h2 id="memcpy">@memcpy</h2>

      <pre><code class="zig">@memcpy(noalias dest: &u8, noalias source: &const u8, byte_count: usize)</code></pre>
      <p>
      This function copies bytes from one region of memory to another. <code>dest</code> and
      <code>source</code> are both pointers and must not overlap.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms. Most code
      should not use this function, instead using something like this:
      </p>
      <pre><code class="zig">for (source[0...byte_count]) |b, i| dest[i] = b;</code></pre>
      <p>
      The optimizer is intelligent enough to turn the above snippet into a memcpy.
      </p>
      <p>There is also a standard library function for this:</p>
      <pre><code class="zig">const mem = @import("std").mem;
mem.copy(u8, dest[0...byte_count], source[0...byte_count]);</code></pre>
      
      <h2 id="memset">@memset</h2>

      <pre><code class="zig">@memset(dest: &u8, c: u8, byte_count: usize)</code></pre>
      <p>
      This function sets a region of memory to <code>c</code>. <code>dest</code> is a pointer.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms. Most
      code should not use this function, instead using something like this:
      </p>
      <pre><code class="zig">for (dest[0...byte_count]) |*b| *b = c;</code></pre>
      <p>
      The optimizer is intelligent enough to turn the above snippet into a memset.
      </p>
      <p>There is also a standard library function for this:</p>
      <pre><code>const mem = @import("std").mem;
mem.set(u8, dest, c);</code></pre>
      
      <h2 id="minValue">@minValue</h2>

      <pre><code class="zig">@minValue(comptime T: type) -&gt; (number literal)</code></pre>
      <p>
      This function returns the minimum value of the integer type T.
      </p>
      <p>
      The result is a compile time constant.
      </p>
      
      <h2 id="mod">@mod</h2>

      <pre><code class="zig">@mod(numerator: T, denominator: T) -&gt; T</code></pre>
      <p>
      Modulus division. For unsigned integers this is the same as
      <code>numerator % denominator</code>. Caller guarantees <code>denominator &gt; 0</code>.
      </p>
      <ul>
        <li><code>@mod(-5, 3) == 1</code></li>
        <li><code>@divFloor(a, b) + @mod(a, b) == a</code></li>
      </ul>
      <p>For a function that returns an error code, see <code>@import("std").math.mod</code>.</p>
      <p>See also:</p><ul>
<li><a href="#rem">@rem</a></li>
</ul>

      
      <h2 id="mulWithOverflow">@mulWithOverflow</h2>

      <pre><code class="zig">@mulWithOverflow(comptime T: type, a: T, b: T, result: &T) -&gt; bool</code></pre>
      <p>
      Performs <code>*result = a * b</code>. If overflow or underflow occurs,
      stores the overflowed bits in <code>result</code> and returns <code>true</code>.
      If no overflow or underflow occurs, returns <code>false</code>.
      </p>
      
      <h2 id="noInlineCall">@noInlineCall</h2>

      <pre><code class="zig">@noInlineCall(function: var, args: ...) -&gt; var</code></pre>
      <p>
      This calls a function, in the same way that invoking an expression with parentheses does:
      </p>
      <pre><code class="zig">const assert = @import("std").debug.assert;
test "noinline function call" {
    assert(@noInlineCall(add, 3, 9) == 12);
}

fn add(a: i32, b: i32) -&gt; i32 { a + b }</code></pre>
      <p>
      Unlike a normal function call, however, <code>@noInlineCall</code> guarantees that the call
      will not be inlined. If the call must be inlined, a compile error is emitted.
      </p>
      <p>See also:</p><ul>
<li><a href="#inlineCall">@inlineCall</a></li>
</ul>

      
      <h2 id="offsetOf">@offsetOf</h2>

      <pre><code class="zig">@offsetOf(comptime T: type, comptime field_name: [] const u8) -&gt; (number literal)</code></pre>
      <p>
      This function returns the byte offset of a field relative to its containing struct.
      </p>
      
      <h2 id="OpaqueType">@OpaqueType</h2>

      <pre><code class="zig">@OpaqueType() -&gt; type</code></pre>
      <p>
      Creates a new type with an unknown size and alignment.
      </p>
      <p>
      This is typically used for type safety when interacting with C code that does not expose struct details.
      Example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const Derp = @OpaqueType();
const Wat = @OpaqueType();

extern fn bar(d: &amp;Derp) void;
export fn foo(w: &amp;Wat) void {
    bar(w);
}

test &quot;call foo&quot; {
    foo(undefined);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:6:9: </span><span class="t31_1">error:</span><span class="t0_1"> expected type '&amp;Derp', found '&amp;Wat'</span>
    bar(w);
        <span class="t32_1">^</span>
</code></pre>

      
      <h2 id="panic">@panic</h2>

      <pre><code class="zig">@panic(message: []const u8) -&gt; noreturn</code></pre>
      <p>
      Invokes the panic handler function. By default the panic handler function
      calls the public <code>panic</code> function exposed in the root source file, or
      if there is not one specified, invokes the one provided in <code>std/special/panic.zig</code>.
      </p>
      <p>Generally it is better to use <code>@import("std").debug.panic</code>.
      However, <code>@panic</code> can be useful for 2 scenarios:
      </p>
      <ul>
        <li>From library code, calling the programmer's panic function if they exposed one in the root source file.</li>
        <li>When mixing C and Zig code, calling the canonical panic implementation across multiple .o files.</li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Root-Source-File">Root Source File</a></li>
</ul>

      
      <h2 id="ptrCast">@ptrCast</h2>

      <pre><code class="zig">@ptrCast(comptime DestType: type, value: var) -&gt; DestType</code></pre>
      <p>
      Converts a pointer of one type to a pointer of another type.
      </p>
      
      <h2 id="ptrToInt">@ptrToInt</h2>

      <pre><code class="zig">@ptrToInt(value: var) -&gt; usize</code></pre>
      <p>
      Converts <code>value</code> to a <code>usize</code> which is the address of the pointer. <code>value</code> can be one of these types:
      </p>
      <ul>
        <li><code>&amp;T</code></li>
        <li><code>?&amp;T</code></li>
        <li><code>fn()</code></li>
        <li><code>?fn()</code></li>
      </ul>
      <p>To convert the other way, use <a href="#intToPtr">@intToPtr</a></p>

      
      <h2 id="rem">@rem</h2>

      <pre><code class="zig">@rem(numerator: T, denominator: T) -&gt; T</code></pre>
      <p>
      Remainder division. For unsigned integers this is the same as
      <code>numerator % denominator</code>. Caller guarantees <code>denominator &gt; 0</code>.
      </p>
      <ul>
        <li><code>@rem(-5, 3) == -2</code></li>
        <li><code>@divTrunc(a, b) + @rem(a, b) == a</code></li>
      </ul>
      <p>For a function that returns an error code, see <code>@import("std").math.rem</code>.</p>
      <p>See also:</p><ul>
<li><a href="#mod">@mod</a></li>
</ul>

      
      <h2 id="returnAddress">@returnAddress</h2>

      <pre><code class="zig">@returnAddress()</code></pre>
      <p>
      This function returns a pointer to the return address of the current stack
      frame.
      </p>
      <p>
      The implications of this are target specific and not consistent across
      all platforms.
      </p>
      <p>
      This function is only valid within function scope.
      </p>
      
      <h2 id="setAlignStack">@setAlignStack</h2>

      <pre><code class="zig">@setAlignStack(comptime alignment: u29)</code></pre>
      <p>
      Ensures that a function will have a stack alignment of at least <code>alignment</code> bytes.
      </p>
      
      <h2 id="setCold">@setCold</h2>

      <pre><code class="zig">@setCold(is_cold: bool)</code></pre>
      <p>
      Tells the optimizer that a function is rarely called.
      </p>
      
      <h2 id="setRuntimeSafety">@setRuntimeSafety</h2>

      <pre><code class="zig">@setRuntimeSafety(safety_on: bool)</code></pre>
      <p>
      Sets whether runtime safety checks are on for the scope that contains the function call.
      </p>

      
      <h2 id="setEvalBranchQuota">@setEvalBranchQuota</h2>

      <pre><code class="zig">@setEvalBranchQuota(new_quota: usize)</code></pre>
      <p>
      Changes the maximum number of backwards branches that compile-time code
      execution can use before giving up and making a compile error.
      </p>
      <p>
      If the <code>new_quota</code> is smaller than the default quota (<code>1000</code>) or
      a previously explicitly set quota, it is ignored.
      </p>
      <p>
      Example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">test &quot;foo&quot; {
    comptime {
        var i = 0;
        while (i &lt; 1001) : (i += 1) {}
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:9: </span><span class="t31_1">error:</span><span class="t0_1"> evaluation exceeded 1000 backwards branches</span>
        while (i &lt; 1001) : (i += 1) {}
        <span class="t32_1">^</span>
</code></pre>

      <p>Now we use <code class="zig">@setEvalBranchQuota</code>:</p>
      <p class="file">test.zig</p><pre><code class="zig">test &quot;foo&quot; {
    comptime {
        @setEvalBranchQuota(1001);
        var i = 0;
        while (i &lt; 1001) : (i += 1) {}
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 foo...OK
</code></pre>


      <p>See also:</p><ul>
<li><a href="#comptime">comptime</a></li>
</ul>

      
      <h2 id="setFloatMode">@setFloatMode</h2>

      <pre><code class="zig">@setFloatMode(scope, mode: @import("builtin").FloatMode)</code></pre>
      <p>
      Sets the floating point mode for a given scope. Possible values are:
      </p>
      <pre><code class="zig">pub const FloatMode = enum {
    Optimized,
    Strict,
};</code></pre>
      <ul>
        <li>
          <code>Optimized</code> (default) - Floating point operations may do all of the following:
          <ul>
            <li>Assume the arguments and result are not NaN. Optimizations are required to retain defined behavior over NaNs, but the value of the result is undefined.</li>
            <li>Assume the arguments and result are not +/-Inf. Optimizations are required to retain defined behavior over +/-Inf, but the value of the result is undefined.</li>
            <li>Treat the sign of a zero argument or result as insignificant.</li>
            <li>Use the reciprocal of an argument rather than perform division.</li>
            <li>Perform floating-point contraction (e.g. fusing a multiply followed by an addition into a fused multiply-and-add).</li>
            <li>Perform algebraically equivalent transformations that may change results in floating point (e.g. reassociate).</li>
          </ul>
          This is equivalent to <code>-ffast-math</code> in GCC.
        </li>
        <li>
          <code>Strict</code> - Floating point operations follow strict IEEE compliance.
        </li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Floating-Point-Operations">Floating Point Operations</a></li>
</ul>

      
      <h2 id="setGlobalLinkage">@setGlobalLinkage</h2>

      <pre><code class="zig">@setGlobalLinkage(global_variable_name, comptime linkage: GlobalLinkage)</code></pre>
      <p>
      <code>GlobalLinkage</code> can be found with <code>@import("builtin").GlobalLinkage</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
</ul>

      
      <h2 id="setGlobalSection">@setGlobalSection</h2>

      <pre><code class="zig">@setGlobalSection(global_variable_name, comptime section_name: []const u8) -&gt; bool</code></pre>
      <p>
      Puts the global variable in the specified section.
      </p>
      
      <h2 id="shlExact">@shlExact</h2>

      <pre><code class="zig">@shlExact(value: T, shift_amt: Log2T) -&gt; T</code></pre>
      <p>
      Performs the left shift operation (<code>&lt;&lt;</code>). Caller guarantees
      that the shift will not shift any 1 bits out.
      </p>
      <p>
      The type of <code>shift_amt</code> is an unsigned integer with <code>log2(T.bit_count)</code> bits.
      This is because <code>shift_amt &gt;= T.bit_count</code> is undefined behavior.
      </p>
      <p>See also:</p><ul>
<li><a href="#shrExact">@shrExact</a></li>
<li><a href="#shlWithOverflow">@shlWithOverflow</a></li>
</ul>

      
      <h2 id="shlWithOverflow">@shlWithOverflow</h2>

      <pre><code class="zig">@shlWithOverflow(comptime T: type, a: T, shift_amt: Log2T, result: &T) -&gt; bool</code></pre>
      <p>
      Performs <code>*result = a &lt;&lt; b</code>. If overflow or underflow occurs,
      stores the overflowed bits in <code>result</code> and returns <code>true</code>.
      If no overflow or underflow occurs, returns <code>false</code>.
      </p>
      <p>
      The type of <code>shift_amt</code> is an unsigned integer with <code>log2(T.bit_count)</code> bits.
      This is because <code>shift_amt &gt;= T.bit_count</code> is undefined behavior.
      </p>
      <p>See also:</p><ul>
<li><a href="#shlExact">@shlExact</a></li>
<li><a href="#shrExact">@shrExact</a></li>
</ul>

      
      <h2 id="shrExact">@shrExact</h2>

      <pre><code class="zig">@shrExact(value: T, shift_amt: Log2T) -&gt; T</code></pre>
      <p>
      Performs the right shift operation (<code>&gt;&gt;</code>). Caller guarantees
      that the shift will not shift any 1 bits out.
      </p>
      <p>
      The type of <code>shift_amt</code> is an unsigned integer with <code>log2(T.bit_count)</code> bits.
      This is because <code>shift_amt &gt;= T.bit_count</code> is undefined behavior.
      </p>
      <p>See also:</p><ul>
<li><a href="#shlExact">@shlExact</a></li>
<li><a href="#shlWithOverflow">@shlWithOverflow</a></li>
</ul>

      
      <h2 id="sizeOf">@sizeOf</h2>

      <pre><code class="zig">@sizeOf(comptime T: type) -&gt; (number literal)</code></pre>
      <p>
      This function returns the number of bytes it takes to store <code>T</code> in memory.
      </p>
      <p>
      The result is a target-specific compile time constant.
      </p>
      
      <h2 id="subWithOverflow">@subWithOverflow</h2>

      <pre><code class="zig">@subWithOverflow(comptime T: type, a: T, b: T, result: &T) -&gt; bool</code></pre>
      <p>
      Performs <code>*result = a - b</code>. If overflow or underflow occurs,
      stores the overflowed bits in <code>result</code> and returns <code>true</code>.
      If no overflow or underflow occurs, returns <code>false</code>.
      </p>
      
      <h2 id="truncate">@truncate</h2>

      <pre><code class="zig">@truncate(comptime T: type, integer) -&gt; T</code></pre>
      <p>
      This function truncates bits from an integer type, resulting in a smaller
      integer type.
      </p>
      <p>
      The following produces a crash in debug mode and undefined behavior in
      release mode:
      </p>
      <pre><code class="zig">const a: u16 = 0xabcd;
const b: u8 = u8(a);</code></pre>
      <p>
      However this is well defined and working code:
      </p>
      <pre><code class="zig">const a: u16 = 0xabcd;
const b: u8 = @truncate(u8, a);
// b is now 0xcd</code></pre>
      <p>
      This function always truncates the significant bits of the integer, regardless
      of endianness on the target platform.
      </p>

      
      <h2 id="typeId">@typeId</h2>

      <pre><code class="zig">@typeId(comptime T: type) -&gt; @import("builtin").TypeId</code></pre>
      <p>
      Returns which kind of type something is. Possible values:
      </p>
      <pre><code class="zig">pub const TypeId = enum {
    Type,
    Void,
    Bool,
    NoReturn,
    Int,
    Float,
    Pointer,
    Array,
    Struct,
    FloatLiteral,
    IntLiteral,
    UndefinedLiteral,
    NullLiteral,
    Nullable,
    ErrorUnion,
    Error,
    Enum,
    Union,
    Fn,
    Namespace,
    Block,
    BoundFn,
    ArgTuple,
    Opaque,
};</code></pre>
      
      <h2 id="typeName">@typeName</h2>

      <pre><code class="zig">@typeName(T: type) -&gt; []u8</code></pre>
      <p>
      This function returns the string representation of a type.
      </p>

      
      <h2 id="typeOf">@typeOf</h2>

      <pre><code class="zig">@typeOf(expression) -&gt; type</code></pre>
      <p>
      This function returns a compile-time constant, which is the type of the
      expression passed as an argument. The expression is evaluated.
      </p>

      
      
      <h1 id="Build-Mode">Build Mode</h1>

      <p>
      Zig has three build modes:
      </p>
      <ul>
        <li><a href="#Debug">Debug</a> (default)</li>
        <li><a href="#ReleaseFast">ReleaseFast</a></li>
        <li><a href="#ReleaseSafe">ReleaseSafe</a></li>
      </ul>
      <p>
      To add standard build options to a <code>build.zig</code> file:
      </p>
      <pre><code class="zig">const Builder = @import(&quot;std&quot;).build.Builder;

pub fn build(b: &amp;Builder) void {
    const exe = b.addExecutable(&quot;example&quot;, &quot;example.zig&quot;);
    exe.setBuildMode(b.standardReleaseOptions());
    b.default_step.dependOn(&amp;exe.step);
}</code></pre>
      <p>
      This causes these options to be available:
      </p>
      <pre><code class="shell">  -Drelease-safe=(bool)  optimizations on and safety on
  -Drelease-fast=(bool)  optimizations on and safety off</code></pre>
      <h2 id="Debug">Debug</h2>

      <pre><code class="shell">$ zig build-exe example.zig</code></pre>
      <ul>
        <li>Fast compilation speed</li>
        <li>Safety checks enabled</li>
        <li>Slow runtime performance</li>
      </ul>
      
      <h2 id="ReleaseFast">ReleaseFast</h2>

      <pre><code class="shell">$ zig build-exe example.zig --release-fast</code></pre>
      <ul>
        <li>Fast runtime performance</li>
        <li>Safety checks disabled</li>
        <li>Slow compilation speed</li>
      </ul>
      
      <h2 id="ReleaseSafe">ReleaseSafe</h2>

      <pre><code class="shell">$ zig build-exe example.zig --release-safe</code></pre>
      <ul>
        <li>Medium runtime performance</li>
        <li>Safety checks enabled</li>
        <li>Slow compilation speed</li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
<li><a href="#Zig-Build-System">Zig Build System</a></li>
<li><a href="#Undefined-Behavior">Undefined Behavior</a></li>
</ul>

      
      
      <h1 id="Undefined-Behavior">Undefined Behavior</h1>

      <p>
      Zig has many instances of undefined behavior. If undefined behavior is
      detected at compile-time, Zig emits an error. Most undefined behavior that
      cannot be detected at compile-time can be detected at runtime. In these cases,
      Zig has safety checks. Safety checks can be disabled on a per-block basis
      with <code>@setRuntimeSafety</code>. The <a href="#ReleaseFast">ReleaseFast</a>
      build mode disables all safety checks in order to facilitate optimizations.
      </p>
      <p>
      When a safety check fails, Zig crashes with a stack trace, like this:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">test &quot;safety check&quot; {
    unreachable;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 safety check...reached unreachable code
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:5</span>: <span class="t2_0">0x203678 in ??? (test)</span>
    unreachable;
    <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/test_runner.zig:11:25</span>: <span class="t2_0">0x21d458 in ??? (test)</span>
        try test_fn.func();
                        <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:85:22</span>: <span class="t2_0">0x21d25b in ??? (test)</span>
            root.main() catch |err| {
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:62:20</span>: <span class="t2_0">0x21d1bb in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:52:39</span>: <span class="t2_0">0x21d04c in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:39:5</span>: <span class="t2_0">0x21cfd0 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>

Tests failed. Use the following command to reproduce the failure:
./zig-cache/test
</code></pre>

      <h2 id="Reaching-Unreachable-Code">Reaching Unreachable Code</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig">comptime {
    assert(false);
}
fn assert(ok: bool) void {
    if (!ok) unreachable; // assertion failure
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:14: </span><span class="t31_1">error:</span><span class="t0_1"> unable to evaluate constant expression</span>
    if (!ok) unreachable; // assertion failure
             <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:11: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    assert(false);
          <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:1:10: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
comptime {
         <span class="t32_1">^</span>
</code></pre>

      <p>At runtime crashes with the message <code>reached unreachable code</code> and a stack trace.</p>
      
      <h2 id="Index-out-of-Bounds">Index out of Bounds</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig">comptime {
    const array = &quot;hello&quot;;
    const garbage = array[5];
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:3:26: </span><span class="t31_1">error:</span><span class="t0_1"> index 5 outside array of size 5</span>
    const garbage = array[5];
                         <span class="t32_1">^</span>
</code></pre>

      <p>At runtime crashes with the message <code>index out of bounds</code> and a stack trace.</p>
      
      <h2 id="Cast-Negative-Number-to-Unsigned-Integer">Cast Negative Number to Unsigned Integer</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig">comptime {
    const value: i32 = -1;
    const unsigned = u32(value);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:3:25: </span><span class="t31_1">error:</span><span class="t0_1"> attempt to cast negative value to unsigned integer</span>
    const unsigned = u32(value);
                        <span class="t32_1">^</span>
</code></pre>

      <p>At runtime crashes with the message <code>attempt to cast negative value to unsigned integer</code> and a stack trace.</p>
      <p>
      If you are trying to obtain the maximum value of an unsigned integer, use <code>@maxValue(T)</code>,
      where <code>T</code> is the integer type, such as <code>u32</code>.
      </p>
      
      <h2 id="Cast-Truncates-Data">Cast Truncates Data</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig">comptime {
    const spartan_count: u16 = 300;
    const byte = u8(spartan_count);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:3:20: </span><span class="t31_1">error:</span><span class="t0_1"> cast from 'u16' to 'u8' truncates bits</span>
    const byte = u8(spartan_count);
                   <span class="t32_1">^</span>
</code></pre>

      <p>At runtime crashes with the message <code>integer cast truncated bits</code> and a stack trace.</p>
      <p>
      If you are trying to truncate bits, use <code>@truncate(T, value)</code>,
      where <code>T</code> is the integer type, such as <code>u32</code>, and <code>value</code>
      is the value you want to truncate.
      </p>
      
      <h2 id="Integer-Overflow">Integer Overflow</h2>

      <h3 id="Default-Operations">Default Operations</h3>

      <p>The following operators can cause integer overflow:</p>
      <ul>
        <li><code>+</code> (addition)</li>
        <li><code>-</code> (subtraction)</li>
        <li><code>-</code> (negation)</li>
        <li><code>*</code> (multiplication)</li>
        <li><code>/</code> (division)</li>
        <li><code>@divTrunc</code> (division)</li>
        <li><code>@divFloor</code> (division)</li>
        <li><code>@divExact</code> (division)</li>
      </ul>
      <p>Example with addition at compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig">comptime {
    var byte: u8 = 255;
    byte += 1;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:3:10: </span><span class="t31_1">error:</span><span class="t0_1"> operation caused overflow</span>
    byte += 1;
         <span class="t32_1">^</span>
</code></pre>

      <p>At runtime crashes with the message <code>integer overflow</code> and a stack trace.</p>
      
      <h3 id="Standard-Library-Math-Functions">Standard Library Math Functions</h3>

      <p>These functions provided by the standard library return possible errors.</p>
      <ul>
        <li><code>@import("std").math.add</code></li>
        <li><code>@import("std").math.sub</code></li>
        <li><code>@import("std").math.mul</code></li>
        <li><code>@import("std").math.divTrunc</code></li>
        <li><code>@import("std").math.divFloor</code></li>
        <li><code>@import("std").math.divExact</code></li>
        <li><code>@import("std").math.shl</code></li>
      </ul>
      <p>Example of catching an overflow for addition:</p>
      <p class="file">test.zig</p><pre><code class="zig">const math = @import(&quot;std&quot;).math;
const warn = @import(&quot;std&quot;).debug.warn;
pub fn main() !void {
    var byte: u8 = 255;

    byte = if (math.add(u8, byte, 1)) |result| result else |err| {
        warn(&quot;unable to add one: {}\n&quot;, @errorName(err));
        return err;
    };

    warn(&quot;result: {}\n&quot;, byte);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
unable to add one: Overflow
error: Overflow
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:8:9</span>: <span class="t2_0">0x21d3e5 in ??? (test)</span>
        return err;
        <span class="t32_1">^</span>
</code></pre>

      
      <h3 id="Builtin-Overflow-Functions">Builtin Overflow Functions</h3>

      <p>
      These builtins return a <code>bool</code> of whether or not overflow
      occurred, as well as returning the overflowed bits:
      </p>
      <ul>
        <li><code>@addWithOverflow</code></li>
        <li><code>@subWithOverflow</code></li>
        <li><code>@mulWithOverflow</code></li>
        <li><code>@shlWithOverflow</code></li>
      </ul>
      <p>
      Example of <code>@addWithOverflow</code>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const warn = @import(&quot;std&quot;).debug.warn;
pub fn main() void {
    var byte: u8 = 255;

    var result: u8 = undefined;
    if (@addWithOverflow(u8, byte, 10, &amp;result)) {
        warn(&quot;overflowed result: {}\n&quot;, result);
    } else {
        warn(&quot;result: {}\n&quot;, result);
    }
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
overflowed result: 9
</code></pre>

      
      <h3 id="Wrapping-Operations">Wrapping Operations</h3>

      <p>
      These operations have guaranteed wraparound semantics.
      </p>
      <ul>
        <li><code>+%</code> (wraparound addition)</li>
        <li><code>-%</code> (wraparound subtraction)</li>
        <li><code>-%</code> (wraparound negation)</li>
        <li><code>*%</code> (wraparound multiplication)</li>
      </ul>
      <p class="file">test.zig</p><pre><code class="zig">const assert = @import(&quot;std&quot;).debug.assert;

test &quot;wraparound addition and subtraction&quot; {
    const x: i32 = @maxValue(i32);
    const min_val = x +% 1;
    assert(min_val == @minValue(i32));
    const max_val = min_val -% 1;
    assert(max_val == @maxValue(i32));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 wraparound addition and subtraction...OK
</code></pre>

      
      
      <h2 id="Exact-Left-Shift-Overflow">Exact Left Shift Overflow</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig">comptime {
    const x = @shlExact(u8(0b01010101), 2);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:15: </span><span class="t31_1">error:</span><span class="t0_1"> operation caused overflow</span>
    const x = @shlExact(u8(0b01010101), 2);
              <span class="t32_1">^</span>
</code></pre>

      <p>At runtime crashes with the message <code>left shift overflowed bits</code> and a stack trace.</p>
      
      <h2 id="Exact-Right-Shift-Overflow">Exact Right Shift Overflow</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig">comptime {
    const x = @shrExact(u8(0b10101010), 2);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:15: </span><span class="t31_1">error:</span><span class="t0_1"> exact shift shifted out 1 bits</span>
    const x = @shrExact(u8(0b10101010), 2);
              <span class="t32_1">^</span>
</code></pre>

      <p>At runtime crashes with the message <code>right shift overflowed bits</code> and a stack trace.</p>
      
      <h2 id="Division-by-Zero">Division by Zero</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig">comptime {
    const a: i32 = 1;
    const b: i32 = 0;
    const c = a / b;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:17: </span><span class="t31_1">error:</span><span class="t0_1"> division by zero</span>
    const c = a / b;
                <span class="t32_1">^</span>
</code></pre>

      <p>At runtime crashes with the message <code>division by zero</code> and a stack trace.</p>

      
      <h2 id="Remainder-Division-by-Zero">Remainder Division by Zero</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig">comptime {
    const a: i32 = 10;
    const b: i32 = 0;
    const c = a % b;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:17: </span><span class="t31_1">error:</span><span class="t0_1"> division by zero</span>
    const c = a % b;
                <span class="t32_1">^</span>
</code></pre>

      <p>At runtime crashes with the message <code>remainder division by zero</code> and a stack trace.</p>

      
      <h2 id="Exact-Division-Remainder">Exact Division Remainder</h2>

      <p>TODO</p>
      
      <h2 id="Slice-Widen-Remainder">Slice Widen Remainder</h2>

      <p>TODO</p>
      
      <h2 id="Attempt-to-Unwrap-Null">Attempt to Unwrap Null</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig">comptime {
    const nullable_number: ?i32 = null;
    const number = ??nullable_number;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:3:20: </span><span class="t31_1">error:</span><span class="t0_1"> unable to unwrap null</span>
    const number = ??nullable_number;
                   <span class="t32_1">^</span>
</code></pre>

      <p>At runtime crashes with the message <code>attempt to unwrap null</code> and a stack trace.</p>
      <p>One way to avoid this crash is to test for null instead of assuming non-null, with
      the <code>if</code> expression:</p>
      <p class="file">test.zig</p><pre><code class="zig">const warn = @import(&quot;std&quot;).debug.warn;
pub fn main() void {
    const nullable_number: ?i32 = null;

    if (nullable_number) |number| {
        warn(&quot;got number: {}\n&quot;, number);
    } else {
        warn(&quot;it's null\n&quot;);
    }
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
it's null
</code></pre>

      
      <h2 id="Attempt-to-Unwrap-Error">Attempt to Unwrap Error</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig">comptime {
    const number = getNumberOrFail() catch unreachable;
}

fn getNumberOrFail() !i32 {
    return error.UnableToReturnNumber;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:38: </span><span class="t31_1">error:</span><span class="t0_1"> caught unexpected error 'UnableToReturnNumber'</span>
    const number = getNumberOrFail() catch unreachable;
                                     <span class="t32_1">^</span>
</code></pre>

      <p>At runtime crashes with the message <code>attempt to unwrap error: ErrorCode</code> and a stack trace.</p>
      <p>One way to avoid this crash is to test for an error instead of assuming a successful result, with
      the <code>if</code> expression:</p>
      <p class="file">test.zig</p><pre><code class="zig">const warn = @import(&quot;std&quot;).debug.warn;

pub fn main() void {
    const result = getNumberOrFail();

    if (result) |number| {
        warn(&quot;got number: {}\n&quot;, number);
    } else |err| {
        warn(&quot;got error: {}\n&quot;, @errorName(err));
    }
}

fn getNumberOrFail() !i32 {
    return error.UnableToReturnNumber;
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
got error: UnableToReturnNumber
</code></pre>

      
      <h2 id="Invalid-Error-Code">Invalid Error Code</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig">comptime {
    const err = error.AnError;
    const number = u32(err) + 10;
    const invalid_err = error(number);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:30: </span><span class="t31_1">error:</span><span class="t0_1"> integer value 11 represents no error</span>
    const invalid_err = error(number);
                             <span class="t32_1">^</span>
</code></pre>

      <p>At runtime crashes with the message <code>invalid error code</code> and a stack trace.</p>
      
      <h2 id="Invalid-Enum-Cast">Invalid Enum Cast</h2>

      <p>TODO</p>

      
      <h2 id="Incorrect-Pointer-Alignment">Incorrect Pointer Alignment</h2>

      <p>TODO</p>

      
      <h2 id="Wrong-Union-Field-Access">Wrong Union Field Access</h2>

      <p>TODO</p>

      
      
      <h1 id="Memory">Memory</h1>

      <p>TODO: explain no default allocator in zig</p>
      <p>TODO: show how to use the allocator interface</p>
      <p>TODO: mention debug allocator</p>
      <p>TODO: importance of checking for allocation failure</p>
      <p>TODO: mention overcommit and the OOM Killer</p>
      <p>TODO: mention recursion</p>
      <p>See also:</p><ul>
<li><a href="#Pointers">Pointers</a></li>
</ul>


      
      <h1 id="Compile-Variables">Compile Variables</h1>

      <p>
      Compile variables are accessible by importing the <code>"builtin"</code> package,
      which the compiler makes available to every Zig source file. It contains
      compile-time constants such as the current target, endianness, and release mode.
      </p>
      <pre><code class="zig">const builtin = @import(&quot;builtin&quot;);
const separator = if (builtin.os == builtin.Os.windows) '\\' else '/';</code></pre>
      <p>
      Example of what is imported with <code>@import("builtin")</code>:
      </p>
      <pre><code class="zig">pub const StackTrace = struct {
    index: usize,
    instruction_addresses: []usize,
};

pub const Os = enum {
    freestanding,
    ananas,
    cloudabi,
    dragonfly,
    freebsd,
    fuchsia,
    ios,
    kfreebsd,
    linux,
    lv2,
    macosx,
    netbsd,
    openbsd,
    solaris,
    windows,
    haiku,
    minix,
    rtems,
    nacl,
    cnk,
    bitrig,
    aix,
    cuda,
    nvcl,
    amdhsa,
    ps4,
    elfiamcu,
    tvos,
    watchos,
    mesa3d,
    contiki,
    zen,
};

pub const Arch = enum {
    armv8_2a,
    armv8_1a,
    armv8,
    armv8r,
    armv8m_baseline,
    armv8m_mainline,
    armv7,
    armv7em,
    armv7m,
    armv7s,
    armv7k,
    armv7ve,
    armv6,
    armv6m,
    armv6k,
    armv6t2,
    armv5,
    armv5te,
    armv4t,
    armeb,
    aarch64,
    aarch64_be,
    avr,
    bpfel,
    bpfeb,
    hexagon,
    mips,
    mipsel,
    mips64,
    mips64el,
    msp430,
    nios2,
    powerpc,
    powerpc64,
    powerpc64le,
    r600,
    amdgcn,
    riscv32,
    riscv64,
    sparc,
    sparcv9,
    sparcel,
    s390x,
    tce,
    tcele,
    thumb,
    thumbeb,
    i386,
    x86_64,
    xcore,
    nvptx,
    nvptx64,
    le32,
    le64,
    amdil,
    amdil64,
    hsail,
    hsail64,
    spir,
    spir64,
    kalimbav3,
    kalimbav4,
    kalimbav5,
    shave,
    lanai,
    wasm32,
    wasm64,
    renderscript32,
    renderscript64,
};

pub const Environ = enum {
    unknown,
    gnu,
    gnuabi64,
    gnueabi,
    gnueabihf,
    gnux32,
    code16,
    eabi,
    eabihf,
    android,
    musl,
    musleabi,
    musleabihf,
    msvc,
    itanium,
    cygnus,
    amdopencl,
    coreclr,
    opencl,
};

pub const ObjectFormat = enum {
    unknown,
    coff,
    elf,
    macho,
    wasm,
};

pub const GlobalLinkage = enum {
    Internal,
    Strong,
    Weak,
    LinkOnce,
};

pub const AtomicOrder = enum {
    Unordered,
    Monotonic,
    Acquire,
    Release,
    AcqRel,
    SeqCst,
};

pub const Mode = enum {
    Debug,
    ReleaseSafe,
    ReleaseFast,
};

pub const TypeId = enum {
    Type,
    Void,
    Bool,
    NoReturn,
    Int,
    Float,
    Pointer,
    Array,
    Struct,
    FloatLiteral,
    IntLiteral,
    UndefinedLiteral,
    NullLiteral,
    Nullable,
    ErrorUnion,
    Error,
    Enum,
    Union,
    Fn,
    Namespace,
    Block,
    BoundFn,
    ArgTuple,
    Opaque,
};

pub const FloatMode = enum {
    Optimized,
    Strict,
};

pub const Endian = enum {
    Big,
    Little,
};

pub const endian = Endian.Little;
pub const is_test = false;
pub const os = Os.linux;
pub const arch = Arch.x86_64;
pub const environ = Environ.gnu;
pub const object_format = ObjectFormat.elf;
pub const mode = Mode.Debug;
pub const link_libc = false;
pub const have_error_return_tracing = true;</code></pre>
      <p>See also:</p><ul>
<li><a href="#Build-Mode">Build Mode</a></li>
</ul>

      
      <h1 id="Root-Source-File">Root Source File</h1>

      <p>TODO: explain how root source file finds other files</p>
      <p>TODO: pub fn main</p>
      <p>TODO: pub fn panic</p>
      <p>TODO: if linking with libc you can use export fn main</p>
      <p>TODO: order independent top level declarations</p>
      <p>TODO: lazy analysis</p>
      <p>TODO: using comptime { _ = @import() }</p>
      
      <h1 id="Zig-Test">Zig Test</h1>

      <p>TODO: basic usage</p>
      <p>TODO: lazy analysis</p>
      <p>TODO: --test-filter</p>
      <p>TODO: --test-name-prefix</p>
      <p>TODO: testing in releasefast and releasesafe mode. assert still works</p>
      
      <h1 id="Zig-Build-System">Zig Build System</h1>

      <p>TODO: explain purpose, it's supposed to replace make/cmake</p>
      <p>TODO: example of building a zig executable</p>
      <p>TODO: example of building a C library</p>
      
      <h1 id="C">C</h1>

      <p>
      Although Zig is independent of C, and, unlike most other languages, does not depend on libc,
      Zig acknowledges the importance of interacting with existing C code.
      </p>
      <p>
      There are a few ways that Zig facilitates C interop.
      </p>
      <h2 id="C-Type-Primitives">C Type Primitives</h2>

      <p>
      These have guaranteed C ABI compatibility and can be used like any other type.
      </p>
      <ul>
        <li><code>c_short</code></li>
        <li><code>c_ushort</code></li>
        <li><code>c_int</code></li>
        <li><code>c_uint</code></li>
        <li><code>c_long</code></li>
        <li><code>c_ulong</code></li>
        <li><code>c_longlong</code></li>
        <li><code>c_ulonglong</code></li>
        <li><code>c_longdouble</code></li>
        <li><code>c_void</code></li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Primitive-Types">Primitive Types</a></li>
</ul>

      
      <h2 id="C-String-Literals">C String Literals</h2>

      <p class="file">test.zig</p><pre><code class="zig">extern fn puts(&amp;const u8) void;

pub fn main() void {
    puts(c&quot;this has a null terminator&quot;);
    puts(
        c\\and so
        c\\does this
        c\\multiline C string literal
    );
}</code></pre><pre><code class="shell">$ zig build-exe test.zig --library c
$ ./test
this has a null terminator
and so
does this
multiline C string literal
</code></pre>

      <p>See also:</p><ul>
<li><a href="#String-Literals">String Literals</a></li>
</ul>

      
      <h2 id="Import-from-C-Header-File">Import from C Header File</h2>

      <p>
      The <code>@cImport</code> builtin function can be used
      to directly import symbols from .h files:
      </p>
      <p class="file">test.zig</p><pre><code class="zig">const c = @cImport({
    // See https://github.com/zig-lang/zig/issues/515
    @cDefine(&quot;_NO_CRT_STDIO_INLINE&quot;, &quot;1&quot;);
    @cInclude(&quot;stdio.h&quot;);
});
pub fn main() void {
    _ = c.printf(c&quot;hello\n&quot;);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig --library c
$ ./test
hello
</code></pre>

      <p>
      The <code>@cImport</code> function takes an expression as a parameter.
      This expression is evaluated at compile-time and is used to control
      preprocessor directives and include multiple .h files:
      </p>
      <pre><code class="zig">const builtin = @import(&quot;builtin&quot;);

const c = @cImport({
    @cDefine(&quot;NDEBUG&quot;, builtin.mode == builtin.Mode.ReleaseFast);
    if (something) {
        @cDefine(&quot;_GNU_SOURCE&quot;, {});
    }
    @cInclude(&quot;stdlib.h&quot;);
    if (something) {
        @cUndef(&quot;_GNU_SOURCE&quot;);
    }
    @cInclude(&quot;soundio.h&quot;);
});</code></pre>
      <p>See also:</p><ul>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cInclude">@cInclude</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cUndef">@cUndef</a></li>
<li><a href="#import">@import</a></li>
</ul>

      
      <h2 id="Mixing-Object-Files">Mixing Object Files</h2>

      <p>
      You can mix Zig object files with any other object files that respect the C ABI. Example:
      </p>
      <p class="file">base64.zig</p>
      <pre><code class="zig">const base64 = @import(&quot;std&quot;).base64;

export fn decode_base_64(dest_ptr: &amp;u8, dest_len: usize,
    source_ptr: &amp;const u8, source_len: usize) usize
{
    const src = source_ptr[0..source_len];
    const dest = dest_ptr[0..dest_len];
    const base64_decoder = base64.standard_decoder_unsafe;
    const decoded_size = base64_decoder.calcSize(src);
    base64_decoder.decode(dest[0..decoded_size], src);
    return decoded_size;
}</code></pre>
      <p class="file">test.c</p>
      <pre><code class="cpp">// This header is generated by zig from base64.zig
#include "base64.h"

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    const char *encoded = "YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz";
    char buf[200];

    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));
    buf[len] = 0;
    puts(buf);

    return 0;
}</code></pre>
      <p class="file">build.zig</p>
      <pre><code class="zig">const Builder = @import(&quot;std&quot;).build.Builder;

pub fn build(b: &amp;Builder) void {
    const obj = b.addObject(&quot;base64&quot;, &quot;base64.zig&quot;);

    const exe = b.addCExecutable(&quot;test&quot;);
    exe.addCompileFlags([][]const u8 {
        &quot;-std=c99&quot;,
    });
    exe.addSourceFile(&quot;test.c&quot;);
    exe.addObject(obj);
    exe.setOutputPath(&quot;.&quot;);

    b.default_step.dependOn(&amp;exe.step);
}</code></pre>
      
      <h2 id="Terminal">Terminal</h2>

      <pre><code class="shell">$ zig build
$ ./test
all your base are belong to us</code></pre>
      <p>See also:</p><ul>
<li><a href="#Targets">Targets</a></li>
<li><a href="#Zig-Build-System">Zig Build System</a></li>
</ul>

      
      
      <h1 id="Targets">Targets</h1>

      <p>
      Zig supports generating code for all targets that LLVM supports. Here is
      what it looks like to execute <code>zig targets</code> on a Linux x86_64
      computer:
      </p>
      <pre><code class="shell">$ zig targets
Architectures:
  armv8_2a
  armv8_1a
  armv8
  armv8r
  armv8m_baseline
  armv8m_mainline
  armv7
  armv7em
  armv7m
  armv7s
  armv7k
  armv7ve
  armv6
  armv6m
  armv6k
  armv6t2
  armv5
  armv5te
  armv4t
  armeb
  aarch64
  aarch64_be
  avr
  bpfel
  bpfeb
  hexagon
  mips
  mipsel
  mips64
  mips64el
  msp430
  nios2
  powerpc
  powerpc64
  powerpc64le
  r600
  amdgcn
  riscv32
  riscv64
  sparc
  sparcv9
  sparcel
  s390x
  tce
  tcele
  thumb
  thumbeb
  i386
  x86_64 (native)
  xcore
  nvptx
  nvptx64
  le32
  le64
  amdil
  amdil64
  hsail
  hsail64
  spir
  spir64
  kalimbav3
  kalimbav4
  kalimbav5
  shave
  lanai
  wasm32
  wasm64
  renderscript32
  renderscript64

Operating Systems:
  freestanding
  ananas
  cloudabi
  dragonfly
  freebsd
  fuchsia
  ios
  kfreebsd
  linux (native)
  lv2
  macosx
  netbsd
  openbsd
  solaris
  windows
  haiku
  minix
  rtems
  nacl
  cnk
  bitrig
  aix
  cuda
  nvcl
  amdhsa
  ps4
  elfiamcu
  tvos
  watchos
  mesa3d
  contiki
  zen

Environments:
  unknown
  gnu (native)
  gnuabi64
  gnueabi
  gnueabihf
  gnux32
  code16
  eabi
  eabihf
  android
  musl
  musleabi
  musleabihf
  msvc
  itanium
  cygnus
  amdopencl
  coreclr
  opencl</code></pre>
      <p>
      The Zig Standard Library (<code>@import("std")</code>) has architecture, environment, and operating sytsem
      abstractions, and thus takes additional work to support more platforms. It currently supports
      Linux x86_64. Not all standard library code requires operating system abstractions, however,
      so things such as generic data structures work an all above platforms.
      </p>
      
      <h1 id="Style-Guide">Style Guide</h1>

      <p>
These coding conventions are not enforced by the compiler, but they are shipped in
this documentation along with the compiler in order to provide a point of
reference, should anyone wish to point to an authority on agreed upon Zig
coding style.
      </p>
      <h2 id="Whitespace">Whitespace</h2>

      <ul>
        <li>
          4 space indentation
        </li>
        <li>
          Open braces on same line, unless you need to wrap.
        </li>
        <li>If a list of things is longer than 2, put each item on its own line and
          exercise the abilty to put an extra comma at the end.
        </li>
        <li>
          Line length: aim for 100; use common sense.
        </li>
      </ul>
      
      <h2 id="Names">Names</h2>

      <p>
      Roughly speaking: <code>camelCaseFunctionName</code>, <code>TitleCaseTypeName</code>,
      <code>snake_case_variable_name</code>. More precisely:
      </p>
      <ul>
        <li>
          If <code>x</code> is a <code>struct</code> (or an alias of a <code>struct</code>),
          then <code>x</code> should be <code>TitleCase</code>.
        </li>
        <li>
          If <code>x</code> otherwise identifies a type, <code>x</code> should have <code>snake_case</code>.
        </li>
        <li>
          If <code>x</code> is callable, and <code>x</code>'s return type is <code>type</code>, then <code>x</code> should be <code>TitleCase</code>.
        </li>
        <li>
          If <code>x</code> is otherwise callable, then <code>x</code> should be <code>camelCase</code>.
        </li>
        <li>
          Otherwise, <code>x</code> should be <code>snake_case</code>.
        </li>
      </ul>
      <p>
      Acronyms, initialisms, proper nouns, or any other word that has capitalization
      rules in written English are subject to naming conventions just like any other
      word. Even acronyms that are only 2 letters long are subject to these
      conventions.
      </p>
      <p>
      These are general rules of thumb; if it makes sense to do something different,
      do what makes sense. For example, if there is an established convention such as
      <code>ENOENT</code>, follow the established convention.
      </p>
      
      <h2 id="Examples">Examples</h2>

      <pre><code class="zig">const namespace_name = @import(&quot;dir_name/file_name.zig&quot;);
var global_var: i32 = undefined;
const const_name = 42;
const primitive_type_alias = f32;
const string_alias = []u8;

const StructName = struct {};
const StructAlias = StructName;

fn functionName(param_name: TypeName) void {
    var functionPointer = functionName;
    functionPointer();
    functionPointer = otherFunction;
    functionPointer();
}
const functionAlias = functionName;

fn ListTemplateFunction(comptime ChildType: type, comptime fixed_size: usize) type {
    return List(ChildType, fixed_size);
}

fn ShortList(comptime T: type, comptime n: usize) type {
    return struct {
        field_name: [n]T,
        fn methodName() void {}
    };
}

// The word XML loses its casing when used in Zig identifiers.
const xml_document =
    \\&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    \\&lt;document&gt;
    \\&lt;/document&gt;
;
const XmlParser = struct {};

// The initials BE (Big Endian) are just another word in Zig identifier names.
fn readU32Be() u32 {}</code></pre>
      <p>
      See the Zig Standard Library for more examples.
      </p>
      
      
      <h1 id="Source-Encoding">Source Encoding</h1>

      <p>Zig source code is encoded in UTF-8. An invalid UTF-8 byte sequence results in a compile error.</p>
      <p>Throughout all zig source code (including in comments), some codepoints are never allowed:</p>
      <ul>
        <li>Ascii control characters, except for U+000a (LF): U+0000 - U+0009, U+000b - U+0001f, U+007f. (Note that Windows line endings (CRLF) are not allowed, and hard tabs are not allowed.)</li>
        <li>Non-Ascii Unicode line endings: U+0085 (NEL), U+2028 (LS), U+2029 (PS).</li>
      </ul>
      <p>The codepoint U+000a (LF) (which is encoded as the single-byte value 0x0a) is the line terminator character. This character always terminates a line of zig source code (except possbly the last line of the file).</p>
      <p>For some discussion on the rationale behind these design decisions, see <a href="https://github.com/zig-lang/zig/issues/663">issue #663</a></p>
      
      <h1 id="Grammar">Grammar</h1>

      <pre><code class="nohighlight">Root = many(TopLevelItem) EOF

TopLevelItem = CompTimeExpression(Block) | TopLevelDecl | TestDecl

TestDecl = "test" String Block

TopLevelDecl = option("pub") (FnDef | ExternDecl | GlobalVarDecl | UseDecl)

GlobalVarDecl = option("export") VariableDeclaration ";"

LocalVarDecl = option("comptime") VariableDeclaration

VariableDeclaration = ("var" | "const") Symbol option(":" TypeExpr) option("align" "(" Expression ")") option("section" "(" Expression ")") "=" Expression

ContainerMember = (ContainerField | FnDef | GlobalVarDecl)

ContainerField = Symbol option(":" PrefixOpExpression option("=" PrefixOpExpression ","

UseDecl = "use" Expression ";"

ExternDecl = "extern" option(String) (FnProto | VariableDeclaration) ";"

FnProto = option("nakedcc" | "stdcallcc" | "extern" | ("async" option("(" Expression ")"))) "fn" option(Symbol) ParamDeclList option("align" "(" Expression ")") option("section" "(" Expression ")") option("!") (TypeExpr | "var")

FnDef = option("inline" | "export") FnProto Block

ParamDeclList = "(" list(ParamDecl, ",") ")"

ParamDecl = option("noalias" | "comptime") option(Symbol ":") (TypeExpr | "var" | "...")

Block = option(Symbol ":") "{" many(Statement) "}"

Statement = LocalVarDecl ";" | Defer(Block) | Defer(Expression) ";" | BlockExpression(Block) | Expression ";" | ";"

TypeExpr = ErrorSetExpr

ErrorSetExpr = (PrefixOpExpression "!" PrefixOpExpression) | PrefixOpExpression

BlockOrExpression = Block | Expression

Expression = TryExpression | ReturnExpression | BreakExpression | AssignmentExpression | CancelExpression | ResumeExpression

AsmExpression = "asm" option("volatile") "(" String option(AsmOutput) ")"

AsmOutput = ":" list(AsmOutputItem, ",") option(AsmInput)

AsmInput = ":" list(AsmInputItem, ",") option(AsmClobbers)

AsmOutputItem = "[" Symbol "]" String "(" (Symbol | "-&gt;" TypeExpr) ")"

AsmInputItem = "[" Symbol "]" String "(" Expression ")"

AsmClobbers= ":" list(String, ",")

UnwrapExpression = BoolOrExpression (UnwrapNullable | UnwrapError) | BoolOrExpression

UnwrapNullable = "??" Expression

UnwrapError = "catch" option("|" Symbol "|") Expression

AssignmentExpression = UnwrapExpression AssignmentOperator UnwrapExpression | UnwrapExpression

AssignmentOperator = "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "&lt;&lt;=" | "&gt;&gt;=" | "&amp;=" | "^=" | "|=" | "*%=" | "+%=" | "-%="

BlockExpression(body) = Block | IfExpression(body) | IfErrorExpression(body) | TestExpression(body) | WhileExpression(body) | ForExpression(body) | SwitchExpression | CompTimeExpression(body) | SuspendExpression(body)

CompTimeExpression(body) = "comptime" body

SwitchExpression = "switch" "(" Expression ")" "{" many(SwitchProng) "}"

SwitchProng = (list(SwitchItem, ",") | "else") "=&gt;" option("|" option("*") Symbol "|") Expression ","

SwitchItem = Expression | (Expression "..." Expression)

ForExpression(body) = option(Symbol ":") option("inline") "for" "(" Expression ")" option("|" option("*") Symbol option("," Symbol) "|") body option("else" BlockExpression(body))

BoolOrExpression = BoolAndExpression "or" BoolOrExpression | BoolAndExpression

ReturnExpression = "return" option(Expression)

TryExpression = "try" Expression

AwaitExpression = "await" Expression

BreakExpression = "break" option(":" Symbol) option(Expression)

CancelExpression = "cancel" Expression;

ResumeExpression = "resume" Expression;

Defer(body) = ("defer" | "deferror") body

IfExpression(body) = "if" "(" Expression ")" body option("else" BlockExpression(body))

SuspendExpression(body) = "suspend" option(("|" Symbol "|" body))

IfErrorExpression(body) = "if" "(" Expression ")" option("|" option("*") Symbol "|") body "else" "|" Symbol "|" BlockExpression(body)

TestExpression(body) = "if" "(" Expression ")" option("|" option("*") Symbol "|") body option("else" BlockExpression(body))

WhileExpression(body) = option(Symbol ":") option("inline") "while" "(" Expression ")" option("|" option("*") Symbol "|") option(":" "(" Expression ")") body option("else" option("|" Symbol "|") BlockExpression(body))

BoolAndExpression = ComparisonExpression "and" BoolAndExpression | ComparisonExpression

ComparisonExpression = BinaryOrExpression ComparisonOperator BinaryOrExpression | BinaryOrExpression

ComparisonOperator = "==" | "!=" | "&lt;" | "&gt;" | "&lt;=" | "&gt;="

BinaryOrExpression = BinaryXorExpression "|" BinaryOrExpression | BinaryXorExpression

BinaryXorExpression = BinaryAndExpression "^" BinaryXorExpression | BinaryAndExpression

BinaryAndExpression = BitShiftExpression "&amp;" BinaryAndExpression | BitShiftExpression

BitShiftExpression = AdditionExpression BitShiftOperator BitShiftExpression | AdditionExpression

BitShiftOperator = "&lt;&lt;" | "&gt;&gt;" | "&lt;&lt;"

AdditionExpression = MultiplyExpression AdditionOperator AdditionExpression | MultiplyExpression

AdditionOperator = "+" | "-" | "++" | "+%" | "-%"

MultiplyExpression = CurlySuffixExpression MultiplyOperator MultiplyExpression | CurlySuffixExpression

CurlySuffixExpression = TypeExpr option(ContainerInitExpression)

MultiplyOperator = "||" | "*" | "/" | "%" | "**" | "*%"

PrefixOpExpression = PrefixOp ErrorSetExpr | SuffixOpExpression

SuffixOpExpression = ("async" option("(" Expression ")") PrimaryExpression FnCallExpression) | PrimaryExpression option(FnCallExpression | ArrayAccessExpression | FieldAccessExpression | SliceExpression)

FieldAccessExpression = "." Symbol

FnCallExpression = "(" list(Expression, ",") ")"

ArrayAccessExpression = "[" Expression "]"

SliceExpression = "[" Expression ".." option(Expression) "]"

ContainerInitExpression = "{" ContainerInitBody "}"

ContainerInitBody = list(StructLiteralField, ",") | list(Expression, ",")

StructLiteralField = "." Symbol "=" Expression

PrefixOp = "!" | "-" | "~" | "*" | ("&amp;" option("align" "(" Expression option(":" Integer ":" Integer) ")" ) option("const") option("volatile")) | "?" | "??" | "-%" | "try" | "await"

PrimaryExpression = Integer | Float | String | CharLiteral | KeywordLiteral | GroupedExpression | BlockExpression(BlockOrExpression) | Symbol | ("@" Symbol FnCallExpression) | ArrayType | FnProto | AsmExpression | ContainerDecl | ("continue" option(":" Symbol)) | ErrorSetDecl

ArrayType : "[" option(Expression) "]" option("align" "(" Expression option(":" Integer ":" Integer) ")")) option("const") option("volatile") TypeExpr

GroupedExpression = "(" Expression ")"

KeywordLiteral = "true" | "false" | "null" | "undefined" | "error" | "this" | "unreachable" | "suspend"

ErrorSetDecl = "error" "{" list(Symbol, ",") "}"

ContainerDecl = option("extern" | "packed")
  ("struct" option(GroupedExpression) | "union" option("enum" option(GroupedExpression) | GroupedExpression) | ("enum" option(GroupedExpression)))
  "{" many(ContainerMember) "}"</code></pre>
      
      <h1 id="Zen">Zen</h1>

      <ul>
        <li>Communicate intent precisely.</li>
        <li>Edge cases matter.</li>
        <li>Favor reading code over writing code.</li>
        <li>Only one obvious way to do things.</li>
        <li>Runtime crashes are better than bugs.</li>
        <li>Compile errors are better than runtime crashes.</li>
        <li>Incremental improvements.</li>
        <li>Avoid local maximums.</li>
        <li>Reduce the amount one must remember.</li>
        <li>Minimize energy spent on coding style.</li>
        <li>Together we serve end users.</li>
      </ul>
      
    </div>
    <script>
/*! highlight.js v9.12.0 | BSD3 License | git.io/hljslicense */
!function(e){var n="object"==typeof window&&window||"object"==typeof self&&self;"undefined"!=typeof exports?e(exports):n&&(n.hljs=e({}),"function"==typeof define&&define.amd&&define([],function(){return n.hljs}))}(function(e){function n(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}function t(e){return e.nodeName.toLowerCase()}function r(e,n){var t=e&&e.exec(n);return t&&0===t.index}function a(e){return k.test(e)}function i(e){var n,t,r,i,o=e.className+" ";if(o+=e.parentNode?e.parentNode.className:"",t=B.exec(o))return w(t[1])?t[1]:"no-highlight";for(o=o.split(/\s+/),n=0,r=o.length;r>n;n++)if(i=o[n],a(i)||w(i))return i}function o(e){var n,t={},r=Array.prototype.slice.call(arguments,1);for(n in e)t[n]=e[n];return r.forEach(function(e){for(n in e)t[n]=e[n]}),t}function u(e){var n=[];return function r(e,a){for(var i=e.firstChild;i;i=i.nextSibling)3===i.nodeType?a+=i.nodeValue.length:1===i.nodeType&&(n.push({event:"start",offset:a,node:i}),a=r(i,a),t(i).match(/br|hr|img|input/)||n.push({event:"stop",offset:a,node:i}));return a}(e,0),n}function c(e,r,a){function i(){return e.length&&r.length?e[0].offset!==r[0].offset?e[0].offset<r[0].offset?e:r:"start"===r[0].event?e:r:e.length?e:r}function o(e){function r(e){return" "+e.nodeName+'="'+n(e.value).replace('"',"&quot;")+'"'}s+="<"+t(e)+E.map.call(e.attributes,r).join("")+">"}function u(e){s+="</"+t(e)+">"}function c(e){("start"===e.event?o:u)(e.node)}for(var l=0,s="",f=[];e.length||r.length;){var g=i();if(s+=n(a.substring(l,g[0].offset)),l=g[0].offset,g===e){f.reverse().forEach(u);do c(g.splice(0,1)[0]),g=i();while(g===e&&g.length&&g[0].offset===l);f.reverse().forEach(o)}else"start"===g[0].event?f.push(g[0].node):f.pop(),c(g.splice(0,1)[0])}return s+n(a.substr(l))}function l(e){return e.v&&!e.cached_variants&&(e.cached_variants=e.v.map(function(n){return o(e,{v:null},n)})),e.cached_variants||e.eW&&[o(e)]||[e]}function s(e){function n(e){return e&&e.source||e}function t(t,r){return new RegExp(n(t),"m"+(e.cI?"i":"")+(r?"g":""))}function r(a,i){if(!a.compiled){if(a.compiled=!0,a.k=a.k||a.bK,a.k){var o={},u=function(n,t){e.cI&&(t=t.toLowerCase()),t.split(" ").forEach(function(e){var t=e.split("|");o[t[0]]=[n,t[1]?Number(t[1]):1]})};"string"==typeof a.k?u("keyword",a.k):x(a.k).forEach(function(e){u(e,a.k[e])}),a.k=o}a.lR=t(a.l||/\w+/,!0),i&&(a.bK&&(a.b="\\b("+a.bK.split(" ").join("|")+")\\b"),a.b||(a.b=/\B|\b/),a.bR=t(a.b),a.e||a.eW||(a.e=/\B|\b/),a.e&&(a.eR=t(a.e)),a.tE=n(a.e)||"",a.eW&&i.tE&&(a.tE+=(a.e?"|":"")+i.tE)),a.i&&(a.iR=t(a.i)),null==a.r&&(a.r=1),a.c||(a.c=[]),a.c=Array.prototype.concat.apply([],a.c.map(function(e){return l("self"===e?a:e)})),a.c.forEach(function(e){r(e,a)}),a.starts&&r(a.starts,i);var c=a.c.map(function(e){return e.bK?"\\.?("+e.b+")\\.?":e.b}).concat([a.tE,a.i]).map(n).filter(Boolean);a.t=c.length?t(c.join("|"),!0):{exec:function(){return null}}}}r(e)}function f(e,t,a,i){function o(e,n){var t,a;for(t=0,a=n.c.length;a>t;t++)if(r(n.c[t].bR,e))return n.c[t]}function u(e,n){if(r(e.eR,n)){for(;e.endsParent&&e.parent;)e=e.parent;return e}return e.eW?u(e.parent,n):void 0}function c(e,n){return!a&&r(n.iR,e)}function l(e,n){var t=N.cI?n[0].toLowerCase():n[0];return e.k.hasOwnProperty(t)&&e.k[t]}function p(e,n,t,r){var a=r?"":I.classPrefix,i='<span class="'+a,o=t?"":C;return i+=e+'">',i+n+o}function h(){var e,t,r,a;if(!E.k)return n(k);for(a="",t=0,E.lR.lastIndex=0,r=E.lR.exec(k);r;)a+=n(k.substring(t,r.index)),e=l(E,r),e?(B+=e[1],a+=p(e[0],n(r[0]))):a+=n(r[0]),t=E.lR.lastIndex,r=E.lR.exec(k);return a+n(k.substr(t))}function d(){var e="string"==typeof E.sL;if(e&&!y[E.sL])return n(k);var t=e?f(E.sL,k,!0,x[E.sL]):g(k,E.sL.length?E.sL:void 0);return E.r>0&&(B+=t.r),e&&(x[E.sL]=t.top),p(t.language,t.value,!1,!0)}function b(){L+=null!=E.sL?d():h(),k=""}function v(e){L+=e.cN?p(e.cN,"",!0):"",E=Object.create(e,{parent:{value:E}})}function m(e,n){if(k+=e,null==n)return b(),0;var t=o(n,E);if(t)return t.skip?k+=n:(t.eB&&(k+=n),b(),t.rB||t.eB||(k=n)),v(t,n),t.rB?0:n.length;var r=u(E,n);if(r){var a=E;a.skip?k+=n:(a.rE||a.eE||(k+=n),b(),a.eE&&(k=n));do E.cN&&(L+=C),E.skip||(B+=E.r),E=E.parent;while(E!==r.parent);return r.starts&&v(r.starts,""),a.rE?0:n.length}if(c(n,E))throw new Error('Illegal lexeme "'+n+'" for mode "'+(E.cN||"<unnamed>")+'"');return k+=n,n.length||1}var N=w(e);if(!N)throw new Error('Unknown language: "'+e+'"');s(N);var R,E=i||N,x={},L="";for(R=E;R!==N;R=R.parent)R.cN&&(L=p(R.cN,"",!0)+L);var k="",B=0;try{for(var M,j,O=0;;){if(E.t.lastIndex=O,M=E.t.exec(t),!M)break;j=m(t.substring(O,M.index),M[0]),O=M.index+j}for(m(t.substr(O)),R=E;R.parent;R=R.parent)R.cN&&(L+=C);return{r:B,value:L,language:e,top:E}}catch(T){if(T.message&&-1!==T.message.indexOf("Illegal"))return{r:0,value:n(t)};throw T}}function g(e,t){t=t||I.languages||x(y);var r={r:0,value:n(e)},a=r;return t.filter(w).forEach(function(n){var t=f(n,e,!1);t.language=n,t.r>a.r&&(a=t),t.r>r.r&&(a=r,r=t)}),a.language&&(r.second_best=a),r}function p(e){return I.tabReplace||I.useBR?e.replace(M,function(e,n){return I.useBR&&"\n"===e?"<br>":I.tabReplace?n.replace(/\t/g,I.tabReplace):""}):e}function h(e,n,t){var r=n?L[n]:t,a=[e.trim()];return e.match(/\bhljs\b/)||a.push("hljs"),-1===e.indexOf(r)&&a.push(r),a.join(" ").trim()}function d(e){var n,t,r,o,l,s=i(e);a(s)||(I.useBR?(n=document.createElementNS("http://www.w3.org/1999/xhtml","div"),n.innerHTML=e.innerHTML.replace(/\n/g,"").replace(/<br[ \/]*>/g,"\n")):n=e,l=n.textContent,r=s?f(s,l,!0):g(l),t=u(n),t.length&&(o=document.createElementNS("http://www.w3.org/1999/xhtml","div"),o.innerHTML=r.value,r.value=c(t,u(o),l)),r.value=p(r.value),e.innerHTML=r.value,e.className=h(e.className,s,r.language),e.result={language:r.language,re:r.r},r.second_best&&(e.second_best={language:r.second_best.language,re:r.second_best.r}))}function b(e){I=o(I,e)}function v(){if(!v.called){v.called=!0;var e=document.querySelectorAll("pre code");E.forEach.call(e,d)}}function m(){addEventListener("DOMContentLoaded",v,!1),addEventListener("load",v,!1)}function N(n,t){var r=y[n]=t(e);r.aliases&&r.aliases.forEach(function(e){L[e]=n})}function R(){return x(y)}function w(e){return e=(e||"").toLowerCase(),y[e]||y[L[e]]}var E=[],x=Object.keys,y={},L={},k=/^(no-?highlight|plain|text)$/i,B=/\blang(?:uage)?-([\w-]+)\b/i,M=/((^(<[^>]+>|\t|)+|(?:\n)))/gm,C="</span>",I={classPrefix:"hljs-",tabReplace:null,useBR:!1,languages:void 0};return e.highlight=f,e.highlightAuto=g,e.fixMarkup=p,e.highlightBlock=d,e.configure=b,e.initHighlighting=v,e.initHighlightingOnLoad=m,e.registerLanguage=N,e.listLanguages=R,e.getLanguage=w,e.inherit=o,e.IR="[a-zA-Z]\\w*",e.UIR="[a-zA-Z_]\\w*",e.NR="\\b\\d+(\\.\\d+)?",e.CNR="(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",e.BNR="\\b(0b[01]+)",e.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",e.BE={b:"\\\\[\\s\\S]",r:0},e.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[e.BE]},e.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[e.BE]},e.PWM={b:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/},e.C=function(n,t,r){var a=e.inherit({cN:"comment",b:n,e:t,c:[]},r||{});return a.c.push(e.PWM),a.c.push({cN:"doctag",b:"(?:TODO|FIXME|NOTE|BUG|XXX):",r:0}),a},e.CLCM=e.C("//","$"),e.CBCM=e.C("/\\*","\\*/"),e.HCM=e.C("#","$"),e.NM={cN:"number",b:e.NR,r:0},e.CNM={cN:"number",b:e.CNR,r:0},e.BNM={cN:"number",b:e.BNR,r:0},e.CSSNM={cN:"number",b:e.NR+"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",r:0},e.RM={cN:"regexp",b:/\//,e:/\/[gimuy]*/,i:/\n/,c:[e.BE,{b:/\[/,e:/\]/,r:0,c:[e.BE]}]},e.TM={cN:"title",b:e.IR,r:0},e.UTM={cN:"title",b:e.UIR,r:0},e.METHOD_GUARD={b:"\\.\\s*"+e.UIR,r:0},e});hljs.registerLanguage("cpp",function(t){var e={cN:"keyword",b:"\\b[a-z\\d_]*_t\\b"},r={cN:"string",v:[{b:'(u8?|U)?L?"',e:'"',i:"\\n",c:[t.BE]},{b:'(u8?|U)?R"',e:'"',c:[t.BE]},{b:"'\\\\?.",e:"'",i:"."}]},s={cN:"number",v:[{b:"\\b(0b[01']+)"},{b:"(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)"},{b:"(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"}],r:0},i={cN:"meta",b:/#\s*[a-z]+\b/,e:/$/,k:{"meta-keyword":"if else elif endif define undef warning error line pragma ifdef ifndef include"},c:[{b:/\\\n/,r:0},t.inherit(r,{cN:"meta-string"}),{cN:"meta-string",b:/<[^\n>]*>/,e:/$/,i:"\\n"},t.CLCM,t.CBCM]},a=t.IR+"\\s*\\(",c={keyword:"int float while private char catch import module export virtual operator sizeof dynamic_cast|10 typedef const_cast|10 const for static_cast|10 union namespace unsigned long volatile static protected bool template mutable if public friend do goto auto void enum else break extern using asm case typeid short reinterpret_cast|10 default double register explicit signed typename try this switch continue inline delete alignof constexpr decltype noexcept static_assert thread_local restrict _Bool complex _Complex _Imaginary atomic_bool atomic_char atomic_schar atomic_uchar atomic_short atomic_ushort atomic_int atomic_uint atomic_long atomic_ulong atomic_llong atomic_ullong new throw return and or not",built_in:"std string cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap array shared_ptr abort abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr",literal:"true false nullptr NULL"},n=[e,t.CLCM,t.CBCM,s,r];return{aliases:["c","cc","h","c++","h++","hpp"],k:c,i:"</",c:n.concat([i,{b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:c,c:["self",e]},{b:t.IR+"::",k:c},{v:[{b:/=/,e:/;/},{b:/\(/,e:/\)/},{bK:"new throw return else",e:/;/}],k:c,c:n.concat([{b:/\(/,e:/\)/,k:c,c:n.concat(["self"]),r:0}]),r:0},{cN:"function",b:"("+t.IR+"[\\*&\\s]+)+"+a,rB:!0,e:/[{;=]/,eE:!0,k:c,i:/[^\w\s\*&]/,c:[{b:a,rB:!0,c:[t.TM],r:0},{cN:"params",b:/\(/,e:/\)/,k:c,r:0,c:[t.CLCM,t.CBCM,r,s,e]},t.CLCM,t.CBCM,i]},{cN:"class",bK:"class struct",e:/[{;:]/,c:[{b:/</,e:/>/,c:["self"]},t.TM]}]),exports:{preprocessor:i,strings:r,k:c}}});hljs.registerLanguage("llvm",function(e){var n="([-a-zA-Z$._][\\w\\-$.]*)";return{k:"begin end true false declare define global constant private linker_private internal available_externally linkonce linkonce_odr weak weak_odr appending dllimport dllexport common default hidden protected extern_weak external thread_local zeroinitializer undef null to tail target triple datalayout volatile nuw nsw nnan ninf nsz arcp fast exact inbounds align addrspace section alias module asm sideeffect gc dbg linker_private_weak attributes blockaddress initialexec localdynamic localexec prefix unnamed_addr ccc fastcc coldcc x86_stdcallcc x86_fastcallcc arm_apcscc arm_aapcscc arm_aapcs_vfpcc ptx_device ptx_kernel intel_ocl_bicc msp430_intrcc spir_func spir_kernel x86_64_sysvcc x86_64_win64cc x86_thiscallcc cc c signext zeroext inreg sret nounwind noreturn noalias nocapture byval nest readnone readonly inlinehint noinline alwaysinline optsize ssp sspreq noredzone noimplicitfloat naked builtin cold nobuiltin noduplicate nonlazybind optnone returns_twice sanitize_address sanitize_memory sanitize_thread sspstrong uwtable returned type opaque eq ne slt sgt sle sge ult ugt ule uge oeq one olt ogt ole oge ord uno ueq une x acq_rel acquire alignstack atomic catch cleanup filter inteldialect max min monotonic nand personality release seq_cst singlethread umax umin unordered xchg add fadd sub fsub mul fmul udiv sdiv fdiv urem srem frem shl lshr ashr and or xor icmp fcmp phi call trunc zext sext fptrunc fpext uitofp sitofp fptoui fptosi inttoptr ptrtoint bitcast addrspacecast select va_arg ret br switch invoke unwind unreachable indirectbr landingpad resume malloc alloca free load store getelementptr extractelement insertelement shufflevector getresult extractvalue insertvalue atomicrmw cmpxchg fence argmemonly double",c:[{cN:"keyword",b:"i\\d+"},e.C(";","\\n",{r:0}),e.QSM,{cN:"string",v:[{b:'"',e:'[^\\\\]"'}],r:0},{cN:"title",v:[{b:"@"+n},{b:"@\\d+"},{b:"!"+n},{b:"!\\d+"+n}]},{cN:"symbol",v:[{b:"%"+n},{b:"%\\d+"},{b:"#\\d+"}]},{cN:"number",v:[{b:"0[xX][a-fA-F0-9]+"},{b:"-?\\d+(?:[.]\\d+)?(?:[eE][-+]?\\d+(?:[.]\\d+)?)?"}],r:0}]}});hljs.registerLanguage("bash",function(e){var t={cN:"variable",v:[{b:/\$[\w\d#@][\w\d_]*/},{b:/\$\{(.*?)}/}]},s={cN:"string",b:/"/,e:/"/,c:[e.BE,t,{cN:"variable",b:/\$\(/,e:/\)/,c:[e.BE]}]},a={cN:"string",b:/'/,e:/'/};return{aliases:["sh","zsh"],l:/\b-?[a-z\._]+\b/,k:{keyword:"if then else elif fi for while in do done case esac function",literal:"true false",built_in:"break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp",_:"-ne -eq -lt -gt -f -d -e -s -l -a"},c:[{cN:"meta",b:/^#![^\n]+sh\s*$/,r:10},{cN:"function",b:/\w[\w\d_]*\s*\(\s*\)\s*\{/,rB:!0,c:[e.inherit(e.TM,{b:/\w[\w\d_]*/})],r:0},e.HCM,s,a,t]}});hljs.registerLanguage("shell",function(s){return{aliases:["console"],c:[{cN:"meta",b:"^\\s{0,3}[\\w\\d\\[\\]()@-]*[>%$#]",starts:{e:"$",sL:"bash"}}]}});
    </script>
    <script>
hljs.registerLanguage("zig", function(t) {
    var e = {
            cN: "keyword",
            b: "\\b[a-z\\d_]*_t\\b"
        },
        r = {
            cN: "string",
            v: [{
                b: '(u8?|U)?L?"',
                e: '"',
                i: "\\n",
                c: [t.BE]
            }, {
                b: '(u8?|U)?R"',
                e: '"',
                c: [t.BE]
            }, {
                b: "'\\\\?.",
                e: "'",
                i: "."
            }]
        },
        s = {
            cN: "number",
            v: [{
                b: "\\b(0b[01']+)"
            }, {
                b: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)"
            }, {
                b: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
            }],
            r: 0
        },
        i = {
            cN: "meta",
            b: /#\s*[a-z]+\b/,
            e: /$/,
            k: {
                "meta-keyword": "zzzzzzdisable"
            },
            c: [{
                b: /\\\n/,
                r: 0
            }, t.inherit(r, {
                cN: "meta-string"
            }), {
                cN: "meta-string",
                b: /<[^\n>]*>/,
                e: /$/,
                i: "\\n"
            }, t.CLCM, t.CBCM]
        },
        a = t.IR + "\\s*\\(",
        c = {
            keyword: "const align var extern stdcallcc nakedcc volatile export pub noalias inline struct packed enum union break return try catch test continue unreachable comptime and or asm defer errdefer if else switch while for fn use bool f32 f64 void type noreturn error i8 u8 i16 u16 i32 u32 i64 u64 isize usize i8w u8w i16w i32w u32w i64w u64w isizew usizew c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong",
            built_in: "breakpoint returnAddress frameAddress fieldParentPtr setFloatMode IntType OpaqueType compileError compileLog setCold setRuntimeSafety setEvalBranchQuota offsetOf memcpy inlineCall setGlobalLinkage setGlobalSection divTrunc divFloor enumTagName intToPtr ptrToInt panic canImplicitCast ptrCast bitCast rem mod memset sizeOf alignOf alignCast maxValue minValue memberCount memberName memberType typeOf addWithOverflow subWithOverflow mulWithOverflow shlWithOverflow shlExact shrExact cInclude cDefine cUndef ctz clz import cImport errorName embedFile cmpxchg fence divExact truncate atomicRmw",
            literal: "true false null undefined"
        },
        n = [e, t.CLCM, t.CBCM, s, r];
    return {
        aliases: ["c", "cc", "h", "c++", "h++", "hpp"],
        k: c,
        i: "</",
        c: n.concat([i, {
            b: "\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",
            e: ">",
            k: c,
            c: ["self", e]
        }, {
            b: t.IR + "::",
            k: c
        }, {
            v: [{
                b: /=/,
                e: /;/
            }, {
                b: /\(/,
                e: /\)/
            }, {
                bK: "new throw return else",
                e: /;/
            }],
            k: c,
            c: n.concat([{
                b: /\(/,
                e: /\)/,
                k: c,
                c: n.concat(["self"]),
                r: 0
            }]),
            r: 0
        }, {
            cN: "function",
            b: "(" + t.IR + "[\\*&\\s]+)+" + a,
            rB: !0,
            e: /[{;=]/,
            eE: !0,
            k: c,
            i: /[^\w\s\*&]/,
            c: [{
                b: a,
                rB: !0,
                c: [t.TM],
                r: 0
            }, {
                cN: "params",
                b: /\(/,
                e: /\)/,
                k: c,
                r: 0,
                c: [t.CLCM, t.CBCM, r, s, e]
            }, t.CLCM, t.CBCM, i]
        }, {
            cN: "class",
            bK: "class struct",
            e: /[{;:]/,
            c: [{
                b: /</,
                e: />/,
                c: ["self"]
            }, t.TM]
        }]),
        exports: {
            preprocessor: i,
            strings: r,
            k: c
        }
    }
});
    hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>

