<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentation - The Zig Programming Language</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
      }
      a:not(:hover) {
        text-decoration: none;
      }
      table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
      }
      th, td {
        padding: 0.1em;
      }
      .t0_1, .t37, .t37_1 {
        font-weight: bold;
      }
      .t2_0 {
        color: grey;
      }
      .t31_1 {
        color: red;
      }
      .t32_1 {
        color: green;
      }
      .t36_1 {
        color: #0086b3;
      }
      .file {
        text-decoration: underline;
      }
      pre,code {
        font-size: 12pt;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        color: #333;
        background: #f8f8f8;
      }
      .table-wrapper {
        width: 100%;
        overflow-y: auto;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      #main-wrapper {
        display: flex;
        flex-direction: column;
      }

      #contents-wrapper {
        flex-grow: 1;
        padding: 0 2em;
      }

      #contents {
        max-width: 60em;
        margin: auto;
      }

      #toc {
        padding: 0 1em;
      }

      @media screen and (min-width: 1025px) {
        #main-wrapper {
            flex-direction: row;
        }
        #toc {
            height: 100vh;
            position: sticky;
            top: 0;
        }
        #contents-wrapper, #toc {
            overflow: auto;
        }
      }

      h1 a, h2 a, h3 a, h4 a, h5 a {
        text-decoration: none;
        color: #333;
      }

      a.hdr {
        visibility: hidden;
      }
      h1:hover > a.hdr, h2:hover > a.hdr, h3:hover > a.hdr, h4:hover > a.hdr, h5:hover > a.hdr {
        visibility: visible;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background-color:#111;
            color: #bbb;
        }
        a {
            color: #88f;
        }
        table, th, td {
            border-color: grey;
        }
        .t2_0 {
            color: grey;
        }
        .t31_1 {
            color: red;
        }
        .t32_1 {
            color: green;
        }
        .t36_1 {
            color: #0086b3;
        }
        pre > code {
            color: #ccc;
            background: #222;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #e33;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
        h1 a, h2 a, h3 a, h4 a, h5 a {
            color: #aaa;
        }
      }
    </style>
  </head>
  <body>
    <div id="main-wrapper">
      <div id="toc">
        <a href="https://ziglang.org/documentation/0.1.1/">0.1.1</a> |
        <a href="https://ziglang.org/documentation/0.2.0/">0.2.0</a> |
        <a href="https://ziglang.org/documentation/0.3.0/">0.3.0</a> |
        <a href="https://ziglang.org/documentation/0.4.0/">0.4.0</a> |
        <a href="https://ziglang.org/documentation/0.5.0/">0.5.0</a> |
        <a href="https://ziglang.org/documentation/0.6.0/">0.6.0</a> |
        <a href="https://ziglang.org/documentation/0.7.0/">0.7.0</a> |
        master
        <h1>Contents</h1>
        

    <ul>
        <li><a id="toc-Introduction" href="#Introduction">Introduction</a></li>
        <li><a id="toc-Hello-World" href="#Hello-World">Hello World</a></li>
        <li><a id="toc-Comments" href="#Comments">Comments</a>
        <ul>
            <li><a id="toc-Doc-comments" href="#Doc-comments">Doc comments</a></li>
            <li><a id="toc-Top-Level-Doc-Comments" href="#Top-Level-Doc-Comments">Top-Level Doc Comments</a></li>
        </ul></li>
        <li><a id="toc-Values" href="#Values">Values</a>
        <ul>
            <li><a id="toc-Primitive-Types" href="#Primitive-Types">Primitive Types</a></li>
            <li><a id="toc-Primitive-Values" href="#Primitive-Values">Primitive Values</a></li>
            <li><a id="toc-String-Literals-and-Unicode-Code-Point-Literals" href="#String-Literals-and-Unicode-Code-Point-Literals">String Literals and Unicode Code Point Literals</a>
            <ul>
                <li><a id="toc-Escape-Sequences" href="#Escape-Sequences">Escape Sequences</a></li>
                <li><a id="toc-Multiline-String-Literals" href="#Multiline-String-Literals">Multiline String Literals</a></li>
            </ul></li>
            <li><a id="toc-Assignment" href="#Assignment">Assignment</a>
            <ul>
                <li><a id="toc-undefined" href="#undefined">undefined</a></li>
            </ul></li>
        </ul></li>
        <li><a id="toc-Variables" href="#Variables">Variables</a>
        <ul>
            <li><a id="toc-Global-Variables" href="#Global-Variables">Global Variables</a></li>
            <li><a id="toc-Thread-Local-Variables" href="#Thread-Local-Variables">Thread Local Variables</a></li>
            <li><a id="toc-Local-Variables" href="#Local-Variables">Local Variables</a></li>
        </ul></li>
        <li><a id="toc-Integers" href="#Integers">Integers</a>
        <ul>
            <li><a id="toc-Integer-Literals" href="#Integer-Literals">Integer Literals</a></li>
            <li><a id="toc-Runtime-Integer-Values" href="#Runtime-Integer-Values">Runtime Integer Values</a></li>
        </ul></li>
        <li><a id="toc-Floats" href="#Floats">Floats</a>
        <ul>
            <li><a id="toc-Float-Literals" href="#Float-Literals">Float Literals</a></li>
            <li><a id="toc-Floating-Point-Operations" href="#Floating-Point-Operations">Floating Point Operations</a></li>
        </ul></li>
        <li><a id="toc-Operators" href="#Operators">Operators</a>
        <ul>
            <li><a id="toc-Table-of-Operators" href="#Table-of-Operators">Table of Operators</a></li>
            <li><a id="toc-Precedence" href="#Precedence">Precedence</a></li>
        </ul></li>
        <li><a id="toc-Arrays" href="#Arrays">Arrays</a>
        <ul>
            <li><a id="toc-Anonymous-List-Literals" href="#Anonymous-List-Literals">Anonymous List Literals</a></li>
            <li><a id="toc-Multidimensional-Arrays" href="#Multidimensional-Arrays">Multidimensional Arrays</a></li>
            <li><a id="toc-Sentinel-Terminated-Arrays" href="#Sentinel-Terminated-Arrays">Sentinel-Terminated Arrays</a></li>
        </ul></li>
        <li><a id="toc-Vectors" href="#Vectors">Vectors</a>
        <ul>
            <li><a id="toc-SIMD" href="#SIMD">SIMD</a></li>
        </ul></li>
        <li><a id="toc-Pointers" href="#Pointers">Pointers</a>
        <ul>
            <li><a id="toc-volatile" href="#volatile">volatile</a></li>
            <li><a id="toc-Alignment" href="#Alignment">Alignment</a></li>
            <li><a id="toc-allowzero" href="#allowzero">allowzero</a></li>
            <li><a id="toc-Sentinel-Terminated-Pointers" href="#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a></li>
        </ul></li>
        <li><a id="toc-Slices" href="#Slices">Slices</a>
        <ul>
            <li><a id="toc-Sentinel-Terminated-Slices" href="#Sentinel-Terminated-Slices">Sentinel-Terminated Slices</a></li>
        </ul></li>
        <li><a id="toc-struct" href="#struct">struct</a>
        <ul>
            <li><a id="toc-Default-Field-Values" href="#Default-Field-Values">Default Field Values</a></li>
            <li><a id="toc-extern-struct" href="#extern-struct">extern struct</a></li>
            <li><a id="toc-packed-struct" href="#packed-struct">packed struct</a></li>
            <li><a id="toc-Struct-Naming" href="#Struct-Naming">Struct Naming</a></li>
            <li><a id="toc-Anonymous-Struct-Literals" href="#Anonymous-Struct-Literals">Anonymous Struct Literals</a></li>
        </ul></li>
        <li><a id="toc-enum" href="#enum">enum</a>
        <ul>
            <li><a id="toc-extern-enum" href="#extern-enum">extern enum</a></li>
            <li><a id="toc-packed-enum" href="#packed-enum">packed enum</a></li>
            <li><a id="toc-Enum-Literals" href="#Enum-Literals">Enum Literals</a></li>
            <li><a id="toc-Non-exhaustive-enum" href="#Non-exhaustive-enum">Non-exhaustive enum</a></li>
        </ul></li>
        <li><a id="toc-union" href="#union">union</a>
        <ul>
            <li><a id="toc-Tagged-union" href="#Tagged-union">Tagged union</a></li>
            <li><a id="toc-extern-union" href="#extern-union">extern union</a></li>
            <li><a id="toc-packed-union" href="#packed-union">packed union</a></li>
            <li><a id="toc-Anonymous-Union-Literals" href="#Anonymous-Union-Literals">Anonymous Union Literals</a></li>
        </ul></li>
        <li><a id="toc-opaque" href="#opaque">opaque</a></li>
        <li><a id="toc-blocks" href="#blocks">blocks</a>
        <ul>
            <li><a id="toc-Shadowing" href="#Shadowing">Shadowing</a></li>
        </ul></li>
        <li><a id="toc-switch" href="#switch">switch</a>
        <ul>
            <li><a id="toc-Exhaustive-Switching" href="#Exhaustive-Switching">Exhaustive Switching</a></li>
            <li><a id="toc-Switching-with-Enum-Literals" href="#Switching-with-Enum-Literals">Switching with Enum Literals</a></li>
        </ul></li>
        <li><a id="toc-while" href="#while">while</a>
        <ul>
            <li><a id="toc-Labeled-while" href="#Labeled-while">Labeled while</a></li>
            <li><a id="toc-while-with-Optionals" href="#while-with-Optionals">while with Optionals</a></li>
            <li><a id="toc-while-with-Error-Unions" href="#while-with-Error-Unions">while with Error Unions</a></li>
            <li><a id="toc-inline-while" href="#inline-while">inline while</a></li>
        </ul></li>
        <li><a id="toc-for" href="#for">for</a>
        <ul>
            <li><a id="toc-Labeled-for" href="#Labeled-for">Labeled for</a></li>
            <li><a id="toc-inline-for" href="#inline-for">inline for</a></li>
        </ul></li>
        <li><a id="toc-if" href="#if">if</a></li>
        <li><a id="toc-defer" href="#defer">defer</a></li>
        <li><a id="toc-unreachable" href="#unreachable">unreachable</a>
        <ul>
            <li><a id="toc-Basics" href="#Basics">Basics</a></li>
            <li><a id="toc-At-Compile-Time" href="#At-Compile-Time">At Compile-Time</a></li>
        </ul></li>
        <li><a id="toc-noreturn" href="#noreturn">noreturn</a></li>
        <li><a id="toc-Functions" href="#Functions">Functions</a>
        <ul>
            <li><a id="toc-Pass-by-value-Parameters" href="#Pass-by-value-Parameters">Pass-by-value Parameters</a></li>
            <li><a id="toc-Function-Parameter-Type-Inference" href="#Function-Parameter-Type-Inference">Function Parameter Type Inference</a></li>
            <li><a id="toc-Function-Reflection" href="#Function-Reflection">Function Reflection</a></li>
        </ul></li>
        <li><a id="toc-Errors" href="#Errors">Errors</a>
        <ul>
            <li><a id="toc-Error-Set-Type" href="#Error-Set-Type">Error Set Type</a>
            <ul>
                <li><a id="toc-The-Global-Error-Set" href="#The-Global-Error-Set">The Global Error Set</a></li>
            </ul></li>
            <li><a id="toc-Error-Union-Type" href="#Error-Union-Type">Error Union Type</a>
            <ul>
                <li><a id="toc-catch" href="#catch">catch</a></li>
                <li><a id="toc-try" href="#try">try</a></li>
                <li><a id="toc-errdefer" href="#errdefer">errdefer</a></li>
                <li><a id="toc-Merging-Error-Sets" href="#Merging-Error-Sets">Merging Error Sets</a></li>
                <li><a id="toc-Inferred-Error-Sets" href="#Inferred-Error-Sets">Inferred Error Sets</a></li>
            </ul></li>
            <li><a id="toc-Error-Return-Traces" href="#Error-Return-Traces">Error Return Traces</a>
            <ul>
                <li><a id="toc-Implementation-Details" href="#Implementation-Details">Implementation Details</a></li>
            </ul></li>
        </ul></li>
        <li><a id="toc-Optionals" href="#Optionals">Optionals</a>
        <ul>
            <li><a id="toc-Optional-Type" href="#Optional-Type">Optional Type</a></li>
            <li><a id="toc-null" href="#null">null</a></li>
            <li><a id="toc-Optional-Pointers" href="#Optional-Pointers">Optional Pointers</a></li>
        </ul></li>
        <li><a id="toc-Casting" href="#Casting">Casting</a>
        <ul>
            <li><a id="toc-Type-Coercion" href="#Type-Coercion">Type Coercion</a>
            <ul>
                <li><a id="toc-Type-Coercion-Stricter-Qualification" href="#Type-Coercion-Stricter-Qualification">Type Coercion: Stricter Qualification</a></li>
                <li><a id="toc-Type-Coercion-Integer-and-Float-Widening" href="#Type-Coercion-Integer-and-Float-Widening">Type Coercion: Integer and Float Widening</a></li>
                <li><a id="toc-Type-Coercion-Coercion-Float-to-Int" href="#Type-Coercion-Coercion-Float-to-Int">Type Coercion: Coercion Float to Int</a></li>
                <li><a id="toc-Type-Coercion-Arrays-and-Pointers" href="#Type-Coercion-Arrays-and-Pointers">Type Coercion: Arrays and Pointers</a></li>
                <li><a id="toc-Type-Coercion-Optionals" href="#Type-Coercion-Optionals">Type Coercion: Optionals</a></li>
                <li><a id="toc-Type-Coercion-Error-Unions" href="#Type-Coercion-Error-Unions">Type Coercion: Error Unions</a></li>
                <li><a id="toc-Type-Coercion-Compile-Time-Known-Numbers" href="#Type-Coercion-Compile-Time-Known-Numbers">Type Coercion: Compile-Time Known Numbers</a></li>
                <li><a id="toc-Type-Coercion-unions-and-enums" href="#Type-Coercion-unions-and-enums">Type Coercion: unions and enums</a></li>
                <li><a id="toc-Type-Coercion-Zero-Bit-Types" href="#Type-Coercion-Zero-Bit-Types">Type Coercion: Zero Bit Types</a></li>
                <li><a id="toc-Type-Coercion-undefined" href="#Type-Coercion-undefined">Type Coercion: undefined</a></li>
            </ul></li>
            <li><a id="toc-Explicit-Casts" href="#Explicit-Casts">Explicit Casts</a></li>
            <li><a id="toc-Peer-Type-Resolution" href="#Peer-Type-Resolution">Peer Type Resolution</a></li>
        </ul></li>
        <li><a id="toc-Zero-Bit-Types" href="#Zero-Bit-Types">Zero Bit Types</a>
        <ul>
            <li><a id="toc-void" href="#void">void</a></li>
            <li><a id="toc-Pointers-to-Zero-Bit-Types" href="#Pointers-to-Zero-Bit-Types">Pointers to Zero Bit Types</a></li>
        </ul></li>
        <li><a id="toc-Result-Location-Semantics" href="#Result-Location-Semantics">Result Location Semantics</a></li>
        <li><a id="toc-usingnamespace" href="#usingnamespace">usingnamespace</a></li>
        <li><a id="toc-comptime" href="#comptime">comptime</a>
        <ul>
            <li><a id="toc-Introducing-the-Compile-Time-Concept" href="#Introducing-the-Compile-Time-Concept">Introducing the Compile-Time Concept</a>
            <ul>
                <li><a id="toc-Compile-Time-Parameters" href="#Compile-Time-Parameters">Compile-Time Parameters</a></li>
                <li><a id="toc-Compile-Time-Variables" href="#Compile-Time-Variables">Compile-Time Variables</a></li>
                <li><a id="toc-Compile-Time-Expressions" href="#Compile-Time-Expressions">Compile-Time Expressions</a></li>
            </ul></li>
            <li><a id="toc-Generic-Data-Structures" href="#Generic-Data-Structures">Generic Data Structures</a></li>
            <li><a id="toc-Case-Study-printf-in-Zig" href="#Case-Study-printf-in-Zig">Case Study: printf in Zig</a></li>
        </ul></li>
        <li><a id="toc-Assembly" href="#Assembly">Assembly</a>
        <ul>
            <li><a id="toc-Output-Constraints" href="#Output-Constraints">Output Constraints</a></li>
            <li><a id="toc-Input-Constraints" href="#Input-Constraints">Input Constraints</a></li>
            <li><a id="toc-Clobbers" href="#Clobbers">Clobbers</a></li>
            <li><a id="toc-Global-Assembly" href="#Global-Assembly">Global Assembly</a></li>
        </ul></li>
        <li><a id="toc-Atomics" href="#Atomics">Atomics</a></li>
        <li><a id="toc-Async-Functions" href="#Async-Functions">Async Functions</a>
        <ul>
            <li><a id="toc-Suspend-and-Resume" href="#Suspend-and-Resume">Suspend and Resume</a>
            <ul>
                <li><a id="toc-Resuming-from-Suspend-Blocks" href="#Resuming-from-Suspend-Blocks">Resuming from Suspend Blocks</a></li>
            </ul></li>
            <li><a id="toc-Async-and-Await" href="#Async-and-Await">Async and Await</a></li>
            <li><a id="toc-Async-Function-Example" href="#Async-Function-Example">Async Function Example</a></li>
        </ul></li>
        <li><a id="toc-Builtin-Functions" href="#Builtin-Functions">Builtin Functions</a>
        <ul style="columns: 2">
            <li><a id="toc-addWithOverflow" href="#addWithOverflow">@addWithOverflow</a></li>
            <li><a id="toc-alignCast" href="#alignCast">@alignCast</a></li>
            <li><a id="toc-alignOf" href="#alignOf">@alignOf</a></li>
            <li><a id="toc-as" href="#as">@as</a></li>
            <li><a id="toc-asyncCall" href="#asyncCall">@asyncCall</a></li>
            <li><a id="toc-atomicLoad" href="#atomicLoad">@atomicLoad</a></li>
            <li><a id="toc-atomicRmw" href="#atomicRmw">@atomicRmw</a></li>
            <li><a id="toc-atomicStore" href="#atomicStore">@atomicStore</a></li>
            <li><a id="toc-bitCast" href="#bitCast">@bitCast</a></li>
            <li><a id="toc-bitOffsetOf" href="#bitOffsetOf">@bitOffsetOf</a></li>
            <li><a id="toc-boolToInt" href="#boolToInt">@boolToInt</a></li>
            <li><a id="toc-bitSizeOf" href="#bitSizeOf">@bitSizeOf</a></li>
            <li><a id="toc-breakpoint" href="#breakpoint">@breakpoint</a></li>
            <li><a id="toc-mulAdd" href="#mulAdd">@mulAdd</a></li>
            <li><a id="toc-byteSwap" href="#byteSwap">@byteSwap</a></li>
            <li><a id="toc-bitReverse" href="#bitReverse">@bitReverse</a></li>
            <li><a id="toc-byteOffsetOf" href="#byteOffsetOf">@byteOffsetOf</a></li>
            <li><a id="toc-call" href="#call">@call</a></li>
            <li><a id="toc-cDefine" href="#cDefine">@cDefine</a></li>
            <li><a id="toc-cImport" href="#cImport">@cImport</a></li>
            <li><a id="toc-cInclude" href="#cInclude">@cInclude</a></li>
            <li><a id="toc-clz" href="#clz">@clz</a></li>
            <li><a id="toc-cmpxchgStrong" href="#cmpxchgStrong">@cmpxchgStrong</a></li>
            <li><a id="toc-cmpxchgWeak" href="#cmpxchgWeak">@cmpxchgWeak</a></li>
            <li><a id="toc-compileError" href="#compileError">@compileError</a></li>
            <li><a id="toc-compileLog" href="#compileLog">@compileLog</a></li>
            <li><a id="toc-ctz" href="#ctz">@ctz</a></li>
            <li><a id="toc-cUndef" href="#cUndef">@cUndef</a></li>
            <li><a id="toc-divExact" href="#divExact">@divExact</a></li>
            <li><a id="toc-divFloor" href="#divFloor">@divFloor</a></li>
            <li><a id="toc-divTrunc" href="#divTrunc">@divTrunc</a></li>
            <li><a id="toc-embedFile" href="#embedFile">@embedFile</a></li>
            <li><a id="toc-enumToInt" href="#enumToInt">@enumToInt</a></li>
            <li><a id="toc-errorName" href="#errorName">@errorName</a></li>
            <li><a id="toc-errorReturnTrace" href="#errorReturnTrace">@errorReturnTrace</a></li>
            <li><a id="toc-errorToInt" href="#errorToInt">@errorToInt</a></li>
            <li><a id="toc-errSetCast" href="#errSetCast">@errSetCast</a></li>
            <li><a id="toc-export" href="#export">@export</a></li>
            <li><a id="toc-fence" href="#fence">@fence</a></li>
            <li><a id="toc-field" href="#field">@field</a></li>
            <li><a id="toc-fieldParentPtr" href="#fieldParentPtr">@fieldParentPtr</a></li>
            <li><a id="toc-floatCast" href="#floatCast">@floatCast</a></li>
            <li><a id="toc-floatToInt" href="#floatToInt">@floatToInt</a></li>
            <li><a id="toc-frame" href="#frame">@frame</a></li>
            <li><a id="toc-Frame" href="#Frame">@Frame</a></li>
            <li><a id="toc-frameAddress" href="#frameAddress">@frameAddress</a></li>
            <li><a id="toc-frameSize" href="#frameSize">@frameSize</a></li>
            <li><a id="toc-hasDecl" href="#hasDecl">@hasDecl</a></li>
            <li><a id="toc-hasField" href="#hasField">@hasField</a></li>
            <li><a id="toc-import" href="#import">@import</a></li>
            <li><a id="toc-intCast" href="#intCast">@intCast</a></li>
            <li><a id="toc-intToEnum" href="#intToEnum">@intToEnum</a></li>
            <li><a id="toc-intToError" href="#intToError">@intToError</a></li>
            <li><a id="toc-intToFloat" href="#intToFloat">@intToFloat</a></li>
            <li><a id="toc-intToPtr" href="#intToPtr">@intToPtr</a></li>
            <li><a id="toc-memcpy" href="#memcpy">@memcpy</a></li>
            <li><a id="toc-memset" href="#memset">@memset</a></li>
            <li><a id="toc-wasmMemorySize" href="#wasmMemorySize">@wasmMemorySize</a></li>
            <li><a id="toc-wasmMemoryGrow" href="#wasmMemoryGrow">@wasmMemoryGrow</a></li>
            <li><a id="toc-mod" href="#mod">@mod</a></li>
            <li><a id="toc-mulWithOverflow" href="#mulWithOverflow">@mulWithOverflow</a></li>
            <li><a id="toc-panic" href="#panic">@panic</a></li>
            <li><a id="toc-popCount" href="#popCount">@popCount</a></li>
            <li><a id="toc-ptrCast" href="#ptrCast">@ptrCast</a></li>
            <li><a id="toc-ptrToInt" href="#ptrToInt">@ptrToInt</a></li>
            <li><a id="toc-rem" href="#rem">@rem</a></li>
            <li><a id="toc-returnAddress" href="#returnAddress">@returnAddress</a></li>
            <li><a id="toc-setAlignStack" href="#setAlignStack">@setAlignStack</a></li>
            <li><a id="toc-setCold" href="#setCold">@setCold</a></li>
            <li><a id="toc-setEvalBranchQuota" href="#setEvalBranchQuota">@setEvalBranchQuota</a></li>
            <li><a id="toc-setFloatMode" href="#setFloatMode">@setFloatMode</a></li>
            <li><a id="toc-setRuntimeSafety" href="#setRuntimeSafety">@setRuntimeSafety</a></li>
            <li><a id="toc-shlExact" href="#shlExact">@shlExact</a></li>
            <li><a id="toc-shlWithOverflow" href="#shlWithOverflow">@shlWithOverflow</a></li>
            <li><a id="toc-shrExact" href="#shrExact">@shrExact</a></li>
            <li><a id="toc-shuffle" href="#shuffle">@shuffle</a></li>
            <li><a id="toc-sizeOf" href="#sizeOf">@sizeOf</a></li>
            <li><a id="toc-splat" href="#splat">@splat</a></li>
            <li><a id="toc-reduce" href="#reduce">@reduce</a></li>
            <li><a id="toc-src" href="#src">@src</a></li>
            <li><a id="toc-sqrt" href="#sqrt">@sqrt</a></li>
            <li><a id="toc-sin" href="#sin">@sin</a></li>
            <li><a id="toc-cos" href="#cos">@cos</a></li>
            <li><a id="toc-exp" href="#exp">@exp</a></li>
            <li><a id="toc-exp2" href="#exp2">@exp2</a></li>
            <li><a id="toc-log" href="#log">@log</a></li>
            <li><a id="toc-log2" href="#log2">@log2</a></li>
            <li><a id="toc-log10" href="#log10">@log10</a></li>
            <li><a id="toc-fabs" href="#fabs">@fabs</a></li>
            <li><a id="toc-floor" href="#floor">@floor</a></li>
            <li><a id="toc-ceil" href="#ceil">@ceil</a></li>
            <li><a id="toc-trunc" href="#trunc">@trunc</a></li>
            <li><a id="toc-round" href="#round">@round</a></li>
            <li><a id="toc-subWithOverflow" href="#subWithOverflow">@subWithOverflow</a></li>
            <li><a id="toc-tagName" href="#tagName">@tagName</a></li>
            <li><a id="toc-This" href="#This">@This</a></li>
            <li><a id="toc-truncate" href="#truncate">@truncate</a></li>
            <li><a id="toc-Type" href="#Type">@Type</a></li>
            <li><a id="toc-typeInfo" href="#typeInfo">@typeInfo</a></li>
            <li><a id="toc-typeName" href="#typeName">@typeName</a></li>
            <li><a id="toc-TypeOf" href="#TypeOf">@TypeOf</a></li>
            <li><a id="toc-unionInit" href="#unionInit">@unionInit</a></li>
        </ul></li>
        <li><a id="toc-Build-Mode" href="#Build-Mode">Build Mode</a>
        <ul>
            <li><a id="toc-Debug" href="#Debug">Debug</a></li>
            <li><a id="toc-ReleaseFast" href="#ReleaseFast">ReleaseFast</a></li>
            <li><a id="toc-ReleaseSafe" href="#ReleaseSafe">ReleaseSafe</a></li>
            <li><a id="toc-ReleaseSmall" href="#ReleaseSmall">ReleaseSmall</a></li>
        </ul></li>
        <li><a id="toc-Single-Threaded-Builds" href="#Single-Threaded-Builds">Single Threaded Builds</a></li>
        <li><a id="toc-Undefined-Behavior" href="#Undefined-Behavior">Undefined Behavior</a>
        <ul>
            <li><a id="toc-Reaching-Unreachable-Code" href="#Reaching-Unreachable-Code">Reaching Unreachable Code</a></li>
            <li><a id="toc-Index-out-of-Bounds" href="#Index-out-of-Bounds">Index out of Bounds</a></li>
            <li><a id="toc-Cast-Negative-Number-to-Unsigned-Integer" href="#Cast-Negative-Number-to-Unsigned-Integer">Cast Negative Number to Unsigned Integer</a></li>
            <li><a id="toc-Cast-Truncates-Data" href="#Cast-Truncates-Data">Cast Truncates Data</a></li>
            <li><a id="toc-Integer-Overflow" href="#Integer-Overflow">Integer Overflow</a>
            <ul>
                <li><a id="toc-Default-Operations" href="#Default-Operations">Default Operations</a></li>
                <li><a id="toc-Standard-Library-Math-Functions" href="#Standard-Library-Math-Functions">Standard Library Math Functions</a></li>
                <li><a id="toc-Builtin-Overflow-Functions" href="#Builtin-Overflow-Functions">Builtin Overflow Functions</a></li>
                <li><a id="toc-Wrapping-Operations" href="#Wrapping-Operations">Wrapping Operations</a></li>
            </ul></li>
            <li><a id="toc-Exact-Left-Shift-Overflow" href="#Exact-Left-Shift-Overflow">Exact Left Shift Overflow</a></li>
            <li><a id="toc-Exact-Right-Shift-Overflow" href="#Exact-Right-Shift-Overflow">Exact Right Shift Overflow</a></li>
            <li><a id="toc-Division-by-Zero" href="#Division-by-Zero">Division by Zero</a></li>
            <li><a id="toc-Remainder-Division-by-Zero" href="#Remainder-Division-by-Zero">Remainder Division by Zero</a></li>
            <li><a id="toc-Exact-Division-Remainder" href="#Exact-Division-Remainder">Exact Division Remainder</a></li>
            <li><a id="toc-Attempt-to-Unwrap-Null" href="#Attempt-to-Unwrap-Null">Attempt to Unwrap Null</a></li>
            <li><a id="toc-Attempt-to-Unwrap-Error" href="#Attempt-to-Unwrap-Error">Attempt to Unwrap Error</a></li>
            <li><a id="toc-Invalid-Error-Code" href="#Invalid-Error-Code">Invalid Error Code</a></li>
            <li><a id="toc-Invalid-Enum-Cast" href="#Invalid-Enum-Cast">Invalid Enum Cast</a></li>
            <li><a id="toc-Invalid-Error-Set-Cast" href="#Invalid-Error-Set-Cast">Invalid Error Set Cast</a></li>
            <li><a id="toc-Incorrect-Pointer-Alignment" href="#Incorrect-Pointer-Alignment">Incorrect Pointer Alignment</a></li>
            <li><a id="toc-Wrong-Union-Field-Access" href="#Wrong-Union-Field-Access">Wrong Union Field Access</a></li>
            <li><a id="toc-Out-of-Bounds-Float-to-Integer-Cast" href="#Out-of-Bounds-Float-to-Integer-Cast">Out of Bounds Float to Integer Cast</a></li>
            <li><a id="toc-Pointer-Cast-Invalid-Null" href="#Pointer-Cast-Invalid-Null">Pointer Cast Invalid Null</a></li>
        </ul></li>
        <li><a id="toc-Memory" href="#Memory">Memory</a>
        <ul>
            <li><a id="toc-Choosing-an-Allocator" href="#Choosing-an-Allocator">Choosing an Allocator</a></li>
            <li><a id="toc-Where-are-the-bytes" href="#Where-are-the-bytes">Where are the bytes?</a></li>
            <li><a id="toc-Implementing-an-Allocator" href="#Implementing-an-Allocator">Implementing an Allocator</a></li>
            <li><a id="toc-Heap-Allocation-Failure" href="#Heap-Allocation-Failure">Heap Allocation Failure</a></li>
            <li><a id="toc-Recursion" href="#Recursion">Recursion</a></li>
            <li><a id="toc-Lifetime-and-Ownership" href="#Lifetime-and-Ownership">Lifetime and Ownership</a></li>
        </ul></li>
        <li><a id="toc-Compile-Variables" href="#Compile-Variables">Compile Variables</a></li>
        <li><a id="toc-Root-Source-File" href="#Root-Source-File">Root Source File</a></li>
        <li><a id="toc-Zig-Test" href="#Zig-Test">Zig Test</a></li>
        <li><a id="toc-Zig-Build-System" href="#Zig-Build-System">Zig Build System</a>
        <ul>
            <li><a id="toc-Building-an-Executable" href="#Building-an-Executable">Building an Executable</a></li>
            <li><a id="toc-Building-a-Library" href="#Building-a-Library">Building a Library</a></li>
            <li><a id="toc-Compiling-C-Source-Code" href="#Compiling-C-Source-Code">Compiling C Source Code</a></li>
        </ul></li>
        <li><a id="toc-C" href="#C">C</a>
        <ul>
            <li><a id="toc-C-Type-Primitives" href="#C-Type-Primitives">C Type Primitives</a></li>
            <li><a id="toc-Import-from-C-Header-File" href="#Import-from-C-Header-File">Import from C Header File</a></li>
            <li><a id="toc-C-Pointers" href="#C-Pointers">C Pointers</a></li>
            <li><a id="toc-Exporting-a-C-Library" href="#Exporting-a-C-Library">Exporting a C Library</a></li>
            <li><a id="toc-Mixing-Object-Files" href="#Mixing-Object-Files">Mixing Object Files</a></li>
        </ul></li>
        <li><a id="toc-WebAssembly" href="#WebAssembly">WebAssembly</a>
        <ul>
            <li><a id="toc-Freestanding" href="#Freestanding">Freestanding</a></li>
            <li><a id="toc-WASI" href="#WASI">WASI</a></li>
        </ul></li>
        <li><a id="toc-Targets" href="#Targets">Targets</a></li>
        <li><a id="toc-Style-Guide" href="#Style-Guide">Style Guide</a>
        <ul>
            <li><a id="toc-Whitespace" href="#Whitespace">Whitespace</a></li>
            <li><a id="toc-Names" href="#Names">Names</a></li>
            <li><a id="toc-Examples" href="#Examples">Examples</a></li>
        </ul></li>
        <li><a id="toc-Source-Encoding" href="#Source-Encoding">Source Encoding</a></li>
        <li><a id="toc-Keyword-Reference" href="#Keyword-Reference">Keyword Reference</a></li>
        <li><a id="toc-Grammar" href="#Grammar">Grammar</a></li>
        <li><a id="toc-Zen" href="#Zen">Zen</a></li>
    </ul>

      </div>
      <div id="contents-wrapper"><div id="contents">
      <h1 id="Introduction"><a href="#toc-Introduction">Introduction</a> <a class="hdr" href="#Introduction">§</a></h1>

      <p>
      Zig is a general-purpose programming language and toolchain for maintaining
      <strong>robust</strong>, <strong>optimal</strong>, and <strong>reusable</strong> software.
      </p>
      <ul>
        <li><strong>Robust</strong> - behavior is correct even for edge cases such as out of memory.</li>
        <li><strong>Optimal</strong> - write programs the best way they can behave and perform.</li>
        <li><strong>Reusable</strong> - the same code works in many environments which have different
          constraints.</li>
        <li><strong>Maintainable</strong> - precisely communicate intent to the compiler and
          other programmers. The language imposes a low overhead to reading code and is
          resilient to changing requirements and environments.</li>
      </ul>
      <p>
      Often the most efficient way to learn something new is to see examples, so
      this documentation shows how to use each of Zig's features. It is
      all on one page so you can search with your browser's search tool.
      </p>
      <p>
      If you search for something specific in this documentation and do not find it,
      please <a href="https://github.com/ziglang/www.ziglang.org/issues/new?title=I%20searched%20for%20___%20in%20the%20docs%20and%20didn%27t%20find%20it">file an issue</a> or <a href="https://webchat.freenode.net/?channels=%23zig">say something on IRC</a>.
      </p>
      <p>
      The code samples in this document are compiled and tested as part of the main test suite of Zig.
      </p>
      <p>
      This HTML document depends on no external files, so you can use it offline.
      </p>
      <p>
      <a href="https://github.com/ziglang/zig/wiki/FAQ#where-is-the-documentation-for-the-zig-standard-library">Where is the documentation for the Zig standard library?</a>
      </p>
      

      <h1 id="Hello-World"><a href="#toc-Hello-World">Hello World</a> <a class="hdr" href="#Hello-World">§</a></h1>


      <p class="file">hello.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> stdout = std.io.getStdOut().writer();
    <span class="tok-kw">try</span> stdout.print(<span class="tok-str">&quot;Hello, {s}!\n&quot;</span>, .{<span class="tok-str">&quot;world&quot;</span>});
}</code></pre><pre><code class="shell">$ zig build-exe hello.zig
$ ./hello
Hello, world!
</code></pre>

      <p>
        The Zig code sample above demonstrates one way to create a program that will output <code>Hello, world!</code>.
      </p>
      <p>
        The code sample shows the contents of a file named <code>hello.zig</code>. Files storing Zig
        source code are <a href="#Source-Encoding">UTF-8 encoded</a> text files. The files storing
        Zig source code are usually named with the <code>.zig</code> extension.
      </p>
      <p>
        Following the <code>hello.zig</code> Zig code sample, the <a href="#Zig-Build-System">Zig Build System</a> is used
        to build an executable program from the <code>hello.zig</code> source code. Then, the
        <code>hello</code> program is executed showing its output <code>Hello, world!</code>. The
        lines beginning with <code>$</code> represent command line prompts and a command.
        Everything else is program output.
      </p>
      <p>
        The code sample begins by adding Zig's Standard Library to the build using the <a href="#import">@import</a> builtin function.
        The <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>)</code> function call creates a structure to represent the Standard Library.
        The code then makes a <a href="#Global-Variables">top-level declaration</a> of a
        <a href="#Assignment">constant identifier</a>, named <code>std</code>, for easy access to
        <a href="https://github.com/ziglang/zig/wiki/FAQ#where-is-the-documentation-for-the-zig-standard-library">Zig's standard library</a>.
      </p>
      <p>
        Next, a <a href="#Functions">public function</a>, <code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span></code>, named <code>main</code>
        is declared. The <code>main</code> function is necessary because it tells the Zig compiler where the start of
        the program exists. Programs designed to be executed will need a <code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span></code> function.
        For more advanced use cases, Zig offers other features to inform the compiler where the start of
        the program exists. Libraries, on the other hand, do not need a <code>main</code> function because
        library code is usually called by other programs.
      </p>
      <p>
        A function is a block of any number of statements and expressions that, as a whole, perform a task.
        Functions may or may not return data after they are done performing their task. If a function
        cannot perform its task, it might return an error. Zig makes all of this explicit.
      </p>
      <p>
        In the <code>hello.zig</code> code sample, the <code>main</code> function is declared
        with the <code class="zig">!<span class="tok-type">void</span></code> return type. This return type is known as an <a href="#Error-Union-Type">Error Union Type</a>.
        This syntax tells the Zig compiler that the function will either return an
        error or a value. An error union type combines an <a href="#Error-Set-Type">Error Set Type</a> and a <a href="#Primitive-Types">Primitive Type</a>.
        The full form of an error union type is
        <code>&lt;error set type&gt;</code><code class="zig">!</code><code>&lt;primitive type&gt;</code>. In the code
        sample, the error set type is not explicitly written on the left side of the <code class="zig">!</code> operator.
        When written this way, the error set type is a special kind of error union type that has an
        <a href="#Inferred-Error-Sets">inferred error set type</a>. The <code class="zig"><span class="tok-type">void</span></code> after the <code class="zig">!</code> operator
        tells the compiler that the function will not return a value under normal circumstances (i.e. no errors occur).
      </p>
      <p>
        Note to experienced programmers: Zig also has the boolean <a href="#Operators">operator</a> <code class="zig">!a</code>
        where <code class="zig">a</code> is a value of type <code class="zig"><span class="tok-type">bool</span></code>. Error union types contain the
        name of the type in the syntax: <code class="zig">!</code><code>&lt;primitive type&gt;</code>.
      </p>
      <p>
        In Zig, a function's block of statements and expressions are surrounded by <code>{</code> and
        <code>}</code> curly-braces. Inside of the <code>main</code> function are expressions that perform
        the task of outputting <code>Hello, world!</code> to standard output.
      </p>
      <p>
        First, a constant identifier, <code>stdout</code>, is initialized to represent standard output's
        writer. Then, the program tries to print the <code>Hello, world!</code>
        message to standard output.
      </p>
      <p>
        Functions sometimes need information to perform their task. In Zig, information is passed
        to functions between open <code>(</code> and close <code>)</code> parenthesis placed after
        the function's name. This information is also known as arguments. When there are
        multiple arguments passed to a function, they are separated by commas <code>,</code>.
      </p>
      <p>
        The two arguments passed to the <code>stdout.print()</code> function, <code>"Hello, {s}!\n"</code>
        and <code>.{"world"}</code>, are evaluated at <a href="#comptime">compile-time</a>. The code sample is
        purposely written to show how to perform <a href="#String-Literals-and-Unicode-Code-Point-Literals">string</a>
        substitution in the <code>print</code> function. The curly-braces inside of the first argument
        are substituted with the compile-time known value inside of the second argument
        (known as an <a href="#Anonymous-Struct-Literals">anonymous struct literal</a>). The <code>\n</code>
        inside of the double-quotes of the first argument is the <a href="#Escape-Sequences">escape sequence</a> for the
        newline character. The <a href="#try">try</a> expression evaluates the result of <code>stdout.print</code>.
        If the result is an error, then the <code class="zig"><span class="tok-kw">try</span></code> expression will return from
        <code>main</code> with the error. Otherwise, the program will continue. In this case, there are no
        more statements or expressions left to execute in the <code>main</code> function, so the program exits.
      </p>
      <p>
        In Zig, the standard output writer's <code>print</code> function is allowed to fail because
        it is actually a function defined as part of a generic Writer. Consider a generic Writer that
        represents writing data to a file. When the disk is full, a write to the file will fail.
        However, we typically do not expect writing text to the standard output to fail. To avoid having
        to handle the failure case of printing to standard output, you can use alternate functions: the
        functions in <code>std.log</code> for proper logging or the <code>std.debug.print</code> function.
        This documentation will use the latter option to print to standard error (stderr) and silently return
        on failure. The next code sample, <code>hello_again.zig</code> demonstrates the use of
        <code>std.debug.print</code>.
      </p>
      <p class="file">hello_again.zig</p><pre><code class="zig"><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    print(<span class="tok-str">&quot;Hello, world!\n&quot;</span>, .{});
}</code></pre><pre><code class="shell">$ zig build-exe hello_again.zig
$ ./hello_again
Hello, world!
</code></pre>

      <p>
      Note that you can leave off the <code class="zig">!</code> from the return type because <code>std.debug.print</code> cannot fail.
      </p>
      <p>See also:</p><ul>
<li><a href="#Values">Values</a></li>
<li><a href="#import">@import</a></li>
<li><a href="#Errors">Errors</a></li>
<li><a href="#Root-Source-File">Root Source File</a></li>
<li><a href="#Source-Encoding">Source Encoding</a></li>
</ul>

      
      <h1 id="Comments"><a href="#toc-Comments">Comments</a> <a class="hdr" href="#Comments">§</a></h1>

      <p class="file">comments.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;comments&quot;</span> {
    <span class="tok-comment">// Comments in Zig start with &quot;//&quot; and end at the next LF byte (end of line).</span>
    <span class="tok-comment">// The below line is a comment, and won't be executed.</span>

    <span class="tok-comment">//expect(false);</span>

    <span class="tok-kw">const</span> x = <span class="tok-null">true</span>;  <span class="tok-comment">// another comment</span>
    expect(x);
}</code></pre><pre><code class="shell">$ zig test comments.zig
Test [1/1] test &quot;comments&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      There are no multiline comments in Zig (e.g. like <code class="c">/* */</code>
      comments in C).  This helps allow Zig to have the property that each line
      of code can be tokenized out of context.
      </p>
      <h2 id="Doc-comments"><a href="#toc-Doc-comments">Doc comments</a> <a class="hdr" href="#Doc-comments">§</a></h2>

      <p>
      A doc comment is one that begins with exactly three slashes (i.e.
      <code class="zig"><span class="tok-comment">///</span></code> but not <code class="zig"><span class="tok-comment">////</span></code>);
      multiple doc comments in a row are merged together to form a multiline
      doc comment.  The doc comment documents whatever immediately follows it.
      </p>
      <pre><code class="zig"><span class="tok-comment">/// A structure for storing a timestamp, with nanosecond precision (this is a</span>
<span class="tok-comment">/// multiline doc comment).</span>
<span class="tok-kw">const</span> Timestamp = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// The number of seconds since the epoch (this is also a doc comment).</span>
    seconds: <span class="tok-type">i64</span>,  <span class="tok-comment">// signed so we can represent pre-1970 (not a doc comment)</span>
    <span class="tok-comment">/// The number of nanoseconds past the second (doc comment again).</span>
    nanos: <span class="tok-type">u32</span>,

    <span class="tok-comment">/// Returns a `Timestamp` struct representing the Unix epoch; that is, the</span>
    <span class="tok-comment">/// moment of 1970 Jan 1 00:00:00 UTC (this is a doc comment too).</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unixEpoch</span>() Timestamp {
        <span class="tok-kw">return</span> Timestamp{
            .seconds = <span class="tok-number">0</span>,
            .nanos = <span class="tok-number">0</span>,
        };
    }
};</code></pre>
      <p>
      Doc comments are only allowed in certain places; eventually, it will
      become a compile error to have a doc comment in an unexpected place, such as
      in the middle of an expression, or just before a non-doc comment.
      </p>
      
      <h2 id="Top-Level-Doc-Comments"><a href="#toc-Top-Level-Doc-Comments">Top-Level Doc Comments</a> <a class="hdr" href="#Top-Level-Doc-Comments">§</a></h2>

      <p>User documentation that doesn't belong to whatever
      immediately follows it, like package-level documentation, goes
      in top-level doc comments. A top-level doc comment is one that
      begins with two slashes and an exclamation point:
      <code class="zig"><span class="tok-comment">//!</span></code>.</p>
      <pre><code class="zig"><span class="tok-comment">//! This module provides functions for retrieving the current date and</span>
<span class="tok-comment">//! time with varying degrees of precision and accuracy. It does not</span>
<span class="tok-comment">//! depend on libc, but will use functions from it if available.</span></code></pre>
      
      
      <h1 id="Values"><a href="#toc-Values">Values</a> <a class="hdr" href="#Values">§</a></h1>

      <p class="file">values.zig</p><pre><code class="zig"><span class="tok-comment">// Top-level declarations are order-independent:</span>
<span class="tok-kw">const</span> print = std.debug.print;
<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> os = std.os;
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-comment">// integers</span>
    <span class="tok-kw">const</span> one_plus_one: <span class="tok-type">i32</span> = <span class="tok-number">1</span> + <span class="tok-number">1</span>;
    print(<span class="tok-str">&quot;1 + 1 = {}\n&quot;</span>, .{one_plus_one});

    <span class="tok-comment">// floats</span>
    <span class="tok-kw">const</span> seven_div_three: <span class="tok-type">f32</span> = <span class="tok-number">7.0</span> / <span class="tok-number">3.0</span>;
    print(<span class="tok-str">&quot;7.0 / 3.0 = {}\n&quot;</span>, .{seven_div_three});

    <span class="tok-comment">// boolean</span>
    print(<span class="tok-str">&quot;{}\n{}\n{}\n&quot;</span>, .{
        <span class="tok-null">true</span> <span class="tok-kw">and</span> <span class="tok-null">false</span>,
        <span class="tok-null">true</span> <span class="tok-kw">or</span> <span class="tok-null">false</span>,
        !<span class="tok-null">true</span>,
    });

    <span class="tok-comment">// optional</span>
    <span class="tok-kw">var</span> optional_value: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;
    assert(optional_value == <span class="tok-null">null</span>);

    print(<span class="tok-str">&quot;\noptional 1\ntype: {s}\nvalue: {s}\n&quot;</span>, .{
        <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(optional_value)),
        optional_value,
    });

    optional_value = <span class="tok-str">&quot;hi&quot;</span>;
    assert(optional_value != <span class="tok-null">null</span>);

    print(<span class="tok-str">&quot;\noptional 2\ntype: {s}\nvalue: {s}\n&quot;</span>, .{
        <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(optional_value)),
        optional_value,
    });

    <span class="tok-comment">// error union</span>
    <span class="tok-kw">var</span> number_or_error: <span class="tok-type">anyerror</span>!<span class="tok-type">i32</span> = <span class="tok-kw">error</span>.ArgNotFound;

    print(<span class="tok-str">&quot;\nerror union 1\ntype: {s}\nvalue: {}\n&quot;</span>, .{
        <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(number_or_error)),
        number_or_error,
    });

    number_or_error = <span class="tok-number">1234</span>;

    print(<span class="tok-str">&quot;\nerror union 2\ntype: {s}\nvalue: {}\n&quot;</span>, .{
        <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@TypeOf</span>(number_or_error)),
        number_or_error,
    });
}</code></pre><pre><code class="shell">$ zig build-exe values.zig
$ ./values
1 + 1 = 2
7.0 / 3.0 = 2.33333325e+00
false
true
false

optional 1
type: ?[]const u8
value: null

optional 2
type: ?[]const u8
value: hi

error union 1
type: anyerror!i32
value: error.ArgNotFound

error union 2
type: anyerror!i32
value: 1234
</code></pre>

      <h2 id="Primitive-Types"><a href="#toc-Primitive-Types">Primitive Types</a> <a class="hdr" href="#Primitive-Types">§</a></h2>

      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Name
          </th>
          <th>
            C Equivalent
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">i8</span></code></td>
          <td><code class="c">int8_t</code></td>
          <td>signed 8-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">u8</span></code></td>
          <td><code class="c">uint8_t</code></td>
          <td>unsigned 8-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">i16</span></code></td>
          <td><code class="c">int16_t</code></td>
          <td>signed 16-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">u16</span></code></td>
          <td><code class="c">uint16_t</code></td>
          <td>unsigned 16-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">i32</span></code></td>
          <td><code class="c">int32_t</code></td>
          <td>signed 32-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">u32</span></code></td>
          <td><code class="c">uint32_t</code></td>
          <td>unsigned 32-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">i64</span></code></td>
          <td><code class="c">int64_t</code></td>
          <td>signed 64-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">u64</span></code></td>
          <td><code class="c">uint64_t</code></td>
          <td>unsigned 64-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">i128</span></code></td>
          <td><code class="c">__int128</code></td>
          <td>signed 128-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">u128</span></code></td>
          <td><code class="c">unsigned __int128</code></td>
          <td>unsigned 128-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">isize</span></code></td>
          <td><code class="c">intptr_t</code></td>
          <td>signed pointer sized integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">usize</span></code></td>
          <td><code class="c">uintptr_t</code></td>
          <td>unsigned pointer sized integer</td>
        </tr>

        <tr>
            <td><code class="zig"><span class="tok-type">c_short</span></code></td>
          <td><code class="c">short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_ushort</span></code></td>
          <td><code class="c">unsigned short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_int</span></code></td>
          <td><code class="c">int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_uint</span></code></td>
          <td><code class="c">unsigned int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_long</span></code></td>
          <td><code class="c">long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_ulong</span></code></td>
          <td><code class="c">unsigned long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_longlong</span></code></td>
          <td><code class="c">long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_ulonglong</span></code></td>
          <td><code class="c">unsigned long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_longdouble</span></code></td>
          <td><code class="c">long double</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_void</span></code></td>
          <td><code class="c">void</code></td>
          <td>for ABI compatibility with C</td>
        </tr>

        <tr>
            <td><code class="zig"><span class="tok-type">f16</span></code></td>
          <td><code class="c">_Float16</code></td>
          <td>16-bit floating point (10-bit mantissa) IEEE-754-2008 binary16</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">f32</span></code></td>
          <td><code class="c">float</code></td>
          <td>32-bit floating point (23-bit mantissa) IEEE-754-2008 binary32</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">f64</span></code></td>
          <td><code class="c">double</code></td>
          <td>64-bit floating point (52-bit mantissa) IEEE-754-2008 binary64</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">f128</span></code></td>
            <td><code class="c">_Float128</code></td>
          <td>128-bit floating point (112-bit mantissa) IEEE-754-2008 binary128</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">bool</span></code></td>
          <td><code class="c">bool</code></td>
          <td><code class="zig"><span class="tok-null">true</span></code> or <code class="zig"><span class="tok-null">false</span></code></td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">void</span></code></td>
          <td>(none)</td>
          <td>0 bit type</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">noreturn</span></code></td>
          <td>(none)</td>
          <td>the type of <code class="zig"><span class="tok-kw">break</span></code>, <code class="zig"><span class="tok-kw">continue</span></code>, <code class="zig"><span class="tok-kw">return</span></code>, <code class="zig"><span class="tok-kw">unreachable</span></code>, and <code class="zig"><span class="tok-kw">while</span> (<span class="tok-null">true</span>) {}</code></td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">type</span></code></td>
          <td>(none)</td>
          <td>the type of types</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">anyerror</span></code></td>
          <td>(none)</td>
          <td>an error code</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">comptime_int</span></code></td>
          <td>(none)</td>
          <td>Only allowed for <a href="#comptime">comptime</a>-known values. The type of integer literals.</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">comptime_float</span></code></td>
          <td>(none)</td>
          <td>Only allowed for <a href="#comptime">comptime</a>-known values. The type of float literals.</td>
        </tr>
      </table>
      </div>
      <p>
      In addition to the integer types above, arbitrary bit-width integers can be referenced by using
      an identifier of <code>i</code> or <code>u</code> followed by digits. For example, the identifier
      <code class="zig"><span class="tok-type">i7</span></code> refers to a signed 7-bit integer. The maximum allowed bit-width of an
      integer type is <code class="zig"><span class="tok-number">65535</span></code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Integers">Integers</a></li>
<li><a href="#Floats">Floats</a></li>
<li><a href="#void">void</a></li>
<li><a href="#Errors">Errors</a></li>
<li><a href="#Type">@Type</a></li>
</ul>

      
      <h2 id="Primitive-Values"><a href="#toc-Primitive-Values">Primitive Values</a> <a class="hdr" href="#Primitive-Values">§</a></h2>

      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Name
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-null">true</span></code> and <code class="zig"><span class="tok-null">false</span></code></td>
            <td><code class="zig"><span class="tok-type">bool</span></code> values</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-null">null</span></code></td>
            <td>used to set an optional type to <code class="zig"><span class="tok-null">null</span></code></td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-null">undefined</span></code></td>
          <td>used to leave a value unspecified</td>
        </tr>
      </table>
      </div>
      <p>See also:</p><ul>
<li><a href="#Optionals">Optionals</a></li>
<li><a href="#undefined">undefined</a></li>
</ul>

      
      <h2 id="String-Literals-and-Unicode-Code-Point-Literals"><a href="#toc-String-Literals-and-Unicode-Code-Point-Literals">String Literals and Unicode Code Point Literals</a> <a class="hdr" href="#String-Literals-and-Unicode-Code-Point-Literals">§</a></h2>

      <p>
      String literals are constant single-item <a href="#Pointers">Pointers</a> to null-terminated byte arrays.
      The type of string literals encodes both the length, and the fact that they are null-terminated,
      and thus they can be <a href="#Type-Coercion">coerced</a> to both <a href="#Slices">Slices</a> and
      <a href="#Sentinel-Terminated-Pointers">Null-Terminated Pointers</a>.
      Dereferencing string literals converts them to <a href="#Arrays">Arrays</a>.
      </p>
      <p>
      The encoding of a string in Zig is de-facto assumed to be UTF-8.
      Because Zig source code is <a href="#Source-Encoding">UTF-8 encoded</a>, any non-ASCII bytes appearing within a string literal
      in source code carry their UTF-8 meaning into the content of the string in the Zig program;
      the bytes are not modified by the compiler.
      However, it is possible to embbed non-UTF-8 bytes into a string literal using <code>\xNN</code> notation.
      </p>
      <p>
      Unicode code point literals have type <code class="zig"><span class="tok-type">comptime_int</span></code>, the same as
      <a href="#Integer-Literals">Integer Literals</a>. All <a href="#Escape-Sequences">Escape Sequences</a> are valid in both string literals
      and Unicode code point literals.
      </p>
      <p>
      In many other programming languages, a Unicode code point literal is called a "character literal".
      However, there is <a href="https://unicode.org/glossary">no precise technical definition of a "character"</a>
      in recent versions of the Unicode specification (as of Unicode 13.0).
      In Zig, a Unicode code point literal corresponds to the Unicode definition of a code point.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;

<span class="tok-kw">test</span> <span class="tok-str">&quot;string literals&quot;</span> {
    <span class="tok-kw">const</span> bytes = <span class="tok-str">&quot;hello&quot;</span>;
    expect(<span class="tok-builtin">@TypeOf</span>(bytes) == *<span class="tok-kw">const</span> [<span class="tok-number">5</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span>);
    expect(bytes.len == <span class="tok-number">5</span>);
    expect(bytes[<span class="tok-number">1</span>] == <span class="tok-str">'e'</span>);
    expect(bytes[<span class="tok-number">5</span>] == <span class="tok-number">0</span>);
    expect(<span class="tok-str">'e'</span> == <span class="tok-str">'\x65'</span>);
    expect(<span class="tok-str">'\u{1f4a9}'</span> == <span class="tok-number">128169</span>);
    expect(<span class="tok-str">'💯'</span> == <span class="tok-number">128175</span>);
    expect(mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">&quot;h\x65llo&quot;</span>));
    expect(<span class="tok-str">&quot;\xff&quot;</span>[<span class="tok-number">0</span>] == <span class="tok-number">0xff</span>); <span class="tok-comment">// non-UTF-8 strings are possible with \xNN notation.</span>
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;string literals&quot;... 

All 1 tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Arrays">Arrays</a></li>
<li><a href="#Zig-Test">Zig Test</a></li>
<li><a href="#Source-Encoding">Source Encoding</a></li>
</ul>

      <h3 id="Escape-Sequences"><a href="#toc-Escape-Sequences">Escape Sequences</a> <a class="hdr" href="#Escape-Sequences">§</a></h3>

      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Escape Sequence
          </th>
          <th>
            Name
          </th>
        </tr>
        <tr>
            <td><code>\n</code></td>
          <td>Newline</td>
        </tr>
        <tr>
            <td><code>\r</code></td>
          <td>Carriage Return</td>
        </tr>
        <tr>
            <td><code>\t</code></td>
          <td>Tab</td>
        </tr>
        <tr>
            <td><code>\\</code></td>
          <td>Backslash</td>
        </tr>
        <tr>
            <td><code>\'</code></td>
          <td>Single Quote</td>
        </tr>
        <tr>
            <td><code>\"</code></td>
          <td>Double Quote</td>
        </tr>
        <tr>
            <td><code>\xNN</code></td>
          <td>hexadecimal 8-bit byte value (2 digits)</td>
        </tr>
        <tr>
            <td><code>\u{NNNNNN}</code></td>
          <td>hexadecimal Unicode code point UTF-8 encoded (1 or more digits)</td>
        </tr>
      </table>
      </div>
      <p>Note that the maximum valid Unicode point is <code class="zig"><span class="tok-number">0x10ffff</span></code>.</p>
      
      <h3 id="Multiline-String-Literals"><a href="#toc-Multiline-String-Literals">Multiline String Literals</a> <a class="hdr" href="#Multiline-String-Literals">§</a></h3>

      <p>
      Multiline string literals have no escapes and can span across multiple lines.
      To start a multiline string literal, use the <code class="zig"><span class="tok-str">\\</span></code> token. Just like a comment,
      the string literal goes until the end of the line. The end of the line is
      not included in the string literal.
      However, if the next line begins with <code class="zig"><span class="tok-str">\\</span></code> then a newline is appended and
      the string literal continues.
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> hello_world_in_c =
    <span class="tok-str">\\#include &lt;stdio.h&gt;
</span>    <span class="tok-str">\\
</span>    <span class="tok-str">\\int main(int argc, char **argv) {
</span>    <span class="tok-str">\\    printf(&quot;hello world\n&quot;);
</span>    <span class="tok-str">\\    return 0;
</span>    <span class="tok-str">\\}
</span>;</code></pre>
      <p>See also:</p><ul>
<li><a href="#embedFile">@embedFile</a></li>
</ul>

      
      
      <h2 id="Assignment"><a href="#toc-Assignment">Assignment</a> <a class="hdr" href="#Assignment">§</a></h2>

      <p>Use the <code class="zig"><span class="tok-kw">const</span></code> keyword to assign a value to an identifier:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> x = <span class="tok-number">1234</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {
    <span class="tok-comment">// It works at global scope as well as inside functions.</span>
    <span class="tok-kw">const</span> y = <span class="tok-number">5678</span>;

    <span class="tok-comment">// Once assigned, an identifier cannot be changed.</span>
    y += <span class="tok-number">1</span>;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;assignment&quot;</span> {
    foo();
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:8:7: </span><span class="t31_1">error: </span><span class="t0_1">cannot assign to constant</span>
    y += 1;
      <span class="t32_1">^</span>
</code></pre>

      <p><code class="zig"><span class="tok-kw">const</span></code> applies to all of the bytes that the identifier immediately addresses. <a href="#Pointers">Pointers</a> have their own const-ness.</p>
      <p>If you need a variable that you can modify, use the <code class="zig"><span class="tok-kw">var</span></code> keyword:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;var&quot;</span> {
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">5678</span>;

    y += <span class="tok-number">1</span>;

    expect(y == <span class="tok-number">5679</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;var&quot;... 

All 1 tests passed.
</code></pre>

      <p>Variables must be initialized:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;initialization&quot;</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span>;

    x = <span class="tok-number">1</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:2:5: </span><span class="t31_1">error: </span><span class="t0_1">variables must be initialized</span>
    var x: i32;
    <span class="t32_1">^</span>
</code></pre>

      <h3 id="undefined"><a href="#toc-undefined">undefined</a> <a class="hdr" href="#undefined">§</a></h3>

      <p>Use <code class="zig"><span class="tok-null">undefined</span></code> to leave variables uninitialized:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;init with undefined&quot;</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
    x = <span class="tok-number">1</span>;
    expect(x == <span class="tok-number">1</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;init with undefined&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      <code class="zig"><span class="tok-null">undefined</span></code> can be <a href="#Type-Coercion">coerced</a> to any type.
          Once this happens, it is no longer possible to detect that the value is <code class="zig"><span class="tok-null">undefined</span></code>.
              <code class="zig"><span class="tok-null">undefined</span></code> means the value could be anything, even something that is nonsense
                  according to the type. Translated into English, <code class="zig"><span class="tok-null">undefined</span></code> means "Not a meaningful
      value. Using this value would be a bug. The value will be unused, or overwritten before being used."
      </p>
      <p>
      In <a href="#Debug">Debug</a> mode, Zig writes <code class="zig"><span class="tok-number">0xaa</span></code> bytes to undefined memory. This is to catch
      bugs early, and to help detect use of undefined memory in a debugger.
      </p>
      
      
      

      <h1 id="Variables"><a href="#toc-Variables">Variables</a> <a class="hdr" href="#Variables">§</a></h1>

      <p>
      A variable is a unit of <a href="#Memory">Memory</a> storage.
      </p>
      <p>
      Variables are never allowed to shadow identifiers from an outer scope.
      </p>
      <p>
      It is generally preferable to use <code class="zig"><span class="tok-kw">const</span></code> rather than
      <code class="zig"><span class="tok-kw">var</span></code> when declaring a variable. This causes less work for both
      humans and computers to do when reading code, and creates more optimization opportunities.
      </p>
      <h2 id="Global-Variables"><a href="#toc-Global-Variables">Global Variables</a> <a class="hdr" href="#Global-Variables">§</a></h2>

      <p>
      Global variables are considered to be a top level declaration, which means that they are
      order-independent and lazily analyzed. The initialization value of global variables is implicitly
      <a href="#comptime">comptime</a>. If a global variable is <code class="zig"><span class="tok-kw">const</span></code> then its value is
      <code class="zig"><span class="tok-kw">comptime</span></code>-known, otherwise it is runtime-known.
      </p>
      <p class="file">global_variables.zig</p><pre><code class="zig"><span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = add(<span class="tok-number">10</span>, x);
<span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = add(<span class="tok-number">12</span>, <span class="tok-number">34</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;global variables&quot;</span> {
    expect(x == <span class="tok-number">46</span>);
    expect(y == <span class="tok-number">56</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a + b;
}

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;</code></pre><pre><code class="shell">$ zig test global_variables.zig
Test [1/1] test &quot;global variables&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      Global variables may be declared inside a <a href="#struct">struct</a>, <a href="#union">union</a>, or <a href="#enum">enum</a>:
      </p>
      <p class="file">namespaced_global.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;namespaced global variable&quot;</span> {
    expect(foo() == <span class="tok-number">1235</span>);
    expect(foo() == <span class="tok-number">1236</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    };
    S.x += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> S.x;
}</code></pre><pre><code class="shell">$ zig test namespaced_global.zig
Test [1/1] test &quot;namespaced global variable&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      The <code class="zig"><span class="tok-kw">extern</span></code> keyword can be used to link against a variable that is exported
      from another object. The <code class="zig"><span class="tok-kw">export</span></code> keyword or <a href="#export">@export</a> builtin function
      can be used to make a variable available to other objects at link time. In both cases,
      the type of the variable must be C ABI compatible.
      </p>
      <p>See also:</p><ul>
<li><a href="#Exporting-a-C-Library">Exporting a C Library</a></li>
</ul>

      

      <h2 id="Thread-Local-Variables"><a href="#toc-Thread-Local-Variables">Thread Local Variables</a> <a class="hdr" href="#Thread-Local-Variables">§</a></h2>

      <p>A variable may be specified to be a thread-local variable using the
      <code class="zig"><span class="tok-kw">threadlocal</span></code> keyword:</p>
      <p class="file">tls.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">threadlocal</span> <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;thread local storage&quot;</span> {
    <span class="tok-kw">const</span> thread1 = <span class="tok-kw">try</span> std.Thread.spawn(testTls, {});
    <span class="tok-kw">const</span> thread2 = <span class="tok-kw">try</span> std.Thread.spawn(testTls, {});
    testTls({});
    thread1.wait();
    thread2.wait();
}

<span class="tok-kw">fn</span> <span class="tok-fn">testTls</span>(context: <span class="tok-type">void</span>) <span class="tok-type">void</span> {
    assert(x == <span class="tok-number">1234</span>);
    x += <span class="tok-number">1</span>;
    assert(x == <span class="tok-number">1235</span>);
}</code></pre><pre><code class="shell">$ zig test tls.zig
Test [1/1] test &quot;thread local storage&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      For <a href="#Single-Threaded-Builds">Single Threaded Builds</a>, all thread local variables are treated as <a href="#Global-Variables">Global Variables</a>.
      </p>
      <p>
      Thread local variables may not be <code class="zig"><span class="tok-kw">const</span></code>.
      </p>
      

      <h2 id="Local-Variables"><a href="#toc-Local-Variables">Local Variables</a> <a class="hdr" href="#Local-Variables">§</a></h2>

      <p>
      Local variables occur inside <a href="#Functions">Functions</a>, <a href="#comptime">comptime</a> blocks, and <a href="#cImport">@cImport</a> blocks.
      </p>
      <p>
      When a local variable is <code class="zig"><span class="tok-kw">const</span></code>, it means that after initialization, the variable's
      value will not change. If the initialization value of a <code class="zig"><span class="tok-kw">const</span></code> variable is
      <a href="#comptime">comptime</a>-known, then the variable is also <code class="zig"><span class="tok-kw">comptime</span></code>-known.
      </p>
      <p>
      A local variable may be qualified with the <code class="zig"><span class="tok-kw">comptime</span></code> keyword. This causes
      the variable's value to be <code class="zig"><span class="tok-kw">comptime</span></code>-known, and all loads and stores of the
      variable to happen during semantic analysis of the program, rather than at runtime.
      All variables declared in a <code class="zig"><span class="tok-kw">comptime</span></code> expression are implicitly
      <code class="zig"><span class="tok-kw">comptime</span></code> variables.
      </p>
      <p class="file">comptime_vars.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;comptime vars&quot;</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;

    x += <span class="tok-number">1</span>;
    y += <span class="tok-number">1</span>;

    expect(x == <span class="tok-number">2</span>);
    expect(y == <span class="tok-number">2</span>);

    <span class="tok-kw">if</span> (y != <span class="tok-number">2</span>) {
        <span class="tok-comment">// This compile error never triggers because y is a comptime variable,</span>
        <span class="tok-comment">// and so `y != 2` is a comptime value, and this if is statically evaluated.</span>
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;wrong y value&quot;</span>);
    }
}</code></pre><pre><code class="shell">$ zig test comptime_vars.zig
Test [1/1] test &quot;comptime vars&quot;... 

All 1 tests passed.
</code></pre>

      
      

      <h1 id="Integers"><a href="#toc-Integers">Integers</a> <a class="hdr" href="#Integers">§</a></h1>

      <h2 id="Integer-Literals"><a href="#toc-Integer-Literals">Integer Literals</a> <a class="hdr" href="#Integer-Literals">§</a></h2>

      <pre><code class="zig"><span class="tok-kw">const</span> decimal_int = <span class="tok-number">98222</span>;
<span class="tok-kw">const</span> hex_int = <span class="tok-number">0xff</span>;
<span class="tok-kw">const</span> another_hex_int = <span class="tok-number">0xFF</span>;
<span class="tok-kw">const</span> octal_int = <span class="tok-number">0o755</span>;
<span class="tok-kw">const</span> binary_int = <span class="tok-number">0b11110000</span>;

<span class="tok-comment">// underscores may be placed between two digits as a visual separator</span>
<span class="tok-kw">const</span> one_billion = <span class="tok-number">1_000_000_000</span>;
<span class="tok-kw">const</span> binary_mask = <span class="tok-number">0b1_1111_1111</span>;
<span class="tok-kw">const</span> permissions = <span class="tok-number">0o7_5_5</span>;
<span class="tok-kw">const</span> big_address = <span class="tok-number">0xFF80_0000_0000_0000</span>;</code></pre>
      
      <h2 id="Runtime-Integer-Values"><a href="#toc-Runtime-Integer-Values">Runtime Integer Values</a> <a class="hdr" href="#Runtime-Integer-Values">§</a></h2>

      <p>
      Integer literals have no size limitation, and if any undefined behavior occurs,
      the compiler catches it.
      </p>
      <p>
      However, once an integer value is no longer known at compile-time, it must have a
      known size, and is vulnerable to undefined behavior.
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">divide</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a / b;
}</code></pre>
      <p>
      In this function, values <code class="zig">a</code> and <code class="zig">b</code> are known only at runtime,
      and thus this division operation is vulnerable to both <a href="#Integer-Overflow">Integer Overflow</a> and
      <a href="#Division-by-Zero">Division by Zero</a>.
      </p>
      <p>
      Operators such as <code class="zig">+</code> and <code class="zig">-</code> cause undefined behavior on
              integer overflow. Also available are operations such as <code class="zig">+%</code> and
                  <code class="zig">-%</code> which are defined to have wrapping arithmetic on all targets.
      </p>
      <p>
      Zig supports arbitrary bit-width integers, referenced by using
      an identifier of <code>i</code> or <code>u</code> followed by digits. For example, the identifier
      <code class="zig"><span class="tok-type">i7</span></code> refers to a signed 7-bit integer. The maximum allowed bit-width of an
      integer type is <code class="zig"><span class="tok-number">65535</span></code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Wrapping-Operations">Wrapping Operations</a></li>
</ul>

      
      
      <h1 id="Floats"><a href="#toc-Floats">Floats</a> <a class="hdr" href="#Floats">§</a></h1>

      <p>Zig has the following floating point types:</p>
      <ul>
          <li><code class="zig"><span class="tok-type">f16</span></code> - IEEE-754-2008 binary16</li>
          <li><code class="zig"><span class="tok-type">f32</span></code> - IEEE-754-2008 binary32</li>
          <li><code class="zig"><span class="tok-type">f64</span></code> - IEEE-754-2008 binary64</li>
          <li><code class="zig"><span class="tok-type">f128</span></code> - IEEE-754-2008 binary128</li>
          <li><code class="zig"><span class="tok-type">c_longdouble</span></code> - matches <code class="c">long double</code> for the target C ABI</li>
      </ul>
      <h2 id="Float-Literals"><a href="#toc-Float-Literals">Float Literals</a> <a class="hdr" href="#Float-Literals">§</a></h2>

      <p>
      Float literals have type <code class="zig"><span class="tok-type">comptime_float</span></code> which is guaranteed to have
      the same precision and operations of the largest other floating point type, which is
      <code class="zig"><span class="tok-type">f128</span></code>.
      </p>
      <p>
      Float literals <a href="#Type-Coercion">coerce</a> to any floating point type,
      and to any <a href="#Integers">integer</a> type when there is no fractional component.
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> floating_point = <span class="tok-number">123.0E+77</span>;
<span class="tok-kw">const</span> another_float = <span class="tok-number">123.0</span>;
<span class="tok-kw">const</span> yet_another = <span class="tok-number">123.0e+77</span>;

<span class="tok-kw">const</span> hex_floating_point = <span class="tok-number">0x103.70p-5</span>;
<span class="tok-kw">const</span> another_hex_float = <span class="tok-number">0x103.70</span>;
<span class="tok-kw">const</span> yet_another_hex_float = <span class="tok-number">0x103.70P-5</span>;

<span class="tok-comment">// underscores may be placed between two digits as a visual separator</span>
<span class="tok-kw">const</span> lightspeed = <span class="tok-number">299_792_458.000_000</span>;
<span class="tok-kw">const</span> nanosecond = <span class="tok-number">0.000_000_001</span>;
<span class="tok-kw">const</span> more_hex = <span class="tok-number">0x1234_5678.9ABC_CDEFp-10</span>;</code></pre>
      <p>
      There is no syntax for NaN, infinity, or negative infinity. For these special values,
      one must use the standard library:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> inf = std.math.inf(<span class="tok-type">f32</span>);
<span class="tok-kw">const</span> negative_inf = -std.math.inf(<span class="tok-type">f64</span>);
<span class="tok-kw">const</span> nan = std.math.nan(<span class="tok-type">f128</span>);</code></pre>
      
      <h2 id="Floating-Point-Operations"><a href="#toc-Floating-Point-Operations">Floating Point Operations</a> <a class="hdr" href="#Floating-Point-Operations">§</a></h2>

      <p>By default floating point operations use <code class="zig">Strict</code> mode,
          but you can switch to <code class="zig">Optimized</code> mode on a per-block basis:</p>
      <p class="file">foo.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = std.builtin;
<span class="tok-kw">const</span> big = <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">1</span> &lt;&lt; <span class="tok-number">40</span>);

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_strict</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span> {
    <span class="tok-kw">return</span> x + big - big;
}

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_optimized</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span> {
    <span class="tok-builtin">@setFloatMode</span>(.Optimized);
    <span class="tok-kw">return</span> x + big - big;
}</code></pre><pre><code class="shell">$ zig build-obj foo.zig -O ReleaseFast</code></pre>

      <p>For this test we have to separate code into two object files -
      otherwise the optimizer figures out all the values at compile-time,
      which operates in strict mode.</p>
      <p class="file">float_mode.zig</p><pre><code class="zig"><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_strict</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span>;
<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_optimized</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x = <span class="tok-number">0.001</span>;
    print(<span class="tok-str">&quot;optimized = {}\n&quot;</span>, .{foo_optimized(x)});
    print(<span class="tok-str">&quot;strict = {}\n&quot;</span>, .{foo_strict(x)});
}</code></pre><pre><code class="shell">$ zig build-exe float_mode.zig foo.o
$ ./float_mode
optimized = 1.0e-03
strict = 9.765625e-04
</code></pre>

      <p>See also:</p><ul>
<li><a href="#setFloatMode">@setFloatMode</a></li>
<li><a href="#Division-by-Zero">Division by Zero</a></li>
</ul>

      
      
      <h1 id="Operators"><a href="#toc-Operators">Operators</a> <a class="hdr" href="#Operators">§</a></h1>

      <p>
      There is no operator overloading. When you see an operator in Zig, you know that
      it is doing something from this table, and nothing else.
      </p>
      <h2 id="Table-of-Operators"><a href="#toc-Table-of-Operators">Table of Operators</a> <a class="hdr" href="#Table-of-Operators">§</a></h2>

      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Syntax
          </th>
          <th>
            Relevant Types
          </th>
          <th>
            Description
          </th>
          <th>
            Example
          </th>
        </tr>
        <tr>
          <td><pre><code class="zig">a + b
a += b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>Addition.
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#addWithOverflow">@addWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">2</span> + <span class="tok-number">5</span> == <span class="tok-number">7</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a +% b
a +%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Wrapping Addition.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#addWithOverflow">@addWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, std.math.maxInt(<span class="tok-type">u32</span>)) +% <span class="tok-number">1</span> == <span class="tok-number">0</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a - b
a -= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>Subtraction.
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#subWithOverflow">@subWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">2</span> - <span class="tok-number">5</span> == -<span class="tok-number">3</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a -% b
a -%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Wrapping Subtraction.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#subWithOverflow">@subWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">0</span>) -% <span class="tok-number">1</span> == std.math.maxInt(<span class="tok-type">u32</span>)</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">-a</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            Negation.
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">-<span class="tok-number">1</span> == <span class="tok-number">0</span> - <span class="tok-number">1</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">-%a</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            Wrapping Negation.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">-%<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, std.math.minInt(<span class="tok-type">i32</span>)) == std.math.minInt(<span class="tok-type">i32</span>)</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a * b
a *= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>Multiplication.
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#mulWithOverflow">@mulWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">2</span> * <span class="tok-number">5</span> == <span class="tok-number">10</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a *% b
a *%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Wrapping Multiplication.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#mulWithOverflow">@mulWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">200</span>) *% <span class="tok-number">2</span> == <span class="tok-number">144</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a / b
a /= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>Division.
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for integers.</li>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for floats in <a href="#Floating-Point-Operations">FloatMode.Optimized Mode</a>.</li>
              <li>Signed integer operands must be comptime-known and positive. In other cases, use
                <a href="#divTrunc">@divTrunc</a>,
                <a href="#divFloor">@divFloor</a>, or
                <a href="#divExact">@divExact</a> instead.
              </li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">10</span> / <span class="tok-number">5</span> == <span class="tok-number">2</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a % b
a %= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>Remainder Division.
            <ul>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for integers.</li>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for floats in <a href="#Floating-Point-Operations">FloatMode.Optimized Mode</a>.</li>
              <li>Signed or floating-point operands must be comptime-known and positive. In other cases, use
                <a href="#rem">@rem</a> or
                <a href="#mod">@mod</a> instead.
              </li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">10</span> % <span class="tok-number">3</span> == <span class="tok-number">1</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &lt;&lt; b
a &lt;&lt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Bit Shift Left.
            <ul>
                <li><code class="zig">b</code> must be <a href="#comptime">comptime-known</a> or have a type with log2 number of bits as <code class="zig">a</code>.</li>
              <li>See also <a href="#shlExact">@shlExact</a>.</li>
              <li>See also <a href="#shlWithOverflow">@shlWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">1</span> &lt;&lt; <span class="tok-number">8</span> == <span class="tok-number">256</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &gt;&gt; b
a &gt;&gt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Bit Shift Right.
            <ul>
                <li><code class="zig">b</code> must be <a href="#comptime">comptime-known</a> or have a type with log2 number of bits as <code class="zig">a</code>.</li>
              <li>See also <a href="#shrExact">@shrExact</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">10</span> &gt;&gt; <span class="tok-number">1</span> == <span class="tok-number">5</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &amp; b
a &amp;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Bitwise AND.
            <ul>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">0b011</span> &amp; <span class="tok-number">0b101</span> == <span class="tok-number">0b001</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a | b
a |= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Bitwise OR.
            <ul>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">0b010</span> | <span class="tok-number">0b100</span> == <span class="tok-number">0b110</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a ^ b
a ^= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Bitwise XOR.
            <ul>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">0b011</span> ^ <span class="tok-number">0b101</span> == <span class="tok-number">0b110</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">~a</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            Bitwise NOT.
          </td>
          <td>
            <pre><code class="zig">~<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0b10101111</span>) == <span class="tok-number">0b01010000</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a <span class="tok-kw">orelse</span> b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Optionals">Optionals</a></li>
            </ul>
          </td>
          <td>If <code class="zig">a</code> is <code class="zig"><span class="tok-null">null</span></code>,
                      returns <code class="zig">b</code> ("default value"),
                          otherwise returns the unwrapped value of <code class="zig">a</code>.
                              Note that <code class="zig">b</code> may be a value of type <a href="#noreturn">noreturn</a>.
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
<span class="tok-kw">const</span> unwrapped = value <span class="tok-kw">orelse</span> <span class="tok-number">1234</span>;
unwrapped == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a.?</code></pre></td>
          <td>
            <ul>
              <li><a href="#Optionals">Optionals</a></li>
            </ul>
          </td>
          <td>
            Equivalent to:
            <pre><code class="zig">a <span class="tok-kw">orelse</span> <span class="tok-kw">unreachable</span></code></pre>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-number">5678</span>;
value.? == <span class="tok-number">5678</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a <span class="tok-kw">catch</span> b
a <span class="tok-kw">catch</span> |err| b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Errors">Error Unions</a></li>
            </ul>
          </td>
          <td>If <code class="zig">a</code> is an <code class="zig"><span class="tok-kw">error</span></code>,
                      returns <code class="zig">b</code> ("default value"),
                          otherwise returns the unwrapped value of <code class="zig">a</code>.
                              Note that <code class="zig">b</code> may be a value of type <a href="#noreturn">noreturn</a>.
                                  <code class="zig">err</code> is the <code class="zig"><span class="tok-kw">error</span></code> and is in scope of the expression <code class="zig">b</code>.
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> value: <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> = <span class="tok-kw">error</span>.Broken;
<span class="tok-kw">const</span> unwrapped = value <span class="tok-kw">catch</span> <span class="tok-number">1234</span>;
unwrapped == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a <span class="tok-kw">and</span> b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td>
              If <code class="zig">a</code> is <code class="zig"><span class="tok-null">false</span></code>, returns <code class="zig"><span class="tok-null">false</span></code>
                          without evaluating <code class="zig">b</code>. Otherwise, returns <code class="zig">b</code>.
          </td>
          <td>
            <pre><code class="zig">(<span class="tok-null">false</span> <span class="tok-kw">and</span> <span class="tok-null">true</span>) == <span class="tok-null">false</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a <span class="tok-kw">or</span> b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td>
              If <code class="zig">a</code> is <code class="zig"><span class="tok-null">true</span></code>, returns <code class="zig"><span class="tok-null">true</span></code>
                          without evaluating <code class="zig">b</code>. Otherwise, returns <code class="zig">b</code>.
          </td>
          <td>
            <pre><code class="zig"><span class="tok-null">false</span> <span class="tok-kw">or</span> <span class="tok-null">true</span> == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">!a</code></pre></td>
          <td>
            <ul>
              <li><a href="#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td>
            Boolean NOT.
          </td>
          <td>
            <pre><code class="zig">!<span class="tok-null">false</span> == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a == b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
              <li><a href="#Primitive-Types">bool</a></li>
              <li><a href="#Primitive-Types">type</a></li>
            </ul>
          </td>
          <td>
              Returns <code class="zig"><span class="tok-null">true</span></code> if a and b are equal, otherwise returns <code class="zig"><span class="tok-null">false</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code class="zig">(<span class="tok-number">1</span> == <span class="tok-number">1</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a == <span class="tok-null">null</span></code></pre></td>
          <td>
            <ul>
              <li><a href="#Optionals">Optionals</a></li>
            </ul>
          </td>
          <td>
              Returns <code class="zig"><span class="tok-null">true</span></code> if a is <code class="zig"><span class="tok-null">null</span></code>, otherwise returns <code class="zig"><span class="tok-null">false</span></code>.
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
value == <span class="tok-null">null</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a != b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
              <li><a href="#Primitive-Types">bool</a></li>
              <li><a href="#Primitive-Types">type</a></li>
            </ul>
          </td>
          <td>
              Returns <code class="zig"><span class="tok-null">false</span></code> if a and b are equal, otherwise returns <code class="zig"><span class="tok-null">true</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code class="zig">(<span class="tok-number">1</span> != <span class="tok-number">1</span>) == <span class="tok-null">false</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &gt; b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code class="zig"><span class="tok-null">true</span></code> if a is greater than b, otherwise returns <code class="zig"><span class="tok-null">false</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code class="zig">(<span class="tok-number">2</span> &gt; <span class="tok-number">1</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &gt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code class="zig"><span class="tok-null">true</span></code> if a is greater than or equal to b, otherwise returns <code class="zig"><span class="tok-null">false</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code class="zig">(<span class="tok-number">2</span> &gt;= <span class="tok-number">1</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &lt; b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code class="zig"><span class="tok-null">true</span></code> if a is less than b, otherwise returns <code class="zig"><span class="tok-null">false</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code class="zig">(<span class="tok-number">1</span> &lt; <span class="tok-number">2</span>) == <span class="tok-null">true</span></code>></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &lt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code class="zig"><span class="tok-null">true</span></code> if a is less than or equal to b, otherwise returns <code class="zig"><span class="tok-null">false</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code class="zig">(<span class="tok-number">1</span> &lt;= <span class="tok-number">2</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a ++ b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Arrays">Arrays</a></li>
            </ul>
          </td>
          <td>
            Array concatenation.
            <ul>
                <li>Only available when <code class="zig">a</code> and <code class="zig">b</code> are <a href="#comptime">compile-time known</a>.
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;
<span class="tok-kw">const</span> array1 = [_]<span class="tok-type">u32</span>{<span class="tok-number">1</span>,<span class="tok-number">2</span>};
<span class="tok-kw">const</span> array2 = [_]<span class="tok-type">u32</span>{<span class="tok-number">3</span>,<span class="tok-number">4</span>};
<span class="tok-kw">const</span> together = array1 ++ array2;
mem.eql(<span class="tok-type">u32</span>, &amp;together, &amp;[_]<span class="tok-type">u32</span>{<span class="tok-number">1</span>,<span class="tok-number">2</span>,<span class="tok-number">3</span>,<span class="tok-number">4</span>})</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a ** b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Arrays">Arrays</a></li>
            </ul>
          </td>
          <td>
            Array multiplication.
            <ul>
                <li>Only available when <code class="zig">a</code> and <code class="zig">b</code> are <a href="#comptime">compile-time known</a>.
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;
<span class="tok-kw">const</span> pattern = <span class="tok-str">&quot;ab&quot;</span> ** <span class="tok-number">3</span>;
mem.eql(<span class="tok-type">u8</span>, pattern, <span class="tok-str">&quot;ababab&quot;</span>)</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a.*</code></pre></td>
          <td>
            <ul>
              <li><a href="#Pointers">Pointers</a></li>
            </ul>
          </td>
          <td>
            Pointer dereference.
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> x: <span class="tok-type">u32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> ptr = &amp;x;
ptr.* == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">&amp;a</code></pre></td>
          <td>
            All types
          </td>
          <td>
            Address of.
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> x: <span class="tok-type">u32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> ptr = &amp;x;
ptr.* == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a || b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Error-Set-Type">Error Set Type</a></li>
            </ul>
          </td>
          <td>
              <a href="#Merging-Error-Sets">Merging Error Sets</a>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> A = <span class="tok-kw">error</span>{One};
<span class="tok-kw">const</span> B = <span class="tok-kw">error</span>{Two};
(A || B) == <span class="tok-kw">error</span>{One, Two}</code></pre>
          </td>
        </tr>
      </table>
      </div>
      
      <h2 id="Precedence"><a href="#toc-Precedence">Precedence</a> <a class="hdr" href="#Precedence">§</a></h2>

      <pre><code class="zig">x() x[] x.y
a!b
x{} x.* x.?
!x -x -%x ~x &amp;x ?x
! * / % ** *% ||
+ - ++ +% -%
&lt;&lt; &gt;&gt;
&amp; ^ |
== != &lt; &gt; &lt;= &gt;=
<span class="tok-kw">and</span>
<span class="tok-kw">or</span>
<span class="tok-kw">orelse</span> <span class="tok-kw">catch</span>
= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</code></pre>
      
      
      <h1 id="Arrays"><a href="#toc-Arrays">Arrays</a> <a class="hdr" href="#Arrays">§</a></h1>

      <p class="file">arrays.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;

<span class="tok-comment">// array literal</span>
<span class="tok-kw">const</span> message = [_]<span class="tok-type">u8</span>{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'o'</span> };

<span class="tok-comment">// get the size of an array</span>
<span class="tok-kw">comptime</span> {
    expect(message.len == <span class="tok-number">5</span>);
}

<span class="tok-comment">// A string literal is a single-item pointer to an array literal.</span>
<span class="tok-kw">const</span> same_message = <span class="tok-str">&quot;hello&quot;</span>;

<span class="tok-kw">comptime</span> {
    expect(mem.eql(<span class="tok-type">u8</span>, &amp;message, same_message));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;iterate over an array&quot;</span> {
    <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (message) |byte| {
        sum += byte;
    }
    expect(sum == <span class="tok-str">'h'</span> + <span class="tok-str">'e'</span> + <span class="tok-str">'l'</span> * <span class="tok-number">2</span> + <span class="tok-str">'o'</span>);
}

<span class="tok-comment">// modifiable array</span>
<span class="tok-kw">var</span> some_integers: [<span class="tok-number">100</span>]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;modify an array&quot;</span> {
    <span class="tok-kw">for</span> (some_integers) |*item, i| {
        item.* = <span class="tok-builtin">@intCast</span>(<span class="tok-type">i32</span>, i);
    }
    expect(some_integers[<span class="tok-number">10</span>] == <span class="tok-number">10</span>);
    expect(some_integers[<span class="tok-number">99</span>] == <span class="tok-number">99</span>);
}

<span class="tok-comment">// array concatenation works if the values are known</span>
<span class="tok-comment">// at compile time</span>
<span class="tok-kw">const</span> part_one = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
<span class="tok-kw">const</span> part_two = [_]<span class="tok-type">i32</span>{ <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> };
<span class="tok-kw">const</span> all_of_it = part_one ++ part_two;
<span class="tok-kw">comptime</span> {
    expect(mem.eql(<span class="tok-type">i32</span>, &amp;all_of_it, &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> }));
}

<span class="tok-comment">// remember that string literals are arrays</span>
<span class="tok-kw">const</span> hello = <span class="tok-str">&quot;hello&quot;</span>;
<span class="tok-kw">const</span> world = <span class="tok-str">&quot;world&quot;</span>;
<span class="tok-kw">const</span> hello_world = hello ++ <span class="tok-str">&quot; &quot;</span> ++ world;
<span class="tok-kw">comptime</span> {
    expect(mem.eql(<span class="tok-type">u8</span>, hello_world, <span class="tok-str">&quot;hello world&quot;</span>));
}

<span class="tok-comment">// ** does repeating patterns</span>
<span class="tok-kw">const</span> pattern = <span class="tok-str">&quot;ab&quot;</span> ** <span class="tok-number">3</span>;
<span class="tok-kw">comptime</span> {
    expect(mem.eql(<span class="tok-type">u8</span>, pattern, <span class="tok-str">&quot;ababab&quot;</span>));
}

<span class="tok-comment">// initialize an array to zero</span>
<span class="tok-kw">const</span> all_zero = [_]<span class="tok-type">u16</span>{<span class="tok-number">0</span>} ** <span class="tok-number">10</span>;

<span class="tok-kw">comptime</span> {
    expect(all_zero.len == <span class="tok-number">10</span>);
    expect(all_zero[<span class="tok-number">5</span>] == <span class="tok-number">0</span>);
}

<span class="tok-comment">// use compile-time code to initialize an array</span>
<span class="tok-kw">var</span> fancy_array = init: {
    <span class="tok-kw">var</span> initial_value: [<span class="tok-number">10</span>]Point = <span class="tok-null">undefined</span>;
    <span class="tok-kw">for</span> (initial_value) |*pt, i| {
        pt.* = Point{
            .x = <span class="tok-builtin">@intCast</span>(<span class="tok-type">i32</span>, i),
            .y = <span class="tok-builtin">@intCast</span>(<span class="tok-type">i32</span>, i) * <span class="tok-number">2</span>,
        };
    }
    <span class="tok-kw">break</span> :init initial_value;
};
<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">i32</span>,
    y: <span class="tok-type">i32</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;compile-time array initialization&quot;</span> {
    expect(fancy_array[<span class="tok-number">4</span>].x == <span class="tok-number">4</span>);
    expect(fancy_array[<span class="tok-number">4</span>].y == <span class="tok-number">8</span>);
}

<span class="tok-comment">// call a function to initialize an array</span>
<span class="tok-kw">var</span> more_points = [_]Point{makePoint(<span class="tok-number">3</span>)} ** <span class="tok-number">10</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">makePoint</span>(x: <span class="tok-type">i32</span>) Point {
    <span class="tok-kw">return</span> Point{
        .x = x,
        .y = x * <span class="tok-number">2</span>,
    };
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;array initialization with function calls&quot;</span> {
    expect(more_points[<span class="tok-number">4</span>].x == <span class="tok-number">3</span>);
    expect(more_points[<span class="tok-number">4</span>].y == <span class="tok-number">6</span>);
    expect(more_points.len == <span class="tok-number">10</span>);
}</code></pre><pre><code class="shell">$ zig test arrays.zig
Test [1/4] test &quot;iterate over an array&quot;... 
Test [2/4] test &quot;modify an array&quot;... 
Test [3/4] test &quot;compile-time array initialization&quot;... 
Test [4/4] test &quot;array initialization with function calls&quot;... 

All 4 tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#for">for</a></li>
<li><a href="#Slices">Slices</a></li>
</ul>


      <h2 id="Anonymous-List-Literals"><a href="#toc-Anonymous-List-Literals">Anonymous List Literals</a> <a class="hdr" href="#Anonymous-List-Literals">§</a></h2>

      <p>Similar to <a href="#Enum-Literals">Enum Literals</a> and <a href="#Anonymous-Struct-Literals">Anonymous Struct Literals</a>
      the type can be omitted from array literals:</p>
      <p class="file">anon_list.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;anonymous list literal syntax&quot;</span> {
    <span class="tok-kw">var</span> array: [<span class="tok-number">4</span>]<span class="tok-type">u8</span> = .{<span class="tok-number">11</span>, <span class="tok-number">22</span>, <span class="tok-number">33</span>, <span class="tok-number">44</span>};
    expect(array[<span class="tok-number">0</span>] == <span class="tok-number">11</span>);
    expect(array[<span class="tok-number">1</span>] == <span class="tok-number">22</span>);
    expect(array[<span class="tok-number">2</span>] == <span class="tok-number">33</span>);
    expect(array[<span class="tok-number">3</span>] == <span class="tok-number">44</span>);
}</code></pre><pre><code class="shell">$ zig test anon_list.zig
Test [1/1] test &quot;anonymous list literal syntax&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      If there is no type in the result location then an anonymous list literal actually
      turns into a <a href="#struct">struct</a> with numbered field names:
      </p>
      <p class="file">infer_list_literal.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;fully anonymous list literal&quot;</span> {
    dump(.{ <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1234</span>), <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">12.34</span>), <span class="tok-null">true</span>, <span class="tok-str">&quot;hi&quot;</span>});
}

<span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(args: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    expect(args.@&quot;0&quot; == <span class="tok-number">1234</span>);
    expect(args.@&quot;1&quot; == <span class="tok-number">12.34</span>);
    expect(args.@&quot;2&quot;);
    expect(args.@&quot;3&quot;[<span class="tok-number">0</span>] == <span class="tok-str">'h'</span>);
    expect(args.@&quot;3&quot;[<span class="tok-number">1</span>] == <span class="tok-str">'i'</span>);
}</code></pre><pre><code class="shell">$ zig test infer_list_literal.zig
Test [1/1] test &quot;fully anonymous list literal&quot;... 

All 1 tests passed.
</code></pre>

      

      <h2 id="Multidimensional-Arrays"><a href="#toc-Multidimensional-Arrays">Multidimensional Arrays</a> <a class="hdr" href="#Multidimensional-Arrays">§</a></h2>

      <p>
      Mutlidimensional arrays can be created by nesting arrays:
      </p>
      <p class="file">multidimensional.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> mat4x4 = [<span class="tok-number">4</span>][<span class="tok-number">4</span>]<span class="tok-type">f32</span>{
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span> },
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span> },
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span> },
    [_]<span class="tok-type">f32</span>{ <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">1.0</span> },
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;multidimensional arrays&quot;</span> {
    <span class="tok-comment">// Access the 2D array by indexing the outer array, and then the inner array.</span>
    expect(mat4x4[<span class="tok-number">1</span>][<span class="tok-number">1</span>] == <span class="tok-number">1.0</span>);

    <span class="tok-comment">// Here we iterate with for loops.</span>
    <span class="tok-kw">for</span> (mat4x4) |row, row_index| {
        <span class="tok-kw">for</span> (row) |cell, column_index| {
            <span class="tok-kw">if</span> (row_index == column_index) {
                expect(cell == <span class="tok-number">1.0</span>);
            }
        }
    }
}</code></pre><pre><code class="shell">$ zig test multidimensional.zig
Test [1/1] test &quot;multidimensional arrays&quot;... 

All 1 tests passed.
</code></pre>

      

      <h2 id="Sentinel-Terminated-Arrays"><a href="#toc-Sentinel-Terminated-Arrays">Sentinel-Terminated Arrays</a> <a class="hdr" href="#Sentinel-Terminated-Arrays">§</a></h2>

      <p>
      The syntax <code class="zig">[N:x]T</code> describes an array which has a sentinel element of value <code class="zig">x</code> at the
      index corresponding to <code class="zig">len</code>.
      </p>
      <p class="file">null_terminated_array.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;null terminated array&quot;</span> {
    <span class="tok-kw">const</span> array = [_:<span class="tok-number">0</span>]<span class="tok-type">u8</span> {<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>};

    expect(<span class="tok-builtin">@TypeOf</span>(array) == [<span class="tok-number">4</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span>);
    expect(array.len == <span class="tok-number">4</span>);
    expect(array[<span class="tok-number">4</span>] == <span class="tok-number">0</span>);
}</code></pre><pre><code class="shell">$ zig test null_terminated_array.zig
Test [1/1] test &quot;null terminated array&quot;... 

All 1 tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a></li>
<li><a href="#Sentinel-Terminated-Slices">Sentinel-Terminated Slices</a></li>
</ul>

      
      

      <h1 id="Vectors"><a href="#toc-Vectors">Vectors</a> <a class="hdr" href="#Vectors">§</a></h1>

      <p>
      A vector is a group of booleans, <a href="#Integers">Integers</a>, <a href="#Floats">Floats</a>, or <a href="#Pointers">Pointers</a> which are operated on
      in parallel using a single instruction (<a href="#SIMD">SIMD</a>). Vector types are created with the builtin function <a href="#Type">@Type</a>,
      or using the shorthand as <code class="zig">std.meta.Vector</code>.
      </p>
      <p>
      TODO talk about C ABI interop
      </p>
      <h2 id="SIMD"><a href="#toc-SIMD">SIMD</a> <a class="hdr" href="#SIMD">§</a></h2>

      <p>
      TODO Zig's SIMD abilities are just beginning to be fleshed out. Here are some talking points to update the
      docs with:
      * What kind of operations can you do? All the operations on integers and floats? What about mixing scalar and vector?
      * How to convert to/from vectors/arrays
      * How to access individual elements from vectors, how to loop over the elements
      * "shuffle"
      * Advice on writing high perf software, how to abstract the best way
      </p>
      
      

      <h1 id="Pointers"><a href="#toc-Pointers">Pointers</a> <a class="hdr" href="#Pointers">§</a></h1>

      <p>
      Zig has two kinds of pointers: single-item and many-item.
      </p>
      <ul>
          <li><code class="zig">*T</code> - single-item pointer to exactly one item.
            <ul>
              <li>Supports deref syntax: <code class="zig">ptr.*</code></li>
            </ul>
          </li>
          <li><code class="zig">[*]T</code> - many-item pointer to unknown number of items.
            <ul>
              <li>Supports index syntax: <code class="zig">ptr[i]</code></li>
              <li>Supports slice syntax: <code class="zig">ptr[start..end]</code></li>
              <li>Supports pointer arithmetic: <code class="zig">ptr + x</code>, <code class="zig">ptr - x</code></li>
              <li><code class="zig">T</code> must have a known size, which means that it cannot be
              <code class="zig"><span class="tok-type">c_void</span></code> or any other <a href="#opaque">opaque type</a>.</li>
            </ul>
          </li>
      </ul>
      <p>These types are closely related to <a href="#Arrays">Arrays</a> and <a href="#Slices">Slices</a>:</p>
        <ul>
            <li><code class="zig">*[N]T</code> - pointer to N items, same as single-item pointer to an array.
            <ul>
                <li>Supports index syntax: <code class="zig">array_ptr[i]</code></li>
                <li>Supports slice syntax: <code class="zig">array_ptr[start..end]</code></li>
                <li>Supports len property: <code class="zig">array_ptr.len</code></li>
            </ul>
            </li>
        </ul>
        <ul>
            <li><code class="zig">[]T</code> - pointer to runtime-known number of items.
            <ul>
                <li>Supports index syntax: <code class="zig">slice[i]</code></li>
                <li>Supports slice syntax: <code class="zig">slice[start..end]</code></li>
                <li>Supports len property: <code class="zig">slice.len</code></li>
            </ul>
            </li>
        </ul>
        <p>Use <code class="zig">&amp;x</code> to obtain a single-item pointer:</p>
        <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;address of syntax&quot;</span> {
    <span class="tok-comment">// Get the address of a variable:</span>
    <span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> x_ptr = &amp;x;

    <span class="tok-comment">// Dereference a pointer:</span>
    expect(x_ptr.* == <span class="tok-number">1234</span>);

    <span class="tok-comment">// When you get the address of a const variable, you get a const single-item pointer.</span>
    expect(<span class="tok-builtin">@TypeOf</span>(x_ptr) == *<span class="tok-kw">const</span> <span class="tok-type">i32</span>);

    <span class="tok-comment">// If you want to mutate the value, you'd need an address of a mutable variable:</span>
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">5678</span>;
    <span class="tok-kw">const</span> y_ptr = &amp;y;
    expect(<span class="tok-builtin">@TypeOf</span>(y_ptr) == *<span class="tok-type">i32</span>);
    y_ptr.* += <span class="tok-number">1</span>;
    expect(y_ptr.* == <span class="tok-number">5679</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer array access&quot;</span> {
    <span class="tok-comment">// Taking an address of an individual element gives a</span>
    <span class="tok-comment">// single-item pointer. This kind of pointer</span>
    <span class="tok-comment">// does not support pointer arithmetic.</span>
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span> };
    <span class="tok-kw">const</span> ptr = &amp;array[<span class="tok-number">2</span>];
    expect(<span class="tok-builtin">@TypeOf</span>(ptr) == *<span class="tok-type">u8</span>);

    expect(array[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);
    ptr.* += <span class="tok-number">1</span>;
    expect(array[<span class="tok-number">2</span>] == <span class="tok-number">4</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/2] test &quot;address of syntax&quot;... 
Test [2/2] test &quot;pointer array access&quot;... 

All 2 tests passed.
</code></pre>

      <p>
        In Zig, we generally prefer <a href="#Slices">Slices</a> rather than <a href="#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a>.
        You can turn an array or pointer into a slice using slice syntax.
      </p>
      <p>
        Slices have bounds checking and are therefore protected
        against this kind of undefined behavior. This is one reason
        we prefer slices to pointers.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer slicing&quot;</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span> };
    <span class="tok-kw">const</span> slice = array[<span class="tok-number">2</span>..<span class="tok-number">4</span>];
    expect(slice.len == <span class="tok-number">2</span>);

    expect(array[<span class="tok-number">3</span>] == <span class="tok-number">4</span>);
    slice[<span class="tok-number">1</span>] += <span class="tok-number">1</span>;
    expect(array[<span class="tok-number">3</span>] == <span class="tok-number">5</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;pointer slicing&quot;... 

All 1 tests passed.
</code></pre>

      <p>Pointers work at compile-time too, as long as the code does not depend on
      an undefined memory layout:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;comptime pointers&quot;</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
        <span class="tok-kw">const</span> ptr = &amp;x;
        ptr.* += <span class="tok-number">1</span>;
        x += <span class="tok-number">1</span>;
        expect(ptr.* == <span class="tok-number">3</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;comptime pointers&quot;... 

All 1 tests passed.
</code></pre>

      <p>To convert an integer address into a pointer, use <code class="zig"><span class="tok-builtin">@intToPtr</span></code>.
      To convert a pointer to an integer, use <code class="zig"><span class="tok-builtin">@ptrToInt</span></code>:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;@ptrToInt and @intToPtr&quot;</span> {
    <span class="tok-kw">const</span> ptr = <span class="tok-builtin">@intToPtr</span>(*<span class="tok-type">i32</span>, <span class="tok-number">0xdeadbee0</span>);
    <span class="tok-kw">const</span> addr = <span class="tok-builtin">@ptrToInt</span>(ptr);
    expect(<span class="tok-builtin">@TypeOf</span>(addr) == <span class="tok-type">usize</span>);
    expect(addr == <span class="tok-number">0xdeadbee0</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;@ptrToInt and @intToPtr&quot;... 

All 1 tests passed.
</code></pre>

      <p>Zig is able to preserve memory addresses in comptime code, as long as
      the pointer is never dereferenced:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;comptime @intToPtr&quot;</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-comment">// Zig is able to do this at compile-time, as long as</span>
        <span class="tok-comment">// ptr is never dereferenced.</span>
        <span class="tok-kw">const</span> ptr = <span class="tok-builtin">@intToPtr</span>(*<span class="tok-type">i32</span>, <span class="tok-number">0xdeadbee0</span>);
        <span class="tok-kw">const</span> addr = <span class="tok-builtin">@ptrToInt</span>(ptr);
        expect(<span class="tok-builtin">@TypeOf</span>(addr) == <span class="tok-type">usize</span>);
        expect(addr == <span class="tok-number">0xdeadbee0</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;comptime @intToPtr&quot;... 

All 1 tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Optional-Pointers">Optional Pointers</a></li>
<li><a href="#intToPtr">@intToPtr</a></li>
<li><a href="#ptrToInt">@ptrToInt</a></li>
<li><a href="#C-Pointers">C Pointers</a></li>
<li><a href="#Pointers-to-Zero-Bit-Types">Pointers to Zero Bit Types</a></li>
</ul>

      <h2 id="volatile"><a href="#toc-volatile">volatile</a> <a class="hdr" href="#volatile">§</a></h2>

      <p>Loads and stores are assumed to not have side effects. If a given load or store
      should have side effects, such as Memory Mapped Input/Output (MMIO), use <code class="zig"><span class="tok-kw">volatile</span></code>.
      In the following code, loads and stores with <code class="zig">mmio_ptr</code> are guaranteed to all happen
      and in the same order as in source code:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;volatile&quot;</span> {
    <span class="tok-kw">const</span> mmio_ptr = <span class="tok-builtin">@intToPtr</span>(*<span class="tok-kw">volatile</span> <span class="tok-type">u8</span>, <span class="tok-number">0x12345678</span>);
    expect(<span class="tok-builtin">@TypeOf</span>(mmio_ptr) == *<span class="tok-kw">volatile</span> <span class="tok-type">u8</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;volatile&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      Note that <code class="zig"><span class="tok-kw">volatile</span></code> is unrelated to concurrency and <a href="#Atomics">Atomics</a>.
      If you see code that is using <code class="zig"><span class="tok-kw">volatile</span></code> for something other than Memory Mapped
      Input/Output, it is probably a bug.
      </p>
      
      <p>
      To convert one pointer type to another, use <a href="#ptrCast">@ptrCast</a>. This is an unsafe
      operation that Zig cannot protect you against. Use <code class="zig"><span class="tok-builtin">@ptrCast</span></code> only when other
      conversions are not possible.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer casting&quot;</span> {
    <span class="tok-kw">const</span> bytes <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">u32</span>)) = [_]<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span> };
    <span class="tok-kw">const</span> u32_ptr = <span class="tok-builtin">@ptrCast</span>(*<span class="tok-kw">const</span> <span class="tok-type">u32</span>, &amp;bytes);
    expect(u32_ptr.* == <span class="tok-number">0x12121212</span>);

    <span class="tok-comment">// Even this example is contrived - there are better ways to do the above than</span>
    <span class="tok-comment">// pointer casting. For example, using a slice narrowing cast:</span>
    <span class="tok-kw">const</span> u32_value = std.mem.bytesAsSlice(<span class="tok-type">u32</span>, bytes[<span class="tok-number">0</span>..])[<span class="tok-number">0</span>];
    expect(u32_value == <span class="tok-number">0x12121212</span>);

    <span class="tok-comment">// And even another way, the most straightforward way to do it:</span>
    expect(<span class="tok-builtin">@bitCast</span>(<span class="tok-type">u32</span>, bytes) == <span class="tok-number">0x12121212</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer child type&quot;</span> {
    <span class="tok-comment">// pointer types have a `child` field which tells you the type they point to.</span>
    expect(<span class="tok-builtin">@typeInfo</span>(*<span class="tok-type">u32</span>).Pointer.child == <span class="tok-type">u32</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/2] test &quot;pointer casting&quot;... 
Test [2/2] test &quot;pointer child type&quot;... 

All 2 tests passed.
</code></pre>

      <h2 id="Alignment"><a href="#toc-Alignment">Alignment</a> <a class="hdr" href="#Alignment">§</a></h2>

      <p>
      Each type has an <strong>alignment</strong> - a number of bytes such that,
      when a value of the type is loaded from or stored to memory,
      the memory address must be evenly divisible by this number. You can use
      <a href="#alignOf">@alignOf</a> to find out this value for any type.
      </p>
      <p>
      Alignment depends on the CPU architecture, but is always a power of two, and
      less than <code class="zig"><span class="tok-number">1</span> &lt;&lt; <span class="tok-number">29</span></code>.
      </p>
      <p>
      In Zig, a pointer type has an alignment value. If the value is equal to the
      alignment of the underlying type, it can be omitted from the type:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;variable alignment&quot;</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> align_of_i32 = <span class="tok-builtin">@alignOf</span>(<span class="tok-builtin">@TypeOf</span>(x));
    expect(<span class="tok-builtin">@TypeOf</span>(&amp;x) == *<span class="tok-type">i32</span>);
    expect(*<span class="tok-type">i32</span> == *<span class="tok-kw">align</span>(align_of_i32) <span class="tok-type">i32</span>);
    <span class="tok-kw">if</span> (std.Target.current.cpu.arch == .x86_64) {
        expect(<span class="tok-builtin">@typeInfo</span>(*<span class="tok-type">i32</span>).Pointer.alignment == <span class="tok-number">4</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;variable alignment&quot;... 

All 1 tests passed.
</code></pre>

      <p>In the same way that a <code class="zig">*<span class="tok-type">i32</span></code> can be <a href="#Type-Coercion">coerced</a> to a
          <code class="zig">*<span class="tok-kw">const</span> <span class="tok-type">i32</span></code>, a pointer with a larger alignment can be implicitly
      cast to a pointer with a smaller alignment, but not vice versa.
      </p>
      <p>
      You can specify alignment on variables and functions. If you do this, then
      pointers to them get the specified alignment:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">var</span> foo: <span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = <span class="tok-number">100</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;global variable alignment&quot;</span> {
    expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(&amp;foo)).Pointer.alignment == <span class="tok-number">4</span>);
    expect(<span class="tok-builtin">@TypeOf</span>(&amp;foo) == *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>);
    <span class="tok-kw">const</span> as_pointer_to_array: *[<span class="tok-number">1</span>]<span class="tok-type">u8</span> = &amp;foo;
    <span class="tok-kw">const</span> as_slice: []<span class="tok-type">u8</span> = as_pointer_to_array;
    expect(<span class="tok-builtin">@TypeOf</span>(as_slice) == []<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">derp</span>() <span class="tok-kw">align</span>(<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-number">2</span>) <span class="tok-type">i32</span> { <span class="tok-kw">return</span> <span class="tok-number">1234</span>; }
<span class="tok-kw">fn</span> <span class="tok-fn">noop1</span>() <span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">void</span> {}
<span class="tok-kw">fn</span> <span class="tok-fn">noop4</span>() <span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">void</span> {}

<span class="tok-kw">test</span> <span class="tok-str">&quot;function alignment&quot;</span> {
    expect(derp() == <span class="tok-number">1234</span>);
    expect(<span class="tok-builtin">@TypeOf</span>(noop1) == <span class="tok-kw">fn</span>() <span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">void</span>);
    expect(<span class="tok-builtin">@TypeOf</span>(noop4) == <span class="tok-kw">fn</span>() <span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">void</span>);
    noop1();
    noop4();
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/2] test &quot;global variable alignment&quot;... 
Test [2/2] test &quot;function alignment&quot;... 

All 2 tests passed.
</code></pre>

      <p>
      If you have a pointer or a slice that has a small alignment, but you know that it actually
      has a bigger alignment, use <a href="#alignCast">@alignCast</a> to change the
      pointer into a more aligned pointer. This is a no-op at runtime, but inserts a
      <a href="#Incorrect-Pointer-Alignment">safety check</a>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer alignment safety&quot;</span> {
    <span class="tok-kw">var</span> array <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = [_]<span class="tok-type">u32</span>{ <span class="tok-number">0x11111111</span>, <span class="tok-number">0x11111111</span> };
    <span class="tok-kw">const</span> bytes = std.mem.sliceAsBytes(array[<span class="tok-number">0</span>..]);
    std.testing.expect(foo(bytes) == <span class="tok-number">0x11111111</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(bytes: []<span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> slice4 = bytes[<span class="tok-number">1</span>..<span class="tok-number">5</span>];
    <span class="tok-kw">const</span> int_slice = std.mem.bytesAsSlice(<span class="tok-type">u32</span>, <span class="tok-builtin">@alignCast</span>(<span class="tok-number">4</span>, slice4));
    <span class="tok-kw">return</span> int_slice[<span class="tok-number">0</span>];
}</code></pre><pre><code class="shell">$ zig test test.zig 
Test [1/1] test &quot;pointer alignment safety&quot;... 
thread 1887 panic: incorrect alignment
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:10:63</span>: <span class="t2_0">0x207bdb in foo (test)</span>
    const int_slice = std.mem.bytesAsSlice(u32, @alignCast(4, slice4));
                                                              <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:6:27</span>: <span class="t2_0">0x20661a in test &quot;pointer alignment safety&quot; (test)</span>
    std.testing.expect(foo(bytes) == 0x11111111);
                          <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/special/test_runner.zig:69:28</span>: <span class="t2_0">0x230558 in std.special.main (test)</span>
        } else test_fn.func();
                           <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:420:37</span>: <span class="t2_0">0x207fd4 in std.start.posixCallMainAndExit (test)</span>
            const result = root.main() catch |err| {
                                    <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x207e72 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
error: the following test command crashed:
docgen_tmp/zig-cache/o/091db03e22edfdd7844d6b7c020b80d0/test /home/vsts/work/1/s/build/release/bin/zig
</code></pre>

      

      <h2 id="allowzero"><a href="#toc-allowzero">allowzero</a> <a class="hdr" href="#allowzero">§</a></h2>

      <p>
      This pointer attribute allows a pointer to have address zero. This is only ever needed on the
      freestanding OS target, where the address zero is mappable. If you want to represent null pointers, use
      <a href="#Optional-Pointers">Optional Pointers</a> instead. <a href="#Optional-Pointers">Optional Pointers</a> with <code class="zig"><span class="tok-kw">allowzero</span></code>
      are not the same size as pointers. In this code example, if the pointer
      did not have the <code class="zig"><span class="tok-kw">allowzero</span></code> attribute, this would be a
      <a href="#Pointer-Cast-Invalid-Null">Pointer Cast Invalid Null</a> panic:
      </p>
      <p class="file">allowzero.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;allowzero&quot;</span> {
    <span class="tok-kw">var</span> zero: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> ptr = <span class="tok-builtin">@intToPtr</span>(*<span class="tok-kw">allowzero</span> <span class="tok-type">i32</span>, zero);
    expect(<span class="tok-builtin">@ptrToInt</span>(ptr) == <span class="tok-number">0</span>);
}</code></pre><pre><code class="shell">$ zig test allowzero.zig
Test [1/1] test &quot;allowzero&quot;... 

All 1 tests passed.
</code></pre>

      

      <h2 id="Sentinel-Terminated-Pointers"><a href="#toc-Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a> <a class="hdr" href="#Sentinel-Terminated-Pointers">§</a></h2>

      <p>
      The syntax <code class="zig">[*:x]T</code> describes a pointer that
      has a length determined by a sentinel value. This provides protection
      against buffer overflow and overreads.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-comment">// This is also available as `std.c.printf`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">extern</span> <span class="tok-str">&quot;c&quot;</span> <span class="tok-kw">fn</span> <span class="tok-fn">printf</span>(format: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, ...) <span class="tok-type">c_int</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    _ = printf(<span class="tok-str">&quot;Hello, world!\n&quot;</span>); <span class="tok-comment">// OK</span>

    <span class="tok-kw">const</span> msg = <span class="tok-str">&quot;Hello, world!\n&quot;</span>;
    <span class="tok-kw">const</span> non_null_terminated_msg: [msg.len]<span class="tok-type">u8</span> = msg.*;
    _ = printf(&amp;non_null_terminated_msg);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig -lc
<span class="t0_1">./docgen_tmp/test.zig:11:17: </span><span class="t31_1">error: </span><span class="t0_1">expected type '[*:0]const u8', found '*const [14]u8'</span>
    _ = printf(&amp;non_null_terminated_msg);
                <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:11:17: </span><span class="t36_1">note: </span><span class="t0_1">destination pointer requires a terminating '0' sentinel</span>
    _ = printf(&amp;non_null_terminated_msg);
                <span class="t32_1">^</span>
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Sentinel-Terminated-Slices">Sentinel-Terminated Slices</a></li>
<li><a href="#Sentinel-Terminated-Arrays">Sentinel-Terminated Arrays</a></li>
</ul>

      
      

      <h1 id="Slices"><a href="#toc-Slices">Slices</a> <a class="hdr" href="#Slices">§</a></h1>

      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;basic slices&quot;</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-comment">// A slice is a pointer and a length. The difference between an array and</span>
    <span class="tok-comment">// a slice is that the array's length is part of the type and known at</span>
    <span class="tok-comment">// compile-time, whereas the slice's length is known at runtime.</span>
    <span class="tok-comment">// Both can be accessed with the `len` field.</span>
    <span class="tok-kw">var</span> known_at_runtime_zero: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> slice = array[known_at_runtime_zero..array.len];
    expect(&amp;slice[<span class="tok-number">0</span>] == &amp;array[<span class="tok-number">0</span>]);
    expect(slice.len == array.len);

    <span class="tok-comment">// Using the address-of operator on a slice gives a single-item pointer,</span>
    <span class="tok-comment">// while using the `ptr` field gives a many-item pointer.</span>
    expect(<span class="tok-builtin">@TypeOf</span>(slice.ptr) == [*]<span class="tok-type">i32</span>);
    expect(<span class="tok-builtin">@TypeOf</span>(&amp;slice[<span class="tok-number">0</span>]) == *<span class="tok-type">i32</span>);
    expect(<span class="tok-builtin">@ptrToInt</span>(slice.ptr) == <span class="tok-builtin">@ptrToInt</span>(&amp;slice[<span class="tok-number">0</span>]));

    <span class="tok-comment">// Slices have array bounds checking. If you try to access something out</span>
    <span class="tok-comment">// of bounds, you'll get a safety check failure:</span>
    slice[<span class="tok-number">10</span>] += <span class="tok-number">1</span>;

    <span class="tok-comment">// Note that `slice.ptr` does not invoke safety checking, while `&amp;slice[0]`</span>
    <span class="tok-comment">// asserts that the slice has len &gt;= 1.</span>
}</code></pre><pre><code class="shell">$ zig test test.zig 
Test [1/1] test &quot;basic slices&quot;... 
thread 1909 panic: index out of bounds
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:22:10</span>: <span class="t2_0">0x206746 in test &quot;basic slices&quot; (test)</span>
    slice[10] += 1;
         <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/special/test_runner.zig:69:28</span>: <span class="t2_0">0x230478 in std.special.main (test)</span>
        } else test_fn.func();
                           <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:420:37</span>: <span class="t2_0">0x207f84 in std.start.posixCallMainAndExit (test)</span>
            const result = root.main() catch |err| {
                                    <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x207e22 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
error: the following test command crashed:
docgen_tmp/zig-cache/o/091db03e22edfdd7844d6b7c020b80d0/test /home/vsts/work/1/s/build/release/bin/zig
</code></pre>

      <p>This is one reason we prefer slices to pointers.</p>
      <p class="file">slices.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> mem = std.mem;
<span class="tok-kw">const</span> fmt = std.fmt;

<span class="tok-kw">test</span> <span class="tok-str">&quot;using slices for strings&quot;</span> {
    <span class="tok-comment">// Zig has no concept of strings. String literals are const pointers</span>
    <span class="tok-comment">// to null-terminated arrays of u8, and by convention parameters</span>
    <span class="tok-comment">// that are &quot;strings&quot; are expected to be UTF-8 encoded slices of u8.</span>
    <span class="tok-comment">// Here we coerce *const [5:0]u8 and *const [6:0]u8 to []const u8</span>
    <span class="tok-kw">const</span> hello: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>;
    <span class="tok-kw">const</span> world: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;世界&quot;</span>;

    <span class="tok-kw">var</span> all_together: [<span class="tok-number">100</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-comment">// You can use slice syntax on an array to convert an array into a slice.</span>
    <span class="tok-kw">const</span> all_together_slice = all_together[<span class="tok-number">0</span>..];
    <span class="tok-comment">// String concatenation example.</span>
    <span class="tok-kw">const</span> hello_world = <span class="tok-kw">try</span> fmt.bufPrint(all_together_slice, <span class="tok-str">&quot;{s} {s}&quot;</span>, .{ hello, world });

    <span class="tok-comment">// Generally, you can use UTF-8 and not worry about whether something is a</span>
    <span class="tok-comment">// string. If you don't need to deal with individual characters, no need</span>
    <span class="tok-comment">// to decode.</span>
    expect(mem.eql(<span class="tok-type">u8</span>, hello_world, <span class="tok-str">&quot;hello 世界&quot;</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;slice pointer&quot;</span> {
    <span class="tok-kw">var</span> array: [<span class="tok-number">10</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> ptr = &amp;array;

    <span class="tok-comment">// You can use slicing syntax to convert a pointer into a slice:</span>
    <span class="tok-kw">const</span> slice = ptr[<span class="tok-number">0</span>..<span class="tok-number">5</span>];
    slice[<span class="tok-number">2</span>] = <span class="tok-number">3</span>;
    expect(slice[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);
    <span class="tok-comment">// The slice is mutable because we sliced a mutable pointer.</span>
    <span class="tok-comment">// Furthermore, it is actually a pointer to an array, since the start</span>
    <span class="tok-comment">// and end indexes were both comptime-known.</span>
    expect(<span class="tok-builtin">@TypeOf</span>(slice) == *[<span class="tok-number">5</span>]<span class="tok-type">u8</span>);

    <span class="tok-comment">// You can also slice a slice:</span>
    <span class="tok-kw">const</span> slice2 = slice[<span class="tok-number">2</span>..<span class="tok-number">3</span>];
    expect(slice2.len == <span class="tok-number">1</span>);
    expect(slice2[<span class="tok-number">0</span>] == <span class="tok-number">3</span>);
}</code></pre><pre><code class="shell">$ zig test slices.zig
Test [1/2] test &quot;using slices for strings&quot;... 
Test [2/2] test &quot;slice pointer&quot;... 

All 2 tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Pointers">Pointers</a></li>
<li><a href="#for">for</a></li>
<li><a href="#Arrays">Arrays</a></li>
</ul>


      <h2 id="Sentinel-Terminated-Slices"><a href="#toc-Sentinel-Terminated-Slices">Sentinel-Terminated Slices</a> <a class="hdr" href="#Sentinel-Terminated-Slices">§</a></h2>

      <p>
      The syntax <code class="zig">[:x]T</code> is a slice which has a runtime known length
      and also guarantees a sentinel value at the element indexed by the length. The type does not
      guarantee that there are no sentinel elements before that. Sentinel-terminated slices allow element
      access to the <code class="zig">len</code> index.
      </p>
      <p class="file">null_terminated_slice.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;null terminated slice&quot;</span> {
    <span class="tok-kw">const</span> slice: [:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>;

    expect(slice.len == <span class="tok-number">5</span>);
    expect(slice[<span class="tok-number">5</span>] == <span class="tok-number">0</span>);
}</code></pre><pre><code class="shell">$ zig test null_terminated_slice.zig
Test [1/1] test &quot;null terminated slice&quot;... 

All 1 tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a></li>
<li><a href="#Sentinel-Terminated-Arrays">Sentinel-Terminated Arrays</a></li>
</ul>

      
      

      <h1 id="struct"><a href="#toc-struct">struct</a> <a class="hdr" href="#struct">§</a></h1>

      <p class="file">structs.zig</p><pre><code class="zig"><span class="tok-comment">// Declare a struct.</span>
<span class="tok-comment">// Zig gives no guarantees about the order of fields and the size of</span>
<span class="tok-comment">// the struct but the fields are guaranteed to be ABI-aligned.</span>
<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">f32</span>,
    y: <span class="tok-type">f32</span>,
};

<span class="tok-comment">// Maybe we want to pass it to OpenGL so we want to be particular about</span>
<span class="tok-comment">// how the bytes are arranged.</span>
<span class="tok-kw">const</span> Point2 = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    x: <span class="tok-type">f32</span>,
    y: <span class="tok-type">f32</span>,
};


<span class="tok-comment">// Declare an instance of a struct.</span>
<span class="tok-kw">const</span> p = Point {
    .x = <span class="tok-number">0.12</span>,
    .y = <span class="tok-number">0.34</span>,
};

<span class="tok-comment">// Maybe we're not ready to fill out some of the fields.</span>
<span class="tok-kw">var</span> p2 = Point {
    .x = <span class="tok-number">0.12</span>,
    .y = <span class="tok-null">undefined</span>,
};

<span class="tok-comment">// Structs can have methods</span>
<span class="tok-comment">// Struct methods are not special, they are only namespaced</span>
<span class="tok-comment">// functions that you can call with dot syntax.</span>
<span class="tok-kw">const</span> Vec3 = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">f32</span>,
    y: <span class="tok-type">f32</span>,
    z: <span class="tok-type">f32</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span>, z: <span class="tok-type">f32</span>) Vec3 {
        <span class="tok-kw">return</span> Vec3 {
            .x = x,
            .y = y,
            .z = z,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dot</span>(self: Vec3, other: Vec3) <span class="tok-type">f32</span> {
        <span class="tok-kw">return</span> self.x * other.x + self.y * other.y + self.z * other.z;
    }
};

<span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;
<span class="tok-kw">test</span> <span class="tok-str">&quot;dot product&quot;</span> {
    <span class="tok-kw">const</span> v1 = Vec3.init(<span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>);
    <span class="tok-kw">const</span> v2 = Vec3.init(<span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>);
    expect(v1.dot(v2) == <span class="tok-number">0.0</span>);

    <span class="tok-comment">// Other than being available to call with dot syntax, struct methods are</span>
    <span class="tok-comment">// not special. You can reference them as any other declaration inside</span>
    <span class="tok-comment">// the struct:</span>
    expect(Vec3.dot(v1, v2) == <span class="tok-number">0.0</span>);
}

<span class="tok-comment">// Structs can have global declarations.</span>
<span class="tok-comment">// Structs can have 0 fields.</span>
<span class="tok-kw">const</span> Empty = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PI = <span class="tok-number">3.14</span>;
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;struct namespaced variable&quot;</span> {
    expect(Empty.PI == <span class="tok-number">3.14</span>);
    expect(<span class="tok-builtin">@sizeOf</span>(Empty) == <span class="tok-number">0</span>);

    <span class="tok-comment">// you can still instantiate an empty struct</span>
    <span class="tok-kw">const</span> does_nothing = Empty {};
}

<span class="tok-comment">// struct field order is determined by the compiler for optimal performance.</span>
<span class="tok-comment">// however, you can still calculate a struct base pointer given a field pointer:</span>
<span class="tok-kw">fn</span> <span class="tok-fn">setYBasedOnX</span>(x: *<span class="tok-type">f32</span>, y: <span class="tok-type">f32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> point = <span class="tok-builtin">@fieldParentPtr</span>(Point, <span class="tok-str">&quot;x&quot;</span>, x);
    point.y = y;
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;field parent pointer&quot;</span> {
    <span class="tok-kw">var</span> point = Point {
        .x = <span class="tok-number">0.1234</span>,
        .y = <span class="tok-number">0.5678</span>,
    };
    setYBasedOnX(&amp;point.x, <span class="tok-number">0.9</span>);
    expect(point.y == <span class="tok-number">0.9</span>);
}

<span class="tok-comment">// You can return a struct from a function. This is how we do generics</span>
<span class="tok-comment">// in Zig:</span>
<span class="tok-kw">fn</span> <span class="tok-fn">LinkedList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
            prev: ?*Node,
            next: ?*Node,
            data: T,
        };

        first: ?*Node,
        last:  ?*Node,
        len:   <span class="tok-type">usize</span>,
    };
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;linked list&quot;</span> {
    <span class="tok-comment">// Functions called at compile-time are memoized. This means you can</span>
    <span class="tok-comment">// do this:</span>
    expect(LinkedList(<span class="tok-type">i32</span>) == LinkedList(<span class="tok-type">i32</span>));

    <span class="tok-kw">var</span> list = LinkedList(<span class="tok-type">i32</span>) {
        .first = <span class="tok-null">null</span>,
        .last = <span class="tok-null">null</span>,
        .len = <span class="tok-number">0</span>,
    };
    expect(list.len == <span class="tok-number">0</span>);

    <span class="tok-comment">// Since types are first class values you can instantiate the type</span>
    <span class="tok-comment">// by assigning it to a variable:</span>
    <span class="tok-kw">const</span> ListOfInts = LinkedList(<span class="tok-type">i32</span>);
    expect(ListOfInts == LinkedList(<span class="tok-type">i32</span>));

    <span class="tok-kw">var</span> node = ListOfInts.Node {
        .prev = <span class="tok-null">null</span>,
        .next = <span class="tok-null">null</span>,
        .data = <span class="tok-number">1234</span>,
    };
    <span class="tok-kw">var</span> list2 = LinkedList(<span class="tok-type">i32</span>) {
        .first = &amp;node,
        .last = &amp;node,
        .len = <span class="tok-number">1</span>,
    };
    expect(list2.first.?.data == <span class="tok-number">1234</span>);
}</code></pre><pre><code class="shell">$ zig test structs.zig
Test [1/4] test &quot;dot product&quot;... 
Test [2/4] test &quot;struct namespaced variable&quot;... 
Test [3/4] test &quot;field parent pointer&quot;... 
Test [4/4] test &quot;linked list&quot;... 

All 4 tests passed.
</code></pre>


      <h2 id="Default-Field-Values"><a href="#toc-Default-Field-Values">Default Field Values</a> <a class="hdr" href="#Default-Field-Values">§</a></h2>

      <p>
      Each struct field may have an expression indicating the default field value. Such expressions
      are executed at <a href="#comptime">comptime</a>, and allow the field to be omitted in a struct literal expression:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
    a: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>,
    b: <span class="tok-type">i32</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;default struct initialization fields&quot;</span> {
    <span class="tok-kw">const</span> x = Foo{
        .b = <span class="tok-number">5</span>,
    };
    <span class="tok-kw">if</span> (x.a + x.b != <span class="tok-number">1239</span>) {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;it's even comptime known!&quot;</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;default struct initialization fields&quot;... 

All 1 tests passed.
</code></pre>

      

      <h2 id="extern-struct"><a href="#toc-extern-struct">extern struct</a> <a class="hdr" href="#extern-struct">§</a></h2>

      <p>An <code class="zig"><span class="tok-kw">extern</span> <span class="tok-kw">struct</span></code> has in-memory layout guaranteed to match the
      C ABI for the target.</p>
      <p>This kind of struct should only be used for compatibility with the C ABI. Every other
      use case should be solved with <a href="#packed-struct">packed struct</a> or normal <a href="#struct">struct</a>.</p>
      <p>See also:</p><ul>
<li><a href="#extern-union">extern union</a></li>
<li><a href="#extern-enum">extern enum</a></li>
</ul>

      

      <h2 id="packed-struct"><a href="#toc-packed-struct">packed struct</a> <a class="hdr" href="#packed-struct">§</a></h2>

      <p>
      Unlike normal structs, <code class="zig"><span class="tok-kw">packed</span></code> structs have guaranteed in-memory layout:
      </p>
      <ul>
        <li>Fields remain in the order declared.</li>
        <li>There is no padding between fields.</li>
        <li>Zig supports arbitrary width <a href="#Integers">Integers</a> and although normally, integers with fewer
        than 8 bits will still use 1 byte of memory, in packed structs, they use
        exactly their bit width.
        </li>
        <li><code class="zig"><span class="tok-type">bool</span></code> fields use exactly 1 bit.</li>
        <li>A <a href="#packed-enum">packed enum</a> field uses exactly the bit width of its integer tag type.</li>
        <li>A <a href="#packed-union">packed union</a> field uses exactly the bit width of the union field with
        the largest bit width.</li>
        <li>Non-ABI-aligned fields are packed into the smallest possible
        ABI-aligned integers in accordance with the target endianness.
        </li>
      </ul>
      <p>
      This means that a <code class="zig"><span class="tok-kw">packed</span> <span class="tok-kw">struct</span></code> can participate
      in a <a href="#bitCast">@bitCast</a> or a <a href="#ptrCast">@ptrCast</a> to reinterpret memory.
      This even works at <a href="#comptime">comptime</a>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = std.builtin;
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Full = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    number: <span class="tok-type">u16</span>,
};
<span class="tok-kw">const</span> Divided = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    half1: <span class="tok-type">u8</span>,
    quarter3: <span class="tok-type">u4</span>,
    quarter4: <span class="tok-type">u4</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;@bitCast between packed structs&quot;</span> {
    doTheTest();
    <span class="tok-kw">comptime</span> doTheTest();
}

<span class="tok-kw">fn</span> <span class="tok-fn">doTheTest</span>() <span class="tok-type">void</span> {
    expect(<span class="tok-builtin">@sizeOf</span>(Full) == <span class="tok-number">2</span>);
    expect(<span class="tok-builtin">@sizeOf</span>(Divided) == <span class="tok-number">2</span>);
    <span class="tok-kw">var</span> full = Full{ .number = <span class="tok-number">0x1234</span> };
    <span class="tok-kw">var</span> divided = <span class="tok-builtin">@bitCast</span>(Divided, full);
    <span class="tok-kw">switch</span> (builtin.endian) {
        .Big =&gt; {
            expect(divided.half1 == <span class="tok-number">0x12</span>);
            expect(divided.quarter3 == <span class="tok-number">0x3</span>);
            expect(divided.quarter4 == <span class="tok-number">0x4</span>);
        },
        .Little =&gt; {
            expect(divided.half1 == <span class="tok-number">0x34</span>);
            expect(divided.quarter3 == <span class="tok-number">0x2</span>);
            expect(divided.quarter4 == <span class="tok-number">0x1</span>);
        },
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;@bitCast between packed structs&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      Zig allows the address to be taken of a non-byte-aligned field:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">var</span> foo = BitField{
    .a = <span class="tok-number">1</span>,
    .b = <span class="tok-number">2</span>,
    .c = <span class="tok-number">3</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer to non-byte-aligned field&quot;</span> {
    <span class="tok-kw">const</span> ptr = &amp;foo.b;
    expect(ptr.* == <span class="tok-number">2</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;pointer to non-byte-aligned field&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      However, the pointer to a non-byte-aligned field has special properties and cannot
      be passed when a normal pointer is expected:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">var</span> bit_field = BitField{
    .a = <span class="tok-number">1</span>,
    .b = <span class="tok-number">2</span>,
    .c = <span class="tok-number">3</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer to non-bit-aligned field&quot;</span> {
    expect(bar(&amp;bit_field.b) == <span class="tok-number">2</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(x: *<span class="tok-kw">const</span> <span class="tok-type">u3</span>) <span class="tok-type">u3</span> {
    <span class="tok-kw">return</span> x.*;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:17:26: </span><span class="t31_1">error: </span><span class="t0_1">expected type '*const u3', found '*align(:3:1) u3'</span>
    expect(bar(&amp;bit_field.b) == 2);
                         <span class="t32_1">^</span>
</code></pre>

      <p>
      In this case, the function <code class="zig">bar</code> cannot be called becuse the pointer
      to the non-ABI-aligned field mentions the bit offset, but the function expects an ABI-aligned pointer.
      </p>
      <p>
      Pointers to non-ABI-aligned fields share the same address as the other fields within their host integer:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">var</span> bit_field = BitField{
    .a = <span class="tok-number">1</span>,
    .b = <span class="tok-number">2</span>,
    .c = <span class="tok-number">3</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer to non-bit-aligned field&quot;</span> {
    expect(<span class="tok-builtin">@ptrToInt</span>(&amp;bit_field.a) == <span class="tok-builtin">@ptrToInt</span>(&amp;bit_field.b));
    expect(<span class="tok-builtin">@ptrToInt</span>(&amp;bit_field.a) == <span class="tok-builtin">@ptrToInt</span>(&amp;bit_field.c));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;pointer to non-bit-aligned field&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      This can be observed with <a href="#bitOffsetOf">@bitOffsetOf</a> and <a href="#byteOffsetOf">byteOffsetOf</a>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> BitField = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u3</span>,
    b: <span class="tok-type">u3</span>,
    c: <span class="tok-type">u2</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer to non-bit-aligned field&quot;</span> {
    <span class="tok-kw">comptime</span> {
        expect(<span class="tok-builtin">@bitOffsetOf</span>(BitField, <span class="tok-str">&quot;a&quot;</span>) == <span class="tok-number">0</span>);
        expect(<span class="tok-builtin">@bitOffsetOf</span>(BitField, <span class="tok-str">&quot;b&quot;</span>) == <span class="tok-number">3</span>);
        expect(<span class="tok-builtin">@bitOffsetOf</span>(BitField, <span class="tok-str">&quot;c&quot;</span>) == <span class="tok-number">6</span>);

        expect(<span class="tok-builtin">@byteOffsetOf</span>(BitField, <span class="tok-str">&quot;a&quot;</span>) == <span class="tok-number">0</span>);
        expect(<span class="tok-builtin">@byteOffsetOf</span>(BitField, <span class="tok-str">&quot;b&quot;</span>) == <span class="tok-number">0</span>);
        expect(<span class="tok-builtin">@byteOffsetOf</span>(BitField, <span class="tok-str">&quot;c&quot;</span>) == <span class="tok-number">0</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;pointer to non-bit-aligned field&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      Packed structs have 1-byte alignment. However if you have an overaligned pointer to a packed struct,
      Zig should correctly understand the alignment of fields. However there is
      <a href="https://github.com/ziglang/zig/issues/1994">a bug</a>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> S = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    a: <span class="tok-type">u32</span>,
    b: <span class="tok-type">u32</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;overaligned pointer to packed struct&quot;</span> {
    <span class="tok-kw">var</span> foo: S <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> ptr: *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) S = &amp;foo;
    <span class="tok-kw">const</span> ptr_to_b: *<span class="tok-type">u32</span> = &amp;ptr.b;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:8:32: </span><span class="t31_1">error: </span><span class="t0_1">expected type '*u32', found '*align(1) u32'</span>
    const ptr_to_b: *u32 = &amp;ptr.b;
                               <span class="t32_1">^</span>
</code></pre>

      <p>When this bug is fixed, the above test in the documentation will unexpectedly pass, which will
      cause the test suite to fail, notifying the bug fixer to update these docs.
      </p>
      <p>
      It's also possible to set alignment of struct fields:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expectEqual = std.testing.expectEqual;

<span class="tok-kw">test</span> <span class="tok-str">&quot;aligned struct fields&quot;</span> {
    <span class="tok-kw">const</span> S = <span class="tok-kw">struct</span> {
        a: <span class="tok-type">u32</span> <span class="tok-kw">align</span>(<span class="tok-number">2</span>),
        b: <span class="tok-type">u32</span> <span class="tok-kw">align</span>(<span class="tok-number">64</span>),
    };
    <span class="tok-kw">var</span> foo = S{ .a = <span class="tok-number">1</span>, .b = <span class="tok-number">2</span> };

    expectEqual(<span class="tok-number">64</span>, <span class="tok-builtin">@alignOf</span>(S));
    expectEqual(*<span class="tok-kw">align</span>(<span class="tok-number">2</span>) <span class="tok-type">u32</span>, <span class="tok-builtin">@TypeOf</span>(&amp;foo.a));
    expectEqual(*<span class="tok-kw">align</span>(<span class="tok-number">64</span>) <span class="tok-type">u32</span>, <span class="tok-builtin">@TypeOf</span>(&amp;foo.b));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;aligned struct fields&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      Using packed structs with <a href="#volatile">volatile</a> is problematic, and may be a compile error in the future.
      For details on this subscribe to
      <a href="https://github.com/ziglang/zig/issues/1761">this issue</a>.
      TODO update these docs with a recommendation on how to use packed structs with MMIO
      (the use case for volatile packed structs) once this issue is resolved.
      Don't worry, there will be a good solution for this use case in zig.
      </p>
      

      <h2 id="Struct-Naming"><a href="#toc-Struct-Naming">Struct Naming</a> <a class="hdr" href="#Struct-Naming">§</a></h2>

      <p>Since all structs are anonymous, Zig infers the type name based on a few rules.</p>
      <ul>
          <li>If the struct is in the initialization expression of a variable, it gets named after
          that variable.</li>
          <li>If the struct is in the <code class="zig"><span class="tok-kw">return</span></code> expression, it gets named after
          the function it is returning from, with the parameter values serialized.</li>
          <li>Otherwise, the struct gets a name such as <code>(anonymous struct at file.zig:7:38)</code>.</li>
      </ul>
      <p class="file">struct_name.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {};
    std.debug.print(<span class="tok-str">&quot;variable: {s}\n&quot;</span>, .{<span class="tok-builtin">@typeName</span>(Foo)});
    std.debug.print(<span class="tok-str">&quot;anonymous: {s}\n&quot;</span>, .{<span class="tok-builtin">@typeName</span>(<span class="tok-kw">struct</span> {})});
    std.debug.print(<span class="tok-str">&quot;function: {s}\n&quot;</span>, .{<span class="tok-builtin">@typeName</span>(List(<span class="tok-type">i32</span>))});
}

<span class="tok-kw">fn</span> <span class="tok-fn">List</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        x: T,
    };
}</code></pre><pre><code class="shell">$ zig build-exe struct_name.zig
$ ./struct_name
variable: Foo
anonymous: struct:6:53
function: List(i32)
</code></pre>

      

      <h2 id="Anonymous-Struct-Literals"><a href="#toc-Anonymous-Struct-Literals">Anonymous Struct Literals</a> <a class="hdr" href="#Anonymous-Struct-Literals">§</a></h2>

      <p>
      Zig allows omitting the struct type of a literal. When the result is <a href="#Type-Coercion">coerced</a>,
      the struct literal will directly instantiate the result location, with no copy:
      </p>
      <p class="file">struct_result.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {x: <span class="tok-type">i32</span>, y: <span class="tok-type">i32</span>};

<span class="tok-kw">test</span> <span class="tok-str">&quot;anonymous struct literal&quot;</span> {
    <span class="tok-kw">var</span> pt: Point = .{
        .x = <span class="tok-number">13</span>,
        .y = <span class="tok-number">67</span>,
    };
    expect(pt.x == <span class="tok-number">13</span>);
    expect(pt.y == <span class="tok-number">67</span>);
}</code></pre><pre><code class="shell">$ zig test struct_result.zig
Test [1/1] test &quot;anonymous struct literal&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      The struct type can be inferred. Here the result location does not include a type, and
      so Zig infers the type:
      </p>
      <p class="file">struct_anon.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;fully anonymous struct&quot;</span> {
    dump(.{
        .int = <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1234</span>),
        .float = <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">12.34</span>),
        .b = <span class="tok-null">true</span>,
        .s = <span class="tok-str">&quot;hi&quot;</span>,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(args: <span class="tok-kw">anytype</span>) <span class="tok-type">void</span> {
    expect(args.int == <span class="tok-number">1234</span>);
    expect(args.float == <span class="tok-number">12.34</span>);
    expect(args.b);
    expect(args.s[<span class="tok-number">0</span>] == <span class="tok-str">'h'</span>);
    expect(args.s[<span class="tok-number">1</span>] == <span class="tok-str">'i'</span>);
}</code></pre><pre><code class="shell">$ zig test struct_anon.zig
Test [1/1] test &quot;fully anonymous struct&quot;... 

All 1 tests passed.
</code></pre>

      
      <p>See also:</p><ul>
<li><a href="#comptime">comptime</a></li>
<li><a href="#fieldParentPtr">@fieldParentPtr</a></li>
</ul>

      
      <h1 id="enum"><a href="#toc-enum">enum</a> <a class="hdr" href="#enum">§</a></h1>

      <p class="file">enums.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;

<span class="tok-comment">// Declare an enum.</span>
<span class="tok-kw">const</span> Type = <span class="tok-kw">enum</span> {
    ok,
    not_ok,
};

<span class="tok-comment">// Declare a specific instance of the enum variant.</span>
<span class="tok-kw">const</span> c = Type.ok;

<span class="tok-comment">// If you want access to the ordinal value of an enum, you</span>
<span class="tok-comment">// can specify the tag type.</span>
<span class="tok-kw">const</span> Value = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {
    zero,
    one,
    two,
};

<span class="tok-comment">// Now you can cast between u2 and Value.</span>
<span class="tok-comment">// The ordinal value starts from 0, counting up for each member.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;enum ordinal value&quot;</span> {
    expect(<span class="tok-builtin">@enumToInt</span>(Value.zero) == <span class="tok-number">0</span>);
    expect(<span class="tok-builtin">@enumToInt</span>(Value.one) == <span class="tok-number">1</span>);
    expect(<span class="tok-builtin">@enumToInt</span>(Value.two) == <span class="tok-number">2</span>);
}

<span class="tok-comment">// You can override the ordinal value for an enum.</span>
<span class="tok-kw">const</span> Value2 = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    hundred = <span class="tok-number">100</span>,
    thousand = <span class="tok-number">1000</span>,
    million = <span class="tok-number">1000000</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;set enum ordinal value&quot;</span> {
    expect(<span class="tok-builtin">@enumToInt</span>(Value2.hundred) == <span class="tok-number">100</span>);
    expect(<span class="tok-builtin">@enumToInt</span>(Value2.thousand) == <span class="tok-number">1000</span>);
    expect(<span class="tok-builtin">@enumToInt</span>(Value2.million) == <span class="tok-number">1000000</span>);
}

<span class="tok-comment">// Enums can have methods, the same as structs and unions.</span>
<span class="tok-comment">// Enum methods are not special, they are only namespaced</span>
<span class="tok-comment">// functions that you can call with dot syntax.</span>
<span class="tok-kw">const</span> Suit = <span class="tok-kw">enum</span> {
    clubs,
    spades,
    diamonds,
    hearts,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isClubs</span>(self: Suit) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self == Suit.clubs;
    }
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;enum method&quot;</span> {
    <span class="tok-kw">const</span> p = Suit.spades;
    expect(!p.isClubs());
}

<span class="tok-comment">// An enum variant of different types can be switched upon.</span>
<span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    string,
    number,
    none,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;enum variant switch&quot;</span> {
    <span class="tok-kw">const</span> p = Foo.number;
    <span class="tok-kw">const</span> what_is_it = <span class="tok-kw">switch</span> (p) {
        Foo.string =&gt; <span class="tok-str">&quot;this is a string&quot;</span>,
        Foo.number =&gt; <span class="tok-str">&quot;this is a number&quot;</span>,
        Foo.none =&gt; <span class="tok-str">&quot;this is a none&quot;</span>,
    };
    expect(mem.eql(<span class="tok-type">u8</span>, what_is_it, <span class="tok-str">&quot;this is a number&quot;</span>));
}

<span class="tok-comment">// @typeInfo can be used to access the integer tag type of an enum.</span>
<span class="tok-kw">const</span> Small = <span class="tok-kw">enum</span> {
    one,
    two,
    three,
    four,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;std.meta.Tag&quot;</span> {
    expect(<span class="tok-builtin">@typeInfo</span>(Small).Enum.tag_type == <span class="tok-type">u2</span>);
}

<span class="tok-comment">// @typeInfo tells us the field count and the fields names:</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;@typeInfo&quot;</span> {
    expect(<span class="tok-builtin">@typeInfo</span>(Small).Enum.fields.len == <span class="tok-number">4</span>);
    expect(mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@typeInfo</span>(Small).Enum.fields[<span class="tok-number">1</span>].name, <span class="tok-str">&quot;two&quot;</span>));
}

<span class="tok-comment">// @tagName gives a []const u8 representation of an enum value:</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;@tagName&quot;</span> {
    expect(mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@tagName</span>(Small.three), <span class="tok-str">&quot;three&quot;</span>));
}</code></pre><pre><code class="shell">$ zig test enums.zig
Test [1/7] test &quot;enum ordinal value&quot;... 
Test [2/7] test &quot;set enum ordinal value&quot;... 
Test [3/7] test &quot;enum method&quot;... 
Test [4/7] test &quot;enum variant switch&quot;... 
Test [5/7] test &quot;std.meta.Tag&quot;... 
Test [6/7] test &quot;@typeInfo&quot;... 
Test [7/7] test &quot;@tagName&quot;... 

All 7 tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#typeInfo">@typeInfo</a></li>
<li><a href="#tagName">@tagName</a></li>
<li><a href="#sizeOf">@sizeOf</a></li>
</ul>


      <h2 id="extern-enum"><a href="#toc-extern-enum">extern enum</a> <a class="hdr" href="#extern-enum">§</a></h2>

      <p>
      By default, enums are not guaranteed to be compatible with the C ABI:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> { a, b, c };
<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">entry</span>(foo: Foo) <span class="tok-type">void</span> { }</code></pre><pre><code class="shell">$ zig build-obj test.zig
<span class="t0_1">./docgen_tmp/test.zig:2:22: </span><span class="t31_1">error: </span><span class="t0_1">parameter of type 'Foo' not allowed in function with calling convention 'C'</span>
export fn entry(foo: Foo) void { 
                     <span class="t32_1">^</span>
</code></pre>

      <p>
      For a C-ABI-compatible enum, use <code class="zig"><span class="tok-kw">extern</span> <span class="tok-kw">enum</span></code>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Foo = <span class="tok-kw">extern</span> <span class="tok-kw">enum</span> { a, b, c };
<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">entry</span>(foo: Foo) <span class="tok-type">void</span> { }</code></pre><pre><code class="shell">$ zig build-obj test.zig</code></pre>

      

      <h2 id="packed-enum"><a href="#toc-packed-enum">packed enum</a> <a class="hdr" href="#packed-enum">§</a></h2>

      <p>By default, the size of enums is not guaranteed.</p>
      <p><code class="zig"><span class="tok-kw">packed</span> <span class="tok-kw">enum</span></code> causes the size of the enum to be the same as the size of the
      integer tag type of the enum:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;packed enum&quot;</span> {
    <span class="tok-kw">const</span> Number = <span class="tok-kw">packed</span> <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {
        one,
        two,
        three,
    };
    std.testing.expect(<span class="tok-builtin">@sizeOf</span>(Number) == <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u8</span>));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;packed enum&quot;... 

All 1 tests passed.
</code></pre>

      <p>This makes the enum eligible to be in a <a href="#packed-struct">packed struct</a>.</p>
      

      <h2 id="Enum-Literals"><a href="#toc-Enum-Literals">Enum Literals</a> <a class="hdr" href="#Enum-Literals">§</a></h2>

      <p>
      Enum literals allow specifying the name of an enum field without specifying the enum type:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Color = <span class="tok-kw">enum</span> {
    auto,
    off,
    on,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;enum literals&quot;</span> {
    <span class="tok-kw">const</span> color1: Color = .auto;
    <span class="tok-kw">const</span> color2 = Color.auto;
    expect(color1 == color2);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;switch using enum literals&quot;</span> {
    <span class="tok-kw">const</span> color = Color.on;
    <span class="tok-kw">const</span> result = <span class="tok-kw">switch</span> (color) {
        .auto =&gt; <span class="tok-null">false</span>,
        .on =&gt; <span class="tok-null">true</span>,
        .off =&gt; <span class="tok-null">false</span>,
    };
    expect(result);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/2] test &quot;enum literals&quot;... 
Test [2/2] test &quot;switch using enum literals&quot;... 

All 2 tests passed.
</code></pre>

      

      <h2 id="Non-exhaustive-enum"><a href="#toc-Non-exhaustive-enum">Non-exhaustive enum</a> <a class="hdr" href="#Non-exhaustive-enum">§</a></h2>

      <p>
      A Non-exhaustive enum can be created by adding a trailing '_' field.
      It  must specify a tag type and cannot consume every enumeration value.
      </p>
      <p>
      <a href="#intToEnum">@intToEnum</a> on a non-exhaustive enum cannot fail.
      </p>
      <p>
      A switch on a non-exhaustive enum can include a '_' prong as an alternative to an <code class="zig"><span class="tok-kw">else</span></code> prong
      with the difference being that it makes it a compile error if all the known tag names are not handled by the switch.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Number = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {
    one,
    two,
    three,
    _,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;switch on non-exhaustive enum&quot;</span> {
    <span class="tok-kw">const</span> number = Number.one;
    <span class="tok-kw">const</span> result = <span class="tok-kw">switch</span> (number) {
        .one =&gt; <span class="tok-null">true</span>,
        .two,
        .three =&gt; <span class="tok-null">false</span>,
        _ =&gt; <span class="tok-null">false</span>,
    };
    expect(result);
    <span class="tok-kw">const</span> is_one = <span class="tok-kw">switch</span> (number) {
        .one =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };
    expect(is_one);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;switch on non-exhaustive enum&quot;... 

All 1 tests passed.
</code></pre>

      
      

      <h1 id="union"><a href="#toc-union">union</a> <a class="hdr" href="#union">§</a></h1>

      <p>
      A bare <code class="zig"><span class="tok-kw">union</span></code> defines a set of possible types that a value
      can be as a list of fields. Only one field can be active at a time.
      The in-memory representation of bare unions is not guaranteed.
      Bare unions cannot be used to reinterpret memory. For that, use <a href="#ptrCast">@ptrCast</a>,
      or use an <a href="#extern-union">extern union</a> or a <a href="#packed-union">packed union</a> which have
      guaranteed in-memory layout.
      <a href="#Wrong-Union-Field-Access">Accessing the non-active field</a> is
      safety-checked <a href="#Undefined-Behavior">Undefined Behavior</a>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Payload = <span class="tok-kw">union</span> {
    int: <span class="tok-type">i64</span>,
    float: <span class="tok-type">f64</span>,
    boolean: <span class="tok-type">bool</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;simple union&quot;</span> {
    <span class="tok-kw">var</span> payload = Payload{ .int = <span class="tok-number">1234</span> };
    payload.float = <span class="tok-number">12.34</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;simple union&quot;... 
thread 2069 panic: access of inactive union field
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:8:12</span>: <span class="t2_0">0x20663b in test &quot;simple union&quot; (test)</span>
    payload.float = 12.34;
           <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/special/test_runner.zig:69:28</span>: <span class="t2_0">0x230318 in std.special.main (test)</span>
        } else test_fn.func();
                           <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:420:37</span>: <span class="t2_0">0x207e24 in std.start.posixCallMainAndExit (test)</span>
            const result = root.main() catch |err| {
                                    <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x207cc2 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
error: the following test command crashed:
docgen_tmp/zig-cache/o/091db03e22edfdd7844d6b7c020b80d0/test /home/vsts/work/1/s/build/release/bin/zig
</code></pre>

      <p>You can activate another field by assigning the entire union:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Payload = <span class="tok-kw">union</span> {
    int: <span class="tok-type">i64</span>,
    float: <span class="tok-type">f64</span>,
    boolean: <span class="tok-type">bool</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;simple union&quot;</span> {
    <span class="tok-kw">var</span> payload = Payload{ .int = <span class="tok-number">1234</span> };
    expect(payload.int == <span class="tok-number">1234</span>);
    payload = Payload{ .float = <span class="tok-number">12.34</span> };
    expect(payload.float == <span class="tok-number">12.34</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;simple union&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      In order to use <a href="#switch">switch</a> with a union, it must be a <a href="#Tagged-union">Tagged union</a>.
      </p>
      <p>
      To initialize a union when the tag is a <a href="#comptime">comptime</a>-known name, see <a href="#unionInit">@unionInit</a>.
      </p>

      <h2 id="Tagged-union"><a href="#toc-Tagged-union">Tagged union</a> <a class="hdr" href="#Tagged-union">§</a></h2>

      <p>Unions can be declared with an enum tag type.
      This turns the union into a <em>tagged</em> union, which makes it eligible
      to use with <a href="#switch">switch</a> expressions.
      Tagged unions coerce to their tag type: <a href="#Type-Coercion-unions-and-enums">Type Coercion: unions and enums</a>.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> ComplexTypeTag = <span class="tok-kw">enum</span> {
    ok,
    not_ok,
};
<span class="tok-kw">const</span> ComplexType = <span class="tok-kw">union</span>(ComplexTypeTag) {
    ok: <span class="tok-type">u8</span>,
    not_ok: <span class="tok-type">void</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;switch on tagged union&quot;</span> {
    <span class="tok-kw">const</span> c = ComplexType{ .ok = <span class="tok-number">42</span> };
    expect(<span class="tok-builtin">@as</span>(ComplexTypeTag, c) == ComplexTypeTag.ok);

    <span class="tok-kw">switch</span> (c) {
        ComplexTypeTag.ok =&gt; |value| expect(value == <span class="tok-number">42</span>),
        ComplexTypeTag.not_ok =&gt; <span class="tok-kw">unreachable</span>,
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;get tag type&quot;</span> {
    expect(std.meta.Tag(ComplexType) == ComplexTypeTag);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;coerce to enum&quot;</span> {
    <span class="tok-kw">const</span> c1 = ComplexType{ .ok = <span class="tok-number">42</span> };
    <span class="tok-kw">const</span> c2 = ComplexType.not_ok;

    expect(c1 == .ok);
    expect(c2 == .not_ok);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/3] test &quot;switch on tagged union&quot;... 
Test [2/3] test &quot;get tag type&quot;... 
Test [3/3] test &quot;coerce to enum&quot;... 

All 3 tests passed.
</code></pre>

      <p>In order to modify the payload of a tagged union in a switch expression,
      place a <code class="zig">*</code> before the variable name to make it a pointer:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> ComplexTypeTag = <span class="tok-kw">enum</span> {
    ok,
    not_ok,
};
<span class="tok-kw">const</span> ComplexType = <span class="tok-kw">union</span>(ComplexTypeTag) {
    ok: <span class="tok-type">u8</span>,
    not_ok: <span class="tok-type">void</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;modify tagged union in switch&quot;</span> {
    <span class="tok-kw">var</span> c = ComplexType{ .ok = <span class="tok-number">42</span> };
    expect(<span class="tok-builtin">@as</span>(ComplexTypeTag, c) == ComplexTypeTag.ok);

    <span class="tok-kw">switch</span> (c) {
        ComplexTypeTag.ok =&gt; |*value| value.* += <span class="tok-number">1</span>,
        ComplexTypeTag.not_ok =&gt; <span class="tok-kw">unreachable</span>,
    }

    expect(c.ok == <span class="tok-number">43</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;modify tagged union in switch&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      Unions can be made to infer the enum tag type.
      Further, unions can have methods just like structs and enums.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Variant = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    int: <span class="tok-type">i32</span>,
    boolean: <span class="tok-type">bool</span>,

    <span class="tok-comment">// void can be omitted when inferring enum tag type.</span>
    none,

    <span class="tok-kw">fn</span> <span class="tok-fn">truthy</span>(self: Variant) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self) {
            Variant.int =&gt; |x_int| x_int != <span class="tok-number">0</span>,
            Variant.boolean =&gt; |x_bool| x_bool,
            Variant.none =&gt; <span class="tok-null">false</span>,
        };
    }
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;union method&quot;</span> {
    <span class="tok-kw">var</span> v1 = Variant{ .int = <span class="tok-number">1</span> };
    <span class="tok-kw">var</span> v2 = Variant{ .boolean = <span class="tok-null">false</span> };

    expect(v1.truthy());
    expect(!v2.truthy());
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;union method&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      <a href="#tagName">@tagName</a> can be used to return a <a href="#comptime">comptime</a>
      <code class="zig">[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code> value representing the field name:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Small2 = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    a: <span class="tok-type">i32</span>,
    b: <span class="tok-type">bool</span>,
    c: <span class="tok-type">u8</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;@tagName&quot;</span> {
    expect(std.mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@tagName</span>(Small2.a), <span class="tok-str">&quot;a&quot;</span>));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;@tagName&quot;... 

All 1 tests passed.
</code></pre>

      

      <h2 id="extern-union"><a href="#toc-extern-union">extern union</a> <a class="hdr" href="#extern-union">§</a></h2>

      <p>
      An <code class="zig"><span class="tok-kw">extern</span> <span class="tok-kw">union</span></code> has memory layout guaranteed to be compatible with
      the target C ABI.
      </p>
      <p>See also:</p><ul>
<li><a href="#extern-struct">extern struct</a></li>
</ul>

      

      <h2 id="packed-union"><a href="#toc-packed-union">packed union</a> <a class="hdr" href="#packed-union">§</a></h2>

      <p>A <code class="zig"><span class="tok-kw">packed</span> <span class="tok-kw">union</span></code> has well-defined in-memory layout and is eligible
      to be in a <a href="#packed-struct">packed struct</a>.
      

      <h2 id="Anonymous-Union-Literals"><a href="#toc-Anonymous-Union-Literals">Anonymous Union Literals</a> <a class="hdr" href="#Anonymous-Union-Literals">§</a></h2>

      <p><a href="#Anonymous-Struct-Literals">Anonymous Struct Literals</a> syntax can be used to initialize unions without specifying
      the type:</p>
      <p class="file">anon_union.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Number = <span class="tok-kw">union</span> {
    int: <span class="tok-type">i32</span>,
    float: <span class="tok-type">f64</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;anonymous union literal syntax&quot;</span> {
    <span class="tok-kw">var</span> i: Number = .{.int = <span class="tok-number">42</span>};
    <span class="tok-kw">var</span> f = makeNumber();
    expect(i.int == <span class="tok-number">42</span>);
    expect(f.float == <span class="tok-number">12.34</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">makeNumber</span>() Number {
    <span class="tok-kw">return</span> .{.float = <span class="tok-number">12.34</span>};
}</code></pre><pre><code class="shell">$ zig test anon_union.zig
Test [1/1] test &quot;anonymous union literal syntax&quot;... 

All 1 tests passed.
</code></pre>

      

      

      <h1 id="opaque"><a href="#toc-opaque">opaque</a> <a class="hdr" href="#opaque">§</a></h1>

      <p>
      <code class="zig"><span class="tok-kw">opaque</span> {}</code> declares a new type with an unknown (but non-zero) size and alignment.
      It can contain declarations the same as <a href="#struct">structs</a>, <a href="#union">unions</a>,
      and <a href="#enum">enums</a>.
      </p>
      <p>
      This is typically used for type safety when interacting with C code that does not expose struct details.
      Example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Derp = <span class="tok-kw">opaque</span> {};
<span class="tok-kw">const</span> Wat = <span class="tok-kw">opaque</span> {};

<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(d: *Derp) <span class="tok-type">void</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(w: *Wat) <span class="tok-kw">callconv</span>(.C) <span class="tok-type">void</span> {
    bar(w);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;call foo&quot;</span> {
    foo(<span class="tok-null">undefined</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:6:9: </span><span class="t31_1">error: </span><span class="t0_1">expected type '*Derp', found '*Wat'</span>
    bar(w);
        <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:6:9: </span><span class="t36_1">note: </span><span class="t0_1">pointer type child 'Wat' cannot cast into pointer type child 'Derp'</span>
    bar(w);
        <span class="t32_1">^</span>
</code></pre>

      

      <h1 id="blocks"><a href="#toc-blocks">blocks</a> <a class="hdr" href="#blocks">§</a></h1>

      <p>
      Blocks are used to limit the scope of variable declarations:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;access variable after block scope&quot;</span> {
    {
        <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    }
    x += <span class="tok-number">1</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:5:5: </span><span class="t31_1">error: </span><span class="t0_1">use of undeclared identifier 'x'</span>
    x += 1;
    <span class="t32_1">^</span>
</code></pre>

      <p>Blocks are expressions. When labeled, <code class="zig"><span class="tok-kw">break</span></code> can be used
      to return a value from the block:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;labeled break from labeled block expression&quot;</span> {
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">123</span>;

    <span class="tok-kw">const</span> x = blk: {
        y += <span class="tok-number">1</span>;
        <span class="tok-kw">break</span> :blk y;
    };
    expect(x == <span class="tok-number">124</span>);
    expect(y == <span class="tok-number">124</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;labeled break from labeled block expression&quot;... 

All 1 tests passed.
</code></pre>

      <p>Here, <code class="zig">blk</code> can be any name.</p>
      <p>See also:</p><ul>
<li><a href="#Labeled-while">Labeled while</a></li>
<li><a href="#Labeled-for">Labeled for</a></li>
</ul>


      <h2 id="Shadowing"><a href="#toc-Shadowing">Shadowing</a> <a class="hdr" href="#Shadowing">§</a></h2>

      <p>It is never allowed for an identifier to "hide" another one by using the same name:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> pi = <span class="tok-number">3.14</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;inside test block&quot;</span> {
    <span class="tok-comment">// Let's even go inside another block</span>
    {
        <span class="tok-kw">var</span> pi: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:6:9: </span><span class="t31_1">error: </span><span class="t0_1">redefinition of 'pi'</span>
        var pi: i32 = 1234;
        <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:1:1: </span><span class="t36_1">note: </span><span class="t0_1">previous definition is here</span>
const pi = 3.14;
<span class="t32_1">^</span>
</code></pre>

      <p>
      Because of this, when you read Zig code you can rely on an identifier always meaning the same thing,
      within the scope it is defined. Note that you can, however use the same name if the scopes are separate:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;separate scopes&quot;</span> {
    {
        <span class="tok-kw">const</span> pi = <span class="tok-number">3.14</span>;
    }
    {
        <span class="tok-kw">var</span> pi: <span class="tok-type">bool</span> = <span class="tok-null">true</span>;
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;separate scopes&quot;... 

All 1 tests passed.
</code></pre>

      
      

      <h1 id="switch"><a href="#toc-switch">switch</a> <a class="hdr" href="#switch">§</a></h1>

      <p class="file">switch.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;switch simple&quot;</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u64</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> zz: <span class="tok-type">u64</span> = <span class="tok-number">103</span>;

    <span class="tok-comment">// All branches of a switch expression must be able to be coerced to a</span>
    <span class="tok-comment">// common type.</span>
    <span class="tok-comment">//</span>
    <span class="tok-comment">// Branches cannot fallthrough. If fallthrough behavior is desired, combine</span>
    <span class="tok-comment">// the cases and use an if.</span>
    <span class="tok-kw">const</span> b = <span class="tok-kw">switch</span> (a) {
        <span class="tok-comment">// Multiple cases can be combined via a ','</span>
        <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> =&gt; <span class="tok-number">0</span>,

        <span class="tok-comment">// Ranges can be specified using the ... syntax. These are inclusive</span>
        <span class="tok-comment">// both ends.</span>
        <span class="tok-number">5</span>...<span class="tok-number">100</span> =&gt; <span class="tok-number">1</span>,

        <span class="tok-comment">// Branches can be arbitrarily complex.</span>
        <span class="tok-number">101</span> =&gt; blk: {
            <span class="tok-kw">const</span> c: <span class="tok-type">u64</span> = <span class="tok-number">5</span>;
            <span class="tok-kw">break</span> :blk c * <span class="tok-number">2</span> + <span class="tok-number">1</span>;
        },

        <span class="tok-comment">// Switching on arbitrary expressions is allowed as long as the</span>
        <span class="tok-comment">// expression is known at compile-time.</span>
        zz =&gt; zz,
        <span class="tok-kw">comptime</span> blk: {
            <span class="tok-kw">const</span> d: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
            <span class="tok-kw">const</span> e: <span class="tok-type">u32</span> = <span class="tok-number">100</span>;
            <span class="tok-kw">break</span> :blk d + e;
        } =&gt; <span class="tok-number">107</span>,

        <span class="tok-comment">// The else branch catches everything not already captured.</span>
        <span class="tok-comment">// Else branches are mandatory unless the entire range of values</span>
        <span class="tok-comment">// is handled.</span>
        <span class="tok-kw">else</span> =&gt; <span class="tok-number">9</span>,
    };

    expect(b == <span class="tok-number">1</span>);
}

<span class="tok-comment">// Switch expressions can be used outside a function:</span>
<span class="tok-kw">const</span> os_msg = <span class="tok-kw">switch</span> (std.Target.current.os.tag) {
    .linux =&gt; <span class="tok-str">&quot;we found a linux user&quot;</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;not a linux user&quot;</span>,
};

<span class="tok-comment">// Inside a function, switch statements implicitly are compile-time</span>
<span class="tok-comment">// evaluated if the target expression is compile-time known.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;switch inside function&quot;</span> {
    <span class="tok-kw">switch</span> (std.Target.current.os.tag) {
        .fuchsia =&gt; {
            <span class="tok-comment">// On an OS other than fuchsia, block is not even analyzed,</span>
            <span class="tok-comment">// so this compile error is not triggered.</span>
            <span class="tok-comment">// On fuchsia this compile error would be triggered.</span>
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;fuchsia not supported&quot;</span>);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
}</code></pre><pre><code class="shell">$ zig test switch.zig
Test [1/2] test &quot;switch simple&quot;... 
Test [2/2] test &quot;switch inside function&quot;... 

All 2 tests passed.
</code></pre>

      <p>
      <code class="zig"><span class="tok-kw">switch</span></code> can be used to capture the field values
      of a <a href="#Tagged-union">Tagged union</a>. Modifications to the field values can be
      done by placing a <code class="zig">*</code> before the capture variable name,
      turning it into a pointer.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;switch on tagged union&quot;</span> {
    <span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
        x: <span class="tok-type">u8</span>,
        y: <span class="tok-type">u8</span>,
    };
    <span class="tok-kw">const</span> Item = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        a: <span class="tok-type">u32</span>,
        c: Point,
        d,
        e: <span class="tok-type">u32</span>,
    };

    <span class="tok-kw">var</span> a = Item{ .c = Point{ .x = <span class="tok-number">1</span>, .y = <span class="tok-number">2</span> } };

    <span class="tok-comment">// Switching on more complex enums is allowed.</span>
    <span class="tok-kw">const</span> b = <span class="tok-kw">switch</span> (a) {
        <span class="tok-comment">// A capture group is allowed on a match, and will return the enum</span>
        <span class="tok-comment">// value matched. If the payload types of both cases are the same</span>
        <span class="tok-comment">// they can be put into the same switch prong.</span>
        Item.a, Item.e =&gt; |item| item,

        <span class="tok-comment">// A reference to the matched value can be obtained using `*` syntax.</span>
        Item.c =&gt; |*item| blk: {
            item.*.x += <span class="tok-number">1</span>;
            <span class="tok-kw">break</span> :blk <span class="tok-number">6</span>;
        },

        <span class="tok-comment">// No else is required if the types cases was exhaustively handled</span>
        Item.d =&gt; <span class="tok-number">8</span>,
    };

    expect(b == <span class="tok-number">6</span>);
    expect(a.c.x == <span class="tok-number">2</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;switch on tagged union&quot;... 

All 1 tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#comptime">comptime</a></li>
<li><a href="#enum">enum</a></li>
<li><a href="#compileError">@compileError</a></li>
<li><a href="#Compile-Variables">Compile Variables</a></li>
</ul>


      <h2 id="Exhaustive-Switching"><a href="#toc-Exhaustive-Switching">Exhaustive Switching</a> <a class="hdr" href="#Exhaustive-Switching">§</a></h2>

      <p>
      When a <code class="zig"><span class="tok-kw">switch</span></code> expression does not have an <code class="zig"><span class="tok-kw">else</span></code> clause,
      it must exhaustively list all the possible values. Failure to do so is a compile error:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Color = <span class="tok-kw">enum</span> {
    auto,
    off,
    on,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;exhaustive switching&quot;</span> {
    <span class="tok-kw">const</span> color = Color.off;
    <span class="tok-kw">switch</span> (color) {
        Color.auto =&gt; {},
        Color.on =&gt; {},
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:9:5: </span><span class="t31_1">error: </span><span class="t0_1">enumeration value 'Color.off' not handled in switch</span>
    switch (color) {
    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:7:29: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
test &quot;exhaustive switching&quot; {
                            <span class="t32_1">^</span>
</code></pre>

      

      <h2 id="Switching-with-Enum-Literals"><a href="#toc-Switching-with-Enum-Literals">Switching with Enum Literals</a> <a class="hdr" href="#Switching-with-Enum-Literals">§</a></h2>

      <p>
      <a href="#Enum-Literals">Enum Literals</a> can be useful to use with <code class="zig"><span class="tok-kw">switch</span></code> to avoid
      repetitively specifying <a href="#enum">enum</a> or <a href="#union">union</a> types:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Color = <span class="tok-kw">enum</span> {
    auto,
    off,
    on,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;enum literals with switch&quot;</span> {
    <span class="tok-kw">const</span> color = Color.off;
    <span class="tok-kw">const</span> result = <span class="tok-kw">switch</span> (color) {
        .auto =&gt; <span class="tok-null">false</span>,
        .on =&gt; <span class="tok-null">false</span>,
        .off =&gt; <span class="tok-null">true</span>,
    };
    expect(result);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;enum literals with switch&quot;... 

All 1 tests passed.
</code></pre>

      
      

      <h1 id="while"><a href="#toc-while">while</a> <a class="hdr" href="#while">§</a></h1>

      <p>
      A while loop is used to repeatedly execute an expression until
      some condition is no longer true.
      </p>
      <p class="file">while.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while basic&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) {
        i += <span class="tok-number">1</span>;
    }
    expect(i == <span class="tok-number">10</span>);
}</code></pre><pre><code class="shell">$ zig test while.zig
Test [1/1] test &quot;while basic&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      Use <code class="zig"><span class="tok-kw">break</span></code> to exit a while loop early.
      </p>
      <p class="file">while.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while break&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">if</span> (i == <span class="tok-number">10</span>)
            <span class="tok-kw">break</span>;
        i += <span class="tok-number">1</span>;
    }
    expect(i == <span class="tok-number">10</span>);
}</code></pre><pre><code class="shell">$ zig test while.zig
Test [1/1] test &quot;while break&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      Use <code class="zig"><span class="tok-kw">continue</span></code> to jump back to the beginning of the loop.
      </p>
      <p class="file">while.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while continue&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        i += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (i &lt; <span class="tok-number">10</span>)
            <span class="tok-kw">continue</span>;
        <span class="tok-kw">break</span>;
    }
    expect(i == <span class="tok-number">10</span>);
}</code></pre><pre><code class="shell">$ zig test while.zig
Test [1/1] test &quot;while continue&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      While loops support a continue expression which is executed when the loop
      is continued. The <code class="zig"><span class="tok-kw">continue</span></code> keyword respects this expression.
      </p>
      <p class="file">while.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while loop continue expression&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {}
    expect(i == <span class="tok-number">10</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;while loop continue expression, more complicated&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> j: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">while</span> (i * j &lt; <span class="tok-number">2000</span>) : ({ i *= <span class="tok-number">2</span>; j *= <span class="tok-number">3</span>; }) {
        <span class="tok-kw">const</span> my_ij = i * j;
        expect(my_ij &lt; <span class="tok-number">2000</span>);
    }
}</code></pre><pre><code class="shell">$ zig test while.zig
Test [1/2] test &quot;while loop continue expression&quot;... 
Test [2/2] test &quot;while loop continue expression, more complicated&quot;... 

All 2 tests passed.
</code></pre>

      <p>
      While loops are expressions. The result of the expression is the
      result of the <code class="zig"><span class="tok-kw">else</span></code> clause of a while loop, which is executed when
      the condition of the while loop is tested as false.
      </p>
      <p>
      <code class="zig"><span class="tok-kw">break</span></code>, like <code class="zig"><span class="tok-kw">return</span></code>, accepts a value
              parameter. This is the result of the <code class="zig"><span class="tok-kw">while</span></code> expression.
                  When you <code class="zig"><span class="tok-kw">break</span></code> from a while loop, the <code class="zig"><span class="tok-kw">else</span></code> branch is not
      evaluated.
      </p>
      <p class="file">while.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while else&quot;</span> {
    expect(rangeHasNumber(<span class="tok-number">0</span>, <span class="tok-number">10</span>, <span class="tok-number">5</span>));
    expect(!rangeHasNumber(<span class="tok-number">0</span>, <span class="tok-number">10</span>, <span class="tok-number">15</span>));
}

<span class="tok-kw">fn</span> <span class="tok-fn">rangeHasNumber</span>(begin: <span class="tok-type">usize</span>, end: <span class="tok-type">usize</span>, number: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">var</span> i = begin;
    <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; end) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (i == number) {
            <span class="tok-kw">break</span> <span class="tok-null">true</span>;
        }
    } <span class="tok-kw">else</span> <span class="tok-null">false</span>;
}</code></pre><pre><code class="shell">$ zig test while.zig
Test [1/1] test &quot;while else&quot;... 

All 1 tests passed.
</code></pre>

      <h2 id="Labeled-while"><a href="#toc-Labeled-while">Labeled while</a> <a class="hdr" href="#Labeled-while">§</a></h2>

      <p>When a <code class="zig"><span class="tok-kw">while</span></code> loop is labeled, it can be referenced from a <code class="zig"><span class="tok-kw">break</span></code>
              or <code class="zig"><span class="tok-kw">continue</span></code> from within a nested loop:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;nested break&quot;</span> {
    outer: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">break</span> :outer;
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;nested continue&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    outer: <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">continue</span> :outer;
        }
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/2] test &quot;nested break&quot;... 
Test [2/2] test &quot;nested continue&quot;... 

All 2 tests passed.
</code></pre>

      
      <h2 id="while-with-Optionals"><a href="#toc-while-with-Optionals">while with Optionals</a> <a class="hdr" href="#while-with-Optionals">§</a></h2>

      <p>
      Just like <a href="#if">if</a> expressions, while loops can take an optional as the
      condition and capture the payload. When <a href="#null">null</a> is encountered the loop
      exits.
      </p>
      <p>
      When the <code class="zig">|x|</code> syntax is present on a <code class="zig"><span class="tok-kw">while</span></code> expression,
      the while condition must have an <a href="#Optional-Type">Optional Type</a>.
      </p>
      <p>
      The <code class="zig"><span class="tok-kw">else</span></code> branch is allowed on optional iteration. In this case, it will
      be executed on the first null value encountered.
      </p>
      <p class="file">while.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while null capture&quot;</span> {
    <span class="tok-kw">var</span> sum1: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    numbers_left = <span class="tok-number">3</span>;
    <span class="tok-kw">while</span> (eventuallyNullSequence()) |value| {
        sum1 += value;
    }
    expect(sum1 == <span class="tok-number">3</span>);

    <span class="tok-kw">var</span> sum2: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    numbers_left = <span class="tok-number">3</span>;
    <span class="tok-kw">while</span> (eventuallyNullSequence()) |value| {
        sum2 += value;
    } <span class="tok-kw">else</span> {
        expect(sum2 == <span class="tok-number">3</span>);
    }
}

<span class="tok-kw">var</span> numbers_left: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">eventuallyNullSequence</span>() ?<span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (numbers_left == <span class="tok-number">0</span>) <span class="tok-null">null</span> <span class="tok-kw">else</span> blk: {
        numbers_left -= <span class="tok-number">1</span>;
        <span class="tok-kw">break</span> :blk numbers_left;
    };
}</code></pre><pre><code class="shell">$ zig test while.zig
Test [1/1] test &quot;while null capture&quot;... 

All 1 tests passed.
</code></pre>

      

      <h2 id="while-with-Error-Unions"><a href="#toc-while-with-Error-Unions">while with Error Unions</a> <a class="hdr" href="#while-with-Error-Unions">§</a></h2>

      <p>
      Just like <a href="#if">if</a> expressions, while loops can take an error union as
      the condition and capture the payload or the error code. When the
      condition results in an error code the else branch is evaluated and
      the loop is finished.
      </p>
      <p>
      When the <code class="zig"><span class="tok-kw">else</span> |x|</code> syntax is present on a <code class="zig"><span class="tok-kw">while</span></code> expression,
      the while condition must have an <a href="#Error-Union-Type">Error Union Type</a>.
      </p>
      <p class="file">while.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while error union capture&quot;</span> {
    <span class="tok-kw">var</span> sum1: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    numbers_left = <span class="tok-number">3</span>;
    <span class="tok-kw">while</span> (eventuallyErrorSequence()) |value| {
        sum1 += value;
    } <span class="tok-kw">else</span> |err| {
        expect(err == <span class="tok-kw">error</span>.ReachedZero);
    }
}

<span class="tok-kw">var</span> numbers_left: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">eventuallyErrorSequence</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (numbers_left == <span class="tok-number">0</span>) <span class="tok-kw">error</span>.ReachedZero <span class="tok-kw">else</span> blk: {
        numbers_left -= <span class="tok-number">1</span>;
        <span class="tok-kw">break</span> :blk numbers_left;
    };
}</code></pre><pre><code class="shell">$ zig test while.zig
Test [1/1] test &quot;while error union capture&quot;... 

All 1 tests passed.
</code></pre>

      

      <h2 id="inline-while"><a href="#toc-inline-while">inline while</a> <a class="hdr" href="#inline-while">§</a></h2>

      <p>
      While loops can be inlined. This causes the loop to be unrolled, which
      allows the code to do some things which only work at compile time,
      such as use types as first class values.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;inline while loop&quot;</span> {
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; <span class="tok-number">3</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> T = <span class="tok-kw">switch</span> (i) {
            <span class="tok-number">0</span> =&gt; <span class="tok-type">f32</span>,
            <span class="tok-number">1</span> =&gt; <span class="tok-type">i8</span>,
            <span class="tok-number">2</span> =&gt; <span class="tok-type">bool</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
        sum += typeNameLength(T);
    }
    expect(sum == <span class="tok-number">9</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">typeNameLength</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@typeName</span>(T).len;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;inline while loop&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      It is recommended to use <code class="zig"><span class="tok-kw">inline</span></code> loops only for one of these reasons:
      </p>
      <ul>
        <li>You need the loop to execute at <a href="#comptime">comptime</a> for the semantics to work.</li>
        <li>
        You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.
        </li>
      </ul>
      
      <p>See also:</p><ul>
<li><a href="#if">if</a></li>
<li><a href="#Optionals">Optionals</a></li>
<li><a href="#Errors">Errors</a></li>
<li><a href="#comptime">comptime</a></li>
<li><a href="#unreachable">unreachable</a></li>
</ul>

      
      <h1 id="for"><a href="#toc-for">for</a> <a class="hdr" href="#for">§</a></h1>

      <p class="file">for.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;for basics&quot;</span> {
    <span class="tok-kw">const</span> items = [_]<span class="tok-type">i32</span> { <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">0</span> };
    <span class="tok-kw">var</span> sum: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;

    <span class="tok-comment">// For loops iterate over slices and arrays.</span>
    <span class="tok-kw">for</span> (items) |value| {
        <span class="tok-comment">// Break and continue are supported.</span>
        <span class="tok-kw">if</span> (value == <span class="tok-number">0</span>) {
            <span class="tok-kw">continue</span>;
        }
        sum += value;
    }
    expect(sum == <span class="tok-number">16</span>);

    <span class="tok-comment">// To iterate over a portion of a slice, reslice.</span>
    <span class="tok-kw">for</span> (items[<span class="tok-number">0</span>..<span class="tok-number">1</span>]) |value| {
        sum += value;
    }
    expect(sum == <span class="tok-number">20</span>);

    <span class="tok-comment">// To access the index of iteration, specify a second capture value.</span>
    <span class="tok-comment">// This is zero-indexed.</span>
    <span class="tok-kw">var</span> sum2: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (items) |value, i| {
        expect(<span class="tok-builtin">@TypeOf</span>(i) == <span class="tok-type">usize</span>);
        sum2 += <span class="tok-builtin">@intCast</span>(<span class="tok-type">i32</span>, i);
    }
    expect(sum2 == <span class="tok-number">10</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;for reference&quot;</span> {
    <span class="tok-kw">var</span> items = [_]<span class="tok-type">i32</span> { <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">2</span> };

    <span class="tok-comment">// Iterate over the slice by reference by</span>
    <span class="tok-comment">// specifying that the capture value is a pointer.</span>
    <span class="tok-kw">for</span> (items) |*value| {
        value.* += <span class="tok-number">1</span>;
    }

    expect(items[<span class="tok-number">0</span>] == <span class="tok-number">4</span>);
    expect(items[<span class="tok-number">1</span>] == <span class="tok-number">5</span>);
    expect(items[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;for else&quot;</span> {
    <span class="tok-comment">// For allows an else attached to it, the same as a while loop.</span>
    <span class="tok-kw">var</span> items = [_]?<span class="tok-type">i32</span> { <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-null">null</span>, <span class="tok-number">5</span> };

    <span class="tok-comment">// For loops can also be used as expressions.</span>
    <span class="tok-comment">// Similar to while loops, when you break from a for loop, the else branch is not evaluated.</span>
    <span class="tok-kw">var</span> sum: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> result = <span class="tok-kw">for</span> (items) |value| {
        <span class="tok-kw">if</span> (value != <span class="tok-null">null</span>) {
            sum += value.?;
        }
    } <span class="tok-kw">else</span> blk: {
        expect(sum == <span class="tok-number">12</span>);
        <span class="tok-kw">break</span> :blk sum;
    };
    expect(result == <span class="tok-number">12</span>);
}</code></pre><pre><code class="shell">$ zig test for.zig
Test [1/3] test &quot;for basics&quot;... 
Test [2/3] test &quot;for reference&quot;... 
Test [3/3] test &quot;for else&quot;... 

All 3 tests passed.
</code></pre>

      <h2 id="Labeled-for"><a href="#toc-Labeled-for">Labeled for</a> <a class="hdr" href="#Labeled-for">§</a></h2>

      <p>When a <code class="zig"><span class="tok-kw">for</span></code> loop is labeled, it can be referenced from a <code class="zig"><span class="tok-kw">break</span></code>
              or <code class="zig"><span class="tok-kw">continue</span></code> from within a nested loop:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;nested break&quot;</span> {
    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    outer: <span class="tok-kw">for</span> ([_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }) |_| {
        <span class="tok-kw">for</span> ([_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }) |_| {
            count += <span class="tok-number">1</span>;
            <span class="tok-kw">break</span> :outer;
        }
    }
    expect(count == <span class="tok-number">1</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;nested continue&quot;</span> {
    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    outer: <span class="tok-kw">for</span> ([_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> }) |_| {
        <span class="tok-kw">for</span> ([_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }) |_| {
            count += <span class="tok-number">1</span>;
            <span class="tok-kw">continue</span> :outer;
        }
    }

    expect(count == <span class="tok-number">8</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/2] test &quot;nested break&quot;... 
Test [2/2] test &quot;nested continue&quot;... 

All 2 tests passed.
</code></pre>

      
      <h2 id="inline-for"><a href="#toc-inline-for">inline for</a> <a class="hdr" href="#inline-for">§</a></h2>

      <p>
      For loops can be inlined. This causes the loop to be unrolled, which
      allows the code to do some things which only work at compile time,
      such as use types as first class values.
      The capture value and iterator value of inlined for loops are
      compile-time known.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;inline for loop&quot;</span> {
    <span class="tok-kw">const</span> nums = [_]<span class="tok-type">i32</span>{<span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">6</span>};
    <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (nums) |i| {
        <span class="tok-kw">const</span> T = <span class="tok-kw">switch</span> (i) {
            <span class="tok-number">2</span> =&gt; <span class="tok-type">f32</span>,
            <span class="tok-number">4</span> =&gt; <span class="tok-type">i8</span>,
            <span class="tok-number">6</span> =&gt; <span class="tok-type">bool</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
        sum += typeNameLength(T);
    }
    expect(sum == <span class="tok-number">9</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">typeNameLength</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@typeName</span>(T).len;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;inline for loop&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      It is recommended to use <code class="zig"><span class="tok-kw">inline</span></code> loops only for one of these reasons:
      </p>
      <ul>
        <li>You need the loop to execute at <a href="#comptime">comptime</a> for the semantics to work.</li>
        <li>
        You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.
        </li>
      </ul>
      
      <p>See also:</p><ul>
<li><a href="#while">while</a></li>
<li><a href="#comptime">comptime</a></li>
<li><a href="#Arrays">Arrays</a></li>
<li><a href="#Slices">Slices</a></li>
</ul>

      
      <h1 id="if"><a href="#toc-if">if</a> <a class="hdr" href="#if">§</a></h1>

      <p class="file">if.zig</p><pre><code class="zig"><span class="tok-comment">// If expressions have three uses, corresponding to the three types:</span>
<span class="tok-comment">// * bool</span>
<span class="tok-comment">// * ?T</span>
<span class="tok-comment">// * anyerror!T</span>

<span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;if expression&quot;</span> {
    <span class="tok-comment">// If expressions are used instead of a ternary expression.</span>
    <span class="tok-kw">const</span> a: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u32</span> = <span class="tok-number">4</span>;
    <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (a != b) <span class="tok-number">47</span> <span class="tok-kw">else</span> <span class="tok-number">3089</span>;
    expect(result == <span class="tok-number">47</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;if boolean&quot;</span> {
    <span class="tok-comment">// If expressions test boolean conditions.</span>
    <span class="tok-kw">const</span> a: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u32</span> = <span class="tok-number">4</span>;
    <span class="tok-kw">if</span> (a != b) {
        expect(<span class="tok-null">true</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a == <span class="tok-number">9</span>) {
        <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">unreachable</span>;
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;if optional&quot;</span> {
    <span class="tok-comment">// If expressions test for null.</span>

    <span class="tok-kw">const</span> a: ?<span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (a) |value| {
        expect(value == <span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">const</span> b: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (b) |value| {
        <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> {
        expect(<span class="tok-null">true</span>);
    }

    <span class="tok-comment">// The else is not required.</span>
    <span class="tok-kw">if</span> (a) |value| {
        expect(value == <span class="tok-number">0</span>);
    }

    <span class="tok-comment">// To test against null only, use the binary equality operator.</span>
    <span class="tok-kw">if</span> (b == <span class="tok-null">null</span>) {
        expect(<span class="tok-null">true</span>);
    }

    <span class="tok-comment">// Access the value by reference using a pointer capture.</span>
    <span class="tok-kw">var</span> c: ?<span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">if</span> (c) |*value| {
        value.* = <span class="tok-number">2</span>;
    }

    <span class="tok-kw">if</span> (c) |value| {
        expect(value == <span class="tok-number">2</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">unreachable</span>;
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;if error union&quot;</span> {
    <span class="tok-comment">// If expressions test for errors.</span>
    <span class="tok-comment">// Note the |err| capture on the else.</span>

    <span class="tok-kw">const</span> a: <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (a) |value| {
        expect(value == <span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">const</span> b: <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> = <span class="tok-kw">error</span>.BadValue;
    <span class="tok-kw">if</span> (b) |value| {
        <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> |err| {
        expect(err == <span class="tok-kw">error</span>.BadValue);
    }

    <span class="tok-comment">// The else and |err| capture is strictly required.</span>
    <span class="tok-kw">if</span> (a) |value| {
        expect(value == <span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> |_| {}

    <span class="tok-comment">// To check only the error value, use an empty block expression.</span>
    <span class="tok-kw">if</span> (b) |_| {} <span class="tok-kw">else</span> |err| {
        expect(err == <span class="tok-kw">error</span>.BadValue);
    }

    <span class="tok-comment">// Access the value by reference using a pointer capture.</span>
    <span class="tok-kw">var</span> c: <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">if</span> (c) |*value| {
        value.* = <span class="tok-number">9</span>;
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">if</span> (c) |value| {
        expect(value == <span class="tok-number">9</span>);
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">unreachable</span>;
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;if error union with optional&quot;</span> {
    <span class="tok-comment">// If expressions test for errors before unwrapping optionals.</span>
    <span class="tok-comment">// The |optional_value| capture's type is ?u32.</span>

    <span class="tok-kw">const</span> a: <span class="tok-type">anyerror</span>!?<span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (a) |optional_value| {
        expect(optional_value.? == <span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">const</span> b: <span class="tok-type">anyerror</span>!?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (b) |optional_value| {
        expect(optional_value == <span class="tok-null">null</span>);
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">const</span> c: <span class="tok-type">anyerror</span>!?<span class="tok-type">u32</span> = <span class="tok-kw">error</span>.BadValue;
    <span class="tok-kw">if</span> (c) |optional_value| {
        <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> |err| {
        expect(err == <span class="tok-kw">error</span>.BadValue);
    }

    <span class="tok-comment">// Access the value by reference by using a pointer capture each time.</span>
    <span class="tok-kw">var</span> d: <span class="tok-type">anyerror</span>!?<span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">if</span> (d) |*optional_value| {
        <span class="tok-kw">if</span> (optional_value.*) |*value| {
            value.* = <span class="tok-number">9</span>;
        }
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">if</span> (d) |optional_value| {
        expect(optional_value.? == <span class="tok-number">9</span>);
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">unreachable</span>;
    }
}</code></pre><pre><code class="shell">$ zig test if.zig
Test [1/5] test &quot;if expression&quot;... 
Test [2/5] test &quot;if boolean&quot;... 
Test [3/5] test &quot;if optional&quot;... 
Test [4/5] test &quot;if error union&quot;... 
Test [5/5] test &quot;if error union with optional&quot;... 

All 5 tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Optionals">Optionals</a></li>
<li><a href="#Errors">Errors</a></li>
</ul>

      
      <h1 id="defer"><a href="#toc-defer">defer</a> <a class="hdr" href="#defer">§</a></h1>

      <p class="file">defer.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> print = std.debug.print;

<span class="tok-comment">// defer will execute an expression at the end of the current scope.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">deferExample</span>() <span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;

    {
        <span class="tok-kw">defer</span> a = <span class="tok-number">2</span>;
        a = <span class="tok-number">1</span>;
    }
    expect(a == <span class="tok-number">2</span>);

    a = <span class="tok-number">5</span>;
    <span class="tok-kw">return</span> a;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;defer basics&quot;</span> {
    expect(deferExample() == <span class="tok-number">5</span>);
}

<span class="tok-comment">// If multiple defer statements are specified, they will be executed in</span>
<span class="tok-comment">// the reverse order they were run.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">deferUnwindExample</span>() <span class="tok-type">void</span> {
    print(<span class="tok-str">&quot;\n&quot;</span>, .{});

    <span class="tok-kw">defer</span> {
        print(<span class="tok-str">&quot;1 &quot;</span>, .{});
    }
    <span class="tok-kw">defer</span> {
        print(<span class="tok-str">&quot;2 &quot;</span>, .{});
    }
    <span class="tok-kw">if</span> (<span class="tok-null">false</span>) {
        <span class="tok-comment">// defers are not run if they are never executed.</span>
        <span class="tok-kw">defer</span> {
            print(<span class="tok-str">&quot;3 &quot;</span>, .{});
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;defer unwinding&quot;</span> {
    deferUnwindExample();
}

<span class="tok-comment">// The errdefer keyword is similar to defer, but will only execute if the</span>
<span class="tok-comment">// scope returns with an error.</span>
<span class="tok-comment">//</span>
<span class="tok-comment">// This is especially useful in allowing a function to clean up properly</span>
<span class="tok-comment">// on error, and replaces goto error handling tactics as seen in c.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">deferErrorExample</span>(is_error: <span class="tok-type">bool</span>) !<span class="tok-type">void</span> {
    print(<span class="tok-str">&quot;\nstart of function\n&quot;</span>, .{});

    <span class="tok-comment">// This will always be executed on exit</span>
    <span class="tok-kw">defer</span> {
        print(<span class="tok-str">&quot;end of function\n&quot;</span>, .{});
    }

    <span class="tok-kw">errdefer</span> {
        print(<span class="tok-str">&quot;encountered an error!\n&quot;</span>, .{});
    }

    <span class="tok-kw">if</span> (is_error) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeferError;
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;errdefer unwinding&quot;</span> {
    deferErrorExample(<span class="tok-null">false</span>) <span class="tok-kw">catch</span> {};
    deferErrorExample(<span class="tok-null">true</span>) <span class="tok-kw">catch</span> {};
}</code></pre><pre><code class="shell">$ zig test defer.zig
Test [1/3] test &quot;defer basics&quot;... 
Test [2/3] test &quot;defer unwinding&quot;... 

2 1 Test [3/3] test &quot;errdefer unwinding&quot;... 

start of function
end of function

start of function
encountered an error!
end of function

All 3 tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Errors">Errors</a></li>
</ul>

      
      <h1 id="unreachable"><a href="#toc-unreachable">unreachable</a> <a class="hdr" href="#unreachable">§</a></h1>

      <p>
      In <code class="zig">Debug</code> and <code class="zig">ReleaseSafe</code> mode, and when using <code>zig test</code>,
      <code class="zig"><span class="tok-kw">unreachable</span></code> emits a call to <code class="zig">panic</code> with the message <code>reached unreachable code</code>.
      </p>
      <p>
      In <code class="zig">ReleaseFast</code> mode, the optimizer uses the assumption that <code class="zig"><span class="tok-kw">unreachable</span></code> code
      will never be hit to perform optimizations. However, <code>zig test</code> even in <code class="zig">ReleaseFast</code> mode
                  still emits <code class="zig"><span class="tok-kw">unreachable</span></code> as calls to <code class="zig">panic</code>.
      </p>
      <h2 id="Basics"><a href="#toc-Basics">Basics</a> <a class="hdr" href="#Basics">§</a></h2>

      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-comment">// unreachable is used to assert that control flow will never happen upon a</span>
<span class="tok-comment">// particular location:</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;basic math&quot;</span> {
    <span class="tok-kw">const</span> x = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> y = <span class="tok-number">2</span>;
    <span class="tok-kw">if</span> (x + y != <span class="tok-number">3</span>) {
        <span class="tok-kw">unreachable</span>;
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;basic math&quot;... 

All 1 tests passed.
</code></pre>

      <p>In fact, this is how <code class="zig">std.debug.assert</code> is implemented:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-comment">// This is how std.debug.assert is implemented</span>
<span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>; <span class="tok-comment">// assertion failure</span>
}

<span class="tok-comment">// This test will fail because we hit unreachable.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;this will fail&quot;</span> {
    assert(<span class="tok-null">false</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;this will fail&quot;... 
thread 2311 panic: reached unreachable code
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:3:14</span>: <span class="t2_0">0x207a3b in assert (test)</span>
    if (!ok) unreachable; // assertion failure
             <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:8:11</span>: <span class="t2_0">0x20659e in test &quot;this will fail&quot; (test)</span>
    assert(false);
          <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/special/test_runner.zig:69:28</span>: <span class="t2_0">0x2302c8 in std.special.main (test)</span>
        } else test_fn.func();
                           <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:420:37</span>: <span class="t2_0">0x207dd4 in std.start.posixCallMainAndExit (test)</span>
            const result = root.main() catch |err| {
                                    <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x207c72 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
error: the following test command crashed:
docgen_tmp/zig-cache/o/091db03e22edfdd7844d6b7c020b80d0/test /home/vsts/work/1/s/build/release/bin/zig
</code></pre>

      
      <h2 id="At-Compile-Time"><a href="#toc-At-Compile-Time">At Compile-Time</a> <a class="hdr" href="#At-Compile-Time">§</a></h2>

      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;type of unreachable&quot;</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-comment">// The type of unreachable is noreturn.</span>

        <span class="tok-comment">// However this assertion will still fail because</span>
        <span class="tok-comment">// evaluating unreachable at compile-time is a compile error.</span>

        assert(<span class="tok-builtin">@TypeOf</span>(<span class="tok-kw">unreachable</span>) == <span class="tok-type">noreturn</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:10:16: </span><span class="t31_1">error: </span><span class="t0_1">unreachable code</span>
        assert(@TypeOf(unreachable) == noreturn);
               <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:3:28: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
test &quot;type of unreachable&quot; {
                           <span class="t32_1">^</span>
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Zig-Test">Zig Test</a></li>
<li><a href="#Build-Mode">Build Mode</a></li>
<li><a href="#comptime">comptime</a></li>
</ul>

      
      
      <h1 id="noreturn"><a href="#toc-noreturn">noreturn</a> <a class="hdr" href="#noreturn">§</a></h1>

      <p>
      <code class="zig"><span class="tok-type">noreturn</span></code> is the type of:
      </p>
      <ul>
          <li><code class="zig"><span class="tok-kw">break</span></code></li>
          <li><code class="zig"><span class="tok-kw">continue</span></code></li>
          <li><code class="zig"><span class="tok-kw">return</span></code></li>
          <li><code class="zig"><span class="tok-kw">unreachable</span></code></li>
          <li><code class="zig"><span class="tok-kw">while</span> (<span class="tok-null">true</span>) {}</code></li>
      </ul>
      <p>When resolving types together, such as <code class="zig"><span class="tok-kw">if</span></code> clauses or <code class="zig"><span class="tok-kw">switch</span></code> prongs,
              the <code class="zig"><span class="tok-type">noreturn</span></code> type is compatible with every other type. Consider:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(condition: <span class="tok-type">bool</span>, b: <span class="tok-type">u32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> a = <span class="tok-kw">if</span> (condition) b <span class="tok-kw">else</span> <span class="tok-kw">return</span>;
    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;do something with a&quot;</span>);
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;noreturn&quot;</span> {
    foo(<span class="tok-null">false</span>, <span class="tok-number">1</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;noreturn&quot;... 

All 1 tests passed.
</code></pre>

      <p>Another use case for <code class="zig"><span class="tok-type">noreturn</span></code> is the <code class="zig">exit</code> function:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">extern</span> <span class="tok-str">&quot;kernel32&quot;</span> <span class="tok-kw">fn</span> <span class="tok-fn">ExitProcess</span>(exit_code: <span class="tok-type">c_uint</span>) <span class="tok-kw">callconv</span>(<span class="tok-kw">if</span> (<span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).arch == .<span class="tok-type">i386</span>) .Stdcall <span class="tok-kw">else</span> .C) <span class="tok-type">noreturn</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;foo&quot;</span> {
    <span class="tok-kw">const</span> value = bar() <span class="tok-kw">catch</span> ExitProcess(<span class="tok-number">1</span>);
    expect(value == <span class="tok-number">1234</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}

<span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;</code></pre><pre><code class="shell">$ zig test test.zig -target x86_64-windows
warning: created docgen_tmp/zig-cache/o/d07e07e2b431b4aedfe2e40d365e5543/test.exe but skipping execution because it is non-native
</code></pre>

      
      <h1 id="Functions"><a href="#toc-Functions">Functions</a> <a class="hdr" href="#Functions">§</a></h1>

      <p class="file">functions.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-comment">// Functions are declared like this</span>
<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> {
    <span class="tok-kw">if</span> (a == <span class="tok-number">0</span>) {
        <span class="tok-kw">return</span> b;
    }

    <span class="tok-kw">return</span> a + b;
}

<span class="tok-comment">// The export specifier makes a function externally visible in the generated</span>
<span class="tok-comment">// object file, and makes it use the C ABI.</span>
<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> { <span class="tok-kw">return</span> a - b; }

<span class="tok-comment">// The extern specifier is used to declare a function that will be resolved</span>
<span class="tok-comment">// at link time, when linking statically, or at runtime, when linking</span>
<span class="tok-comment">// dynamically.</span>
<span class="tok-comment">// The callconv specifier changes the calling convention of the function.</span>
<span class="tok-kw">extern</span> <span class="tok-str">&quot;kernel32&quot;</span> <span class="tok-kw">fn</span> <span class="tok-fn">ExitProcess</span>(exit_code: <span class="tok-type">u32</span>) <span class="tok-kw">callconv</span>(<span class="tok-kw">if</span> (<span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).arch == .<span class="tok-type">i386</span>) .Stdcall <span class="tok-kw">else</span> .C) <span class="tok-type">noreturn</span>;
<span class="tok-kw">extern</span> <span class="tok-str">&quot;c&quot;</span> <span class="tok-kw">fn</span> <span class="tok-fn">atan2</span>(a: <span class="tok-type">f64</span>, b: <span class="tok-type">f64</span>) <span class="tok-type">f64</span>;

<span class="tok-comment">// The @setCold builtin tells the optimizer that a function is rarely called.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">abort</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@setCold</span>(<span class="tok-null">true</span>);
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {}
}

<span class="tok-comment">// The naked calling convention makes a function not have any function prologue or epilogue.</span>
<span class="tok-comment">// This can be useful when integrating with assembly.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">_start</span>() <span class="tok-kw">callconv</span>(.Naked) <span class="tok-type">noreturn</span> {
    abort();
}

<span class="tok-comment">// The inline calling convention forces a function to be inlined at all call sites.</span>
<span class="tok-comment">// If the function cannot be inlined, it is a compile-time error.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">shiftLeftOne</span>(a: <span class="tok-type">u32</span>) <span class="tok-kw">callconv</span>(.Inline) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> a &lt;&lt; <span class="tok-number">1</span>;
}

<span class="tok-comment">// The pub specifier allows the function to be visible when importing.</span>
<span class="tok-comment">// Another file can use @import and call sub2</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub2</span>(a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> { <span class="tok-kw">return</span> a - b; }

<span class="tok-comment">// Functions can be used as values and are equivalent to pointers.</span>
<span class="tok-kw">const</span> call2_op = <span class="tok-kw">fn</span> (a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">do_op</span>(fn_call: call2_op, op1: <span class="tok-type">i8</span>, op2: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> {
    <span class="tok-kw">return</span> fn_call(op1, op2);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;function&quot;</span> {
    expect(do_op(add, <span class="tok-number">5</span>, <span class="tok-number">6</span>) == <span class="tok-number">11</span>);
    expect(do_op(sub2, <span class="tok-number">5</span>, <span class="tok-number">6</span>) == -<span class="tok-number">1</span>);
}</code></pre><pre><code class="shell">$ zig test functions.zig
Test [1/1] test &quot;function&quot;... 

All 1 tests passed.
</code></pre>

      <p>Function values are like pointers:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">comptime</span> {
    expect(<span class="tok-builtin">@TypeOf</span>(foo) == <span class="tok-kw">fn</span>()<span class="tok-type">void</span>);
    expect(<span class="tok-builtin">@sizeOf</span>(<span class="tok-kw">fn</span>()<span class="tok-type">void</span>) == <span class="tok-builtin">@sizeOf</span>(?<span class="tok-kw">fn</span>()<span class="tok-type">void</span>));
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> { }</code></pre><pre><code class="shell">$ zig build-obj test.zig</code></pre>

      <h2 id="Pass-by-value-Parameters"><a href="#toc-Pass-by-value-Parameters">Pass-by-value Parameters</a> <a class="hdr" href="#Pass-by-value-Parameters">§</a></h2>

      <p>
      Primitive types such as <a href="#Integers">Integers</a> and <a href="#Floats">Floats</a> passed as parameters
      are copied, and then the copy is available in the function body. This is called "passing by value".
      Copying a primitive type is essentially free and typically involves nothing more than
      setting a register.
      </p>
      <p>
      Structs, unions, and arrays can sometimes be more efficiently passed as a reference, since a copy
      could be arbitrarily expensive depending on the size. When these types are passed
      as parameters, Zig may choose to copy and pass by value, or pass by reference, whichever way
      Zig decides will be faster. This is made possible, in part, by the fact that parameters are immutable.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">i32</span>,
    y: <span class="tok-type">i32</span>,
};

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(point: Point) <span class="tok-type">i32</span> {
    <span class="tok-comment">// Here, `point` could be a reference, or a copy. The function body</span>
    <span class="tok-comment">// can ignore the difference and treat it as a value. Be very careful</span>
    <span class="tok-comment">// taking the address of the parameter - it should be treated as if</span>
    <span class="tok-comment">// the address will become invalid when the function returns.</span>
    <span class="tok-kw">return</span> point.x + point.y;
}

<span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;pass struct to function&quot;</span> {
    expect(foo(Point{ .x = <span class="tok-number">1</span>, .y = <span class="tok-number">2</span> }) == <span class="tok-number">3</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;pass struct to function&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      For extern functions, Zig follows the C ABI for passing structs and unions by value.
      </p>
      
      <h2 id="Function-Parameter-Type-Inference"><a href="#toc-Function-Parameter-Type-Inference">Function Parameter Type Inference</a> <a class="hdr" href="#Function-Parameter-Type-Inference">§</a></h2>

      <p>
      Function parameters can be declared with <code class="zig"><span class="tok-kw">anytype</span></code> in place of the type.
      In this case the parameter types will be inferred when the function is called.
      Use <a href="#TypeOf">@TypeOf</a> and <a href="#typeInfo">@typeInfo</a> to get information about the inferred type.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">fn</span> <span class="tok-fn">addFortyTwo</span>(x: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(x) {
    <span class="tok-kw">return</span> x + <span class="tok-number">42</span>;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;fn type inference&quot;</span> {
    expect(addFortyTwo(<span class="tok-number">1</span>) == <span class="tok-number">43</span>);
    expect(<span class="tok-builtin">@TypeOf</span>(addFortyTwo(<span class="tok-number">1</span>)) == <span class="tok-type">comptime_int</span>);
    <span class="tok-kw">var</span> y: <span class="tok-type">i64</span> = <span class="tok-number">2</span>;
    expect(addFortyTwo(y) == <span class="tok-number">44</span>);
    expect(<span class="tok-builtin">@TypeOf</span>(addFortyTwo(y)) == <span class="tok-type">i64</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;fn type inference&quot;... 

All 1 tests passed.
</code></pre>


      
      <h2 id="Function-Reflection"><a href="#toc-Function-Reflection">Function Reflection</a> <a class="hdr" href="#Function-Reflection">§</a></h2>

      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;fn reflection&quot;</span> {
    expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(expect)).Fn.return_type.? == <span class="tok-type">void</span>);
    expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(expect)).Fn.is_var_args == <span class="tok-null">false</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;fn reflection&quot;... 

All 1 tests passed.
</code></pre>

      
      
      <h1 id="Errors"><a href="#toc-Errors">Errors</a> <a class="hdr" href="#Errors">§</a></h1>

      <h2 id="Error-Set-Type"><a href="#toc-Error-Set-Type">Error Set Type</a> <a class="hdr" href="#Error-Set-Type">§</a></h2>

      <p>
      An error set is like an <a href="#enum">enum</a>.
      However, each error name across the entire compilation gets assigned an unsigned integer
      greater than 0. You are allowed to declare the same error name more than once, and if you do, it
      gets assigned the same integer value.
      </p>
      <p>
      The number of unique error values across the entire compilation should determine the size of the error set type.
      However right now it is hard coded to be a <code class="zig"><span class="tok-type">u16</span></code>. See <a href="https://github.com/ziglang/zig/issues/786">#768</a>.
      </p>
      <p>
      You can <a href="#Type-Coercion">coerce</a> an error from a subset to a superset:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> FileOpenError = <span class="tok-kw">error</span> {
    AccessDenied,
    OutOfMemory,
    FileNotFound,
};

<span class="tok-kw">const</span> AllocationError = <span class="tok-kw">error</span> {
    OutOfMemory,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;coerce subset to superset&quot;</span> {
    <span class="tok-kw">const</span> err = foo(AllocationError.OutOfMemory);
    std.testing.expect(err == FileOpenError.OutOfMemory);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(err: AllocationError) FileOpenError {
    <span class="tok-kw">return</span> err;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;coerce subset to superset&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      But you cannot <a href="#Type-Coercion">coerce</a> an error from a superset to a subset:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> FileOpenError = <span class="tok-kw">error</span> {
    AccessDenied,
    OutOfMemory,
    FileNotFound,
};

<span class="tok-kw">const</span> AllocationError = <span class="tok-kw">error</span> {
    OutOfMemory,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;coerce superset to subset&quot;</span> {
    foo(FileOpenError.OutOfMemory) <span class="tok-kw">catch</span> {};
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(err: FileOpenError) AllocationError {
    <span class="tok-kw">return</span> err;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:16:12: </span><span class="t31_1">error: </span><span class="t0_1">expected type 'AllocationError', found 'FileOpenError'</span>
    return err;
           <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:2:5: </span><span class="t36_1">note: </span><span class="t0_1">'error.AccessDenied' not a member of destination error set</span>
    AccessDenied,
    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:4:5: </span><span class="t36_1">note: </span><span class="t0_1">'error.FileNotFound' not a member of destination error set</span>
    FileNotFound,
    <span class="t32_1">^</span>
</code></pre>

      <p>
      There is a shortcut for declaring an error set with only 1 value, and then getting that value:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> err = <span class="tok-kw">error</span>.FileNotFound;</code></pre>
      <p>This is equivalent to:</p>
      <pre><code class="zig"><span class="tok-kw">const</span> err = (<span class="tok-kw">error</span> {FileNotFound}).FileNotFound;</code></pre>
      <p>
      This becomes useful when using <a href="#Inferred-Error-Sets">Inferred Error Sets</a>.
      </p>
      <h3 id="The-Global-Error-Set"><a href="#toc-The-Global-Error-Set">The Global Error Set</a> <a class="hdr" href="#The-Global-Error-Set">§</a></h3>

      <p><code class="zig"><span class="tok-type">anyerror</span></code> refers to the global error set.
      This is the error set that contains all errors in the entire compilation unit.
      It is a superset of all other error sets and a subset of none of them.
      </p>
      <p>
      You can <a href="#Type-Coercion">coerce</a> any error set to the global one, and you can explicitly
      cast an error of the global error set to a non-global one. This inserts a language-level
      assert to make sure the error value is in fact in the destination error set.
      </p>
      <p>
      The global error set should generally be avoided because it prevents the
      compiler from knowing what errors are possible at compile-time. Knowing
      the error set at compile-time is better for generated documentation and
      helpful error messages, such as forgetting a possible error value in a <a href="#switch">switch</a>.
      </p>
      
      
      <h2 id="Error-Union-Type"><a href="#toc-Error-Union-Type">Error Union Type</a> <a class="hdr" href="#Error-Union-Type">§</a></h2>

      <p>
      An error set type and normal type can be combined with the <code class="zig">!</code>
      binary operator to form an error union type. You are likely to use an
      error union type more often than an error set type by itself.
      </p>
      <p>
      Here is a function to parse a string into a 64-bit integer:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> maxInt = std.math.maxInt;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseU64</span>(buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, radix: <span class="tok-type">u8</span>) !<span class="tok-type">u64</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">for</span> (buf) |c| {
        <span class="tok-kw">const</span> digit = charToDigit(c);

        <span class="tok-kw">if</span> (digit &gt;= radix) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidChar;
        }

        <span class="tok-comment">// x *= radix</span>
        <span class="tok-kw">if</span> (<span class="tok-builtin">@mulWithOverflow</span>(<span class="tok-type">u64</span>, x, radix, &amp;x)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
        }

        <span class="tok-comment">// x += digit</span>
        <span class="tok-kw">if</span> (<span class="tok-builtin">@addWithOverflow</span>(<span class="tok-type">u64</span>, x, digit, &amp;x)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
        }
    }

    <span class="tok-kw">return</span> x;
}

<span class="tok-kw">fn</span> <span class="tok-fn">charToDigit</span>(c: <span class="tok-type">u8</span>) <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (c) {
        <span class="tok-str">'0'</span> ... <span class="tok-str">'9'</span> =&gt; c - <span class="tok-str">'0'</span>,
        <span class="tok-str">'A'</span> ... <span class="tok-str">'Z'</span> =&gt; c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>,
        <span class="tok-str">'a'</span> ... <span class="tok-str">'z'</span> =&gt; c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>,
        <span class="tok-kw">else</span> =&gt; maxInt(<span class="tok-type">u8</span>),
    };
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;parse u64&quot;</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> parseU64(<span class="tok-str">&quot;1234&quot;</span>, <span class="tok-number">10</span>);
    std.testing.expect(result == <span class="tok-number">1234</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;parse u64&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      Notice the return type is <code class="zig">!<span class="tok-type">u64</span></code>. This means that the function
      either returns an unsigned 64 bit integer, or an error. We left off the error set
      to the left of the <code class="zig">!</code>, so the error set is inferred.
      </p>
      <p>
      Within the function definition, you can see some return statements that return
      an error, and at the bottom a return statement that returns a <code class="zig"><span class="tok-type">u64</span></code>.
          Both types <a href="#Type-Coercion">coerce</a> to <code class="zig"><span class="tok-type">anyerror</span>!<span class="tok-type">u64</span></code>.
      </p>
      <p>
      What it looks like to use this function varies depending on what you're
      trying to do. One of the following:
      </p>
      <ul>
        <li>You want to provide a default value if it returned an error.</li>
        <li>If it returned an error then you want to return the same error.</li>
        <li>You know with complete certainty it will not return an error, so want to unconditionally unwrap it.</li>
        <li>You want to take a different action for each possible error.</li>
      </ul>
      <h3 id="catch"><a href="#toc-catch">catch</a> <a class="hdr" href="#catch">§</a></h3>

      <p>If you want to provide a default value, you can use the <code class="zig"><span class="tok-kw">catch</span></code> binary operator:</p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = parseU64(str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-number">13</span>;
    <span class="tok-comment">// ...</span>
}</code></pre>
      <p>
      In this code, <code class="zig">number</code> will be equal to the successfully parsed string, or
          a default value of 13. The type of the right hand side of the binary <code class="zig"><span class="tok-kw">catch</span></code> operator must
              match the unwrapped error union type, or be of type <code class="zig"><span class="tok-type">noreturn</span></code>.
      </p>
      
      <h3 id="try"><a href="#toc-try">try</a> <a class="hdr" href="#try">§</a></h3>

      <p>Let's say you wanted to return the error if you got one, otherwise continue with the
      function logic:</p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = parseU64(str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">return</span> err;
    <span class="tok-comment">// ...</span>
}</code></pre>
      <p>
      There is a shortcut for this. The <code class="zig"><span class="tok-kw">try</span></code> expression:
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = <span class="tok-kw">try</span> parseU64(str, <span class="tok-number">10</span>);
    <span class="tok-comment">// ...</span>
}</code></pre>
      <p>
      <code class="zig"><span class="tok-kw">try</span></code> evaluates an error union expression. If it is an error, it returns
      from the current function with the same error. Otherwise, the expression results in
      the unwrapped value.
      </p>
      
      <p>
        Maybe you know with complete certainty that an expression will never be an error.
        In this case you can do this:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> number = parseU64(<span class="tok-str">&quot;1234&quot;</span>, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</code></pre>
      <p>
      Here we know for sure that "1234" will parse successfully. So we put the
      <code class="zig"><span class="tok-kw">unreachable</span></code> value on the right hand side. <code class="zig"><span class="tok-kw">unreachable</span></code> generates
      a panic in Debug and ReleaseSafe modes and undefined behavior in ReleaseFast mode. So, while we're debugging the
      application, if there <em>was</em> a surprise error here, the application would crash
      appropriately.
      </p>
      <p>
      Finally, you may want to take a different action for every situation. For that, we combine
      the <a href="#if">if</a> and <a href="#switch">switch</a> expression:
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (parseU64(str, <span class="tok-number">10</span>)) |number| {
        doSomethingWithNumber(number);
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Overflow =&gt; {
            <span class="tok-comment">// handle overflow...</span>
        },
        <span class="tok-comment">// we promise that InvalidChar won't happen (or crash in debug mode if it does)</span>
        <span class="tok-kw">error</span>.InvalidChar =&gt; <span class="tok-kw">unreachable</span>,
    }
}</code></pre>
      <h3 id="errdefer"><a href="#toc-errdefer">errdefer</a> <a class="hdr" href="#errdefer">§</a></h3>

      <p>
      The other component to error handling is defer statements.
      In addition to an unconditional <a href="#defer">defer</a>, Zig has <code class="zig"><span class="tok-kw">errdefer</span></code>,
      which evaluates the deferred expression on block exit path if and only if
      the function returned with an error from the block.
      </p>
      <p>
      Example:
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">createFoo</span>(param: <span class="tok-type">i32</span>) !Foo {
    <span class="tok-kw">const</span> foo = <span class="tok-kw">try</span> tryToAllocateFoo();
    <span class="tok-comment">// now we have allocated foo. we need to free it if the function fails.</span>
    <span class="tok-comment">// but we want to return it if the function succeeds.</span>
    <span class="tok-kw">errdefer</span> deallocateFoo(foo);

    <span class="tok-kw">const</span> tmp_buf = allocateTmpBuffer() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;
    <span class="tok-comment">// tmp_buf is truly a temporary resource, and we for sure want to clean it up</span>
    <span class="tok-comment">// before this block leaves scope</span>
    <span class="tok-kw">defer</span> deallocateTmpBuffer(tmp_buf);

    <span class="tok-kw">if</span> (param &gt; <span class="tok-number">1337</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidParam;

    <span class="tok-comment">// here the errdefer will not run since we're returning success from the function.</span>
    <span class="tok-comment">// but the defer will run!</span>
    <span class="tok-kw">return</span> foo;
}</code></pre>
      <p>
      The neat thing about this is that you get robust error handling without
      the verbosity and cognitive overhead of trying to make sure every exit path
      is covered. The deallocation code is always directly following the allocation code.
      </p>
      
      <p>
      A couple of other tidbits about error handling:
      </p>
      <ul>
        <li>These primitives give enough expressiveness that it's completely practical
            to have failing to check for an error be a compile error. If you really want
            to ignore the error, you can add <code class="zig"><span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span></code> and
            get the added benefit of crashing in Debug and ReleaseSafe modes if your assumption was wrong.
        </li>
        <li>
          Since Zig understands error types, it can pre-weight branches in favor of
          errors not occurring. Just a small optimization benefit that is not available
          in other languages.
        </li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#defer">defer</a></li>
<li><a href="#if">if</a></li>
<li><a href="#switch">switch</a></li>
</ul>


      <p>An error union is created with the <code class="zig">!</code> binary operator.
      You can use compile-time reflection to access the child type of an error union:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;error union&quot;</span> {
    <span class="tok-kw">var</span> foo: <span class="tok-type">anyerror</span>!<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;

    <span class="tok-comment">// Coerce from child type of an error union:</span>
    foo = <span class="tok-number">1234</span>;

    <span class="tok-comment">// Coerce from an error set:</span>
    foo = <span class="tok-kw">error</span>.SomeError;

    <span class="tok-comment">// Use compile-time reflection to access the payload type of an error union:</span>
    <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(foo)).ErrorUnion.payload == <span class="tok-type">i32</span>);

    <span class="tok-comment">// Use compile-time reflection to access the error set type of an error union:</span>
    <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(foo)).ErrorUnion.error_set == <span class="tok-type">anyerror</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;error union&quot;... 

All 1 tests passed.
</code></pre>

      <h3 id="Merging-Error-Sets"><a href="#toc-Merging-Error-Sets">Merging Error Sets</a> <a class="hdr" href="#Merging-Error-Sets">§</a></h3>

      <p>
      Use the <code class="zig">||</code> operator to merge two error sets together. The resulting
      error set contains the errors of both error sets. Doc comments from the left-hand
      side override doc comments from the right-hand side. In this example, the doc
      comments for <code class="zig">C.PathNotFound</code> is <code>A doc comment</code>.
      </p>
      <p>
      This is especially useful for functions which return different error sets depending
      on <a href="#comptime">comptime</a> branches. For example, the Zig standard library uses
      <code class="zig">LinuxFileOpenError || WindowsFileOpenError</code> for the error set of opening
      files.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> A = <span class="tok-kw">error</span>{
    NotDir,

    <span class="tok-comment">/// A doc comment</span>
    PathNotFound,
};
<span class="tok-kw">const</span> B = <span class="tok-kw">error</span>{
    OutOfMemory,

    <span class="tok-comment">/// B doc comment</span>
    PathNotFound,
};

<span class="tok-kw">const</span> C = A || B;

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() C!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;merge error sets&quot;</span> {
    <span class="tok-kw">if</span> (foo()) {
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unexpected&quot;</span>);
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unexpected&quot;</span>),
        <span class="tok-kw">error</span>.PathNotFound =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unexpected&quot;</span>),
        <span class="tok-kw">error</span>.NotDir =&gt; {},
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;merge error sets&quot;... 

All 1 tests passed.
</code></pre>

      
      <h3 id="Inferred-Error-Sets"><a href="#toc-Inferred-Error-Sets">Inferred Error Sets</a> <a class="hdr" href="#Inferred-Error-Sets">§</a></h3>

      <p>
      Because many functions in Zig return a possible error, Zig supports inferring the error set.
      To infer the error set for a function, use this syntax:
      </p>
<p class="file">test.zig</p><pre><code class="zig"><span class="tok-comment">// With an inferred error set</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add_inferred</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) !T {
    <span class="tok-kw">var</span> answer: T = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@addWithOverflow</span>(T, a, b, &amp;answer)) <span class="tok-kw">error</span>.Overflow <span class="tok-kw">else</span> answer;
}

<span class="tok-comment">// With an explicit error set</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add_explicit</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) Error!T {
    <span class="tok-kw">var</span> answer: T = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@addWithOverflow</span>(T, a, b, &amp;answer)) <span class="tok-kw">error</span>.Overflow <span class="tok-kw">else</span> answer;
}

<span class="tok-kw">const</span> Error = <span class="tok-kw">error</span> {
    Overflow,
};

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;inferred error set&quot;</span> {
    <span class="tok-kw">if</span> (add_inferred(<span class="tok-type">u8</span>, <span class="tok-number">255</span>, <span class="tok-number">1</span>)) |_| <span class="tok-kw">unreachable</span> <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Overflow =&gt; {}, <span class="tok-comment">// ok</span>
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;inferred error set&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      When a function has an inferred error set, that function becomes generic and thus it becomes
      trickier to do certain things with it, such as obtain a function pointer, or have an error
      set that is consistent across different build targets. Additionally, inferred error sets
      are incompatible with recursion.
      </p>
      <p>
      In these situations, it is recommended to use an explicit error set. You can generally start
      with an empty error set and let compile errors guide you toward completing the set.
      </p>
      <p>
      These limitations may be overcome in a future version of Zig.
      </p>
      
      
      <h2 id="Error-Return-Traces"><a href="#toc-Error-Return-Traces">Error Return Traces</a> <a class="hdr" href="#Error-Return-Traces">§</a></h2>

      <p>
      Error Return Traces show all the points in the code that an error was returned to the calling function. This makes it practical to use <a href="#try">try</a> everywhere and then still be able to know what happened if an error ends up bubbling all the way out of your application.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> foo(<span class="tok-number">12</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: <span class="tok-type">i32</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (x &gt;= <span class="tok-number">5</span>) {
        <span class="tok-kw">try</span> bar();
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> bang2();
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (baz()) {
        <span class="tok-kw">try</span> quux();
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">try</span> hello(),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> another(),
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">baz</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> bang1();
}

<span class="tok-kw">fn</span> <span class="tok-fn">quux</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">hello</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">another</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> bang1();
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang1</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang2</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied;
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
error: PermissionDenied
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:39:5</span>: <span class="t2_0">0x234b82 in bang1 (test)</span>
    return error.FileNotFound;
    <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:23:5</span>: <span class="t2_0">0x234a5f in baz (test)</span>
    try bang1();
    <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:43:5</span>: <span class="t2_0">0x234a22 in bang2 (test)</span>
    return error.PermissionDenied;
    <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:31:5</span>: <span class="t2_0">0x234b4f in hello (test)</span>
    try bang2();
    <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:17:31</span>: <span class="t2_0">0x2349ee in bar (test)</span>
        error.FileNotFound =&gt; try hello(),
                              <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:7:9</span>: <span class="t2_0">0x2348dc in foo (test)</span>
        try bar();
        <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:2:5</span>: <span class="t2_0">0x22d664 in main (test)</span>
    try foo(12);
    <span class="t32_1">^</span>
</code></pre>

      <p>
      Look closely at this example. This is no stack trace.
      </p>
      <p>
      You can see that the final error bubbled up was <code class="zig">PermissionDenied</code>,
          but the original error that started this whole thing was <code class="zig">FileNotFound</code>. In the <code class="zig">bar</code> function, the code handles the original error code,
      and then returns another one, from the switch statement. Error Return Traces make this clear, whereas a stack trace would look like this:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    foo(<span class="tok-number">12</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: <span class="tok-type">i32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (x &gt;= <span class="tok-number">5</span>) {
        bar();
    } <span class="tok-kw">else</span> {
        bang2();
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (baz()) {
        quux();
    } <span class="tok-kw">else</span> {
        hello();
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">baz</span>() <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> bang1();
}

<span class="tok-kw">fn</span> <span class="tok-fn">quux</span>() <span class="tok-type">void</span> {
    bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">hello</span>() <span class="tok-type">void</span> {
    bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang1</span>() <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang2</span>() <span class="tok-type">void</span> {
    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;PermissionDenied&quot;</span>);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 2495 panic: PermissionDenied
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:38:5</span>: <span class="t2_0">0x236156 in bang2 (test)</span>
    @panic(&quot;PermissionDenied&quot;);
    <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:30:10</span>: <span class="t2_0">0x2368f8 in hello (test)</span>
    bang2();
         <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:17:14</span>: <span class="t2_0">0x23613a in bar (test)</span>
        hello();
             <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:7:12</span>: <span class="t2_0">0x2346b5 in foo (test)</span>
        bar();
           <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:2:8</span>: <span class="t2_0">0x22d4ad in main (test)</span>
    foo(12);
       <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204e0e in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204ce2 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      <p>
      Here, the stack trace does not explain how the control
      flow in <code class="zig">bar</code> got to the <code class="zig">hello()</code> call.
      One would have to open a debugger or further instrument the application
      in order to find out. The error return trace, on the other hand,
      shows exactly how the error bubbled up.
      </p>
      <p>
      This debugging feature makes it easier to iterate quickly on code that
      robustly handles all error conditions. This means that Zig developers
      will naturally find themselves writing correct, robust code in order
      to increase their development pace.
      </p>
      <p>
      Error Return Traces are enabled by default in <a href="#Debug">Debug</a> and <a href="#ReleaseSafe">ReleaseSafe</a> builds and disabled by default in <a href="#ReleaseFast">ReleaseFast</a> and <a href="#ReleaseSmall">ReleaseSmall</a> builds.
      </p>
      <p>
      There are a few ways to activate this error return tracing feature:
      </p>
      <ul>
        <li>Return an error from main</li>
        <li>An error makes its way to <code class="zig"><span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span></code> and you have not overridden the default panic handler</li>
        <li>Use <a href="#errorReturnTrace">errorReturnTrace</a> to access the current return trace. You can use <code class="zig">std.debug.dumpStackTrace</code> to print it. This function returns comptime-known <a href="#null">null</a> when building without error return tracing support.</li>
      </ul>
      <h3 id="Implementation-Details"><a href="#toc-Implementation-Details">Implementation Details</a> <a class="hdr" href="#Implementation-Details">§</a></h3>

      <p>
      To analyze performance cost, there are two cases:
      </p>
      <ul>
        <li>when no errors are returned</li>
        <li>when returning errors</li>
      </ul>
      <p>
      For the case when no errors are returned, the cost is a single memory write operation, only in the first non-failable function in the call graph that calls a failable function, i.e. when a function returning <code class="zig"><span class="tok-type">void</span></code> calls a function returning <code class="zig"><span class="tok-kw">error</span></code>.
      This is to initialize this struct in the stack memory:
      </p>
      <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StackTrace = <span class="tok-kw">struct</span> {
    index: <span class="tok-type">usize</span>,
    instruction_addresses: [N]<span class="tok-type">usize</span>,
};</code></pre>
      <p>
      Here, N is the maximum function call depth as determined by call graph analysis. Recursion is ignored and counts for 2.
      </p>
      <p>
      A pointer to <code class="zig">StackTrace</code> is passed as a secret parameter to every function that can return an error, but it's always the first parameter, so it can likely sit in a register and stay there.
      </p>
      <p>
      That's it for the path when no errors occur. It's practically free in terms of performance.
      </p>
      <p>
      When generating the code for a function that returns an error, just before the <code class="zig"><span class="tok-kw">return</span></code> statement (only for the <code class="zig"><span class="tok-kw">return</span></code> statements that return errors), Zig generates a call to this function:
      </p>
      <pre><code class="zig"><span class="tok-comment">// marked as &quot;no-inline&quot; in LLVM IR</span>
<span class="tok-kw">fn</span> <span class="tok-fn">__zig_return_error</span>(stack_trace: *StackTrace) <span class="tok-type">void</span> {
    stack_trace.instruction_addresses[stack_trace.index] = <span class="tok-builtin">@returnAddress</span>();
    stack_trace.index = (stack_trace.index + <span class="tok-number">1</span>) % N;
}</code></pre>
      <p>
      The cost is 2 math operations plus some memory reads and writes. The memory accessed is constrained and should remain cached for the duration of the error return bubbling.
      </p>
      <p>
      As for code size cost, 1 function call before a return statement is no big deal. Even so,
      I have <a href="https://github.com/ziglang/zig/issues/690">a plan</a> to make the call to
      <code class="zig">__zig_return_error</code> a tail call, which brings the code size cost down to actually zero. What is a return statement in code without error return tracing can become a jump instruction in code with error return tracing.
      </p>
      
      
      
      <h1 id="Optionals"><a href="#toc-Optionals">Optionals</a> <a class="hdr" href="#Optionals">§</a></h1>

      <p>
      One area that Zig provides safety without compromising efficiency or
      readability is with the optional type.
      </p>
      <p>
      The question mark symbolizes the optional type. You can convert a type to an optional
      type by putting a question mark in front of it, like this:
      </p>
      <pre><code class="zig"><span class="tok-comment">// normal integer</span>
<span class="tok-kw">const</span> normal_int: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;

<span class="tok-comment">// optional integer</span>
<span class="tok-kw">const</span> optional_int: ?<span class="tok-type">i32</span> = <span class="tok-number">5678</span>;</code></pre>
      <p>
      Now the variable <code class="zig">optional_int</code> could be an <code class="zig"><span class="tok-type">i32</span></code>, or <code class="zig"><span class="tok-null">null</span></code>.
      </p>
      <p>
      Instead of integers, let's talk about pointers. Null references are the source of many runtime
      exceptions, and even stand accused of being
      <a href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/">the worst mistake of computer science</a>.
      </p>
      <p>Zig does not have them.</p>
      <p>
      Instead, you can use an optional pointer. This secretly compiles down to a normal pointer,
      since we know we can use 0 as the null value for the optional type. But the compiler
      can check your work and make sure you don't assign null to something that can't be null.
      </p>
      <p>
      Typically the downside of not having null is that it makes the code more verbose to
      write. But, let's compare some equivalent C code and Zig code.
      </p>
      <p>
      Task: call malloc, if the result is null, return null.
      </p>
      <p>C code</p>
      <pre><code class="cpp">// malloc prototype included for reference
void *malloc(size_t size);

struct Foo *do_a_thing(void) {
    char *ptr = malloc(1234);
    if (!ptr) return NULL;
    // ...
}</code></pre>
      <p>Zig code</p>
      <pre><code class="zig"><span class="tok-comment">// malloc prototype included for reference</span>
<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">malloc</span>(size: size_t) ?*<span class="tok-type">u8</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>() ?*Foo {
    <span class="tok-kw">const</span> ptr = malloc(<span class="tok-number">1234</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-comment">// ...</span>
}</code></pre>
      <p>
        Here, Zig is at least as convenient, if not more, than C. And, the type of "ptr"
        is <code class="zig">*<span class="tok-type">u8</span></code> <em>not</em> <code class="zig">?*<span class="tok-type">u8</span></code>. The <code class="zig"><span class="tok-kw">orelse</span></code> keyword
                    unwrapped the optional type and therefore <code class="zig">ptr</code> is guaranteed to be non-null everywhere
        it is used in the function.
      </p>
      <p>
        The other form of checking against NULL you might see looks like this:
      </p>
      <pre><code class="cpp">void do_a_thing(struct Foo *foo) {
    // do some stuff

    if (foo) {
        do_something_with_foo(foo);
    }

    // do some stuff
}</code></pre>
      <p>
        In Zig you can accomplish the same thing:
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(optional_foo: ?*Foo) <span class="tok-type">void</span> {
    <span class="tok-comment">// do some stuff</span>

    <span class="tok-kw">if</span> (optional_foo) |foo| {
      doSomethingWithFoo(foo);
    }

    <span class="tok-comment">// do some stuff</span>
}</code></pre>
      <p>
      Once again, the notable thing here is that inside the if block,
      <code class="zig">foo</code> is no longer an optional pointer, it is a pointer, which
      cannot be null.
      </p>
      <p>
      One benefit to this is that functions which take pointers as arguments can
      be annotated with the "nonnull" attribute - <code>__attribute__((nonnull))</code> in
      <a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html">GCC</a>.
      The optimizer can sometimes make better decisions knowing that pointer arguments
      cannot be null.
      </p>
      <h2 id="Optional-Type"><a href="#toc-Optional-Type">Optional Type</a> <a class="hdr" href="#Optional-Type">§</a></h2>

      <p>An optional is created by putting <code class="zig">?</code> in front of a type. You can use compile-time
      reflection to access the child type of an optional:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;optional type&quot;</span> {
    <span class="tok-comment">// Declare an optional and coerce from null:</span>
    <span class="tok-kw">var</span> foo: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-comment">// Coerce from child type of an optional</span>
    foo = <span class="tok-number">1234</span>;

    <span class="tok-comment">// Use compile-time reflection to access the child type of the optional:</span>
    <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(foo)).Optional.child == <span class="tok-type">i32</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;optional type&quot;... 

All 1 tests passed.
</code></pre>

      
      <h2 id="null"><a href="#toc-null">null</a> <a class="hdr" href="#null">§</a></h2>

      <p>
      Just like <a href="#undefined">undefined</a>, <code class="zig"><span class="tok-null">null</span></code> has its own type, and the only way to use it is to
      cast it to a different type:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> optional_value: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;</code></pre>
      
      <h2 id="Optional-Pointers"><a href="#toc-Optional-Pointers">Optional Pointers</a> <a class="hdr" href="#Optional-Pointers">§</a></h2>

      <p>An optional pointer is guaranteed to be the same size as a pointer. The <code class="zig"><span class="tok-null">null</span></code> of
      the optional is guaranteed to be address 0.</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;optional pointers&quot;</span> {
    <span class="tok-comment">// Pointers cannot be null. If you want a null pointer, use the optional</span>
    <span class="tok-comment">// prefix `?` to make the pointer type optional.</span>
    <span class="tok-kw">var</span> ptr: ?*<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    ptr = &amp;x;

    expect(ptr.?.* == <span class="tok-number">1</span>);

    <span class="tok-comment">// Optional pointers are the same size as normal pointers, because pointer</span>
    <span class="tok-comment">// value 0 is used as the null value.</span>
    expect(<span class="tok-builtin">@sizeOf</span>(?*<span class="tok-type">i32</span>) == <span class="tok-builtin">@sizeOf</span>(*<span class="tok-type">i32</span>));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;optional pointers&quot;... 

All 1 tests passed.
</code></pre>

      
      
      <h1 id="Casting"><a href="#toc-Casting">Casting</a> <a class="hdr" href="#Casting">§</a></h1>

      <p>
      A <strong>type cast</strong> converts a value of one type to another.
      Zig has <a href="#Type-Coercion">Type Coercion</a> for conversions that are known to be completely safe and unambiguous,
      and <a href="#Explicit-Casts">Explicit Casts</a> for conversions that one would not want to happen on accident.
      There is also a third kind of type conversion called <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for
      the case when a result type must be decided given multiple operand types.
      </p>
      <h2 id="Type-Coercion"><a href="#toc-Type-Coercion">Type Coercion</a> <a class="hdr" href="#Type-Coercion">§</a></h2>

      <p>
      Type coercion occurs when one type is expected, but different type is provided:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;type coercion - variable declaration&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u8</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u16</span> = a;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;type coercion - function call&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u8</span> = <span class="tok-number">1</span>;
    foo(a);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(b: <span class="tok-type">u16</span>) <span class="tok-type">void</span> {}

<span class="tok-kw">test</span> <span class="tok-str">&quot;type coercion - @as builtin&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u8</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> b = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, a);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/3] test &quot;type coercion - variable declaration&quot;... 
Test [2/3] test &quot;type coercion - function call&quot;... 
Test [3/3] test &quot;type coercion - @as builtin&quot;... 

All 3 tests passed.
</code></pre>

      <p>
      Type coercions are only allowed when it is completely unambiguous how to get from one type to another,
      and the transformation is guaranteed to be safe. There is one exception, which is <a href="#C-Pointers">C Pointers</a>.
      </p>
      <h3 id="Type-Coercion-Stricter-Qualification"><a href="#toc-Type-Coercion-Stricter-Qualification">Type Coercion: Stricter Qualification</a> <a class="hdr" href="#Type-Coercion-Stricter-Qualification">§</a></h3>

      <p>
      Values which have the same representation at runtime can be cast to increase the strictness
      of the qualifiers, no matter how nested the qualifiers are:
      </p>
      <ul>
          <li><code class="zig"><span class="tok-kw">const</span></code> - non-const to const is allowed</li>
          <li><code class="zig"><span class="tok-kw">volatile</span></code> - non-volatile to volatile is allowed</li>
          <li><code class="zig"><span class="tok-kw">align</span></code> - bigger to smaller alignment is allowed </li>
          <li><a href="#Error-Set-Type">error sets</a> to supersets is allowed</li>
      </ul>
      <p>
      These casts are no-ops at runtime since the value representation does not change.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;type coercion - const qualification&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> b: *<span class="tok-type">i32</span> = &amp;a;
    foo(b);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(a: *<span class="tok-kw">const</span> <span class="tok-type">i32</span>) <span class="tok-type">void</span> {}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;type coercion - const qualification&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      In addition, pointers coerce to const optional pointers:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> mem = std.mem;

<span class="tok-kw">test</span> <span class="tok-str">&quot;cast *[1][*]const u8 to [*]const ?[*]const u8&quot;</span> {
    <span class="tok-kw">const</span> window_name = [<span class="tok-number">1</span>][*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{<span class="tok-str">&quot;window name&quot;</span>};
    <span class="tok-kw">const</span> x: [*]<span class="tok-kw">const</span> ?[*]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;window_name;
    expect(mem.eql(<span class="tok-type">u8</span>, std.mem.spanZ(<span class="tok-builtin">@ptrCast</span>([*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, x[<span class="tok-number">0</span>].?)), <span class="tok-str">&quot;window name&quot;</span>));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;cast *[1][*]const u8 to [*]const ?[*]const u8&quot;... 

All 1 tests passed.
</code></pre>

      
      <h3 id="Type-Coercion-Integer-and-Float-Widening"><a href="#toc-Type-Coercion-Integer-and-Float-Widening">Type Coercion: Integer and Float Widening</a> <a class="hdr" href="#Type-Coercion-Integer-and-Float-Widening">§</a></h3>

      <p>
      <a href="#Integers">Integers</a> coerce to integer types which can represent every value of the old type, and likewise
      <a href="#Floats">Floats</a> coerce to float types which can represent every value of the old type.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> mem = std.mem;

<span class="tok-kw">test</span> <span class="tok-str">&quot;integer widening&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u8</span> = <span class="tok-number">250</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u16</span> = a;
    <span class="tok-kw">var</span> c: <span class="tok-type">u32</span> = b;
    <span class="tok-kw">var</span> d: <span class="tok-type">u64</span> = c;
    <span class="tok-kw">var</span> e: <span class="tok-type">u64</span> = d;
    <span class="tok-kw">var</span> f: <span class="tok-type">u128</span> = e;
    expect(f == a);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;implicit unsigned integer to signed integer&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u8</span> = <span class="tok-number">250</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">i16</span> = a;
    expect(b == <span class="tok-number">250</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;float widening&quot;</span> {
    <span class="tok-comment">// Note: there is an open issue preventing this from working on aarch64:</span>
    <span class="tok-comment">// https://github.com/ziglang/zig/issues/3282</span>
    <span class="tok-kw">if</span> (std.Target.current.cpu.arch == .aarch64) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> a: <span class="tok-type">f16</span> = <span class="tok-number">12.34</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">f32</span> = a;
    <span class="tok-kw">var</span> c: <span class="tok-type">f64</span> = b;
    <span class="tok-kw">var</span> d: <span class="tok-type">f128</span> = c;
    expect(d == a);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/3] test &quot;integer widening&quot;... 
Test [2/3] test &quot;implicit unsigned integer to signed integer&quot;... 
Test [3/3] test &quot;float widening&quot;... 

All 3 tests passed.
</code></pre>

      
      <h3 id="Type-Coercion-Coercion-Float-to-Int"><a href="#toc-Type-Coercion-Coercion-Float-to-Int">Type Coercion: Coercion Float to Int</a> <a class="hdr" href="#Type-Coercion-Coercion-Float-to-Int">§</a></h3>

      <p>
      A compiler error is appropriate because this ambiguous expression leaves the compiler
      two choices about the coercion.
      </p>
      <ul>
        <li> Cast <code class="zig"><span class="tok-number">54.0</span></code> to <code class="zig"><span class="tok-type">comptime_int</span></code> resulting in <code class="zig"><span class="tok-builtin">@as</span>(<span class="tok-type">comptime_int</span>, <span class="tok-number">10</span>)</code>, which is casted to <code class="zig"><span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">10</span>)</code></li>
        <li> Cast <code class="zig"><span class="tok-number">5</span></code> to <code class="zig"><span class="tok-type">comptime_float</span></code> resulting in <code class="zig"><span class="tok-builtin">@as</span>(<span class="tok-type">comptime_float</span>, <span class="tok-number">10.8</span>)</code>, which is casted to <code class="zig"><span class="tok-builtin">@as</span>(<span class="tok-type">f32</span>, <span class="tok-number">10.8</span>)</code></li>
      </ul>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-comment">// Compile time coercion of float to int</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;implicit cast to comptime_int&quot;</span> {
    <span class="tok-kw">var</span> f: <span class="tok-type">f32</span> = <span class="tok-number">54.0</span> / <span class="tok-number">5</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:3:18: </span><span class="t31_1">error: </span><span class="t0_1">float value 54.000000 cannot be coerced to type 'comptime_int'</span>
    var f: f32 = 54.0 / 5;
                 <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:3:23: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
    var f: f32 = 54.0 / 5;
                      <span class="t32_1">^</span>
</code></pre>

      
      <h3 id="Type-Coercion-Arrays-and-Pointers"><a href="#toc-Type-Coercion-Arrays-and-Pointers">Type Coercion: Arrays and Pointers</a> <a class="hdr" href="#Type-Coercion-Arrays-and-Pointers">§</a></h3>

      <p class="file">coerce_arrays_and_ptrs.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-comment">// This cast exists primarily so that string literals can be</span>
<span class="tok-comment">// passed to functions that accept const slices. However</span>
<span class="tok-comment">// it is probably going to be removed from the language when</span>
<span class="tok-comment">// https://github.com/ziglang/zig/issues/265 is implemented.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;[N]T to []const T&quot;</span> {
    <span class="tok-kw">var</span> x1: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>;
    <span class="tok-kw">var</span> x2: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[<span class="tok-number">5</span>]<span class="tok-type">u8</span>{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-number">111</span> };
    expect(std.mem.eql(<span class="tok-type">u8</span>, x1, x2));

    <span class="tok-kw">var</span> y: []<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;[<span class="tok-number">2</span>]<span class="tok-type">f32</span>{ <span class="tok-number">1.2</span>, <span class="tok-number">3.4</span> };
    expect(y[<span class="tok-number">0</span>] == <span class="tok-number">1.2</span>);
}

<span class="tok-comment">// Likewise, it works when the destination type is an error union.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;[N]T to E![]const T&quot;</span> {
    <span class="tok-kw">var</span> x1: <span class="tok-type">anyerror</span>![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>;
    <span class="tok-kw">var</span> x2: <span class="tok-type">anyerror</span>![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[<span class="tok-number">5</span>]<span class="tok-type">u8</span>{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-number">111</span> };
    expect(std.mem.eql(<span class="tok-type">u8</span>, <span class="tok-kw">try</span> x1, <span class="tok-kw">try</span> x2));

    <span class="tok-kw">var</span> y: <span class="tok-type">anyerror</span>![]<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;[<span class="tok-number">2</span>]<span class="tok-type">f32</span>{ <span class="tok-number">1.2</span>, <span class="tok-number">3.4</span> };
    expect((<span class="tok-kw">try</span> y)[<span class="tok-number">0</span>] == <span class="tok-number">1.2</span>);
}

<span class="tok-comment">// Likewise, it works when the destination type is an optional.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;[N]T to ?[]const T&quot;</span> {
    <span class="tok-kw">var</span> x1: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>;
    <span class="tok-kw">var</span> x2: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;[<span class="tok-number">5</span>]<span class="tok-type">u8</span>{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-number">111</span> };
    expect(std.mem.eql(<span class="tok-type">u8</span>, x1.?, x2.?));

    <span class="tok-kw">var</span> y: ?[]<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;[<span class="tok-number">2</span>]<span class="tok-type">f32</span>{ <span class="tok-number">1.2</span>, <span class="tok-number">3.4</span> };
    expect(y.?[<span class="tok-number">0</span>] == <span class="tok-number">1.2</span>);
}

<span class="tok-comment">// In this cast, the array length becomes the slice length.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;*[N]T to []T&quot;</span> {
    <span class="tok-kw">var</span> buf: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>.*;
    <span class="tok-kw">const</span> x: []<span class="tok-type">u8</span> = &amp;buf;
    expect(std.mem.eql(<span class="tok-type">u8</span>, x, <span class="tok-str">&quot;hello&quot;</span>));

    <span class="tok-kw">const</span> buf2 = [<span class="tok-number">2</span>]<span class="tok-type">f32</span>{ <span class="tok-number">1.2</span>, <span class="tok-number">3.4</span> };
    <span class="tok-kw">const</span> x2: []<span class="tok-kw">const</span> <span class="tok-type">f32</span> = &amp;buf2;
    expect(std.mem.eql(<span class="tok-type">f32</span>, x2, &amp;[<span class="tok-number">2</span>]<span class="tok-type">f32</span>{ <span class="tok-number">1.2</span>, <span class="tok-number">3.4</span> }));
}

<span class="tok-comment">// Single-item pointers to arrays can be coerced to many-item pointers.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;*[N]T to [*]T&quot;</span> {
    <span class="tok-kw">var</span> buf: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>.*;
    <span class="tok-kw">const</span> x: [*]<span class="tok-type">u8</span> = &amp;buf;
    expect(x[<span class="tok-number">4</span>] == <span class="tok-str">'o'</span>);
    <span class="tok-comment">// x[5] would be an uncaught out of bounds pointer dereference!</span>
}

<span class="tok-comment">// Likewise, it works when the destination type is an optional.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;*[N]T to ?[*]T&quot;</span> {
    <span class="tok-kw">var</span> buf: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>.*;
    <span class="tok-kw">const</span> x: ?[*]<span class="tok-type">u8</span> = &amp;buf;
    expect(x.?[<span class="tok-number">4</span>] == <span class="tok-str">'o'</span>);
}

<span class="tok-comment">// Single-item pointers can be cast to len-1 single-item arrays.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;*T to *[1]T&quot;</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> y: *[<span class="tok-number">1</span>]<span class="tok-type">i32</span> = &amp;x;
    <span class="tok-kw">const</span> z: [*]<span class="tok-type">i32</span> = y;
    expect(z[<span class="tok-number">0</span>] == <span class="tok-number">1234</span>);
}</code></pre><pre><code class="shell">$ zig test coerce_arrays_and_ptrs.zig
Test [1/7] test &quot;[N]T to []const T&quot;... 
Test [2/7] test &quot;[N]T to E![]const T&quot;... 
Test [3/7] test &quot;[N]T to ?[]const T&quot;... 
Test [4/7] test &quot;*[N]T to []T&quot;... 
Test [5/7] test &quot;*[N]T to [*]T&quot;... 
Test [6/7] test &quot;*[N]T to ?[*]T&quot;... 
Test [7/7] test &quot;*T to *[1]T&quot;... 

All 7 tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#C-Pointers">C Pointers</a></li>
</ul>

      
      <h3 id="Type-Coercion-Optionals"><a href="#toc-Type-Coercion-Optionals">Type Coercion: Optionals</a> <a class="hdr" href="#Type-Coercion-Optionals">§</a></h3>

      <p>
      The payload type of <a href="#Optionals">Optionals</a>, as well as <a href="#null">null</a>, coerce to the optional type.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;coerce to optionals&quot;</span> {
    <span class="tok-kw">const</span> x: ?<span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> y: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    expect(x.? == <span class="tok-number">1234</span>);
    expect(y == <span class="tok-null">null</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;coerce to optionals&quot;... 

All 1 tests passed.
</code></pre>

      <p>It works nested inside the <a href="#Error-Union-Type">Error Union Type</a>, too:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;coerce to optionals wrapped in error union&quot;</span> {
    <span class="tok-kw">const</span> x: <span class="tok-type">anyerror</span>!?<span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> y: <span class="tok-type">anyerror</span>!?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    expect((<span class="tok-kw">try</span> x).? == <span class="tok-number">1234</span>);
    expect((<span class="tok-kw">try</span> y) == <span class="tok-null">null</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;coerce to optionals wrapped in error union&quot;... 

All 1 tests passed.
</code></pre>

      
      <h3 id="Type-Coercion-Error-Unions"><a href="#toc-Type-Coercion-Error-Unions">Type Coercion: Error Unions</a> <a class="hdr" href="#Type-Coercion-Error-Unions">§</a></h3>

      <p>The payload type of an <a href="#Error-Union-Type">Error Union Type</a> as well as the <a href="#Error-Set-Type">Error Set Type</a>
      coerce to the error union type:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;coercion to error unions&quot;</span> {
    <span class="tok-kw">const</span> x: <span class="tok-type">anyerror</span>!<span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> y: <span class="tok-type">anyerror</span>!<span class="tok-type">i32</span> = <span class="tok-kw">error</span>.Failure;

    expect((<span class="tok-kw">try</span> x) == <span class="tok-number">1234</span>);
    std.testing.expectError(<span class="tok-kw">error</span>.Failure, y);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;coercion to error unions&quot;... 

All 1 tests passed.
</code></pre>

      
      <h3 id="Type-Coercion-Compile-Time-Known-Numbers"><a href="#toc-Type-Coercion-Compile-Time-Known-Numbers">Type Coercion: Compile-Time Known Numbers</a> <a class="hdr" href="#Type-Coercion-Compile-Time-Known-Numbers">§</a></h3>

      <p>When a number is <a href="#comptime">comptime</a>-known to be representable in the destination type,
      it may be coerced:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;coercing large integer type to smaller one when value is comptime known to fit&quot;</span> {
    <span class="tok-kw">const</span> x: <span class="tok-type">u64</span> = <span class="tok-number">255</span>;
    <span class="tok-kw">const</span> y: <span class="tok-type">u8</span> = x;
    expect(y == <span class="tok-number">255</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;coercing large integer type to smaller one when value is comptime known ... 

All 1 tests passed.
</code></pre>

      
      <h3 id="Type-Coercion-unions-and-enums"><a href="#toc-Type-Coercion-unions-and-enums">Type Coercion: unions and enums</a> <a class="hdr" href="#Type-Coercion-unions-and-enums">§</a></h3>

      <p>Tagged unions can be coerced to enums, and enums can be coerced to tagged unions
      when they are <a href="#comptime">comptime</a>-known to be a field of the union that has only one possible value, such as
      <a href="#void">void</a>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> E = <span class="tok-kw">enum</span> {
    one,
    two,
    three,
};

<span class="tok-kw">const</span> U = <span class="tok-kw">union</span>(E) {
    one: <span class="tok-type">i32</span>,
    two: <span class="tok-type">f32</span>,
    three,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;coercion between unions and enums&quot;</span> {
    <span class="tok-kw">var</span> u = U{ .two = <span class="tok-number">12.34</span> };
    <span class="tok-kw">var</span> e: E = u;
    expect(e == E.two);

    <span class="tok-kw">const</span> three = E.three;
    <span class="tok-kw">var</span> another_u: U = three;
    expect(another_u == E.three);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;coercion between unions and enums&quot;... 

All 1 tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#union">union</a></li>
<li><a href="#enum">enum</a></li>
</ul>

      
      <h3 id="Type-Coercion-Zero-Bit-Types"><a href="#toc-Type-Coercion-Zero-Bit-Types">Type Coercion: Zero Bit Types</a> <a class="hdr" href="#Type-Coercion-Zero-Bit-Types">§</a></h3>

      <p><a href="#Zero-Bit-Types">Zero Bit Types</a> may be coerced to single-item <a href="#Pointers">Pointers</a>,
      regardless of const.</p>
      <p>TODO document the reasoning for this</p>
      <p>TODO document whether vice versa should work and why</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;coercion of zero bit types&quot;</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">void</span> = {};
    <span class="tok-kw">var</span> y: *<span class="tok-type">void</span> = x;
    <span class="tok-comment">//var z: void = y; // TODO</span>
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;coercion of zero bit types&quot;... 

All 1 tests passed.
</code></pre>

      
      <h3 id="Type-Coercion-undefined"><a href="#toc-Type-Coercion-undefined">Type Coercion: undefined</a> <a class="hdr" href="#Type-Coercion-undefined">§</a></h3>

      <p><a href="#undefined">undefined</a> can be cast to any type.</p>
      
      

      <h2 id="Explicit-Casts"><a href="#toc-Explicit-Casts">Explicit Casts</a> <a class="hdr" href="#Explicit-Casts">§</a></h2>

      <p>
      Explicit casts are performed via <a href="#Builtin-Functions">Builtin Functions</a>.
      Some explicit casts are safe; some are not.
      Some explicit casts perform language-level assertions; some do not.
      Some explicit casts are no-ops at runtime; some are not.
      </p>
      <ul>
          <li><a href="#bitCast">@bitCast</a> - change type but maintain bit representation</li>
          <li><a href="#alignCast">@alignCast</a> - make a pointer have more alignment</li>
          <li><a href="#boolToInt">@boolToInt</a> - convert true to 1 and false to 0</li>
          <li><a href="#enumToInt">@enumToInt</a> - obtain the integer tag value of an enum or tagged union</li>
          <li><a href="#errSetCast">@errSetCast</a> - convert to a smaller error set</li>
          <li><a href="#errorToInt">@errorToInt</a> - obtain the integer value of an error code</li>
          <li><a href="#floatCast">@floatCast</a> - convert a larger float to a smaller float</li>
          <li><a href="#floatToInt">@floatToInt</a> - obtain the integer part of a float value</li>
          <li><a href="#intCast">@intCast</a> - convert between integer types</li>
          <li><a href="#intToEnum">@intToEnum</a> - obtain an enum value based on its integer tag value</li>
          <li><a href="#intToError">@intToError</a> - obtain an error code based on its integer value</li>
          <li><a href="#intToFloat">@intToFloat</a> - convert an integer to a float value</li>
          <li><a href="#intToPtr">@intToPtr</a> - convert an address to a pointer</li>
          <li><a href="#ptrCast">@ptrCast</a> - convert between pointer types</li>
          <li><a href="#ptrToInt">@ptrToInt</a> - obtain the address of a pointer</li>
          <li><a href="#truncate">@truncate</a> - convert between integer types, chopping off bits</li>
      </ul>
      

      <h2 id="Peer-Type-Resolution"><a href="#toc-Peer-Type-Resolution">Peer Type Resolution</a> <a class="hdr" href="#Peer-Type-Resolution">§</a></h2>

      <p>Peer Type Resolution occurs in these places:</p>
      <ul>
        <li><a href="#switch">switch</a> expressions</li>
        <li><a href="#if">if</a> expressions</li>
        <li><a href="#while">while</a> expressions</li>
        <li><a href="#for">for</a> expressions</li>
        <li>Multiple break statements in a block</li>
        <li>Some <a href="#Table-of-Operators">binary operations</a></li>
      </ul>
      <p>
      This kind of type resolution chooses a type that all peer types can coerce into. Here are
      some examples:
      </p>
      <p class="file">peer_type_resolution.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> mem = std.mem;

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer resolve int widening&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">i8</span> = <span class="tok-number">12</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">i16</span> = <span class="tok-number">34</span>;
    <span class="tok-kw">var</span> c = a + b;
    expect(c == <span class="tok-number">46</span>);
    expect(<span class="tok-builtin">@TypeOf</span>(c) == <span class="tok-type">i16</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer resolve arrays of different size to const slice&quot;</span> {
    expect(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">true</span>), <span class="tok-str">&quot;true&quot;</span>));
    expect(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">false</span>), <span class="tok-str">&quot;false&quot;</span>));
    <span class="tok-kw">comptime</span> expect(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">true</span>), <span class="tok-str">&quot;true&quot;</span>));
    <span class="tok-kw">comptime</span> expect(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">false</span>), <span class="tok-str">&quot;false&quot;</span>));
}
<span class="tok-kw">fn</span> <span class="tok-fn">boolToStr</span>(b: <span class="tok-type">bool</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (b) <span class="tok-str">&quot;true&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;false&quot;</span>;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer resolve array and const slice&quot;</span> {
    testPeerResolveArrayConstSlice(<span class="tok-null">true</span>);
    <span class="tok-kw">comptime</span> testPeerResolveArrayConstSlice(<span class="tok-null">true</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">testPeerResolveArrayConstSlice</span>(b: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> value1 = <span class="tok-kw">if</span> (b) <span class="tok-str">&quot;aoeu&quot;</span> <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">&quot;zz&quot;</span>);
    <span class="tok-kw">const</span> value2 = <span class="tok-kw">if</span> (b) <span class="tok-builtin">@as</span>([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-str">&quot;zz&quot;</span>) <span class="tok-kw">else</span> <span class="tok-str">&quot;aoeu&quot;</span>;
    expect(mem.eql(<span class="tok-type">u8</span>, value1, <span class="tok-str">&quot;aoeu&quot;</span>));
    expect(mem.eql(<span class="tok-type">u8</span>, value2, <span class="tok-str">&quot;zz&quot;</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer type resolution: ?T and T&quot;</span> {
    expect(peerTypeTAndOptionalT(<span class="tok-null">true</span>, <span class="tok-null">false</span>).? == <span class="tok-number">0</span>);
    expect(peerTypeTAndOptionalT(<span class="tok-null">false</span>, <span class="tok-null">false</span>).? == <span class="tok-number">3</span>);
    <span class="tok-kw">comptime</span> {
        expect(peerTypeTAndOptionalT(<span class="tok-null">true</span>, <span class="tok-null">false</span>).? == <span class="tok-number">0</span>);
        expect(peerTypeTAndOptionalT(<span class="tok-null">false</span>, <span class="tok-null">false</span>).? == <span class="tok-number">3</span>);
    }
}
<span class="tok-kw">fn</span> <span class="tok-fn">peerTypeTAndOptionalT</span>(c: <span class="tok-type">bool</span>, b: <span class="tok-type">bool</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (c) {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (b) <span class="tok-null">null</span> <span class="tok-kw">else</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">0</span>);
    }

    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">3</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer type resolution: *[0]u8 and []const u8&quot;</span> {
    expect(peerTypeEmptyArrayAndSlice(<span class="tok-null">true</span>, <span class="tok-str">&quot;hi&quot;</span>).len == <span class="tok-number">0</span>);
    expect(peerTypeEmptyArrayAndSlice(<span class="tok-null">false</span>, <span class="tok-str">&quot;hi&quot;</span>).len == <span class="tok-number">1</span>);
    <span class="tok-kw">comptime</span> {
        expect(peerTypeEmptyArrayAndSlice(<span class="tok-null">true</span>, <span class="tok-str">&quot;hi&quot;</span>).len == <span class="tok-number">0</span>);
        expect(peerTypeEmptyArrayAndSlice(<span class="tok-null">false</span>, <span class="tok-str">&quot;hi&quot;</span>).len == <span class="tok-number">1</span>);
    }
}
<span class="tok-kw">fn</span> <span class="tok-fn">peerTypeEmptyArrayAndSlice</span>(a: <span class="tok-type">bool</span>, slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (a) {
        <span class="tok-kw">return</span> &amp;[_]<span class="tok-type">u8</span>{};
    }

    <span class="tok-kw">return</span> slice[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;peer type resolution: *[0]u8, []const u8, and anyerror![]u8&quot;</span> {
    {
        <span class="tok-kw">var</span> data = <span class="tok-str">&quot;hi&quot;</span>.*;
        <span class="tok-kw">const</span> slice = data[<span class="tok-number">0</span>..];
        expect((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">true</span>, slice)).len == <span class="tok-number">0</span>);
        expect((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">false</span>, slice)).len == <span class="tok-number">1</span>);
    }
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> data = <span class="tok-str">&quot;hi&quot;</span>.*;
        <span class="tok-kw">const</span> slice = data[<span class="tok-number">0</span>..];
        expect((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">true</span>, slice)).len == <span class="tok-number">0</span>);
        expect((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">false</span>, slice)).len == <span class="tok-number">1</span>);
    }
}
<span class="tok-kw">fn</span> <span class="tok-fn">peerTypeEmptyArrayAndSliceAndError</span>(a: <span class="tok-type">bool</span>, slice: []<span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (a) {
        <span class="tok-kw">return</span> &amp;[_]<span class="tok-type">u8</span>{};
    }

    <span class="tok-kw">return</span> slice[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer type resolution: *const T and ?*T&quot;</span> {
    <span class="tok-kw">const</span> a = <span class="tok-builtin">@intToPtr</span>(*<span class="tok-kw">const</span> <span class="tok-type">usize</span>, <span class="tok-number">0x123456780</span>);
    <span class="tok-kw">const</span> b = <span class="tok-builtin">@intToPtr</span>(?*<span class="tok-type">usize</span>, <span class="tok-number">0x123456780</span>);
    expect(a == b);
    expect(b == a);
}</code></pre><pre><code class="shell">$ zig test peer_type_resolution.zig
Test [1/7] test &quot;peer resolve int widening&quot;... 
Test [2/7] test &quot;peer resolve arrays of different size to const slice&quot;... 
Test [3/7] test &quot;peer resolve array and const slice&quot;... 
Test [4/7] test &quot;peer type resolution: ?T and T&quot;... 
Test [5/7] test &quot;peer type resolution: *[0]u8 and []const u8&quot;... 
Test [6/7] test &quot;peer type resolution: *[0]u8, []const u8, and anyerror![]u8&quot;... 
Test [7/7] test &quot;peer type resolution: *const T and ?*T&quot;... 

All 7 tests passed.
</code></pre>

      
      

      <h1 id="Zero-Bit-Types"><a href="#toc-Zero-Bit-Types">Zero Bit Types</a> <a class="hdr" href="#Zero-Bit-Types">§</a></h1>

      <p>For some types, <a href="#sizeOf">@sizeOf</a> is 0:</p>
      <ul>
          <li><a href="#void">void</a></li>
          <li>The <a href="#Integers">Integers</a> <code class="zig"><span class="tok-type">u0</span></code> and <code class="zig"><span class="tok-type">i0</span></code>.</li>
          <li><a href="#Arrays">Arrays</a> and <a href="#Vectors">Vectors</a> with len 0, or with an element type that is a zero bit type.</li>
          <li>An <a href="#enum">enum</a> with only 1 tag.</li>
          <li>A <a href="#struct">struct</a> with all fields being zero bit types.</li>
          <li>A <a href="#union">union</a> with only 1 field which is a zero bit type.</li>
          <li><a href="#Pointers-to-Zero-Bit-Types">Pointers to Zero Bit Types</a> are themselves zero bit types.</li>
      </ul>
      <p>
      These types can only ever have one possible value, and thus
      require 0 bits to represent. Code that makes use of these types is
      not included in the final generated code:
      </p>
      <pre><code class="zig"><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">entry</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">void</span> = {};
    <span class="tok-kw">var</span> y: <span class="tok-type">void</span> = {};
    x = y;
}</code></pre>
      <p>When this turns into machine code, there is no code generated in the
      body of <code class="zig">entry</code>, even in <a href="#Debug">Debug</a> mode. For example, on x86_64:</p>
      <pre><code>0000000000000010 &lt;entry&gt;:
  10:	55                   	push   %rbp
  11:	48 89 e5             	mov    %rsp,%rbp
  14:	5d                   	pop    %rbp
  15:	c3                   	retq   </code></pre>
      <p>These assembly instructions do not have any code associated with the void values -
      they only perform the function call prologue and epilog.</p>

      <h2 id="void"><a href="#toc-void">void</a> <a class="hdr" href="#void">§</a></h2>

      <p>
      <code class="zig"><span class="tok-type">void</span></code> can be useful for instantiating generic types. For example, given a
          <code class="zig">Map(Key, Value)</code>, one can pass <code class="zig"><span class="tok-type">void</span></code> for the <code class="zig">Value</code>
                      type to make it into a <code class="zig">Set</code>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;turn HashMap into a set with void&quot;</span> {
    <span class="tok-kw">var</span> map = std.AutoHashMap(<span class="tok-type">i32</span>, <span class="tok-type">void</span>).init(std.testing.allocator);
    <span class="tok-kw">defer</span> map.deinit();

    <span class="tok-kw">try</span> map.put(<span class="tok-number">1</span>, {});
    <span class="tok-kw">try</span> map.put(<span class="tok-number">2</span>, {});

    expect(map.contains(<span class="tok-number">2</span>));
    expect(!map.contains(<span class="tok-number">3</span>));

    _ = map.remove(<span class="tok-number">2</span>);
    expect(!map.contains(<span class="tok-number">2</span>));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;turn HashMap into a set with void&quot;... 

All 1 tests passed.
</code></pre>

      <p>Note that this is different from using a dummy value for the hash map value.
      By using <code class="zig"><span class="tok-type">void</span></code> as the type of the value, the hash map entry type has no value field, and
      thus the hash map takes up less space. Further, all the code that deals with storing and loading the
      value is deleted, as seen above.
      </p>
      <p>
      <code class="zig"><span class="tok-type">void</span></code> is distinct from <code class="zig"><span class="tok-type">c_void</span></code>, which is defined like this:
              <code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> <span class="tok-type">c_void</span> = <span class="tok-kw">opaque</span> {};</code>.
                  <code class="zig"><span class="tok-type">void</span></code> has a known size of 0 bytes, and <code class="zig"><span class="tok-type">c_void</span></code> has an unknown, but non-zero, size.
      </p>
      <p>
      Expressions of type <code class="zig"><span class="tok-type">void</span></code> are the only ones whose value can be ignored. For example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;ignoring expression value&quot;</span> {
    foo();
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:2:8: </span><span class="t31_1">error: </span><span class="t0_1">expression value is ignored</span>
    foo();
       <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:1:34: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
test &quot;ignoring expression value&quot; {
                                 <span class="t32_1">^</span>
</code></pre>

      <p>However, if the expression has type <code class="zig"><span class="tok-type">void</span></code>, there will be no error. Function return values can also be explicitly ignored by assigning them to <code class="zig">_</code>. </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;void is ignored&quot;</span> {
    returnsVoid();
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;explicitly ignoring expression value&quot;</span> {
    _ = foo();
}

<span class="tok-kw">fn</span> <span class="tok-fn">returnsVoid</span>() <span class="tok-type">void</span> {}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/2] test &quot;void is ignored&quot;... 
Test [2/2] test &quot;explicitly ignoring expression value&quot;... 

All 2 tests passed.
</code></pre>

      

      <h2 id="Pointers-to-Zero-Bit-Types"><a href="#toc-Pointers-to-Zero-Bit-Types">Pointers to Zero Bit Types</a> <a class="hdr" href="#Pointers-to-Zero-Bit-Types">§</a></h2>

      <p>Pointers to zero bit types also have zero bits. They always compare equal to each other:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer to empty struct&quot;</span> {
    <span class="tok-kw">const</span> Empty = <span class="tok-kw">struct</span> {};
    <span class="tok-kw">var</span> a = Empty{};
    <span class="tok-kw">var</span> b = Empty{};
    <span class="tok-kw">var</span> ptr_a = &amp;a;
    <span class="tok-kw">var</span> ptr_b = &amp;b;
    <span class="tok-kw">comptime</span> expect(ptr_a == ptr_b);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;pointer to empty struct&quot;... 

All 1 tests passed.
</code></pre>

      <p>The type being pointed to can only ever be one value; therefore loads and stores are
      never generated. <a href="#ptrToInt">ptrToInt</a> and <a href="#intToPtr">intToPtr</a> are not allowed:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Empty = <span class="tok-kw">struct</span> {};

<span class="tok-kw">test</span> <span class="tok-str">&quot;@ptrToInt for pointer to zero bit type&quot;</span> {
    <span class="tok-kw">var</span> a = Empty{};
    _ = <span class="tok-builtin">@ptrToInt</span>(&amp;a);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;@intToPtr for pointer to zero bit type&quot;</span> {
    _ = <span class="tok-builtin">@intToPtr</span>(*Empty, <span class="tok-number">0x1</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:4:5: </span><span class="t31_1">error: </span><span class="t0_1">pointer to size 0 type has no address</span>
    var a = Empty{};
    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:9: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
    _ = @ptrToInt(&amp;a);
        <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:9:19: </span><span class="t31_1">error: </span><span class="t0_1">type '*Empty' has 0 bits and cannot store information</span>
    _ = @intToPtr(*Empty, 0x1);
                  <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:9:9: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
    _ = @intToPtr(*Empty, 0x1);
        <span class="t32_1">^</span>
</code></pre>

      
      

      <h1 id="Result-Location-Semantics"><a href="#toc-Result-Location-Semantics">Result Location Semantics</a> <a class="hdr" href="#Result-Location-Semantics">§</a></h1>

      <p>
      <a href="https://github.com/ziglang/zig/issues/2809">TODO add documentation for this</a>
      </p>
      

      <h1 id="usingnamespace"><a href="#toc-usingnamespace">usingnamespace</a> <a class="hdr" href="#usingnamespace">§</a></h1>

      <p>
      <code class="zig"><span class="tok-kw">usingnamespace</span></code> is a top level declaration that imports all the public declarations of
      the operand, which must be a <a href="#struct">struct</a>, <a href="#union">union</a>, or <a href="#enum">enum</a>, into the current scope:
      </p>
      <p class="file">usingnamespace.zig</p><pre><code class="zig"><span class="tok-kw">usingnamespace</span> <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;using std namespace&quot;</span> {
    testing.expect(<span class="tok-null">true</span>);
}</code></pre><pre><code class="shell">$ zig test usingnamespace.zig
Test [1/1] test &quot;using std namespace&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      Instead of the above pattern, it is generally recommended to explicitly alias individual declarations.
      However, <code class="zig"><span class="tok-kw">usingnamespace</span></code> has an important use case when organizing the public
      API of a file or package. For example, one might have <code>c.zig</code> with all of the
      <a href="#Import-from-C-Header-File">C imports</a>:
      </p>
      <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">usingnamespace</span> <span class="tok-builtin">@cImport</span>({
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;epoxy/gl.h&quot;</span>);
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;GLFW/glfw3.h&quot;</span>);
    <span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;STBI_ONLY_PNG&quot;</span>, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;STBI_NO_STDIO&quot;</span>, <span class="tok-str">&quot;&quot;</span>);
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;stb_image.h&quot;</span>);
});</code></pre>
      <p>
      The above example demonstrates using <code class="zig"><span class="tok-kw">pub</span></code> to qualify the
      <code class="zig"><span class="tok-kw">usingnamespace</span></code> additionally makes the imported declarations
      <code class="zig"><span class="tok-kw">pub</span></code>. This can be used to forward declarations, giving precise control
      over what declarations a given file exposes.
      </p>
      

      <h1 id="comptime"><a href="#toc-comptime">comptime</a> <a class="hdr" href="#comptime">§</a></h1>

      <p>
      Zig places importance on the concept of whether an expression is known at compile-time.
      There are a few different places this concept is used, and these building blocks are used
      to keep the language small, readable, and powerful.
      </p>
      <h2 id="Introducing-the-Compile-Time-Concept"><a href="#toc-Introducing-the-Compile-Time-Concept">Introducing the Compile-Time Concept</a> <a class="hdr" href="#Introducing-the-Compile-Time-Concept">§</a></h2>

      <h3 id="Compile-Time-Parameters"><a href="#toc-Compile-Time-Parameters">Compile-Time Parameters</a> <a class="hdr" href="#Compile-Time-Parameters">§</a></h3>

      <p>
      Compile-time parameters is how Zig implements generics. It is compile-time duck typing.
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a &gt; b) a <span class="tok-kw">else</span> b;
}
<span class="tok-kw">fn</span> <span class="tok-fn">gimmeTheBiggerFloat</span>(a: <span class="tok-type">f32</span>, b: <span class="tok-type">f32</span>) <span class="tok-type">f32</span> {
    <span class="tok-kw">return</span> max(<span class="tok-type">f32</span>, a, b);
}
<span class="tok-kw">fn</span> <span class="tok-fn">gimmeTheBiggerInteger</span>(a: <span class="tok-type">u64</span>, b: <span class="tok-type">u64</span>) <span class="tok-type">u64</span> {
    <span class="tok-kw">return</span> max(<span class="tok-type">u64</span>, a, b);
}</code></pre>
      <p>
      In Zig, types are first-class citizens. They can be assigned to variables, passed as parameters to functions,
      and returned from functions. However, they can only be used in expressions which are known at <em>compile-time</em>,
      which is why the parameter <code class="zig">T</code> in the above snippet must be marked with <code class="zig"><span class="tok-kw">comptime</span></code>.
      </p>
      <p>
      A <code class="zig"><span class="tok-kw">comptime</span></code> parameter means that:
      </p>
      <ul>
        <li>At the callsite, the value must be known at compile-time, or it is a compile error.</li>
        <li>In the function definition, the value is known at compile-time.</li>
      </ul>
      <p>
      For example, if we were to introduce another function to the above snippet:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a &gt; b) a <span class="tok-kw">else</span> b;
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;try to pass a runtime type&quot;</span> {
    foo(<span class="tok-null">false</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(condition: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = max(
        <span class="tok-kw">if</span> (condition) <span class="tok-type">f32</span> <span class="tok-kw">else</span> <span class="tok-type">u64</span>,
        <span class="tok-number">1234</span>,
        <span class="tok-number">5678</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:9:9: </span><span class="t31_1">error: </span><span class="t0_1">values of type 'type' must be comptime known</span>
        if (condition) f32 else u64,
        <span class="t32_1">^</span>
</code></pre>

      <p>
      This is an error because the programmer attempted to pass a value only known at run-time
      to a function which expects a value known at compile-time.
      </p>
      <p>
      Another way to get an error is if we pass a type that violates the type checker when the
      function is analyzed. This is what it means to have <em>compile-time duck typing</em>.
      </p>
      <p>
      For example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a &gt; b) a <span class="tok-kw">else</span> b;
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;try to compare bools&quot;</span> {
    _ = max(<span class="tok-type">bool</span>, <span class="tok-null">true</span>, <span class="tok-null">false</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:2:18: </span><span class="t31_1">error: </span><span class="t0_1">operator not allowed for type 'bool'</span>
    return if (a &gt; b) a else b;
                 <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:12: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    _ = max(bool, true, false);
           <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:4:29: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
test &quot;try to compare bools&quot; {
                            <span class="t32_1">^</span>
</code></pre>

      <p>
      On the flip side, inside the function definition with the <code class="zig"><span class="tok-kw">comptime</span></code> parameter, the
      value is known at compile-time. This means that we actually could make this work for the bool type
      if we wanted to:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">if</span> (T == <span class="tok-type">bool</span>) {
        <span class="tok-kw">return</span> a <span class="tok-kw">or</span> b;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a &gt; b) {
        <span class="tok-kw">return</span> a;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> b;
    }
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;try to compare bools&quot;</span> {
    <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect(max(<span class="tok-type">bool</span>, <span class="tok-null">false</span>, <span class="tok-null">true</span>) == <span class="tok-null">true</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;try to compare bools&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      This works because Zig implicitly inlines <code class="zig"><span class="tok-kw">if</span></code> expressions when the condition
      is known at compile-time, and the compiler guarantees that it will skip analysis of
      the branch not taken.
      </p>
      <p>
      This means that the actual function generated for <code class="zig">max</code> in this situation looks like
      this:
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(a: <span class="tok-type">bool</span>, b: <span class="tok-type">bool</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> a <span class="tok-kw">or</span> b;
}</code></pre>
      <p>
      All the code that dealt with compile-time known values is eliminated and we are left with only
      the necessary run-time code to accomplish the task.
      </p>
      <p>
      This works the same way for <code class="zig"><span class="tok-kw">switch</span></code> expressions - they are implicitly inlined
      when the target expression is compile-time known.
      </p>
      
      <h3 id="Compile-Time-Variables"><a href="#toc-Compile-Time-Variables">Compile-Time Variables</a> <a class="hdr" href="#Compile-Time-Variables">§</a></h3>

      <p>
      In Zig, the programmer can label variables as <code class="zig"><span class="tok-kw">comptime</span></code>. This guarantees to the compiler
      that every load and store of the variable is performed at compile-time. Any violation of this results in a
      compile error.
      </p>
      <p>
      This combined with the fact that we can <code class="zig"><span class="tok-kw">inline</span></code> loops allows us to write
      a function which is partially evaluated at compile-time and partially at run-time.
      </p>
      <p>
      For example:
      </p>
      <p class="file">comptime_vars.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">const</span> CmdFn = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    func: <span class="tok-kw">fn</span>(<span class="tok-type">i32</span>) <span class="tok-type">i32</span>,
};

<span class="tok-kw">const</span> cmd_fns = [_]CmdFn{
    CmdFn {.name = <span class="tok-str">&quot;one&quot;</span>, .func = one},
    CmdFn {.name = <span class="tok-str">&quot;two&quot;</span>, .func = two},
    CmdFn {.name = <span class="tok-str">&quot;three&quot;</span>, .func = three},
};
<span class="tok-kw">fn</span> <span class="tok-fn">one</span>(value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> { <span class="tok-kw">return</span> value + <span class="tok-number">1</span>; }
<span class="tok-kw">fn</span> <span class="tok-fn">two</span>(value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> { <span class="tok-kw">return</span> value + <span class="tok-number">2</span>; }
<span class="tok-kw">fn</span> <span class="tok-fn">three</span>(value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> { <span class="tok-kw">return</span> value + <span class="tok-number">3</span>; }

<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(<span class="tok-kw">comptime</span> prefix_char: <span class="tok-type">u8</span>, start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; cmd_fns.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (cmd_fns[i].name[<span class="tok-number">0</span>] == prefix_char) {
            result = cmd_fns[i].func(result);
        }
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;perform fn&quot;</span> {
    expect(performFn(<span class="tok-str">'t'</span>, <span class="tok-number">1</span>) == <span class="tok-number">6</span>);
    expect(performFn(<span class="tok-str">'o'</span>, <span class="tok-number">0</span>) == <span class="tok-number">1</span>);
    expect(performFn(<span class="tok-str">'w'</span>, <span class="tok-number">99</span>) == <span class="tok-number">99</span>);
}</code></pre><pre><code class="shell">$ zig test comptime_vars.zig
Test [1/1] test &quot;perform fn&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      This example is a bit contrived, because the compile-time evaluation component is unnecessary;
      this code would work fine if it was all done at run-time. But it does end up generating
      different code. In this example, the function <code class="zig">performFn</code> is generated three different times,
          for the different values of <code class="zig">prefix_char</code> provided:
      </p>
      <pre><code class="zig"><span class="tok-comment">// From the line:</span>
<span class="tok-comment">// expect(performFn('t', 1) == 6);</span>
<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    result = two(result);
    result = three(result);
    <span class="tok-kw">return</span> result;
}</code></pre>
      <pre><code class="zig"><span class="tok-comment">// From the line:</span>
<span class="tok-comment">// expect(performFn('o', 0) == 1);</span>
<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    result = one(result);
    <span class="tok-kw">return</span> result;
}</code></pre>
      <pre><code class="zig"><span class="tok-comment">// From the line:</span>
<span class="tok-comment">// expect(performFn('w', 99) == 99);</span>
<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    <span class="tok-kw">return</span> result;
}</code></pre>
      <p>
      Note that this happens even in a debug build; in a release build these generated functions still
      pass through rigorous LLVM optimizations. The important thing to note, however, is not that this
      is a way to write more optimized code, but that it is a way to make sure that what <em>should</em> happen
      at compile-time, <em>does</em> happen at compile-time. This catches more errors and as demonstrated
      later in this article, allows expressiveness that in other languages requires using macros,
      generated code, or a preprocessor to accomplish.
      </p>
      
      <h3 id="Compile-Time-Expressions"><a href="#toc-Compile-Time-Expressions">Compile-Time Expressions</a> <a class="hdr" href="#Compile-Time-Expressions">§</a></h3>

      <p>
      In Zig, it matters whether a given expression is known at compile-time or run-time. A programmer can
      use a <code class="zig"><span class="tok-kw">comptime</span></code> expression to guarantee that the expression will be evaluated at compile-time.
      If this cannot be accomplished, the compiler will emit an error. For example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">exit</span>() <span class="tok-type">noreturn</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;foo&quot;</span> {
    <span class="tok-kw">comptime</span> {
        exit();
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:5:9: </span><span class="t31_1">error: </span><span class="t0_1">unable to evaluate constant expression</span>
        exit();
        <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:13: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
        exit();
            <span class="t32_1">^</span>
</code></pre>

      <p>
      It doesn't make sense that a program could call <code class="zig">exit()</code> (or any other external function)
          at compile-time, so this is a compile error. However, a <code class="zig"><span class="tok-kw">comptime</span></code> expression does much
      more than sometimes cause a compile error.
      </p>
      <p>
      Within a <code class="zig"><span class="tok-kw">comptime</span></code> expression:
      </p>
      <ul>
          <li>All variables are <code class="zig"><span class="tok-kw">comptime</span></code> variables.</li>
          <li>All <code class="zig"><span class="tok-kw">if</span></code>, <code class="zig"><span class="tok-kw">while</span></code>, <code class="zig"><span class="tok-kw">for</span></code>, and <code class="zig"><span class="tok-kw">switch</span></code>
          expressions are evaluated at compile-time, or emit a compile error if this is not possible.</li>
        <li>All function calls cause the compiler to interpret the function at compile-time, emitting a
          compile error if the function tries to do something that has global run-time side effects.</li>
      </ul>
      <p>
      This means that a programmer can create a function which is called both at compile-time and run-time, with
      no modification to the function required.
      </p>
      <p>
      Let's look at an example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">u32</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">if</span> (index &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> index;
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;fibonacci&quot;</span> {
    <span class="tok-comment">// test fibonacci at run-time</span>
    expect(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);

    <span class="tok-comment">// test fibonacci at compile-time</span>
    <span class="tok-kw">comptime</span> {
        expect(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;fibonacci&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      Imagine if we had forgotten the base case of the recursive function and tried to run the tests:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">u32</span>) <span class="tok-type">u32</span> {
    <span class="tok-comment">//if (index &lt; 2) return index;</span>
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;fibonacci&quot;</span> {
    <span class="tok-kw">comptime</span> {
        expect(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:5:28: </span><span class="t31_1">error: </span><span class="t0_1">operation caused overflow</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                           <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:10:25: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
        expect(fibonacci(7) == 13);
                        <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:8:18: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
test &quot;fibonacci&quot; {
                 <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:10:25: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
        expect(fibonacci(7) == 13);
                        <span class="t32_1">^</span>
</code></pre>

      <p>
      The compiler produces an error which is a stack trace from trying to evaluate the
      function at compile-time.
      </p>
      <p>
      Luckily, we used an unsigned integer, and so when we tried to subtract 1 from 0, it triggered
      undefined behavior, which is always a compile error if the compiler knows it happened.
      But what would have happened if we used a signed integer?
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-comment">//if (index &lt; 2) return index;</span>
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;fibonacci&quot;</span> {
    <span class="tok-kw">comptime</span> {
        expect(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t31_1">error: </span><span class="t0_1">evaluation exceeded 1000 backwards branches</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:21: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:10:25: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
        expect(fibonacci(7) == 13);
                        <span class="t32_1">^</span>
</code></pre>

      <p>
      The compiler noticed that evaluating this function at compile-time took a long time,
      and thus emitted a compile error and gave up. If the programmer wants to increase
      the budget for compile-time computation, they can use a built-in function called
      <a href="#setEvalBranchQuota">@setEvalBranchQuota</a> to change the default number 1000 to something else.
      </p>
      <p>
      What if we fix the base case, but put the wrong value in the <code class="zig">expect</code> line?
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">if</span> (index &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> index;
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;fibonacci&quot;</span> {
    <span class="tok-kw">comptime</span> {
        expect(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">99999</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./build/release/lib/zig/std/testing.zig:292:14: </span><span class="t31_1">error: </span><span class="t0_1">encountered @panic at compile-time</span>
    if (!ok) @panic(&quot;test failure&quot;);
             <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:10:15: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
        expect(fibonacci(7) == 99999);
              <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:8:18: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
test &quot;fibonacci&quot; {
                 <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:10:15: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
        expect(fibonacci(7) == 99999);
              <span class="t32_1">^</span>
</code></pre>

      <p>
      What happened is Zig started interpreting the <code class="zig">expect</code> function with the
          parameter <code class="zig">ok</code> set to <code class="zig"><span class="tok-null">false</span></code>. When the interpreter hit
                  <code class="zig"><span class="tok-builtin">@panic</span></code> it emitted a compile error because a panic during compile
      causes a compile error if it is detected at compile-time.
      </p>

      <p>
      In the global scope (outside of any function), all expressions are implicitly
      <code class="zig"><span class="tok-kw">comptime</span></code> expressions. This means that we can use functions to
      initialize complex static data. For example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> first_25_primes = firstNPrimes(<span class="tok-number">25</span>);
<span class="tok-kw">const</span> sum_of_first_25_primes = sum(&amp;first_25_primes);

<span class="tok-kw">fn</span> <span class="tok-fn">firstNPrimes</span>(<span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) [n]<span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> prime_list: [n]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> next_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> test_number: <span class="tok-type">i32</span> = <span class="tok-number">2</span>;
    <span class="tok-kw">while</span> (next_index &lt; prime_list.len) : (test_number += <span class="tok-number">1</span>) {
        <span class="tok-kw">var</span> test_prime_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> is_prime = <span class="tok-null">true</span>;
        <span class="tok-kw">while</span> (test_prime_index &lt; next_index) : (test_prime_index += <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (test_number % prime_list[test_prime_index] == <span class="tok-number">0</span>) {
                is_prime = <span class="tok-null">false</span>;
                <span class="tok-kw">break</span>;
            }
        }
        <span class="tok-kw">if</span> (is_prime) {
            prime_list[next_index] = test_number;
            next_index += <span class="tok-number">1</span>;
        }
    }
    <span class="tok-kw">return</span> prime_list;
}

<span class="tok-kw">fn</span> <span class="tok-fn">sum</span>(numbers: []<span class="tok-kw">const</span> <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (numbers) |x| {
        result += x;
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;variable values&quot;</span> {
    <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect(sum_of_first_25_primes == <span class="tok-number">1060</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;variable values&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      When we compile this program, Zig generates the constants
      with the answer pre-computed. Here are the lines from the generated LLVM IR:
      </p>
      <pre><code class="llvm">@0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97]
@1 = internal unnamed_addr constant i32 1060</code></pre>
      <p>
      Note that we did not have to do anything special with the syntax of these functions. For example,
      we could call the <code class="zig">sum</code> function as is with a slice of numbers whose length and values were
      only known at run-time.
      </p>
      
      
      <h2 id="Generic-Data-Structures"><a href="#toc-Generic-Data-Structures">Generic Data Structures</a> <a class="hdr" href="#Generic-Data-Structures">§</a></h2>

      <p>
      Zig uses these capabilities to implement generic data structures without introducing any
      special-case syntax. If you followed along so far, you may already know how to create a
      generic data structure.
      </p>
      <p>
      Here is an example of a generic <code class="zig">List</code> data structure, that we will instantiate with
          the type <code class="zig"><span class="tok-type">i32</span></code>. In Zig we refer to the type as <code class="zig">List(<span class="tok-type">i32</span>)</code>.
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">List</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        items: []T,
        len: <span class="tok-type">usize</span>,
    };
}</code></pre>
      <p>
      That's it. It's a function that returns an anonymous <code class="zig"><span class="tok-kw">struct</span></code>. For the purposes of error messages
          and debugging, Zig infers the name <code class="zig"><span class="tok-str">&quot;List(i32)&quot;</span></code> from the function name and parameters invoked when creating
      the anonymous struct.
      </p>
      <p>
      To keep the language small and uniform, all aggregate types in Zig are anonymous. To give a type
      a name, we assign it to a constant:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
    next: *Node,
    name: []<span class="tok-type">u8</span>,
};</code></pre>
      <p>
      This works because all top level declarations are order-independent, and as long as there isn't
      an actual infinite regression, values can refer to themselves, directly or indirectly. In this case,
      <code class="zig">Node</code> refers to itself as a pointer, which is not actually an infinite regression, so
      it works fine.
      </p>
      
      <h2 id="Case-Study-printf-in-Zig"><a href="#toc-Case-Study-printf-in-Zig">Case Study: printf in Zig</a> <a class="hdr" href="#Case-Study-printf-in-Zig">§</a></h2>

      <p>
      Putting all of this together, let's see how <code class="zig">printf</code> works in Zig.
      </p>
      <p class="file">printf.zig</p><pre><code class="zig"><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">const</span> a_number: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> a_string = <span class="tok-str">&quot;foobar&quot;</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    print(<span class="tok-str">&quot;here is a string: '{s}' here is a number: {}\n&quot;</span>, .{a_string, a_number});
}</code></pre><pre><code class="shell">$ zig build-exe printf.zig
$ ./printf
here is a string: 'foobar' here is a number: 1234
</code></pre>


      <p>
      Let's crack open the implementation of this and see how it works:
      </p>

      <pre><code class="zig"><span class="tok-comment">/// Calls print and then flushes the buffer.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printf</span>(self: *Writer, <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> State = <span class="tok-kw">enum</span> {
        start,
        open_brace,
        close_brace,
    };

    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> start_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> state = State.start;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> next_arg: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (format) |c, i| {
        <span class="tok-kw">switch</span> (state) {
            State.start =&gt; <span class="tok-kw">switch</span> (c) {
                <span class="tok-str">'{'</span> =&gt; {
                    <span class="tok-kw">if</span> (start_index &lt; i) <span class="tok-kw">try</span> self.write(format[start_index..i]);
                    state = State.open_brace;
                },
                <span class="tok-str">'}'</span> =&gt; {
                    <span class="tok-kw">if</span> (start_index &lt; i) <span class="tok-kw">try</span> self.write(format[start_index..i]);
                    state = State.close_brace;
                },
                <span class="tok-kw">else</span> =&gt; {},
            },
            State.open_brace =&gt; <span class="tok-kw">switch</span> (c) {
                <span class="tok-str">'{'</span> =&gt; {
                    state = State.start;
                    start_index = i;
                },
                <span class="tok-str">'}'</span> =&gt; {
                    <span class="tok-kw">try</span> self.printValue(args[next_arg]);
                    next_arg += <span class="tok-number">1</span>;
                    state = State.start;
                    start_index = i + <span class="tok-number">1</span>;
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unknown format character: &quot;</span> ++ c),
            },
            State.close_brace =&gt; <span class="tok-kw">switch</span> (c) {
                <span class="tok-str">'}'</span> =&gt; {
                    state = State.start;
                    start_index = i;
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Single '}' encountered in format string&quot;</span>),
            },
        }
    }
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">if</span> (args.len != next_arg) {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unused arguments&quot;</span>);
        }
        <span class="tok-kw">if</span> (state != State.Start) {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Incomplete format string: &quot;</span> ++ format);
        }
    }
    <span class="tok-kw">if</span> (start_index &lt; format.len) {
        <span class="tok-kw">try</span> self.write(format[start_index..format.len]);
    }
    <span class="tok-kw">try</span> self.flush();
}</code></pre>
      <p>
      This is a proof of concept implementation; the actual function in the standard library has more
      formatting capabilities.
      </p>
      <p>
      Note that this is not hard-coded into the Zig compiler; this is userland code in the standard library.
      </p>
      <p>
      When this function is analyzed from our example code above, Zig partially evaluates the function
      and emits a function that actually looks like this:
      </p>
      <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printf</span>(self: *Writer, arg0: <span class="tok-type">i32</span>, arg1: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.write(<span class="tok-str">&quot;here is a string: '&quot;</span>);
    <span class="tok-kw">try</span> self.printValue(arg0);
    <span class="tok-kw">try</span> self.write(<span class="tok-str">&quot;' here is a number: &quot;</span>);
    <span class="tok-kw">try</span> self.printValue(arg1);
    <span class="tok-kw">try</span> self.write(<span class="tok-str">&quot;\n&quot;</span>);
    <span class="tok-kw">try</span> self.flush();
}</code></pre>
      <p>
      <code class="zig">printValue</code> is a function that takes a parameter of any type, and does different things depending
      on the type:
      </p>
      <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printValue</span>(self: *Writer, value: <span class="tok-kw">anytype</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(value))) {
        .Int =&gt; {
            <span class="tok-kw">return</span> self.printInt(T, value);
        },
        .Float =&gt; {
            <span class="tok-kw">return</span> self.printFloat(T, value);
        },
        <span class="tok-kw">else</span> =&gt; {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to print type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>);
        },
    }
}</code></pre>
      <p>
      And now, what happens if we give too many arguments to <code class="zig">printf</code>?
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">const</span> a_number: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> a_string = <span class="tok-str">&quot;foobar&quot;</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;printf too many arguments&quot;</span> {
    print(<span class="tok-str">&quot;here is a string: '{s}' here is a number: {}\n&quot;</span>, .{
        a_string,
        a_number,
        a_number,
    });
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./build/release/lib/zig/std/fmt.zig:362:9: </span><span class="t31_1">error: </span><span class="t0_1">Unused arguments</span>
        @compileError(&quot;Unused arguments&quot;);
        <span class="t32_1">^</span>
<span class="t0_1">./build/release/lib/zig/std/io/writer.zig:34:34: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
            return std.fmt.format(self, format, args);
                                 <span class="t32_1">^</span>
<span class="t0_1">./build/release/lib/zig/std/debug.zig:65:27: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    nosuspend stderr.print(fmt, args) catch return;
                          <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:7:10: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    print(&quot;here is a string: '{s}' here is a number: {}\n&quot;, .{
         <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:6:34: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
test &quot;printf too many arguments&quot; {
                                 <span class="t32_1">^</span>
<span class="t0_1">./build/release/lib/zig/std/io/writer.zig:34:34: </span><span class="t31_1">error: </span><span class="t0_1">expected type 'std.os.WriteError!void', found '@typeInfo(@typeInfo(@TypeOf(std.fmt.format)).Fn.return_type.?).ErrorUnion.error_set!void'</span>
            return std.fmt.format(self, format, args);
                                 <span class="t32_1">^</span>
<span class="t0_1">./build/release/lib/zig/std/debug.zig:65:27: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    nosuspend stderr.print(fmt, args) catch return;
                          <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:7:10: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    print(&quot;here is a string: '{s}' here is a number: {}\n&quot;, .{
         <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:6:34: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
test &quot;printf too many arguments&quot; {
                                 <span class="t32_1">^</span>
<span class="t0_1">./build/release/lib/zig/std/io/writer.zig:34:34: </span><span class="t36_1">note: </span><span class="t0_1">error set '@typeInfo(@typeInfo(@TypeOf(std.fmt.format)).Fn.return_type.?).ErrorUnion.error_set' cannot cast into error set 'std.os.WriteError'</span>
            return std.fmt.format(self, format, args);
                                 <span class="t32_1">^</span>
</code></pre>

      <p>
      Zig gives programmers the tools needed to protect themselves against their own mistakes.
      </p>
      <p>
      Zig doesn't care whether the format argument is a string literal,
      only that it is a compile-time known value that can be coerced to a <code class="zig">[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code>:
      </p>
      <p class="file">printf.zig</p><pre><code class="zig"><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">const</span> a_number: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> a_string = <span class="tok-str">&quot;foobar&quot;</span>;
<span class="tok-kw">const</span> fmt = <span class="tok-str">&quot;here is a string: '{s}' here is a number: {}\n&quot;</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    print(fmt, .{a_string, a_number});
}</code></pre><pre><code class="shell">$ zig build-exe printf.zig
$ ./printf
here is a string: 'foobar' here is a number: 1234
</code></pre>

      <p>
      This works fine.
      </p>
      <p>
      Zig does not special case string formatting in the compiler and instead exposes enough power to accomplish this
      task in userland. It does so without introducing another language on top of Zig, such as
      a macro language or a preprocessor language. It's Zig all the way down.
      </p>
      
      <p>See also:</p><ul>
<li><a href="#inline-while">inline while</a></li>
<li><a href="#inline-for">inline for</a></li>
</ul>

      
      <h1 id="Assembly"><a href="#toc-Assembly">Assembly</a> <a class="hdr" href="#Assembly">§</a></h1>

      <p>
      For some use cases, it may be necessary to directly control the machine code generated
      by Zig programs, rather than relying on Zig's code generation. For these cases, one
      can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux
      using inline assembly:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-kw">const</span> msg = <span class="tok-str">&quot;hello world\n&quot;</span>;
    _ = syscall3(SYS_write, STDOUT_FILENO, <span class="tok-builtin">@ptrToInt</span>(msg), msg.len);
    _ = syscall1(SYS_exit, <span class="tok-number">0</span>);
    <span class="tok-kw">unreachable</span>;
}

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SYS_write = <span class="tok-number">1</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> SYS_exit = <span class="tok-number">60</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> STDOUT_FILENO = <span class="tok-number">1</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">syscall1</span>(number: <span class="tok-type">usize</span>, arg1: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;syscall&quot;</span>
        : [ret] <span class="tok-str">&quot;={rax}&quot;</span> (-&gt; <span class="tok-type">usize</span>)
        : [number] <span class="tok-str">&quot;{rax}&quot;</span> (number),
          [arg1] <span class="tok-str">&quot;{rdi}&quot;</span> (arg1)
        : <span class="tok-str">&quot;rcx&quot;</span>, <span class="tok-str">&quot;r11&quot;</span>
    );
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">syscall3</span>(number: <span class="tok-type">usize</span>, arg1: <span class="tok-type">usize</span>, arg2: <span class="tok-type">usize</span>, arg3: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">asm</span> <span class="tok-kw">volatile</span> (<span class="tok-str">&quot;syscall&quot;</span>
        : [ret] <span class="tok-str">&quot;={rax}&quot;</span> (-&gt; <span class="tok-type">usize</span>)
        : [number] <span class="tok-str">&quot;{rax}&quot;</span> (number),
          [arg1] <span class="tok-str">&quot;{rdi}&quot;</span> (arg1),
          [arg2] <span class="tok-str">&quot;{rsi}&quot;</span> (arg2),
          [arg3] <span class="tok-str">&quot;{rdx}&quot;</span> (arg3)
        : <span class="tok-str">&quot;rcx&quot;</span>, <span class="tok-str">&quot;r11&quot;</span>
    );
}</code></pre><pre><code class="shell">$ zig build-exe test.zig -target x86_64-linux
$ ./test
hello world
</code></pre>

      <p>
      Dissecting the syntax:
      </p>
      <pre><code class="zig"><span class="tok-comment">// Inline assembly is an expression which returns a value.</span>
<span class="tok-comment">// the `asm` keyword begins the expression.</span>
_ = <span class="tok-kw">asm</span>
<span class="tok-comment">// `volatile` is an optional modifier that tells Zig this</span>
<span class="tok-comment">// inline assembly expression has side-effects. Without</span>
<span class="tok-comment">// `volatile`, Zig is allowed to delete the inline assembly</span>
<span class="tok-comment">// code if the result is unused.</span>
<span class="tok-kw">volatile</span> (
<span class="tok-comment">// Next is a comptime string which is the assembly code.</span>
<span class="tok-comment">// Inside this string one may use `%[ret]`, `%[number]`,</span>
<span class="tok-comment">// or `%[arg1]` where a register is expected, to specify</span>
<span class="tok-comment">// the register that Zig uses for the argument or return value,</span>
<span class="tok-comment">// if the register constraint strings are used. However in</span>
<span class="tok-comment">// the below code, this is not used. A literal `%` can be</span>
<span class="tok-comment">// obtained by escaping it with a double percent: `%%`.</span>
<span class="tok-comment">// Often multiline string syntax comes in handy here.</span>
    <span class="tok-str">\\syscall
</span><span class="tok-comment">// Next is the output. It is possible in the future Zig will</span>
<span class="tok-comment">// support multiple outputs, depending on how</span>
<span class="tok-comment">// https://github.com/ziglang/zig/issues/215 is resolved.</span>
<span class="tok-comment">// It is allowed for there to be no outputs, in which case</span>
<span class="tok-comment">// this colon would be directly followed by the colon for the inputs.</span>
    :
<span class="tok-comment">// This specifies the name to be used in `%[ret]` syntax in</span>
<span class="tok-comment">// the above assembly string. This example does not use it,</span>
<span class="tok-comment">// but the syntax is mandatory.</span>
    [ret]
<span class="tok-comment">// Next is the output constraint string. This feature is still</span>
<span class="tok-comment">// considered unstable in Zig, and so LLVM/GCC documentation</span>
<span class="tok-comment">// must be used to understand the semantics.</span>
<span class="tok-comment">// http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string</span>
<span class="tok-comment">// https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html</span>
<span class="tok-comment">// In this example, the constraint string means &quot;the result value of</span>
<span class="tok-comment">// this inline assembly instruction is whatever is in $rax&quot;.</span>
    <span class="tok-str">&quot;={rax}&quot;</span>
<span class="tok-comment">// Next is either a value binding, or `-&gt;` and then a type. The</span>
<span class="tok-comment">// type is the result type of the inline assembly expression.</span>
<span class="tok-comment">// If it is a value binding, then `%[ret]` syntax would be used</span>
<span class="tok-comment">// to refer to the register bound to the value.</span>
    (-&gt; <span class="tok-type">usize</span>)
<span class="tok-comment">// Next is the list of inputs.</span>
<span class="tok-comment">// The constraint for these inputs means, &quot;when the assembly code is</span>
<span class="tok-comment">// executed, $rax shall have the value of `number` and $rdi shall have</span>
<span class="tok-comment">// the value of `arg1`&quot;. Any number of input parameters is allowed,</span>
<span class="tok-comment">// including none.</span>
    : [number] <span class="tok-str">&quot;{rax}&quot;</span> (number),
        [arg1] <span class="tok-str">&quot;{rdi}&quot;</span> (arg1)
<span class="tok-comment">// Next is the list of clobbers. These declare a set of registers whose</span>
<span class="tok-comment">// values will not be preserved by the execution of this assembly code.</span>
<span class="tok-comment">// These do not include output or input registers. The special clobber</span>
<span class="tok-comment">// value of &quot;memory&quot; means that the assembly writes to arbitrary undeclared</span>
<span class="tok-comment">// memory locations - not only the memory pointed to by a declared indirect</span>
<span class="tok-comment">// output. In this example we list $rcx and $r11 because it is known the</span>
<span class="tok-comment">// kernel syscall does not preserve these registers.</span>
    : <span class="tok-str">&quot;rcx&quot;</span>, <span class="tok-str">&quot;r11&quot;</span>
);</code></pre>
      <p>
      For i386 and x86_64 targets, the syntax is AT&amp;T syntax, rather than the more
      popular Intel syntax. This is due to technical constraints; assembly parsing is
      provided by LLVM and its support for Intel syntax is buggy and not well tested.
      </p>
      <p>
      Some day Zig may have its own assembler. This would allow it to integrate more seamlessly
      into the language, as well as be compatible with the popular NASM syntax. This documentation
      section will be updated before 1.0.0 is released, with a conclusive statement about the status
      of AT&amp;T vs Intel/NASM syntax.
      </p>
      <h2 id="Output-Constraints"><a href="#toc-Output-Constraints">Output Constraints</a> <a class="hdr" href="#Output-Constraints">§</a></h2>

      <p>
      Output constraints are still considered to be unstable in Zig, and
      so
      <a href="http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string">LLVM documentation</a>
      and
      <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">GCC documentation</a>
      must be used to understand the semantics.
      </p>
      <p>
      Note that some breaking changes to output constraints are planned with
      <a href="https://github.com/ziglang/zig/issues/215">issue #215</a>.
      </p>
      

      <h2 id="Input-Constraints"><a href="#toc-Input-Constraints">Input Constraints</a> <a class="hdr" href="#Input-Constraints">§</a></h2>

      <p>
      Input constraints are still considered to be unstable in Zig, and
      so
      <a href="http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string">LLVM documentation</a>
      and
      <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">GCC documentation</a>
      must be used to understand the semantics.
      </p>
      <p>
      Note that some breaking changes to input constraints are planned with
      <a href="https://github.com/ziglang/zig/issues/215">issue #215</a>.
      </p>
      

      <h2 id="Clobbers"><a href="#toc-Clobbers">Clobbers</a> <a class="hdr" href="#Clobbers">§</a></h2>

      <p>
      Clobbers are the set of registers whose values will not be preserved by the execution of
      the assembly code. These do not include output or input registers. The special clobber
      value of <code class="zig"><span class="tok-str">&quot;memory&quot;</span></code> means that the assembly causes writes to
      arbitrary undeclared memory locations - not only the memory pointed to by a declared
      indirect output.
      </p>
      <p>
      Failure to declare the full set of clobbers for a given inline assembly
      expression is unchecked <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      

      <h2 id="Global-Assembly"><a href="#toc-Global-Assembly">Global Assembly</a> <a class="hdr" href="#Global-Assembly">§</a></h2>

      <p>
      When an assembly expression occurs in a top level <a href="#comptime">comptime</a> block, this is
      <strong>global assembly</strong>.
      </p>
      <p>
      This kind of assembly has different rules than inline assembly. First, <code class="zig"><span class="tok-kw">volatile</span></code>
      is not valid because all global assembly is unconditionally included.
      Second, there are no inputs, outputs, or clobbers. All global assembly is concatenated
      verbatim into one long string and assembled together. There are no template substitution rules regarding
      <code>%</code> as there are in inline assembly expressions.
      </p>
      <p class="file">global-asm.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">comptime</span> {
    <span class="tok-kw">asm</span> (
        <span class="tok-str">\\.global my_func;
</span>        <span class="tok-str">\\.type my_func, @function;
</span>        <span class="tok-str">\\my_func:
</span>        <span class="tok-str">\\  lea (%rdi,%rsi,1),%eax
</span>        <span class="tok-str">\\  retq
</span>    );
}

<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">my_func</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;global assembly&quot;</span> {
    expect(my_func(<span class="tok-number">12</span>, <span class="tok-number">34</span>) == <span class="tok-number">46</span>);
}</code></pre><pre><code class="shell">$ zig test global-asm.zig -target x86_64-linux
Test [1/1] test &quot;global assembly&quot;... 

All 1 tests passed.
</code></pre>

      
      

      <h1 id="Atomics"><a href="#toc-Atomics">Atomics</a> <a class="hdr" href="#Atomics">§</a></h1>

      <p>TODO: @fence()</p>
      <p>TODO: @atomic rmw</p>
      <p>TODO: builtin atomic memory ordering enum</p>
      
      <h1 id="Async-Functions"><a href="#toc-Async-Functions">Async Functions</a> <a class="hdr" href="#Async-Functions">§</a></h1>

      <p>
      When a function is called, a frame is pushed to the stack,
      the function runs until it reaches a return statement, and then the frame is popped from the stack.
      At the callsite, the following code does not run until the function returns.
      </p>
      <p>
      An async function is a function whose callsite is split into an <code class="zig"><span class="tok-kw">async</span></code> initiation,
      followed by an <code class="zig"><span class="tok-kw">await</span></code> completion. Its frame is
      provided explicitly by the caller, and it can be suspended and resumed any number of times.
      </p>
      <p>
      Zig infers that a function is <code class="zig"><span class="tok-kw">async</span></code> when it observes that the function contains
      a <strong>suspension point</strong>. Async functions can be called the same as normal functions. A
      function call of an async function is a suspend point.
      </p>
      <h2 id="Suspend-and-Resume"><a href="#toc-Suspend-and-Resume">Suspend and Resume</a> <a class="hdr" href="#Suspend-and-Resume">§</a></h2>

      <p>
      At any point, a function may suspend itself. This causes control flow to
      return to the callsite (in the case of the first suspension),
      or resumer (in the case of subsequent suspensions).
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;suspend with no resume&quot;</span> {
    <span class="tok-kw">var</span> frame = <span class="tok-kw">async</span> func();
    expect(x == <span class="tok-number">2</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">func</span>() <span class="tok-type">void</span> {
    x += <span class="tok-number">1</span>;
    <span class="tok-kw">suspend</span>;
    <span class="tok-comment">// This line is never reached because the suspend has no matching resume.</span>
    x += <span class="tok-number">1</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;suspend with no resume&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      In the same way that each allocation should have a corresponding free,
      Each <code class="zig"><span class="tok-kw">suspend</span></code> should have a corresponding <code class="zig"><span class="tok-kw">resume</span></code>.
      A <strong>suspend block</strong> allows a function to put a pointer to its own
      frame somewhere, for example into an event loop, even if that action will perform a
      <code class="zig"><span class="tok-kw">resume</span></code> operation on a different thread.
      <a href="#frame">@frame</a> provides access to the async function frame pointer.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">var</span> the_frame: <span class="tok-kw">anyframe</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">var</span> result = <span class="tok-null">false</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;async function suspend with block&quot;</span> {
    _ = <span class="tok-kw">async</span> testSuspendBlock();
    expect(!result);
    <span class="tok-kw">resume</span> the_frame;
    expect(result);
}

<span class="tok-kw">fn</span> <span class="tok-fn">testSuspendBlock</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">suspend</span> {
        <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@TypeOf</span>(<span class="tok-builtin">@frame</span>()) == *<span class="tok-builtin">@Frame</span>(testSuspendBlock));
        the_frame = <span class="tok-builtin">@frame</span>();
    }
    result = <span class="tok-null">true</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;async function suspend with block&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      <code class="zig"><span class="tok-kw">suspend</span></code> causes a function to be <code class="zig"><span class="tok-kw">async</span></code>.
      </p>

      <h3 id="Resuming-from-Suspend-Blocks"><a href="#toc-Resuming-from-Suspend-Blocks">Resuming from Suspend Blocks</a> <a class="hdr" href="#Resuming-from-Suspend-Blocks">§</a></h3>

      <p>
      Upon entering a <code class="zig"><span class="tok-kw">suspend</span></code> block, the async function is already considered
      suspended, and can be resumed. For example, if you started another kernel thread,
      and had that thread call <code class="zig"><span class="tok-kw">resume</span></code> on the frame pointer provided by the
      <a href="#frame">@frame</a>, the new thread would begin executing after the suspend
      block, while the old thread continued executing the suspend block.
      </p>
      <p>
      However, the async function can be directly resumed from the suspend block, in which case it
      never returns to its resumer and continues executing.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;resume from suspend&quot;</span> {
    <span class="tok-kw">var</span> my_result: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    _ = <span class="tok-kw">async</span> testResumeFromSuspend(&amp;my_result);
    std.testing.expect(my_result == <span class="tok-number">2</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">testResumeFromSuspend</span>(my_result: *<span class="tok-type">i32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">suspend</span> {
        <span class="tok-kw">resume</span> <span class="tok-builtin">@frame</span>();
    }
    my_result.* += <span class="tok-number">1</span>;
    <span class="tok-kw">suspend</span>;
    my_result.* += <span class="tok-number">1</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;resume from suspend&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      This is guaranteed to tail call, and therefore will not cause a new stack frame.
      </p>
      
      

      <h2 id="Async-and-Await"><a href="#toc-Async-and-Await">Async and Await</a> <a class="hdr" href="#Async-and-Await">§</a></h2>

      <p>
      In the same way that every <code class="zig"><span class="tok-kw">suspend</span></code> has a matching
      <code class="zig"><span class="tok-kw">resume</span></code>, every <code class="zig"><span class="tok-kw">async</span></code> has a matching <code class="zig"><span class="tok-kw">await</span></code>.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;async and await&quot;</span> {
    <span class="tok-comment">// The test block is not async and so cannot have a suspend</span>
    <span class="tok-comment">// point in it. By using the nosuspend keyword, we promise that</span>
    <span class="tok-comment">// the code in amain will finish executing without suspending</span>
    <span class="tok-comment">// back to the test block.</span>
    <span class="tok-kw">nosuspend</span> amain();
}

<span class="tok-kw">fn</span> <span class="tok-fn">amain</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> frame = <span class="tok-kw">async</span> func();
    <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@TypeOf</span>(frame) == <span class="tok-builtin">@Frame</span>(func));

    <span class="tok-kw">const</span> ptr: <span class="tok-kw">anyframe</span>-&gt;<span class="tok-type">void</span> = &amp;frame;
    <span class="tok-kw">const</span> any_ptr: <span class="tok-kw">anyframe</span> = ptr;

    <span class="tok-kw">resume</span> any_ptr;
    <span class="tok-kw">await</span> ptr;
}

<span class="tok-kw">fn</span> <span class="tok-fn">func</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">suspend</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;async and await&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      The <code class="zig"><span class="tok-kw">await</span></code> keyword is used to coordinate with an async function's
      <code class="zig"><span class="tok-kw">return</span></code> statement.
      </p>
      <p>
      <code class="zig"><span class="tok-kw">await</span></code> is a suspend point, and takes as an operand anything that
      coerces to <code class="zig"><span class="tok-kw">anyframe</span>-&gt;T</code>.
      </p>
      <p>
      There is a common misconception that <code class="zig"><span class="tok-kw">await</span></code> resumes the target function.
      It is the other way around: it suspends until the target function completes.
      In the event that the target function has already completed, <code class="zig"><span class="tok-kw">await</span></code>
      does not suspend; instead it copies the
      return value directly from the target function's frame.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">var</span> the_frame: <span class="tok-kw">anyframe</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">var</span> final_result: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;async function await&quot;</span> {
    seq(<span class="tok-str">'a'</span>);
    _ = <span class="tok-kw">async</span> amain();
    seq(<span class="tok-str">'f'</span>);
    <span class="tok-kw">resume</span> the_frame;
    seq(<span class="tok-str">'i'</span>);
    expect(final_result == <span class="tok-number">1234</span>);
    expect(std.mem.eql(<span class="tok-type">u8</span>, &amp;seq_points, <span class="tok-str">&quot;abcdefghi&quot;</span>));
}
<span class="tok-kw">fn</span> <span class="tok-fn">amain</span>() <span class="tok-type">void</span> {
    seq(<span class="tok-str">'b'</span>);
    <span class="tok-kw">var</span> f = <span class="tok-kw">async</span> another();
    seq(<span class="tok-str">'e'</span>);
    final_result = <span class="tok-kw">await</span> f;
    seq(<span class="tok-str">'h'</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">another</span>() <span class="tok-type">i32</span> {
    seq(<span class="tok-str">'c'</span>);
    <span class="tok-kw">suspend</span> {
        seq(<span class="tok-str">'d'</span>);
        the_frame = <span class="tok-builtin">@frame</span>();
    }
    seq(<span class="tok-str">'g'</span>);
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}

<span class="tok-kw">var</span> seq_points = [_]<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-str">&quot;abcdefghi&quot;</span>.len;
<span class="tok-kw">var</span> seq_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">seq</span>(c: <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    seq_points[seq_index] = c;
    seq_index += <span class="tok-number">1</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;async function await&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      In general, <code class="zig"><span class="tok-kw">suspend</span></code> is lower level than <code class="zig"><span class="tok-kw">await</span></code>. Most application
      code will use only <code class="zig"><span class="tok-kw">async</span></code> and <code class="zig"><span class="tok-kw">await</span></code>, but event loop
      implementations will make use of <code class="zig"><span class="tok-kw">suspend</span></code> internally.
      </p>
      

      <h2 id="Async-Function-Example"><a href="#toc-Async-Function-Example">Async Function Example</a> <a class="hdr" href="#Async-Function-Example">§</a></h2>

      <p>
      Putting all of this together, here is an example of typical
      <code class="zig"><span class="tok-kw">async</span></code>/<code class="zig"><span class="tok-kw">await</span></code> usage:
      </p>
      <p class="file">async.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> Allocator = std.mem.Allocator;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    _ = <span class="tok-kw">async</span> amainWrap();

    <span class="tok-comment">// Typically we would use an event loop to manage resuming async functions,</span>
    <span class="tok-comment">// but in this example we hard code what the event loop would do,</span>
    <span class="tok-comment">// to make things deterministic.</span>
    <span class="tok-kw">resume</span> global_file_frame;
    <span class="tok-kw">resume</span> global_download_frame;
}

<span class="tok-kw">fn</span> <span class="tok-fn">amainWrap</span>() <span class="tok-type">void</span> {
    amain() <span class="tok-kw">catch</span> |e| {
        std.debug.print(<span class="tok-str">&quot;{}\n&quot;</span>, .{e});
        <span class="tok-kw">if</span> (<span class="tok-builtin">@errorReturnTrace</span>()) |trace| {
            std.debug.dumpStackTrace(trace.*);
        }
        std.process.exit(<span class="tok-number">1</span>);
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">amain</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> allocator = std.heap.page_allocator;
    <span class="tok-kw">var</span> download_frame = <span class="tok-kw">async</span> fetchUrl(allocator, <span class="tok-str">&quot;https://example.com/&quot;</span>);
    <span class="tok-kw">var</span> awaited_download_frame = <span class="tok-null">false</span>;
    <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (!awaited_download_frame) {
        <span class="tok-kw">if</span> (<span class="tok-kw">await</span> download_frame) |r| allocator.free(r) <span class="tok-kw">else</span> |_| {}
    };

    <span class="tok-kw">var</span> file_frame = <span class="tok-kw">async</span> readFile(allocator, <span class="tok-str">&quot;something.txt&quot;</span>);
    <span class="tok-kw">var</span> awaited_file_frame = <span class="tok-null">false</span>;
    <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (!awaited_file_frame) {
        <span class="tok-kw">if</span> (<span class="tok-kw">await</span> file_frame) |r| allocator.free(r) <span class="tok-kw">else</span> |_| {}
    };

    awaited_file_frame = <span class="tok-null">true</span>;
    <span class="tok-kw">const</span> file_text = <span class="tok-kw">try</span> <span class="tok-kw">await</span> file_frame;
    <span class="tok-kw">defer</span> allocator.free(file_text);

    awaited_download_frame = <span class="tok-null">true</span>;
    <span class="tok-kw">const</span> download_text = <span class="tok-kw">try</span> <span class="tok-kw">await</span> download_frame;
    <span class="tok-kw">defer</span> allocator.free(download_text);

    std.debug.print(<span class="tok-str">&quot;download_text: {s}\n&quot;</span>, .{download_text});
    std.debug.print(<span class="tok-str">&quot;file_text: {s}\n&quot;</span>, .{file_text});
}

<span class="tok-kw">var</span> global_download_frame: <span class="tok-kw">anyframe</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">fetchUrl</span>(allocator: *Allocator, url: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> std.mem.dupe(allocator, <span class="tok-type">u8</span>, <span class="tok-str">&quot;this is the downloaded url contents&quot;</span>);
    <span class="tok-kw">errdefer</span> allocator.free(result);
    <span class="tok-kw">suspend</span> {
        global_download_frame = <span class="tok-builtin">@frame</span>();
    }
    std.debug.print(<span class="tok-str">&quot;fetchUrl returning\n&quot;</span>, .{});
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">var</span> global_file_frame: <span class="tok-kw">anyframe</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">readFile</span>(allocator: *Allocator, filename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> std.mem.dupe(allocator, <span class="tok-type">u8</span>, <span class="tok-str">&quot;this is the file contents&quot;</span>);
    <span class="tok-kw">errdefer</span> allocator.free(result);
    <span class="tok-kw">suspend</span> {
        global_file_frame = <span class="tok-builtin">@frame</span>();
    }
    std.debug.print(<span class="tok-str">&quot;readFile returning\n&quot;</span>, .{});
    <span class="tok-kw">return</span> result;
}</code></pre><pre><code class="shell">$ zig build-exe async.zig
$ ./async
readFile returning
fetchUrl returning
download_text: this is the downloaded url contents
file_text: this is the file contents
</code></pre>

      <p>
      Now we remove the <code class="zig"><span class="tok-kw">suspend</span></code> and <code class="zig"><span class="tok-kw">resume</span></code> code, and
      observe the same behavior, with one tiny difference:
      </p>
      <p class="file">blocking.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> Allocator = std.mem.Allocator;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    _ = <span class="tok-kw">async</span> amainWrap();
}

<span class="tok-kw">fn</span> <span class="tok-fn">amainWrap</span>() <span class="tok-type">void</span> {
    amain() <span class="tok-kw">catch</span> |e| {
        std.debug.print(<span class="tok-str">&quot;{}\n&quot;</span>, .{e});
        <span class="tok-kw">if</span> (<span class="tok-builtin">@errorReturnTrace</span>()) |trace| {
            std.debug.dumpStackTrace(trace.*);
        }
        std.process.exit(<span class="tok-number">1</span>);
    };
}

<span class="tok-kw">fn</span> <span class="tok-fn">amain</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> allocator = std.heap.page_allocator;
    <span class="tok-kw">var</span> download_frame = <span class="tok-kw">async</span> fetchUrl(allocator, <span class="tok-str">&quot;https://example.com/&quot;</span>);
    <span class="tok-kw">var</span> awaited_download_frame = <span class="tok-null">false</span>;
    <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (!awaited_download_frame) {
        <span class="tok-kw">if</span> (<span class="tok-kw">await</span> download_frame) |r| allocator.free(r) <span class="tok-kw">else</span> |_| {}
    };

    <span class="tok-kw">var</span> file_frame = <span class="tok-kw">async</span> readFile(allocator, <span class="tok-str">&quot;something.txt&quot;</span>);
    <span class="tok-kw">var</span> awaited_file_frame = <span class="tok-null">false</span>;
    <span class="tok-kw">errdefer</span> <span class="tok-kw">if</span> (!awaited_file_frame) {
        <span class="tok-kw">if</span> (<span class="tok-kw">await</span> file_frame) |r| allocator.free(r) <span class="tok-kw">else</span> |_| {}
    };

    awaited_file_frame = <span class="tok-null">true</span>;
    <span class="tok-kw">const</span> file_text = <span class="tok-kw">try</span> <span class="tok-kw">await</span> file_frame;
    <span class="tok-kw">defer</span> allocator.free(file_text);

    awaited_download_frame = <span class="tok-null">true</span>;
    <span class="tok-kw">const</span> download_text = <span class="tok-kw">try</span> <span class="tok-kw">await</span> download_frame;
    <span class="tok-kw">defer</span> allocator.free(download_text);

    std.debug.print(<span class="tok-str">&quot;download_text: {s}\n&quot;</span>, .{download_text});
    std.debug.print(<span class="tok-str">&quot;file_text: {s}\n&quot;</span>, .{file_text});
}

<span class="tok-kw">fn</span> <span class="tok-fn">fetchUrl</span>(allocator: *Allocator, url: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> std.mem.dupe(allocator, <span class="tok-type">u8</span>, <span class="tok-str">&quot;this is the downloaded url contents&quot;</span>);
    <span class="tok-kw">errdefer</span> allocator.free(result);
    std.debug.print(<span class="tok-str">&quot;fetchUrl returning\n&quot;</span>, .{});
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">fn</span> <span class="tok-fn">readFile</span>(allocator: *Allocator, filename: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> std.mem.dupe(allocator, <span class="tok-type">u8</span>, <span class="tok-str">&quot;this is the file contents&quot;</span>);
    <span class="tok-kw">errdefer</span> allocator.free(result);
    std.debug.print(<span class="tok-str">&quot;readFile returning\n&quot;</span>, .{});
    <span class="tok-kw">return</span> result;
}</code></pre><pre><code class="shell">$ zig build-exe blocking.zig
$ ./blocking
fetchUrl returning
readFile returning
download_text: this is the downloaded url contents
file_text: this is the file contents
</code></pre>

      <p>
      Previously, the <code class="zig">fetchUrl</code> and <code class="zig">readFile</code> functions suspended,
      and were resumed in an order determined by the <code class="zig">main</code> function. Now,
      since there are no suspend points, the order of the printed "... returning" messages
      is determined by the order of <code class="zig"><span class="tok-kw">async</span></code> callsites.
      </p>
      

      
        <h1 id="Builtin-Functions"><a href="#toc-Builtin-Functions">Builtin Functions</a> <a class="hdr" href="#Builtin-Functions">§</a></h1>

      <p>
      Builtin functions are provided by the compiler and are prefixed with <code>@</code>.
      The <code class="zig"><span class="tok-kw">comptime</span></code> keyword on a parameter means that the parameter must be known
      at compile time.
      </p>
      <h2 id="addWithOverflow"><a href="#toc-addWithOverflow">@addWithOverflow</a> <a class="hdr" href="#addWithOverflow">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@addWithOverflow</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T, result: *T) <span class="tok-type">bool</span></code></pre>
      <p>
      Performs <code class="zig">result.* = a + b</code>. If overflow or underflow occurs,
          stores the overflowed bits in <code class="zig">result</code> and returns <code class="zig"><span class="tok-null">true</span></code>.
                  If no overflow or underflow occurs, returns <code class="zig"><span class="tok-null">false</span></code>.
      </p>
      
      <h2 id="alignCast"><a href="#toc-alignCast">@alignCast</a> <a class="hdr" href="#alignCast">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@alignCast</span>(<span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>, ptr: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      <code class="zig">ptr</code> can be <code class="zig">*T</code>, <code class="zig"><span class="tok-kw">fn</span>()</code>, <code class="zig">?*T</code>,
                      <code class="zig">?<span class="tok-kw">fn</span>()</code>, or <code class="zig">[]T</code>. It returns the same type as <code class="zig">ptr</code>
      except with the alignment adjusted to the new value.
      </p>
      <p>A <a href="#Incorrect-Pointer-Alignment">pointer alignment safety check</a> is added
      to the generated code to make sure the pointer is aligned as promised.</p>

      
      <h2 id="alignOf"><a href="#toc-alignOf">@alignOf</a> <a class="hdr" href="#alignOf">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@alignOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      This function returns the number of bytes that this type should be aligned to
      for the current target to match the C ABI. When the child type of a pointer has
      this alignment, the alignment can be omitted from the type.
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;
<span class="tok-kw">comptime</span> {
    expect(*<span class="tok-type">u32</span> == *<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">u32</span>)) <span class="tok-type">u32</span>);
}</code></pre>
      <p>
      The result is a target-specific compile time constant. It is guaranteed to be
      less than or equal to <a href="#sizeOf">@sizeOf(T)</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Alignment">Alignment</a></li>
</ul>

      

      <h2 id="as"><a href="#toc-as">@as</a> <a class="hdr" href="#as">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@as</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, expression) T</code></pre>
      <p>
      Performs <a href="#Type-Coercion">Type Coercion</a>. This cast is allowed when the conversion is unambiguous and safe,
      and is the preferred way to convert between types, whenever possible.
      </p>
      

      <h2 id="asyncCall"><a href="#toc-asyncCall">@asyncCall</a> <a class="hdr" href="#asyncCall">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@asyncCall</span>(frame_buffer: []<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-builtin">@Frame</span>(anyAsyncFunction))) <span class="tok-type">u8</span>, result_ptr, function_ptr, args: <span class="tok-kw">anytype</span>) <span class="tok-kw">anyframe</span>-&gt;T</code></pre>
      <p>
      <code class="zig"><span class="tok-builtin">@asyncCall</span></code> performs an <code class="zig"><span class="tok-kw">async</span></code> call on a function pointer,
      which may or may not be an <a href="#Async-Functions">async function</a>.
      </p>
      <p>
      The provided <code class="zig">frame_buffer</code> must be large enough to fit the entire function frame.
      This size can be determined with <a href="#frameSize">@frameSize</a>. To provide a too-small buffer
      invokes safety-checked <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      <p>
      <code class="zig">result_ptr</code> is optional (<a href="#null">null</a> may be provided). If provided,
      the function call will write its result directly to the result pointer, which will be available to
      read after <a href="#Async-and-Await">await</a> completes. Any result location provided to
      <code class="zig"><span class="tok-kw">await</span></code> will copy the result from <code class="zig">result_ptr</code>.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;async fn pointer in a struct field&quot;</span> {
    <span class="tok-kw">var</span> data: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
        bar: <span class="tok-kw">fn</span> (*<span class="tok-type">i32</span>) <span class="tok-kw">callconv</span>(.Async) <span class="tok-type">void</span>,
    };
    <span class="tok-kw">var</span> foo = Foo{ .bar = func };
    <span class="tok-kw">var</span> bytes: [<span class="tok-number">64</span>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-builtin">@Frame</span>(func))) = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> f = <span class="tok-builtin">@asyncCall</span>(&amp;bytes, {}, foo.bar, .{&amp;data});
    expect(data == <span class="tok-number">2</span>);
    <span class="tok-kw">resume</span> f;
    expect(data == <span class="tok-number">4</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">func</span>(y: *<span class="tok-type">i32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">defer</span> y.* += <span class="tok-number">2</span>;
    y.* += <span class="tok-number">1</span>;
    <span class="tok-kw">suspend</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;async fn pointer in a struct field&quot;... 

All 1 tests passed.
</code></pre>

      

      <h2 id="atomicLoad"><a href="#toc-atomicLoad">@atomicLoad</a> <a class="hdr" href="#atomicLoad">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@atomicLoad</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *<span class="tok-kw">const</span> T, <span class="tok-kw">comptime</span> ordering: builtin.AtomicOrder) T</code></pre>
      <p>
      This builtin function atomically dereferences a pointer and returns the value.
      </p>
      <p>
      <code class="zig">T</code> must be a pointer, a <code class="zig"><span class="tok-type">bool</span></code>, a float,
      an integer or an enum.
      </p>
      
      <h2 id="atomicRmw"><a href="#toc-atomicRmw">@atomicRmw</a> <a class="hdr" href="#atomicRmw">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@atomicRmw</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, <span class="tok-kw">comptime</span> op: builtin.AtomicRmwOp, operand: T, <span class="tok-kw">comptime</span> ordering: builtin.AtomicOrder) T</code></pre>
      <p>
      This builtin function atomically modifies memory and then returns the previous value.
      </p>
      <p>
      <code class="zig">T</code> must be a pointer, a <code class="zig"><span class="tok-type">bool</span></code>, a float,
      an integer or an enum.
      </p>
      <p>
      Supported operations:
      </p>
      <ul>
        <li><code class="zig">.Xchg</code> - stores the operand unmodified. Supports enums, integers and floats.</li>
        <li><code class="zig">.Add</code> - for integers, twos complement wraparound addition.
            Also supports <a href="#Floats">Floats</a>.</li>
        <li><code class="zig">.Sub</code> - for integers, twos complement wraparound subtraction.
            Also supports <a href="#Floats">Floats</a>.</li>
        <li><code class="zig">.And</code> - bitwise and</li>
        <li><code class="zig">.Nand</code> - bitwise nand</li>
        <li><code class="zig">.Or</code> - bitwise or</li>
        <li><code class="zig">.Xor</code> - bitwise xor</li>
        <li><code class="zig">.Max</code> - stores the operand if it is larger. Supports integers and floats.</li>
        <li><code class="zig">.Min</code> - stores the operand if it is smaller. Supports integers and floats.</li>
      </ul>
      
      <h2 id="atomicStore"><a href="#toc-atomicStore">@atomicStore</a> <a class="hdr" href="#atomicStore">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@atomicStore</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, value: T, <span class="tok-kw">comptime</span> ordering: builtin.AtomicOrder) <span class="tok-type">void</span></code></pre>
      <p>
      This builtin function atomically stores a value.
      </p>
      <p>
      <code class="zig">T</code> must be a pointer, a <code class="zig"><span class="tok-type">bool</span></code>, a float,
      an integer or an enum.
      </p>
      
      <h2 id="bitCast"><a href="#toc-bitCast">@bitCast</a> <a class="hdr" href="#bitCast">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@bitCast</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, value: <span class="tok-kw">anytype</span>) DestType</code></pre>
      <p>
      Converts a value of one type to another type.
      </p>
      <p>
      Asserts that <code class="zig"><span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@TypeOf</span>(value)) == <span class="tok-builtin">@sizeOf</span>(DestType)</code>.
      </p>
      <p>
      Asserts that <code class="zig"><span class="tok-builtin">@typeInfo</span>(DestType) != .Pointer</code>. Use <code class="zig"><span class="tok-builtin">@ptrCast</span></code> or <code class="zig"><span class="tok-builtin">@intToPtr</span></code> if you need this.
      </p>
      <p>
      Can be used for these things for example:
      </p>
      <ul>
          <li>Convert <code class="zig"><span class="tok-type">f32</span></code> to <code class="zig"><span class="tok-type">u32</span></code> bits</li>
          <li>Convert <code class="zig"><span class="tok-type">i32</span></code> to <code class="zig"><span class="tok-type">u32</span></code> preserving twos complement</li>
      </ul>
      <p>
      Works at compile-time if <code class="zig">value</code> is known at compile time. It's a compile error to bitcast a struct to a scalar type of the same size since structs have undefined layout. However if the struct is packed then it works.
      </p>
      

      <h2 id="bitOffsetOf"><a href="#toc-bitOffsetOf">@bitOffsetOf</a> <a class="hdr" href="#bitOffsetOf">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@bitOffsetOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      Returns the bit offset of a field relative to its containing struct.
      </p>
      <p>
      For non <a href="#packed-struct">packed structs</a>, this will always be divisible by <code class="zig"><span class="tok-number">8</span></code>.
      For packed structs, non-byte-aligned fields will share a byte offset, but they will have different
      bit offsets.
      </p>
      <p>See also:</p><ul>
<li><a href="#byteOffsetOf">@byteOffsetOf</a></li>
</ul>

      

      <h2 id="boolToInt"><a href="#toc-boolToInt">@boolToInt</a> <a class="hdr" href="#boolToInt">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@boolToInt</span>(value: <span class="tok-type">bool</span>) <span class="tok-type">u1</span></code></pre>
      <p>
      Converts <code class="zig"><span class="tok-null">true</span></code> to <code class="zig"><span class="tok-type">u1</span>(<span class="tok-number">1</span>)</code> and <code class="zig"><span class="tok-null">false</span></code> to
                  <code class="zig"><span class="tok-type">u1</span>(<span class="tok-number">0</span>)</code>.
      </p>
      <p>
      If the value is known at compile-time, the return type is <code class="zig"><span class="tok-type">comptime_int</span></code>
          instead of <code class="zig"><span class="tok-type">u1</span></code>.
      </p>
      

      <h2 id="bitSizeOf"><a href="#toc-bitSizeOf">@bitSizeOf</a> <a class="hdr" href="#bitSizeOf">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@bitSizeOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      This function returns the number of bits it takes to store <code class="zig">T</code> in memory.
      The result is a target-specific compile time constant.
      </p>
      <p>
      This function measures the size at runtime. For types that are disallowed at runtime, such as
      <code class="zig"><span class="tok-type">comptime_int</span></code> and <code class="zig"><span class="tok-type">type</span></code>, the result is <code class="zig"><span class="tok-number">0</span></code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#sizeOf">@sizeOf</a></li>
<li><a href="#typeInfo">@typeInfo</a></li>
</ul>

      

      <h2 id="breakpoint"><a href="#toc-breakpoint">@breakpoint</a> <a class="hdr" href="#breakpoint">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@breakpoint</span>()</code></pre>
      <p>
      This function inserts a platform-specific debug trap instruction which causes
      debuggers to break there.
      </p>
      <p>
      This function is only valid within function scope.
      </p>

      
      <h2 id="mulAdd"><a href="#toc-mulAdd">@mulAdd</a> <a class="hdr" href="#mulAdd">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@mulAdd</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T, c: T) T</code></pre>
      <p>
      Fused multiply add, similar to <code class="zig">(a * b) + c</code>, except
      only rounds once, and is thus more accurate.
      </p>
      <p>
      Supports Floats and Vectors of floats.
      </p>
      

      <h2 id="byteSwap"><a href="#toc-byteSwap">@byteSwap</a> <a class="hdr" href="#byteSwap">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@byteSwap</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, operand: T) T</code></pre>
      <p><code class="zig">T</code> must be an integer type with bit count evenly divisible by 8.</p>
      <p><code class="zig">operand</code> may be an <a href="#Integers">integer</a> or <a href="#Vectors">vector</a>.</p>
      <p>
      Swaps the byte order of the integer. This converts a big endian integer to a little endian integer,
      and converts a little endian integer to a big endian integer.
      </p>
      <p>
      Note that for the purposes of memory layout with respect to endianness, the integer type should be
      related to the number of bytes reported by <a href="#sizeOf">@sizeOf</a> bytes. This is demonstrated with
      <code class="zig"><span class="tok-type">u24</span></code>. <code class="zig"><span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u24</span>) == <span class="tok-number">4</span></code>, which means that a
      <code class="zig"><span class="tok-type">u24</span></code> stored in memory takes 4 bytes, and those 4 bytes are what are swapped on
      a little vs big endian system. On the other hand, if <code class="zig">T</code> is specified to
      be <code class="zig"><span class="tok-type">u24</span></code>, then only 3 bytes are reversed.
      </p>
      

      <h2 id="bitReverse"><a href="#toc-bitReverse">@bitReverse</a> <a class="hdr" href="#bitReverse">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@bitReverse</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, integer: T) T</code></pre>
      <p><code class="zig">T</code> accepts any integer type.</p>
      <p>
      Reverses the bitpattern of an integer value, including the sign bit if applicable.
      </p>
      <p>
      For example 0b10110110 (<code class="zig"><span class="tok-type">u8</span> = <span class="tok-number">182</span></code>, <code class="zig"><span class="tok-type">i8</span> = -<span class="tok-number">74</span></code>)
      becomes 0b01101101 (<code class="zig"><span class="tok-type">u8</span> = <span class="tok-number">109</span></code>, <code class="zig"><span class="tok-type">i8</span> = <span class="tok-number">109</span></code>).
      </p>
      

      <h2 id="byteOffsetOf"><a href="#toc-byteOffsetOf">@byteOffsetOf</a> <a class="hdr" href="#byteOffsetOf">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@byteOffsetOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      Returns the byte offset of a field relative to its containing struct.
      </p>
      <p>See also:</p><ul>
<li><a href="#bitOffsetOf">@bitOffsetOf</a></li>
</ul>

      

      <h2 id="call"><a href="#toc-call">@call</a> <a class="hdr" href="#call">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@call</span>(options: std.builtin.CallOptions, function: <span class="tok-kw">anytype</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Calls a function, in the same way that invoking an expression with parentheses does:
      </p>
      <p class="file">call.zig</p><pre><code class="zig"><span class="tok-kw">const</span> expect = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;noinline function call&quot;</span> {
    expect(<span class="tok-builtin">@call</span>(.{}, add, .{<span class="tok-number">3</span>, <span class="tok-number">9</span>}) == <span class="tok-number">12</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a + b;
}</code></pre><pre><code class="shell">$ zig test call.zig
Test [1/1] test &quot;noinline function call&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      <code class="zig"><span class="tok-builtin">@call</span></code> allows more flexibility than normal function call syntax does. The
      <code class="zig">CallOptions</code> struct is reproduced here:
      </p>
      <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CallOptions = <span class="tok-kw">struct</span> {
    modifier: Modifier = .auto,
    stack: ?[]<span class="tok-kw">align</span>(std.Target.stack_align) <span class="tok-type">u8</span> = <span class="tok-null">null</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Modifier = <span class="tok-kw">enum</span> {
        <span class="tok-comment">/// Equivalent to function call syntax.</span>
        auto,

        <span class="tok-comment">/// Equivalent to async keyword used with function call syntax.</span>
        async_kw,

        <span class="tok-comment">/// Prevents tail call optimization. This guarantees that the return</span>
        <span class="tok-comment">/// address will point to the callsite, as opposed to the callsite's</span>
        <span class="tok-comment">/// callsite. If the call is otherwise required to be tail-called</span>
        <span class="tok-comment">/// or inlined, a compile error is emitted instead.</span>
        never_tail,

        <span class="tok-comment">/// Guarantees that the call will not be inlined. If the call is</span>
        <span class="tok-comment">/// otherwise required to be inlined, a compile error is emitted instead.</span>
        never_inline,

        <span class="tok-comment">/// Asserts that the function call will not suspend. This allows a</span>
        <span class="tok-comment">/// non-async function to call an async function.</span>
        no_async,

        <span class="tok-comment">/// Guarantees that the call will be generated with tail call optimization.</span>
        <span class="tok-comment">/// If this is not possible, a compile error is emitted instead.</span>
        always_tail,

        <span class="tok-comment">/// Guarantees that the call will inlined at the callsite.</span>
        <span class="tok-comment">/// If this is not possible, a compile error is emitted instead.</span>
        always_inline,

        <span class="tok-comment">/// Evaluates the call at compile-time. If the call cannot be completed at</span>
        <span class="tok-comment">/// compile-time, a compile error is emitted instead.</span>
        compile_time,
    };
};</code></pre>
      

      <h2 id="cDefine"><a href="#toc-cDefine">@cDefine</a> <a class="hdr" href="#cDefine">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@cDefine</span>(<span class="tok-kw">comptime</span> name: []<span class="tok-type">u8</span>, value)</code></pre>
      <p>
      This function can only occur inside <code class="zig"><span class="tok-builtin">@cImport</span></code>.
      </p>
      <p>
      This appends <code>#define $name $value</code> to the <code class="zig"><span class="tok-builtin">@cImport</span></code>
      temporary buffer.
      </p>
      <p>
      To define without a value, like this:
      </p>
      <pre><code class="c">#define _GNU_SOURCE</code></pre>
      <p>
      Use the void value, like this:
      </p>
      <pre><code class="zig"><span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;_GNU_SOURCE&quot;</span>, {})</code></pre>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cInclude">@cInclude</a></li>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cUndef">@cUndef</a></li>
<li><a href="#void">void</a></li>
</ul>

      
      <h2 id="cImport"><a href="#toc-cImport">@cImport</a> <a class="hdr" href="#cImport">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@cImport</span>(expression) <span class="tok-type">type</span></code></pre>
      <p>
      This function parses C code and imports the functions, types, variables,
      and compatible macro definitions into a new empty struct type, and then
      returns that type.
      </p>
      <p>
      <code class="zig">expression</code> is interpreted at compile time. The builtin functions
          <code class="zig"><span class="tok-builtin">@cInclude</span></code>, <code class="zig"><span class="tok-builtin">@cDefine</span></code>, and <code class="zig"><span class="tok-builtin">@cUndef</span></code> work
      within this expression, appending to a temporary buffer which is then parsed as C code.
      </p>
      <p>
      Usually you should only have one <code class="zig"><span class="tok-builtin">@cImport</span></code> in your entire application, because it saves the compiler
      from invoking clang multiple times, and prevents inline functions from being duplicated.
      </p>
      <p>
      Reasons for having multiple <code class="zig"><span class="tok-builtin">@cImport</span></code> expressions would be:
      </p>
      <ul>
          <li>To avoid a symbol collision, for example if foo.h and bar.h both <code>#define CONNECTION_COUNT</code></li>
        <li>To analyze the C code with different preprocessor defines</li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cInclude">@cInclude</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cUndef">@cUndef</a></li>
</ul>

      
      <h2 id="cInclude"><a href="#toc-cInclude">@cInclude</a> <a class="hdr" href="#cInclude">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@cInclude</span>(<span class="tok-kw">comptime</span> path: []<span class="tok-type">u8</span>)</code></pre>
      <p>
      This function can only occur inside <code class="zig"><span class="tok-builtin">@cImport</span></code>.
      </p>
      <p>
      This appends <code>#include &lt;$path&gt;\n</code> to the <code class="zig">c_import</code>
      temporary buffer.
      </p>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cUndef">@cUndef</a></li>
</ul>

      

      <h2 id="clz"><a href="#toc-clz">@clz</a> <a class="hdr" href="#clz">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@clz</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, integer: T)</code></pre>
      <p>
      This function counts the number of most-significant (leading in a big-Endian sense) zeroes in <code class="zig">integer</code>.
      </p>
      <p>
      If <code class="zig">integer</code> is known at <a href="#comptime">comptime</a>,
      the return type is <code class="zig"><span class="tok-type">comptime_int</span></code>.
      Otherwise, the return type is an unsigned integer with the minimum number
      of bits that can represent the bit count of the integer type.
      </p>
      <p>
      If <code class="zig">integer</code> is zero, <code class="zig"><span class="tok-builtin">@clz</span></code> returns the bit width
      of integer type <code class="zig">T</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#ctz">@ctz</a></li>
<li><a href="#popCount">@popCount</a></li>
</ul>

      

      <h2 id="cmpxchgStrong"><a href="#toc-cmpxchgStrong">@cmpxchgStrong</a> <a class="hdr" href="#cmpxchgStrong">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@cmpxchgStrong</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T</code></pre>
      <p>
      This function performs a strong atomic compare exchange operation. It's the equivalent of this code,
      except atomic:
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">cmpxchgStrongButNotAtomic</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T) ?T {
    <span class="tok-kw">const</span> old_value = ptr.*;
    <span class="tok-kw">if</span> (old_value == expected_value) {
        ptr.* = new_value;
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> old_value;
    }
}</code></pre>
      <p>
      If you are using cmpxchg in a loop, <a href="#cmpxchgWeak">@cmpxchgWeak</a> is the better choice, because it can be implemented
      more efficiently in machine instructions.
      </p>
      <p>
      <code class="zig">T</code> must be a pointer, a <code class="zig"><span class="tok-type">bool</span></code>, a float,
      an integer or an enum.
      </p>
      <p><code class="zig"><span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(ptr)).Pointer.alignment</code> must be <code class="zig">&gt;= <span class="tok-builtin">@sizeOf</span>(T).</code></p>
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
<li><a href="#cmpxchgWeak">cmpxchgWeak</a></li>
</ul>

      
      <h2 id="cmpxchgWeak"><a href="#toc-cmpxchgWeak">@cmpxchgWeak</a> <a class="hdr" href="#cmpxchgWeak">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@cmpxchgWeak</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T</code></pre>
      <p>
      This function performs a weak atomic compare exchange operation. It's the equivalent of this code,
      except atomic:
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">cmpxchgWeakButNotAtomic</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T) ?T {
    <span class="tok-kw">const</span> old_value = ptr.*;
    <span class="tok-kw">if</span> (old_value == expected_value <span class="tok-kw">and</span> usuallyTrueButSometimesFalse()) {
        ptr.* = new_value;
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> old_value;
    }
}</code></pre>
      <p>
      If you are using cmpxchg in a loop, the sporadic failure will be no problem, and <code class="zig">cmpxchgWeak</code>
      is the better choice, because it can be implemented more efficiently in machine instructions.
      However if you need a stronger guarantee, use <a href="#cmpxchgStrong">@cmpxchgStrong</a>.
      </p>
      <p>
      <code class="zig">T</code> must be a pointer, a <code class="zig"><span class="tok-type">bool</span></code>, a float,
      an integer or an enum.
      </p>
      <p><code class="zig"><span class="tok-builtin">@typeInfo</span>(<span class="tok-builtin">@TypeOf</span>(ptr)).Pointer.alignment</code> must be <code class="zig">&gt;= <span class="tok-builtin">@sizeOf</span>(T).</code></p>
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
<li><a href="#cmpxchgStrong">cmpxchgStrong</a></li>
</ul>

      

      <h2 id="compileError"><a href="#toc-compileError">@compileError</a> <a class="hdr" href="#compileError">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@compileError</span>(<span class="tok-kw">comptime</span> msg: []<span class="tok-type">u8</span>)</code></pre>
      <p>
      This function, when semantically analyzed, causes a compile error with the
      message <code class="zig">msg</code>.
      </p>
      <p>
      There are several ways that code avoids being semantically checked, such as
      using <code class="zig"><span class="tok-kw">if</span></code> or <code class="zig"><span class="tok-kw">switch</span></code> with compile time constants,
              and <code class="zig"><span class="tok-kw">comptime</span></code> functions.
      </p>
      

      <h2 id="compileLog"><a href="#toc-compileLog">@compileLog</a> <a class="hdr" href="#compileLog">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@compileLog</span>(args: ...)</code></pre>
      <p>
      This function prints the arguments passed to it at compile-time.
      </p>
      <p>
      To prevent accidentally leaving compile log statements in a codebase,
      a compilation error is added to the build, pointing to the compile
      log statement. This error prevents code from being generated, but
      does not otherwise interfere with analysis.
      </p>
      <p>
      This function can be used to do "printf debugging" on
      compile-time executing code.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">const</span> num1 = blk: {
    <span class="tok-kw">var</span> val1: <span class="tok-type">i32</span> = <span class="tok-number">99</span>;
    <span class="tok-builtin">@compileLog</span>(<span class="tok-str">&quot;comptime val1 = &quot;</span>, val1);
    val1 = val1 + <span class="tok-number">1</span>;
    <span class="tok-kw">break</span> :blk val1;
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;main&quot;</span> {
    <span class="tok-builtin">@compileLog</span>(<span class="tok-str">&quot;comptime in main&quot;</span>);

    print(<span class="tok-str">&quot;Runtime in main, num1 = {}.\n&quot;</span>, .{num1});
}</code></pre><pre><code class="shell">$ zig test test.zig
| *&quot;comptime in main&quot;
| *&quot;comptime val1 = &quot;, 99
<span class="t0_1">./docgen_tmp/test.zig:11:5: </span><span class="t31_1">error: </span><span class="t0_1">found compile log statement</span>
    @compileLog(&quot;comptime in main&quot;);
    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:1:35: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
const print = @import(&quot;std&quot;).debug.print;
                                  <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:13:5: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
    print(&quot;Runtime in main, num1 = {}.\n&quot;, .{num1});
    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:5:5: </span><span class="t31_1">error: </span><span class="t0_1">found compile log statement</span>
    @compileLog(&quot;comptime val1 = &quot;, val1);
    <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:13:46: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
    print(&quot;Runtime in main, num1 = {}.\n&quot;, .{num1});
                                             <span class="t32_1">^</span>
</code></pre>

      <p>
      will ouput:
      </p>
      <p>
      If all <code class="zig"><span class="tok-builtin">@compileLog</span></code> calls are removed or
      not encountered by analysis, the
      program compiles successfully and the generated executable prints:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">const</span> num1 = blk: {
    <span class="tok-kw">var</span> val1: <span class="tok-type">i32</span> = <span class="tok-number">99</span>;
    val1 = val1 + <span class="tok-number">1</span>;
    <span class="tok-kw">break</span> :blk val1;
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;main&quot;</span> {
    print(<span class="tok-str">&quot;Runtime in main, num1 = {}.\n&quot;</span>, .{num1});
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;main&quot;... 
Runtime in main, num1 = 100.

All 1 tests passed.
</code></pre>

      

      <h2 id="ctz"><a href="#toc-ctz">@ctz</a> <a class="hdr" href="#ctz">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@ctz</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, integer: T)</code></pre>
      <p>
      This function counts the number of least-significant (trailing in a big-Endian sense) zeroes in <code class="zig">integer</code>.
      </p>
      <p>
      If <code class="zig">integer</code> is known at <a href="#comptime">comptime</a>,
      the return type is <code class="zig"><span class="tok-type">comptime_int</span></code>.
      Otherwise, the return type is an unsigned integer with the minimum number
      of bits that can represent the bit count of the integer type.
      </p>
      <p>
      If <code class="zig">integer</code> is zero, <code class="zig"><span class="tok-builtin">@ctz</span></code> returns
      the bit width of integer type <code class="zig">T</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#clz">@clz</a></li>
<li><a href="#popCount">@popCount</a></li>
</ul>

      

      <h2 id="cUndef"><a href="#toc-cUndef">@cUndef</a> <a class="hdr" href="#cUndef">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@cUndef</span>(<span class="tok-kw">comptime</span> name: []<span class="tok-type">u8</span>)</code></pre>
      <p>
      This function can only occur inside <code class="zig"><span class="tok-builtin">@cImport</span></code>.
      </p>
      <p>
      This appends <code>#undef $name</code> to the <code class="zig"><span class="tok-builtin">@cImport</span></code>
      temporary buffer.
      </p>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cInclude">@cInclude</a></li>
</ul>

      

      <h2 id="divExact"><a href="#toc-divExact">@divExact</a> <a class="hdr" href="#divExact">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@divExact</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      Exact division. Caller guarantees <code class="zig">denominator != <span class="tok-number">0</span></code> and
          <code class="zig"><span class="tok-builtin">@divTrunc</span>(numerator, denominator) * denominator == numerator</code>.
      </p>
      <ul>
          <li><code class="zig"><span class="tok-builtin">@divExact</span>(<span class="tok-number">6</span>, <span class="tok-number">3</span>) == <span class="tok-number">2</span></code></li>
          <li><code class="zig"><span class="tok-builtin">@divExact</span>(a, b) * b == a</code></li>
      </ul>
      <p>For a function that returns a possible error code, use <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divExact</code>.</p>
      <p>See also:</p><ul>
<li><a href="#divTrunc">@divTrunc</a></li>
<li><a href="#divFloor">@divFloor</a></li>
</ul>

      
      <h2 id="divFloor"><a href="#toc-divFloor">@divFloor</a> <a class="hdr" href="#divFloor">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@divFloor</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      Floored division. Rounds toward negative infinity. For unsigned integers it is
      the same as <code class="zig">numerator / denominator</code>. Caller guarantees <code class="zig">denominator != <span class="tok-number">0</span></code> and
              <code class="zig">!(<span class="tok-builtin">@typeInfo</span>(T) == .Int <span class="tok-kw">and</span> T.is_signed <span class="tok-kw">and</span> numerator == std.math.minInt(T) <span class="tok-kw">and</span> denominator == -<span class="tok-number">1</span>)</code>.
      </p>
      <ul>
          <li><code class="zig"><span class="tok-builtin">@divFloor</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == -<span class="tok-number">2</span></code></li>
          <li><code class="zig">(<span class="tok-builtin">@divFloor</span>(a, b) * b) + <span class="tok-builtin">@mod</span>(a, b) == a</code></li>
      </ul>
      <p>For a function that returns a possible error code, use <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divFloor</code>.</p>
      <p>See also:</p><ul>
<li><a href="#divTrunc">@divTrunc</a></li>
<li><a href="#divExact">@divExact</a></li>
</ul>

      
      <h2 id="divTrunc"><a href="#toc-divTrunc">@divTrunc</a> <a class="hdr" href="#divTrunc">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@divTrunc</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      Truncated division. Rounds toward zero. For unsigned integers it is
      the same as <code class="zig">numerator / denominator</code>. Caller guarantees <code class="zig">denominator != <span class="tok-number">0</span></code> and
              <code class="zig">!(<span class="tok-builtin">@typeInfo</span>(T) == .Int <span class="tok-kw">and</span> T.is_signed <span class="tok-kw">and</span> numerator == std.math.minInt(T) <span class="tok-kw">and</span> denominator == -<span class="tok-number">1</span>)</code>.
      </p>
      <ul>
          <li><code class="zig"><span class="tok-builtin">@divTrunc</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == -<span class="tok-number">1</span></code></li>
          <li><code class="zig">(<span class="tok-builtin">@divTrunc</span>(a, b) * b) + <span class="tok-builtin">@rem</span>(a, b) == a</code></li>
      </ul>
      <p>For a function that returns a possible error code, use <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divTrunc</code>.</p>
      <p>See also:</p><ul>
<li><a href="#divFloor">@divFloor</a></li>
<li><a href="#divExact">@divExact</a></li>
</ul>

      
      <h2 id="embedFile"><a href="#toc-embedFile">@embedFile</a> <a class="hdr" href="#embedFile">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@embedFile</span>(<span class="tok-kw">comptime</span> path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) *<span class="tok-kw">const</span> [X:<span class="tok-number">0</span>]<span class="tok-type">u8</span></code></pre>
      <p>
      This function returns a compile time constant pointer to null-terminated,
      fixed-size array with length equal to the byte count of the file given by
      <code class="zig">path</code>. The contents of the array are the contents of the file.
      This is equivalent to a <a href="#String-Literals-and-Unicode-Code-Point-Literals">string literal</a>
      with the file contents.
      </p>
      <p>
      <code class="zig">path</code> is absolute or relative to the current file, just like <code class="zig"><span class="tok-builtin">@import</span></code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#import">@import</a></li>
</ul>

      

      <h2 id="enumToInt"><a href="#toc-enumToInt">@enumToInt</a> <a class="hdr" href="#enumToInt">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@enumToInt</span>(enum_or_tagged_union: <span class="tok-kw">anytype</span>) <span class="tok-kw">anytype</span></code></pre>
      <p>
      Converts an enumeration value into its integer tag type. When a tagged union is passed,
      the tag value is used as the enumeration value.
      </p>
      <p>
      If there is only one possible enum value, the resut is a <code class="zig"><span class="tok-type">comptime_int</span></code>
      known at <a href="#comptime">comptime</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#intToEnum">@intToEnum</a></li>
</ul>

      

      <h2 id="errorName"><a href="#toc-errorName">@errorName</a> <a class="hdr" href="#errorName">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@errorName</span>(err: <span class="tok-type">anyerror</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre>
      <p>
      This function returns the string representation of an error. The string representation
      of <code class="zig"><span class="tok-kw">error</span>.OutOfMem</code> is <code class="zig"><span class="tok-str">&quot;OutOfMem&quot;</span></code>.
      </p>
      <p>
      If there are no calls to <code class="zig"><span class="tok-builtin">@errorName</span></code> in an entire application,
      or all calls have a compile-time known value for <code class="zig">err</code>, then no
      error name table will be generated.
      </p>
      

      <h2 id="errorReturnTrace"><a href="#toc-errorReturnTrace">@errorReturnTrace</a> <a class="hdr" href="#errorReturnTrace">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@errorReturnTrace</span>() ?*builtin.StackTrace</code></pre>
      <p>
      If the binary is built with error return tracing, and this function is invoked in a
      function that calls a function with an error or error union return type, returns a
      stack trace object. Otherwise returns <a href="#null">null</a>.
      </p>
      

      <h2 id="errorToInt"><a href="#toc-errorToInt">@errorToInt</a> <a class="hdr" href="#errorToInt">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@errorToInt</span>(err: <span class="tok-kw">anytype</span>) std.meta.Int(.unsigned, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">anyerror</span>) * <span class="tok-number">8</span>)</code></pre>
      <p>
      Supports the following types:
      </p>
      <ul>
          <li><a href="#The-Global-Error-Set">The Global Error Set</a></li>
          <li><a href="#Error-Set-Type">Error Set Type</a></li>
          <li><a href="#Error-Union-Type">Error Union Type</a></li>
      </ul>
      <p>
      Converts an error to the integer representation of an error.
      </p>
      <p>
      It is generally recommended to avoid this
      cast, as the integer representation of an error is not stable across source code changes.
      </p>
      <p>See also:</p><ul>
<li><a href="#intToError">@intToError</a></li>
</ul>

      

      <h2 id="errSetCast"><a href="#toc-errSetCast">@errSetCast</a> <a class="hdr" href="#errSetCast">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@errSetCast</span>(<span class="tok-kw">comptime</span> T: DestType, value: <span class="tok-kw">anytype</span>) DestType</code></pre>
      <p>
      Converts an error value from one error set to another error set. Attempting to convert an error
      which is not in the destination error set results in safety-protected <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      

      <h2 id="export"><a href="#toc-export">@export</a> <a class="hdr" href="#export">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@export</span>(target: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> options: std.builtin.ExportOptions) <span class="tok-type">void</span></code></pre>
      <p>
      Creates a symbol in the output object file.
      </p>
      <p>
      This function can be called from a <a href="#comptime">comptime</a> block to conditionally export symbols.
      When <code class="zig">target</code> is a function with the C calling convention and
      <code class="zig">options.linkage</code> is <code class="zig">Strong</code>, this is equivalent to
      the <code class="zig"><span class="tok-kw">export</span></code> keyword used on a function:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-builtin">@export</span>(internalName, .{ .name = <span class="tok-str">&quot;foo&quot;</span>, .linkage = .Strong });
}

<span class="tok-kw">fn</span> <span class="tok-fn">internalName</span>() <span class="tok-kw">callconv</span>(.C) <span class="tok-type">void</span> {}</code></pre><pre><code class="shell">$ zig build-obj test.zig</code></pre>

      <p>This is equivalent to:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {}</code></pre><pre><code class="shell">$ zig build-obj test.zig</code></pre>

      <p>Note that even when using <code class="zig"><span class="tok-kw">export</span></code>, <code class="zig">@&quot;foo&quot;</code> syntax can
      be used to choose any string for the symbol name:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">@&quot;A function name that is a complete sentence.&quot;</span>() <span class="tok-type">void</span> {}</code></pre><pre><code class="shell">$ zig build-obj test.zig</code></pre>

      <p>
      When looking at the resulting object, you can see the symbol is used verbatim:
      </p>
      <pre><code>00000000000001f0 T A function name that is a complete sentence.</code></pre>
      <p>See also:</p><ul>
<li><a href="#Exporting-a-C-Library">Exporting a C Library</a></li>
</ul>

      

      <h2 id="fence"><a href="#toc-fence">@fence</a> <a class="hdr" href="#fence">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@fence</span>(order: AtomicOrder)</code></pre>
      <p>
      The <code class="zig">fence</code> function is used to introduce happens-before edges between operations.
      </p>
      <p>
      <code class="zig">AtomicOrder</code> can be found with <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).AtomicOrder</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
</ul>

      

      <h2 id="field"><a href="#toc-field">@field</a> <a class="hdr" href="#field">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@field</span>(lhs: <span class="tok-kw">anytype</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) (field)</code></pre>
      <p>Performs field access by a compile-time string. Works on both fields and declarations.
      </p>
       <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">u32</span>,
    y: <span class="tok-type">u32</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">var</span> z: <span class="tok-type">u32</span> = <span class="tok-number">1</span>;
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;field access by string&quot;</span> {
    <span class="tok-kw">const</span> expect = std.testing.expect;
    <span class="tok-kw">var</span> p = Point{ .x = <span class="tok-number">0</span>, .y = <span class="tok-number">0</span> };

    <span class="tok-builtin">@field</span>(p, <span class="tok-str">&quot;x&quot;</span>) = <span class="tok-number">4</span>;
    <span class="tok-builtin">@field</span>(p, <span class="tok-str">&quot;y&quot;</span>) = <span class="tok-builtin">@field</span>(p, <span class="tok-str">&quot;x&quot;</span>) + <span class="tok-number">1</span>;

    expect(<span class="tok-builtin">@field</span>(p, <span class="tok-str">&quot;x&quot;</span>) == <span class="tok-number">4</span>);
    expect(<span class="tok-builtin">@field</span>(p, <span class="tok-str">&quot;y&quot;</span>) == <span class="tok-number">5</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;decl access by string&quot;</span> {
    <span class="tok-kw">const</span> expect = std.testing.expect;

    expect(<span class="tok-builtin">@field</span>(Point, <span class="tok-str">&quot;z&quot;</span>) == <span class="tok-number">1</span>);

    <span class="tok-builtin">@field</span>(Point, <span class="tok-str">&quot;z&quot;</span>) = <span class="tok-number">2</span>;
    expect(<span class="tok-builtin">@field</span>(Point, <span class="tok-str">&quot;z&quot;</span>) == <span class="tok-number">2</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/2] test &quot;field access by string&quot;... 
Test [2/2] test &quot;decl access by string&quot;... 

All 2 tests passed.
</code></pre>


      

      <h2 id="fieldParentPtr"><a href="#toc-fieldParentPtr">@fieldParentPtr</a> <a class="hdr" href="#fieldParentPtr">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-kw">comptime</span> ParentType: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    field_ptr: *T) *ParentType</code></pre>
      <p>
      Given a pointer to a field, returns the base pointer of a struct.
      </p>
      

      <h2 id="floatCast"><a href="#toc-floatCast">@floatCast</a> <a class="hdr" href="#floatCast">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@floatCast</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, value: <span class="tok-kw">anytype</span>) DestType</code></pre>
      <p>
      Convert from one float type to another. This cast is safe, but may cause the
      numeric value to lose precision.
      </p>
      

      <h2 id="floatToInt"><a href="#toc-floatToInt">@floatToInt</a> <a class="hdr" href="#floatToInt">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@floatToInt</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, float: <span class="tok-kw">anytype</span>) DestType</code></pre>
      <p>
      Converts the integer part of a floating point number to the destination type.
      </p>
      <p>
      If the integer part of the floating point number cannot fit in the destination type,
      it invokes safety-checked <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#intToFloat">@intToFloat</a></li>
</ul>

      

      <h2 id="frame"><a href="#toc-frame">@frame</a> <a class="hdr" href="#frame">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@frame</span>() *<span class="tok-builtin">@Frame</span>(func)</code></pre>
      <p>
      This function returns a pointer to the frame for a given function. This type
      can be <a href="#Type-Coercion">coerced</a> to <code class="zig"><span class="tok-kw">anyframe</span>-&gt;T</code> and
      to <code class="zig"><span class="tok-kw">anyframe</span></code>, where <code class="zig">T</code> is the return type
      of the function in scope.
      </p>
      <p>
      This function does not mark a suspension point, but it does cause the function in scope
      to become an <a href="#Async-Functions">async function</a>.
      </p>
      

      <h2 id="Frame"><a href="#toc-Frame">@Frame</a> <a class="hdr" href="#Frame">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@Frame</span>(func: <span class="tok-kw">anytype</span>) <span class="tok-type">type</span></code></pre>
      <p>
      This function returns the frame type of a function. This works for <a href="#Async-Functions">Async Functions</a>
      as well as any function without a specific calling convention.
      </p>
      <p>
      This type is suitable to be used as the return type of <a href="#Async-and-Await">async</a> which
      allows one to, for example, heap-allocate an async function frame:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;heap allocated frame&quot;</span> {
    <span class="tok-kw">const</span> frame = <span class="tok-kw">try</span> std.heap.page_allocator.create(<span class="tok-builtin">@Frame</span>(func));
    frame.* = <span class="tok-kw">async</span> func();
}

<span class="tok-kw">fn</span> <span class="tok-fn">func</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">suspend</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;heap allocated frame&quot;... 

All 1 tests passed.
</code></pre>

      

      <h2 id="frameAddress"><a href="#toc-frameAddress">@frameAddress</a> <a class="hdr" href="#frameAddress">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@frameAddress</span>() <span class="tok-type">usize</span></code></pre>
      <p>
      This function returns the base pointer of the current stack frame.
      </p>
      <p>
      The implications of this are target specific and not consistent across all
      platforms. The frame address may not be available in release mode due to
      aggressive optimizations.
      </p>
      <p>
      This function is only valid within function scope.
      </p>
      

      <h2 id="frameSize"><a href="#toc-frameSize">@frameSize</a> <a class="hdr" href="#frameSize">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@frameSize</span>() <span class="tok-type">usize</span></code></pre>
      <p>
      This is the same as <code class="zig"><span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@Frame</span>(func))</code>, where <code class="zig">func</code>
      may be runtime-known.
      </p>
      <p>
      This function is typically used in conjunction with <a href="#asyncCall">@asyncCall</a>.
      </p>
      

      <h2 id="hasDecl"><a href="#toc-hasDecl">@hasDecl</a> <a class="hdr" href="#hasDecl">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@hasDecl</span>(<span class="tok-kw">comptime</span> Container: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre>
      <p>
      Returns whether or not a <a href="#struct">struct</a>, <a href="#enum">enum</a>, or <a href="#union">union</a> has a declaration
      matching <code class="zig">name</code>.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
    nope: <span class="tok-type">i32</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">var</span> blah = <span class="tok-str">&quot;xxx&quot;</span>;
    <span class="tok-kw">const</span> hi = <span class="tok-number">1</span>;
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;@hasDecl&quot;</span> {
    expect(<span class="tok-builtin">@hasDecl</span>(Foo, <span class="tok-str">&quot;blah&quot;</span>));

    <span class="tok-comment">// Even though `hi` is private, @hasDecl returns true because this test is</span>
    <span class="tok-comment">// in the same file scope as Foo. It would return false if Foo was declared</span>
    <span class="tok-comment">// in a different file.</span>
    expect(<span class="tok-builtin">@hasDecl</span>(Foo, <span class="tok-str">&quot;hi&quot;</span>));

    <span class="tok-comment">// @hasDecl is for declarations; not fields.</span>
    expect(!<span class="tok-builtin">@hasDecl</span>(Foo, <span class="tok-str">&quot;nope&quot;</span>));
    expect(!<span class="tok-builtin">@hasDecl</span>(Foo, <span class="tok-str">&quot;nope1234&quot;</span>));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;@hasDecl&quot;... 

All 1 tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#hasField">@hasField</a></li>
</ul>

      

      <h2 id="hasField"><a href="#toc-hasField">@hasField</a> <a class="hdr" href="#hasField">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@hasField</span>(<span class="tok-kw">comptime</span> Container: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span></code></pre>
      <p>Returns whether the field name of a struct, union, or enum exists.</p>
      <p>
      The result is a compile time constant.
      </p>
      <p>
      It does not include functions, variables, or constants.
      </p>
      <p>See also:</p><ul>
<li><a href="#hasDecl">@hasDecl</a></li>
</ul>

      

      <h2 id="import"><a href="#toc-import">@import</a> <a class="hdr" href="#import">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-kw">comptime</span> path: []<span class="tok-type">u8</span>) <span class="tok-type">type</span></code></pre>
      <p>
      This function finds a zig file corresponding to <code class="zig">path</code> and adds it to the build,
      if it is not already added.
      </p>
      <p>
      Zig source files are implicitly structs, with a name equal to the file's basename with the extension
      truncated. <code class="zig"><span class="tok-builtin">@import</span></code> returns the struct type corresponding to the file.
      </p>
      <p>
      Declarations which have the <code class="zig"><span class="tok-kw">pub</span></code> keyword may be referenced from a different
      source file than the one they are declared in.
      </p>
      <p>
      <code class="zig">path</code> can be a relative path or it can be the name of a package.
      If it is a relative path, it is relative to the file that contains the <code class="zig"><span class="tok-builtin">@import</span></code>
      function call.
      </p>
      <p>
      The following packages are always available:
      </p>
      <ul>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>)</code> - Zig Standard Library</li>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>)</code> - Compiler-provided types and variables.
              The command <code>zig builtin</code> outputs the source to stdout for reference.
          </li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
<li><a href="#embedFile">@embedFile</a></li>
</ul>

      

      <h2 id="intCast"><a href="#toc-intCast">@intCast</a> <a class="hdr" href="#intCast">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@intCast</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, int: <span class="tok-kw">anytype</span>) DestType</code></pre>
      <p>
      Converts an integer to another integer while keeping the same numerical value.
      Attempting to convert a number which is out of range of the destination type results in
      safety-protected <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      <p>
      If <code class="zig">T</code> is <code class="zig"><span class="tok-type">comptime_int</span></code>,
      then this is semantically equivalent to <a href="#Type-Coercion">Type Coercion</a>.
      </p>
      

      <h2 id="intToEnum"><a href="#toc-intToEnum">@intToEnum</a> <a class="hdr" href="#intToEnum">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@intToEnum</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, int_value: std.meta.Tag(DestType)) DestType</code></pre>
      <p>
      Converts an integer into an <a href="#enum">enum</a> value.
      </p>
      <p>
      Attempting to convert an integer which represents no value in the chosen enum type invokes
      safety-checked <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#enumToInt">@enumToInt</a></li>
</ul>

      

      <h2 id="intToError"><a href="#toc-intToError">@intToError</a> <a class="hdr" href="#intToError">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@intToError</span>(value: std.meta.Int(.unsigned, <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">anyerror</span>) * <span class="tok-number">8</span>)) <span class="tok-type">anyerror</span></code></pre>
      <p>
      Converts from the integer representation of an error into <a href="#The-Global-Error-Set">The Global Error Set</a> type.
      </p>
      <p>
      It is generally recommended to avoid this
      cast, as the integer representation of an error is not stable across source code changes.
      </p>
      <p>
      Attempting to convert an integer that does not correspond to any error results in
      safety-protected <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#errorToInt">@errorToInt</a></li>
</ul>

      

      <h2 id="intToFloat"><a href="#toc-intToFloat">@intToFloat</a> <a class="hdr" href="#intToFloat">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@intToFloat</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, int: <span class="tok-kw">anytype</span>) DestType</code></pre>
      <p>
      Converts an integer to the closest floating point representation. To convert the other way, use <a href="#floatToInt">@floatToInt</a>. This cast is always safe.
      </p>
      

      <h2 id="intToPtr"><a href="#toc-intToPtr">@intToPtr</a> <a class="hdr" href="#intToPtr">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@intToPtr</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, address: <span class="tok-type">usize</span>) DestType</code></pre>
      <p>
      Converts an integer to a <a href="#Pointers">pointer</a>. To convert the other way, use <a href="#ptrToInt">@ptrToInt</a>.
      </p>
      <p>
      If the destination pointer type does not allow address zero and <code class="zig">address</code>
      is zero, this invokes safety-checked <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      

      <h2 id="memcpy"><a href="#toc-memcpy">@memcpy</a> <a class="hdr" href="#memcpy">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@memcpy</span>(<span class="tok-kw">noalias</span> dest: [*]<span class="tok-type">u8</span>, <span class="tok-kw">noalias</span> source: [*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, byte_count: <span class="tok-type">usize</span>)</code></pre>
      <p>
      This function copies bytes from one region of memory to another. <code class="zig">dest</code> and
          <code class="zig">source</code> are both pointers and must not overlap.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms. Most code
      should not use this function, instead using something like this:
      </p>
      <pre><code class="zig"><span class="tok-kw">for</span> (source[<span class="tok-number">0</span>..byte_count]) |b, i| dest[i] = b;</code></pre>
      <p>
      The optimizer is intelligent enough to turn the above snippet into a memcpy.
      </p>
      <p>There is also a standard library function for this:</p>
      <pre><code class="zig"><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;
mem.copy(<span class="tok-type">u8</span>, dest[<span class="tok-number">0</span>..byte_count], source[<span class="tok-number">0</span>..byte_count]);</code></pre>
      

      <h2 id="memset"><a href="#toc-memset">@memset</a> <a class="hdr" href="#memset">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@memset</span>(dest: [*]<span class="tok-type">u8</span>, c: <span class="tok-type">u8</span>, byte_count: <span class="tok-type">usize</span>)</code></pre>
      <p>
      This function sets a region of memory to <code class="zig">c</code>. <code class="zig">dest</code> is a pointer.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms. Most
      code should not use this function, instead using something like this:
      </p>
      <pre><code class="zig"><span class="tok-kw">for</span> (dest[<span class="tok-number">0</span>..byte_count]) |*b| b.* = c;</code></pre>
      <p>
      The optimizer is intelligent enough to turn the above snippet into a memset.
      </p>
      <p>There is also a standard library function for this:</p>
      <pre><code class="zig"><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;
mem.set(<span class="tok-type">u8</span>, dest, c);</code></pre>
      

      <h2 id="wasmMemorySize"><a href="#toc-wasmMemorySize">@wasmMemorySize</a> <a class="hdr" href="#wasmMemorySize">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@wasmMemorySize</span>(index: <span class="tok-type">u32</span>) <span class="tok-type">u32</span></code></pre>
      <p>
      This function returns the size of the Wasm memory identified by <code class="zig">index</code> as
      an unsigned value in units of Wasm pages. Note that each Wasm page is 64KB in size.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms usually useful for allocator
      designers targeting Wasm. So unless you are writing a new allocator from scratch, you should use
      something like <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).heap.WasmPageAllocator</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#wasmMemoryGrow">@wasmMemoryGrow</a></li>
</ul>

      

      <h2 id="wasmMemoryGrow"><a href="#toc-wasmMemoryGrow">@wasmMemoryGrow</a> <a class="hdr" href="#wasmMemoryGrow">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@wasmMemoryGrow</span>(index: <span class="tok-type">u32</span>, delta: <span class="tok-type">u32</span>) <span class="tok-type">i32</span></code></pre>
      <p>
      This function increases the size of the Wasm memory identified by <code class="zig">index</code> by
      <code class="zig">delta</code> in units of unsigned number of Wasm pages. Note that each Wasm page
      is 64KB in size. On success, returns previous memory size; on failure, if the allocation fails,
      returns -1.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms usually useful for allocator
      designers targeting Wasm. So unless you are writing a new allocator from scratch, you should use
      something like <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).heap.WasmPageAllocator</code>.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;@wasmMemoryGrow&quot;</span> {
    <span class="tok-kw">if</span> (builtin.arch != .wasm32) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.SkipZigTest;

    <span class="tok-kw">var</span> prev = <span class="tok-builtin">@wasmMemorySize</span>(<span class="tok-number">0</span>);
    expect(prev == <span class="tok-builtin">@wasmMemoryGrow</span>(<span class="tok-number">0</span>, <span class="tok-number">1</span>));
    expect(prev + <span class="tok-number">1</span> == <span class="tok-builtin">@wasmMemorySize</span>(<span class="tok-number">0</span>));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;@wasmMemoryGrow&quot;... 
Test [2/1] 
test &quot;@wasmMemoryGrow&quot;...SKIP

0 passed; 1 skipped.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#wasmMemorySize">@wasmMemorySize</a></li>
</ul>

      

      <h2 id="mod"><a href="#toc-mod">@mod</a> <a class="hdr" href="#mod">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@mod</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      Modulus division. For unsigned integers this is the same as
      <code class="zig">numerator % denominator</code>. Caller guarantees <code class="zig">denominator &gt; <span class="tok-number">0</span></code>.
      </p>
      <ul>
          <li><code class="zig"><span class="tok-builtin">@mod</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == <span class="tok-number">1</span></code></li>
          <li><code class="zig">(<span class="tok-builtin">@divFloor</span>(a, b) * b) + <span class="tok-builtin">@mod</span>(a, b) == a</code></li>
      </ul>
      <p>For a function that returns an error code, see <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.mod</code>.</p>
      <p>See also:</p><ul>
<li><a href="#rem">@rem</a></li>
</ul>

      

      <h2 id="mulWithOverflow"><a href="#toc-mulWithOverflow">@mulWithOverflow</a> <a class="hdr" href="#mulWithOverflow">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@mulWithOverflow</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T, result: *T) <span class="tok-type">bool</span></code></pre>
      <p>
      Performs <code class="zig">result.* = a * b</code>. If overflow or underflow occurs,
          stores the overflowed bits in <code class="zig">result</code> and returns <code class="zig"><span class="tok-null">true</span></code>.
                  If no overflow or underflow occurs, returns <code class="zig"><span class="tok-null">false</span></code>.
      </p>
      

      <h2 id="panic"><a href="#toc-panic">@panic</a> <a class="hdr" href="#panic">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@panic</span>(message: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">noreturn</span></code></pre>
      <p>
      Invokes the panic handler function. By default the panic handler function
      calls the public <code class="zig">panic</code> function exposed in the root source file, or
      if there is not one specified, the <code class="zig">std.builtin.default_panic</code>
      function from <code class="zig">std/builtin.zig</code>.
      </p>
      <p>Generally it is better to use <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.panic</code>.
          However, <code class="zig"><span class="tok-builtin">@panic</span></code> can be useful for 2 scenarios:
      </p>
      <ul>
        <li>From library code, calling the programmer's panic function if they exposed one in the root source file.</li>
        <li>When mixing C and Zig code, calling the canonical panic implementation across multiple .o files.</li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Root-Source-File">Root Source File</a></li>
</ul>

      

      <h2 id="popCount"><a href="#toc-popCount">@popCount</a> <a class="hdr" href="#popCount">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@popCount</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, integer: T)</code></pre>
      <p>Counts the number of bits set in an integer.</p>
      <p>
      If <code class="zig">integer</code> is known at <a href="#comptime">comptime</a>,
      the return type is <code class="zig"><span class="tok-type">comptime_int</span></code>.
      Otherwise, the return type is an unsigned integer with the minimum number
      of bits that can represent the bit count of the integer type.
      </p>
      <p>See also:</p><ul>
<li><a href="#ctz">@ctz</a></li>
<li><a href="#clz">@clz</a></li>
</ul>

      

      <h2 id="ptrCast"><a href="#toc-ptrCast">@ptrCast</a> <a class="hdr" href="#ptrCast">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@ptrCast</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, value: <span class="tok-kw">anytype</span>) DestType</code></pre>
      <p>
      Converts a pointer of one type to a pointer of another type.
      </p>
      <p>
      <a href="#Optional-Pointers">Optional Pointers</a> are allowed. Casting an optional pointer which is <a href="#null">null</a>
      to a non-optional pointer invokes safety-checked <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      

      <h2 id="ptrToInt"><a href="#toc-ptrToInt">@ptrToInt</a> <a class="hdr" href="#ptrToInt">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@ptrToInt</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-type">usize</span></code></pre>
      <p>
      Converts <code class="zig">value</code> to a <code class="zig"><span class="tok-type">usize</span></code> which is the address of the pointer. <code class="zig">value</code> can be one of these types:
      </p>
      <ul>
          <li><code class="zig">*T</code></li>
          <li><code class="zig">?*T</code></li>
          <li><code class="zig"><span class="tok-kw">fn</span>()</code></li>
          <li><code class="zig">?<span class="tok-kw">fn</span>()</code></li>
      </ul>
      <p>To convert the other way, use <a href="#intToPtr">@intToPtr</a></p>

      

      <h2 id="rem"><a href="#toc-rem">@rem</a> <a class="hdr" href="#rem">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@rem</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      Remainder division. For unsigned integers this is the same as
      <code class="zig">numerator % denominator</code>. Caller guarantees <code class="zig">denominator &gt; <span class="tok-number">0</span></code>.
      </p>
      <ul>
          <li><code class="zig"><span class="tok-builtin">@rem</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == -<span class="tok-number">2</span></code></li>
          <li><code class="zig">(<span class="tok-builtin">@divTrunc</span>(a, b) * b) + <span class="tok-builtin">@rem</span>(a, b) == a</code></li>
      </ul>
      <p>For a function that returns an error code, see <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.rem</code>.</p>
      <p>See also:</p><ul>
<li><a href="#mod">@mod</a></li>
</ul>

      

      <h2 id="returnAddress"><a href="#toc-returnAddress">@returnAddress</a> <a class="hdr" href="#returnAddress">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@returnAddress</span>() <span class="tok-type">usize</span></code></pre>
      <p>
      This function returns the address of the next machine code instruction that will be executed
      when the current function returns.
      </p>
      <p>
      The implications of this are target specific and not consistent across
      all platforms.
      </p>
      <p>
      This function is only valid within function scope. If the function gets inlined into
      a calling function, the returned address will apply to the calling function.
      </p>
      
      <h2 id="setAlignStack"><a href="#toc-setAlignStack">@setAlignStack</a> <a class="hdr" href="#setAlignStack">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@setAlignStack</span>(<span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>)</code></pre>
      <p>
      Ensures that a function will have a stack alignment of at least <code class="zig">alignment</code> bytes.
      </p>
      

      <h2 id="setCold"><a href="#toc-setCold">@setCold</a> <a class="hdr" href="#setCold">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@setCold</span>(is_cold: <span class="tok-type">bool</span>)</code></pre>
      <p>
      Tells the optimizer that a function is rarely called.
      </p>
      

      <h2 id="setEvalBranchQuota"><a href="#toc-setEvalBranchQuota">@setEvalBranchQuota</a> <a class="hdr" href="#setEvalBranchQuota">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@setEvalBranchQuota</span>(new_quota: <span class="tok-type">u32</span>)</code></pre>
      <p>
      Changes the maximum number of backwards branches that compile-time code
      execution can use before giving up and making a compile error.
      </p>
      <p>
      If the <code class="zig">new_quota</code> is smaller than the default quota (<code class="zig"><span class="tok-number">1000</span></code>) or
      a previously explicitly set quota, it is ignored.
      </p>
      <p>
      Example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;foo&quot;</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; <span class="tok-number">1001</span>) : (i += <span class="tok-number">1</span>) {}
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:4:9: </span><span class="t31_1">error: </span><span class="t0_1">evaluation exceeded 1000 backwards branches</span>
        while (i &lt; 1001) : (i += 1) {}
        <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:1:12: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
test &quot;foo&quot; {
           <span class="t32_1">^</span>
</code></pre>

      <p>Now we use <code class="zig"><span class="tok-builtin">@setEvalBranchQuota</span></code>:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;foo&quot;</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">1001</span>);
        <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; <span class="tok-number">1001</span>) : (i += <span class="tok-number">1</span>) {}
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;foo&quot;... 

All 1 tests passed.
</code></pre>


      <p>See also:</p><ul>
<li><a href="#comptime">comptime</a></li>
</ul>

      

      <h2 id="setFloatMode"><a href="#toc-setFloatMode">@setFloatMode</a> <a class="hdr" href="#setFloatMode">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@setFloatMode</span>(mode: <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).FloatMode)</code></pre>
      <p>
      Sets the floating point mode of the current scope. Possible values are:
      </p>
      <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FloatMode = <span class="tok-kw">enum</span> {
    Strict,
    Optimized,
};</code></pre>
      <ul>
        <li>
            <code class="zig">Strict</code> (default) - Floating point operations follow strict IEEE compliance.
        </li>
        <li>
            <code class="zig">Optimized</code> - Floating point operations may do all of the following:
          <ul>
            <li>Assume the arguments and result are not NaN. Optimizations are required to retain defined behavior over NaNs, but the value of the result is undefined.</li>
            <li>Assume the arguments and result are not +/-Inf. Optimizations are required to retain defined behavior over +/-Inf, but the value of the result is undefined.</li>
            <li>Treat the sign of a zero argument or result as insignificant.</li>
            <li>Use the reciprocal of an argument rather than perform division.</li>
            <li>Perform floating-point contraction (e.g. fusing a multiply followed by an addition into a fused multiply-and-add).</li>
            <li>Perform algebraically equivalent transformations that may change results in floating point (e.g. reassociate).</li>
          </ul>
          This is equivalent to <code>-ffast-math</code> in GCC.
        </li>
      </ul>
      <p>
      The floating point mode is inherited by child scopes, and can be overridden in any scope.
      You can set the floating point mode in a struct or module scope by using a comptime block.
      </p>
      <p>See also:</p><ul>
<li><a href="#Floating-Point-Operations">Floating Point Operations</a></li>
</ul>

      

      <h2 id="setRuntimeSafety"><a href="#toc-setRuntimeSafety">@setRuntimeSafety</a> <a class="hdr" href="#setRuntimeSafety">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@setRuntimeSafety</span>(safety_on: <span class="tok-type">bool</span>)</code></pre>
      <p>
      Sets whether runtime safety checks are enabled for the scope that contains the function call.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;@setRuntimeSafety&quot;</span> {
    <span class="tok-comment">// The builtin applies to the scope that it is called in. So here, integer overflow</span>
    <span class="tok-comment">// will not be caught in ReleaseFast and ReleaseSmall modes:</span>
    <span class="tok-comment">// var x: u8 = 255;</span>
    <span class="tok-comment">// x += 1; // undefined behavior in ReleaseFast/ReleaseSmall modes.</span>
    {
        <span class="tok-comment">// However this block has safety enabled, so safety checks happen here,</span>
        <span class="tok-comment">// even in ReleaseFast and ReleaseSmall modes.</span>
        <span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">true</span>);
        <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
        x += <span class="tok-number">1</span>;

        {
            <span class="tok-comment">// The value can be overridden at any scope. So here integer overflow</span>
            <span class="tok-comment">// would not be caught in any build mode.</span>
            <span class="tok-builtin">@setRuntimeSafety</span>(<span class="tok-null">false</span>);
            <span class="tok-comment">// var x: u8 = 255;</span>
            <span class="tok-comment">// x += 1; // undefined behavior in all build modes.</span>
        }
    }
}</code></pre><pre><code class="shell">$ zig test test.zig -OReleaseFast
Test [1/1] test &quot;@setRuntimeSafety&quot;... 
thread 3377 panic: integer overflow
error: the following test command crashed:
docgen_tmp/zig-cache/o/1ff0859384c59a7d907b1ce9d27729f9/test /home/vsts/work/1/s/build/release/bin/zig
</code></pre>

      <p>Note: it is <a href="https://github.com/ziglang/zig/issues/978">planned</a> to replace
      <code class="zig"><span class="tok-builtin">@setRuntimeSafety</span></code> with <code>@optimizeFor</code></p>

      

      <h2 id="shlExact"><a href="#toc-shlExact">@shlExact</a> <a class="hdr" href="#shlExact">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@shlExact</span>(value: T, shift_amt: Log2T) T</code></pre>
      <p>
      Performs the left shift operation (<code class="zig">&lt;&lt;</code>). Caller guarantees
      that the shift will not shift any 1 bits out.
      </p>
      <p>
      The type of <code class="zig">shift_amt</code> is an unsigned integer with <code class="zig">log2(T.bit_count)</code> bits.
              This is because <code class="zig">shift_amt &gt;= T.bit_count</code> is undefined behavior.
      </p>
      <p>See also:</p><ul>
<li><a href="#shrExact">@shrExact</a></li>
<li><a href="#shlWithOverflow">@shlWithOverflow</a></li>
</ul>

      

      <h2 id="shlWithOverflow"><a href="#toc-shlWithOverflow">@shlWithOverflow</a> <a class="hdr" href="#shlWithOverflow">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@shlWithOverflow</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, shift_amt: Log2T, result: *T) <span class="tok-type">bool</span></code></pre>
      <p>
      Performs <code class="zig">result.* = a &lt;&lt; b</code>. If overflow or underflow occurs,
                 stores the overflowed bits in <code class="zig">result</code> and returns <code class="zig"><span class="tok-null">true</span></code>.
                         If no overflow or underflow occurs, returns <code class="zig"><span class="tok-null">false</span></code>.
      </p>
      <p>
      The type of <code class="zig">shift_amt</code> is an unsigned integer with <code class="zig">log2(T.bit_count)</code> bits.
              This is because <code class="zig">shift_amt &gt;= T.bit_count</code> is undefined behavior.
      </p>
      <p>See also:</p><ul>
<li><a href="#shlExact">@shlExact</a></li>
<li><a href="#shrExact">@shrExact</a></li>
</ul>

      

      <h2 id="shrExact"><a href="#toc-shrExact">@shrExact</a> <a class="hdr" href="#shrExact">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@shrExact</span>(value: T, shift_amt: Log2T) T</code></pre>
      <p>
      Performs the right shift operation (<code class="zig">&gt;&gt;</code>). Caller guarantees
      that the shift will not shift any 1 bits out.
      </p>
      <p>
      The type of <code class="zig">shift_amt</code> is an unsigned integer with <code class="zig">log2(T.bit_count)</code> bits.
              This is because <code class="zig">shift_amt &gt;= T.bit_count</code> is undefined behavior.
      </p>
      <p>See also:</p><ul>
<li><a href="#shlExact">@shlExact</a></li>
<li><a href="#shlWithOverflow">@shlWithOverflow</a></li>
</ul>

      

      <h2 id="shuffle"><a href="#toc-shuffle">@shuffle</a> <a class="hdr" href="#shuffle">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@shuffle</span>(<span class="tok-kw">comptime</span> E: <span class="tok-type">type</span>, a: std.meta.Vector(a_len, E), b: std.meta.Vector(b_len, E), <span class="tok-kw">comptime</span> mask: std.meta.Vector(mask_len, <span class="tok-type">i32</span>)) std.meta.Vector(mask_len, E)</code></pre>
      <p>
      Constructs a new <a href="#Vectors">vector</a> by selecting elements from <code class="zig">a</code> and
      <code class="zig">b</code> based on <code class="zig">mask</code>.
      </p>
      <p>
      Each element in <code class="zig">mask</code> selects an element from either <code class="zig">a</code> or
      <code class="zig">b</code>. Positive numbers select from <code class="zig">a</code> starting at 0.
      Negative values select from <code class="zig">b</code>, starting at <code class="zig">-<span class="tok-number">1</span></code> and going down.
      It is recommended to use the <code class="zig">~</code> operator from indexes from <code class="zig">b</code>
      so that both indexes can start from <code class="zig"><span class="tok-number">0</span></code> (i.e. <code class="zig">~<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">0</span>)</code> is
      <code class="zig">-<span class="tok-number">1</span></code>).
      </p>
      <p>
      For each element of <code class="zig">mask</code>, if it or the selected value from
      <code class="zig">a</code> or <code class="zig">b</code> is <code class="zig"><span class="tok-null">undefined</span></code>,
      then the resulting element is <code class="zig"><span class="tok-null">undefined</span></code>.
      </p>
      <p>
      <code class="zig">a_len</code> and <code class="zig">b_len</code> may differ in length. Out-of-bounds element
      indexes in <code class="zig">mask</code> result in compile errors.
      </p>
      <p>
      If <code class="zig">a</code> or <code class="zig">b</code> is <code class="zig"><span class="tok-null">undefined</span></code>, it
      is equivalent to a vector of all <code class="zig"><span class="tok-null">undefined</span></code> with the same length as the other vector.
      If both vectors are <code class="zig"><span class="tok-null">undefined</span></code>, <code class="zig"><span class="tok-builtin">@shuffle</span></code> returns
      a vector with all elements <code class="zig"><span class="tok-null">undefined</span></code>.
      </p>
      <p>
      <code class="zig">E</code> must be an <a href="#Integers">integer</a>, <a href="#Floats">float</a>,
      <a href="#Pointers">pointer</a>, or <code class="zig"><span class="tok-type">bool</span></code>. The mask may be any vector length, and its
      length determines the result length.
      </p>
      <p>See also:</p><ul>
<li><a href="#SIMD">SIMD</a></li>
</ul>

      

      <h2 id="sizeOf"><a href="#toc-sizeOf">@sizeOf</a> <a class="hdr" href="#sizeOf">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@sizeOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      This function returns the number of bytes it takes to store <code class="zig">T</code> in memory.
      The result is a target-specific compile time constant.
      </p>
      <p>
      This size may contain padding bytes. If there were two consecutive T in memory, this would be the offset
      in bytes between element at index 0 and the element at index 1. For <a href="#Integers">integer</a>,
      consider whether you want to use <code class="zig"><span class="tok-builtin">@sizeOf</span>(T)</code> or
      <code class="zig"><span class="tok-builtin">@typeInfo</span>(T).Int.bits</code>.
      </p>
      <p>
      This function measures the size at runtime. For types that are disallowed at runtime, such as
      <code class="zig"><span class="tok-type">comptime_int</span></code> and <code class="zig"><span class="tok-type">type</span></code>, the result is <code class="zig"><span class="tok-number">0</span></code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#bitSizeOf">@bitSizeOf</a></li>
<li><a href="#typeInfo">@typeInfo</a></li>
</ul>

      

      <h2 id="splat"><a href="#toc-splat">@splat</a> <a class="hdr" href="#splat">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@splat</span>(<span class="tok-kw">comptime</span> len: <span class="tok-type">u32</span>, scalar: <span class="tok-kw">anytype</span>) std.meta.Vector(len, <span class="tok-builtin">@TypeOf</span>(scalar))</code></pre>
      <p>
      Produces a vector of length <code class="zig">len</code> where each element is the value
      <code class="zig">scalar</code>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;vector @splat&quot;</span> {
    <span class="tok-kw">const</span> scalar: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
    <span class="tok-kw">const</span> result = <span class="tok-builtin">@splat</span>(<span class="tok-number">4</span>, scalar);
    <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@TypeOf</span>(result) == std.meta.Vector(<span class="tok-number">4</span>, <span class="tok-type">u32</span>));
    expect(std.mem.eql(<span class="tok-type">u32</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">4</span>]<span class="tok-type">u32</span>, result), &amp;[_]<span class="tok-type">u32</span>{ <span class="tok-number">5</span>, <span class="tok-number">5</span>, <span class="tok-number">5</span>, <span class="tok-number">5</span> }));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;vector @splat&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      <code class="zig">scalar</code> must be an <a href="#Integers">integer</a>, <a href="#Primitive-Types">bool</a>,
      <a href="#Floats">float</a>, or <a href="#Pointers">pointer</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Vectors">Vectors</a></li>
<li><a href="#shuffle">@shuffle</a></li>
</ul>

      

      <h2 id="reduce"><a href="#toc-reduce">@reduce</a> <a class="hdr" href="#reduce">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@reduce</span>(<span class="tok-kw">comptime</span> op: builtin.ReduceOp, value: <span class="tok-kw">anytype</span>) std.meta.Child(value)</code></pre>
      <p>
      Transforms a <a href="#Vectors">vector</a> into a scalar value by performing a
      sequential horizontal reduction of its elements using the specified operator <code class="zig">op</code>.
      </p>
      <p>
      Not every operator is available for every vector element type:
      </p>
      <ul>
          <li><code class="zig">.And</code>, <code class="zig">.Or</code>,
            <code class="zig">.Xor</code> are available for
            <code class="zig"><span class="tok-type">bool</span></code> vectors,</li>
          <li><code class="zig">.Min</code>, <code class="zig">.Max</code>,
            <code class="zig">.Add</code>, <code class="zig">.Mul</code> are
            available for <a href="#Floats">floating point</a> vectors,</li>
          <li>Every operator is available for <a href="#Integers">integer</a> vectors.
      </ul>
      <p>
      Note that <code class="zig">.Add</code> and <code class="zig">.Mul</code>
      reductions on integral types are wrapping; when applied on floating point
      types the operation associativity is preserved, unless the float mode is
      set to <code class="zig">Optimized</code>.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;vector @reduce&quot;</span> {
    <span class="tok-kw">const</span> value: std.meta.Vector(<span class="tok-number">4</span>, <span class="tok-type">i32</span>) = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, -<span class="tok-number">1</span>, <span class="tok-number">1</span>, -<span class="tok-number">1</span> };
    <span class="tok-kw">const</span> result = value &gt; <span class="tok-builtin">@splat</span>(<span class="tok-number">4</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-number">0</span>));
    <span class="tok-comment">// result is { true, false, true, false };</span>
    <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@TypeOf</span>(result) == std.meta.Vector(<span class="tok-number">4</span>, <span class="tok-type">bool</span>));
    <span class="tok-kw">const</span> is_all_true = <span class="tok-builtin">@reduce</span>(.And, result);
    <span class="tok-kw">comptime</span> expect(<span class="tok-builtin">@TypeOf</span>(is_all_true) == <span class="tok-type">bool</span>);
    expect(is_all_true == <span class="tok-null">false</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;vector @reduce&quot;... 

All 1 tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Vectors">Vectors</a></li>
<li><a href="#setFloatMode">@setFloatMode</a></li>
</ul>

      

      <h2 id="src"><a href="#toc-src">@src</a> <a class="hdr" href="#src">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@src</span>() std.builtin.SourceLocation</code></pre>
      <p>
      Returns a <code class="zig">SourceLocation</code> struct representing the function's name and location in the source code. This must be called in a function.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;@src&quot;</span> {
    doTheTest();
}

<span class="tok-kw">fn</span> <span class="tok-fn">doTheTest</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> src = <span class="tok-builtin">@src</span>();

    expect(src.line == <span class="tok-number">9</span>);
    expect(src.column == <span class="tok-number">17</span>);
    expect(std.mem.endsWith(<span class="tok-type">u8</span>, src.fn_name, <span class="tok-str">&quot;doTheTest&quot;</span>));
    expect(std.mem.endsWith(<span class="tok-type">u8</span>, src.file, <span class="tok-str">&quot;test.zig&quot;</span>));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;@src&quot;... 

All 1 tests passed.
</code></pre>

      
      <h2 id="sqrt"><a href="#toc-sqrt">@sqrt</a> <a class="hdr" href="#sqrt">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@sqrt</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Performs the square root of a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats, with the caveat that
      <a href="https://github.com/ziglang/zig/issues/4026">some float operations are not yet implemented for all float types</a>.
      </p>
      
      <h2 id="sin"><a href="#toc-sin">@sin</a> <a class="hdr" href="#sin">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@sin</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Sine trigometric function on a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats, with the caveat that
      <a href="https://github.com/ziglang/zig/issues/4026">some float operations are not yet implemented for all float types</a>.
      </p>
      
      <h2 id="cos"><a href="#toc-cos">@cos</a> <a class="hdr" href="#cos">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@cos</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Cosine trigometric function on a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats, with the caveat that
      <a href="https://github.com/ziglang/zig/issues/4026">some float operations are not yet implemented for all float types</a>.
      </p>
      
      <h2 id="exp"><a href="#toc-exp">@exp</a> <a class="hdr" href="#exp">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@exp</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Base-e exponential function on a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats, with the caveat that
      <a href="https://github.com/ziglang/zig/issues/4026">some float operations are not yet implemented for all float types</a>.
      </p>
      
      <h2 id="exp2"><a href="#toc-exp2">@exp2</a> <a class="hdr" href="#exp2">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@exp2</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Base-2 exponential function on a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats, with the caveat that
      <a href="https://github.com/ziglang/zig/issues/4026">some float operations are not yet implemented for all float types</a>.
      </p>
      
      <h2 id="log"><a href="#toc-log">@log</a> <a class="hdr" href="#log">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@log</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the natural logarithm of a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats, with the caveat that
      <a href="https://github.com/ziglang/zig/issues/4026">some float operations are not yet implemented for all float types</a>.
      </p>
      
      <h2 id="log2"><a href="#toc-log2">@log2</a> <a class="hdr" href="#log2">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@log2</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the logarithm to the base 2 of a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats, with the caveat that
      <a href="https://github.com/ziglang/zig/issues/4026">some float operations are not yet implemented for all float types</a>.
      </p>
      
      <h2 id="log10"><a href="#toc-log10">@log10</a> <a class="hdr" href="#log10">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@log10</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the logarithm to the base 10 of a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats, with the caveat that
      <a href="https://github.com/ziglang/zig/issues/4026">some float operations are not yet implemented for all float types</a>.
      </p>
      
      <h2 id="fabs"><a href="#toc-fabs">@fabs</a> <a class="hdr" href="#fabs">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@fabs</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the absolute value of a floating point number. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats, with the caveat that
      <a href="https://github.com/ziglang/zig/issues/4026">some float operations are not yet implemented for all float types</a>.
      </p>
      
      <h2 id="floor"><a href="#toc-floor">@floor</a> <a class="hdr" href="#floor">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@floor</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the largest integral value not greater than the given floating point number.
      Uses a dedicated hardware instruction when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats, with the caveat that
      <a href="https://github.com/ziglang/zig/issues/4026">some float operations are not yet implemented for all float types</a>.
      </p>
      
      <h2 id="ceil"><a href="#toc-ceil">@ceil</a> <a class="hdr" href="#ceil">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@ceil</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Returns the largest integral value not less than the given floating point number.
      Uses a dedicated hardware instruction when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats, with the caveat that
      <a href="https://github.com/ziglang/zig/issues/4026">some float operations are not yet implemented for all float types</a>.
      </p>
      
      <h2 id="trunc"><a href="#toc-trunc">@trunc</a> <a class="hdr" href="#trunc">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@trunc</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Rounds the given floating point number to an integer, towards zero.
      Uses a dedicated hardware instruction when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats, with the caveat that
      <a href="https://github.com/ziglang/zig/issues/4026">some float operations are not yet implemented for all float types</a>.
      </p>
      
      <h2 id="round"><a href="#toc-round">@round</a> <a class="hdr" href="#round">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@round</span>(value: <span class="tok-kw">anytype</span>) <span class="tok-builtin">@TypeOf</span>(value)</code></pre>
      <p>
      Rounds the given floating point number to an integer, away from zero. Uses a dedicated hardware instruction
      when available.
      </p>
      <p>
      Supports <a href="#Floats">Floats</a> and <a href="#Vectors">Vectors</a> of floats, with the caveat that
      <a href="https://github.com/ziglang/zig/issues/4026">some float operations are not yet implemented for all float types</a>.
      </p>
      

      <h2 id="subWithOverflow"><a href="#toc-subWithOverflow">@subWithOverflow</a> <a class="hdr" href="#subWithOverflow">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@subWithOverflow</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T, result: *T) <span class="tok-type">bool</span></code></pre>
      <p>
      Performs <code class="zig">result.* = a - b</code>. If overflow or underflow occurs,
          stores the overflowed bits in <code class="zig">result</code> and returns <code class="zig"><span class="tok-null">true</span></code>.
                  If no overflow or underflow occurs, returns <code class="zig"><span class="tok-null">false</span></code>.
      </p>
      

      <h2 id="tagName"><a href="#toc-tagName">@tagName</a> <a class="hdr" href="#tagName">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@tagName</span>(value: <span class="tok-kw">anytype</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre>
      <p>
      Converts an enum value or union value to a slice of bytes representing the name.</p><p>If the enum is non-exhaustive and the tag value does not map to a name, it invokes safety-checked <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      

      <h2 id="This"><a href="#toc-This">@This</a> <a class="hdr" href="#This">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@This</span>() <span class="tok-type">type</span></code></pre>
      <p>
      Returns the innermost struct, enum, or union that this function call is inside.
      This can be useful for an anonymous struct that needs to refer to itself:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;@This()&quot;</span> {
    <span class="tok-kw">var</span> items = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> list = List(<span class="tok-type">i32</span>){ .items = items[<span class="tok-number">0</span>..] };
    expect(list.length() == <span class="tok-number">4</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">List</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        items: []T,

        <span class="tok-kw">fn</span> <span class="tok-fn">length</span>(self: Self) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.items.len;
        }
    };
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;@This()&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      When <code class="zig"><span class="tok-builtin">@This</span>()</code> is used at global scope, it returns a reference to the
      struct that corresponds to the current file.
      </p>
      

      <h2 id="truncate"><a href="#toc-truncate">@truncate</a> <a class="hdr" href="#truncate">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@truncate</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, integer: <span class="tok-kw">anytype</span>) T</code></pre>
      <p>
      This function truncates bits from an integer type, resulting in a smaller
      or same-sized integer type.
      </p>
      <p>
      The following produces safety-checked <a href="#Undefined-Behavior">Undefined Behavior</a>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;integer cast panic&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u16</span> = <span class="tok-number">0xabcd</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u8</span> = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u8</span>, a);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;integer cast panic&quot;... 
thread 3422 panic: integer cast truncated bits
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:3:17</span>: <span class="t2_0">0x2065d5 in test &quot;integer cast panic&quot; (test)</span>
    var b: u8 = @intCast(u8, a);
                <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/special/test_runner.zig:69:28</span>: <span class="t2_0">0x2302b8 in std.special.main (test)</span>
        } else test_fn.func();
                           <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:420:37</span>: <span class="t2_0">0x207dc4 in std.start.posixCallMainAndExit (test)</span>
            const result = root.main() catch |err| {
                                    <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x207c62 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
error: the following test command crashed:
docgen_tmp/zig-cache/o/091db03e22edfdd7844d6b7c020b80d0/test /home/vsts/work/1/s/build/release/bin/zig
</code></pre>

      <p>
      However this is well defined and working code:
      </p>
      <p class="file">truncate.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;integer truncation&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u16</span> = <span class="tok-number">0xabcd</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u8</span> = <span class="tok-builtin">@truncate</span>(<span class="tok-type">u8</span>, a);
    expect(b == <span class="tok-number">0xcd</span>);
}</code></pre><pre><code class="shell">$ zig test truncate.zig
Test [1/1] test &quot;integer truncation&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      This function always truncates the significant bits of the integer, regardless
      of endianness on the target platform.
      </p>
      

      <h2 id="Type"><a href="#toc-Type">@Type</a> <a class="hdr" href="#Type">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@Type</span>(<span class="tok-kw">comptime</span> info: <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).TypeInfo) <span class="tok-type">type</span></code></pre>
      <p>
      This function is the inverse of <a href="#typeInfo">@typeInfo</a>. It reifies type information
      into a <code class="zig"><span class="tok-type">type</span></code>.
      </p>
      <p>
      It is available for the following types:
      </p>
      <ul>
          <li><code class="zig"><span class="tok-type">type</span></code></li>
          <li><code class="zig"><span class="tok-type">noreturn</span></code></li>
          <li><code class="zig"><span class="tok-type">void</span></code></li>
          <li><code class="zig"><span class="tok-type">bool</span></code></li>
          <li><a href="#Integers">Integers</a> - The maximum bit count for an integer type is <code class="zig"><span class="tok-number">65535</span></code>.</li>
          <li><a href="#Floats">Floats</a></li>
          <li><a href="#Pointers">Pointers</a></li>
          <li><code class="zig"><span class="tok-type">comptime_int</span></code></li>
          <li><code class="zig"><span class="tok-type">comptime_float</span></code></li>
          <li><code class="zig"><span class="tok-builtin">@TypeOf</span>(<span class="tok-null">undefined</span>)</code></li>
          <li><code class="zig"><span class="tok-builtin">@TypeOf</span>(<span class="tok-null">null</span>)</code></li>
          <li><a href="#Arrays">Arrays</a></li>
          <li><a href="#Optionals">Optionals</a></li>
          <li><a href="#Error-Set-Type">Error Set Type</a></li>
          <li><a href="#Error-Union-Type">Error Union Type</a></li>
          <li><a href="#Vectors">Vectors</a></li>
          <li><a href="#opaque">opaque</a></li>
          <li><a href="#Frame">@Frame</a></li>
          <li><code class="zig"><span class="tok-kw">anyframe</span></code></li>
          <li><a href="#struct">struct</a></li>
          <li><a href="#enum">enum</a></li>
          <li><a href="#Enum-Literals">Enum Literals</a></li>
          <li><a href="#union">union</a></li>
      </ul>
      <p>
      For these types, <code class="zig"><span class="tok-builtin">@Type</span></code> is not available:
      </p>
      <ul>
          <li><a href="#Functions">Functions</a></li>
          <li>BoundFn</li>
      </ul>
      
      <h2 id="typeInfo"><a href="#toc-typeInfo">@typeInfo</a> <a class="hdr" href="#typeInfo">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@typeInfo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).builtin.TypeInfo</code></pre>
      <p>
      Provides type reflection.
      </p>
      <p>
      For <a href="#struct">structs</a>, <a href="#union">unions</a>, <a href="#enum">enums</a>, and
      <a href="#Error-Set-Type">error sets</a>, the fields are guaranteed to be in the same
      order as declared. For declarations, the order is unspecified.
      </p>
      

      <h2 id="typeName"><a href="#toc-typeName">@typeName</a> <a class="hdr" href="#typeName">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@typeName</span>(T: <span class="tok-type">type</span>) [N]<span class="tok-type">u8</span></code></pre>
      <p>
      This function returns the string representation of a type, as
      an array. It is equivalent to a string literal of the type name.
      </p>

      

      <h2 id="TypeOf"><a href="#toc-TypeOf">@TypeOf</a> <a class="hdr" href="#TypeOf">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@TypeOf</span>(...) <span class="tok-type">type</span></code></pre>
      <p>
      <code class="zig"><span class="tok-builtin">@TypeOf</span></code> is a special builtin function that takes any (nonzero) number of expressions
      as parameters and returns the type of the result, using <a href="#Peer-Type-Resolution">Peer Type Resolution</a>.
      </p>
      <p>
      The expressions are evaluated, however they are guaranteed to have no <em>runtime</em> side-effects:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;no runtime side effects&quot;</span> {
    <span class="tok-kw">var</span> data: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> T = <span class="tok-builtin">@TypeOf</span>(foo(<span class="tok-type">i32</span>, &amp;data));
    <span class="tok-kw">comptime</span> expect(T == <span class="tok-type">i32</span>);
    expect(data == <span class="tok-number">0</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T) T {
    ptr.* += <span class="tok-number">1</span>;
    <span class="tok-kw">return</span> ptr.*;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;no runtime side effects&quot;... 

All 1 tests passed.
</code></pre>

      

      <h2 id="unionInit"><a href="#toc-unionInit">@unionInit</a> <a class="hdr" href="#unionInit">§</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@unionInit</span>(<span class="tok-kw">comptime</span> Union: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> active_field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, init_expr) Union</code></pre>
      <p>
      This is the same thing as <a href="#union">union</a> initialization syntax, except that the field name is a
      <a href="#comptime">comptime</a>-known value rather than an identifier token.
      </p>
      <p>
      <code class="zig"><span class="tok-builtin">@unionInit</span></code> forwards its <a href="#Result-Location-Semantics">result location</a> to <code class="zig">init_expr</code>.
      </p>
      
      

      <h1 id="Build-Mode"><a href="#toc-Build-Mode">Build Mode</a> <a class="hdr" href="#Build-Mode">§</a></h1>

      <p>
      Zig has four build modes:
      </p>
      <ul>
        <li><a href="#Debug">Debug</a> (default)</li>
        <li><a href="#ReleaseFast">ReleaseFast</a></li>
        <li><a href="#ReleaseSafe">ReleaseSafe</a></li>
        <li><a href="#ReleaseSmall">ReleaseSmall</a></li>
      </ul>
      <p>
      To add standard build options to a <code>build.zig</code> file:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> Builder = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).build.Builder;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *Builder) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> exe = b.addExecutable(<span class="tok-str">&quot;example&quot;</span>, <span class="tok-str">&quot;example.zig&quot;</span>);
    exe.setBuildMode(b.standardReleaseOptions());
    b.default_step.dependOn(&amp;exe.step);
}</code></pre>
      <p>
      This causes these options to be available:
      </p>
      <pre><code class="shell">  -Drelease-safe=[bool] optimizations on and safety on
  -Drelease-fast=[bool] optimizations on and safety off
  -Drelease-small=[bool] size optimizations on and safety off</code></pre>
      <h2 id="Debug"><a href="#toc-Debug">Debug</a> <a class="hdr" href="#Debug">§</a></h2>

      <pre><code class="shell">$ zig build-exe example.zig</code></pre>
      <ul>
        <li>Fast compilation speed</li>
        <li>Safety checks enabled</li>
        <li>Slow runtime performance</li>
        <li>Large binary size</li>
        <li>No reproducible build requirement</li>
      </ul>
      
      <h2 id="ReleaseFast"><a href="#toc-ReleaseFast">ReleaseFast</a> <a class="hdr" href="#ReleaseFast">§</a></h2>

      <pre><code class="shell">$ zig build-exe example.zig -O ReleaseFast</code></pre>
      <ul>
        <li>Fast runtime performance</li>
        <li>Safety checks disabled</li>
        <li>Slow compilation speed</li>
        <li>Large binary size</li>
        <li>Reproducible build</li>
      </ul>
      
      <h2 id="ReleaseSafe"><a href="#toc-ReleaseSafe">ReleaseSafe</a> <a class="hdr" href="#ReleaseSafe">§</a></h2>

      <pre><code class="shell">$ zig build-exe example.zig -O ReleaseSafe</code></pre>
      <ul>
        <li>Medium runtime performance</li>
        <li>Safety checks enabled</li>
        <li>Slow compilation speed</li>
        <li>Large binary size</li>
        <li>Reproducible build</li>
      </ul>
      
      <h2 id="ReleaseSmall"><a href="#toc-ReleaseSmall">ReleaseSmall</a> <a class="hdr" href="#ReleaseSmall">§</a></h2>

      <pre><code class="shell">$ zig build-exe example.zig -O ReleaseSmall</code></pre>
      <ul>
        <li>Medium runtime performance</li>
        <li>Safety checks disabled</li>
        <li>Slow compilation speed</li>
        <li>Small binary size</li>
        <li>Reproducible build</li>
      </ul>
      
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
<li><a href="#Zig-Build-System">Zig Build System</a></li>
<li><a href="#Undefined-Behavior">Undefined Behavior</a></li>
</ul>

      

      <h1 id="Single-Threaded-Builds"><a href="#toc-Single-Threaded-Builds">Single Threaded Builds</a> <a class="hdr" href="#Single-Threaded-Builds">§</a></h1>

      <p>Zig has a compile option <code>--single-threaded</code> which has the following effects:</p>
      <ul>
        <li>All <a href="#Thread-Local-Variables">Thread Local Variables</a> are treated as <a href="#Global-Variables">Global Variables</a>.</li>
        <li>The overhead of <a href="#Async-Functions">Async Functions</a> becomes equivalent to function call overhead.</li>
        <li>The <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).single_threaded</code> becomes <code class="zig"><span class="tok-null">true</span></code>
          and therefore various userland APIs which read this variable become more efficient.
          For example <code class="zig">std.Mutex</code> becomes
          an empty data structure and all of its functions become no-ops.</li>
      </ul>
      

      <h1 id="Undefined-Behavior"><a href="#toc-Undefined-Behavior">Undefined Behavior</a> <a class="hdr" href="#Undefined-Behavior">§</a></h1>

      <p>
      Zig has many instances of undefined behavior. If undefined behavior is
      detected at compile-time, Zig emits a compile error and refuses to continue.
      Most undefined behavior that cannot be detected at compile-time can be detected
      at runtime. In these cases, Zig has safety checks. Safety checks can be disabled
      on a per-block basis with <a href="#setRuntimeSafety">@setRuntimeSafety</a>. The <a href="#ReleaseFast">ReleaseFast</a>
      and <a href="#ReleaseSmall">ReleaseSmall</a> build modes disable all safety checks (except where overridden
      by <a href="#setRuntimeSafety">@setRuntimeSafety</a>) in order to facilitate optimizations.
      </p>
      <p>
      When a safety check fails, Zig crashes with a stack trace, like this:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;safety check&quot;</span> {
    <span class="tok-kw">unreachable</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;safety check&quot;... 
thread 3456 panic: reached unreachable code
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:2:5</span>: <span class="t2_0">0x2065aa in test &quot;safety check&quot; (test)</span>
    unreachable;
    <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/special/test_runner.zig:69:28</span>: <span class="t2_0">0x230288 in std.special.main (test)</span>
        } else test_fn.func();
                           <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:420:37</span>: <span class="t2_0">0x207d94 in std.start.posixCallMainAndExit (test)</span>
            const result = root.main() catch |err| {
                                    <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x207c32 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
error: the following test command crashed:
docgen_tmp/zig-cache/o/091db03e22edfdd7844d6b7c020b80d0/test /home/vsts/work/1/s/build/release/bin/zig
</code></pre>

      <h2 id="Reaching-Unreachable-Code"><a href="#toc-Reaching-Unreachable-Code">Reaching Unreachable Code</a> <a class="hdr" href="#Reaching-Unreachable-Code">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    assert(<span class="tok-null">false</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>; <span class="tok-comment">// assertion failure</span>
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:5:14: </span><span class="t31_1">error: </span><span class="t0_1">reached unreachable code</span>
    if (!ok) unreachable; // assertion failure
             <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:2:11: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
    assert(false);
          <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:1:10: </span><span class="t36_1">note: </span><span class="t0_1">called from here</span>
comptime {
         <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:2:11: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
    assert(false);
          <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    std.debug.assert(<span class="tok-null">false</span>);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3468 panic: reached unreachable code
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/debug.zig:223:14</span>: <span class="t2_0">0x203fdb in std.debug.assert (test)</span>
    if (!ok) unreachable; // assertion failure
             <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:4:21</span>: <span class="t2_0">0x22d47a in main (test)</span>
    std.debug.assert(false);
                    <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204dde in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204cb2 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      
      <h2 id="Index-out-of-Bounds"><a href="#toc-Index-out-of-Bounds">Index out of Bounds</a> <a class="hdr" href="#Index-out-of-Bounds">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> array: [<span class="tok-number">5</span>]<span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>.*;
    <span class="tok-kw">const</span> garbage = array[<span class="tok-number">5</span>];
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:3:26: </span><span class="t31_1">error: </span><span class="t0_1">index 5 outside array of size 5</span>
    const garbage = array[5];
                         <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x = foo(<span class="tok-str">&quot;hello&quot;</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> x[<span class="tok-number">5</span>];
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3480 panic: index out of bounds
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:6:13</span>: <span class="t2_0">0x2346c9 in foo (test)</span>
    return x[5];
            <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:2:16</span>: <span class="t2_0">0x22d4a6 in main (test)</span>
    var x = foo(&quot;hello&quot;);
               <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204dfe in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204cd2 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      
      <h2 id="Cast-Negative-Number-to-Unsigned-Integer"><a href="#toc-Cast-Negative-Number-to-Unsigned-Integer">Cast Negative Number to Unsigned Integer</a> <a class="hdr" href="#Cast-Negative-Number-to-Unsigned-Integer">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> value: <span class="tok-type">i32</span> = -<span class="tok-number">1</span>;
    <span class="tok-kw">const</span> unsigned = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u32</span>, value);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:3:22: </span><span class="t31_1">error: </span><span class="t0_1">attempt to cast negative value to unsigned integer</span>
    const unsigned = @intCast(u32, value);
                     <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> value: <span class="tok-type">i32</span> = -<span class="tok-number">1</span>;
    <span class="tok-kw">var</span> unsigned = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u32</span>, value);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{unsigned});
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3492 panic: attempt to cast negative value to unsigned integer
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:5:20</span>: <span class="t2_0">0x22d527 in main (test)</span>
    var unsigned = @intCast(u32, value);
                   <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204e4e in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204d22 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      <p>
      To obtain the maximum value of an unsigned integer, use <code class="zig">std.math.maxInt</code>.
      </p>
      
      <h2 id="Cast-Truncates-Data"><a href="#toc-Cast-Truncates-Data">Cast Truncates Data</a> <a class="hdr" href="#Cast-Truncates-Data">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> spartan_count: <span class="tok-type">u16</span> = <span class="tok-number">300</span>;
    <span class="tok-kw">const</span> byte = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u8</span>, spartan_count);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:3:18: </span><span class="t31_1">error: </span><span class="t0_1">cast from 'u16' to 'u8' truncates bits</span>
    const byte = @intCast(u8, spartan_count);
                 <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> spartan_count: <span class="tok-type">u16</span> = <span class="tok-number">300</span>;
    <span class="tok-kw">const</span> byte = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u8</span>, spartan_count);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{byte});
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3504 panic: integer cast truncated bits
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:5:18</span>: <span class="t2_0">0x22d52c in main (test)</span>
    const byte = @intCast(u8, spartan_count);
                 <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204e4e in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204d22 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      <p>
      To truncate bits, use <a href="#truncate">@truncate</a>.
      </p>
      
      <h2 id="Integer-Overflow"><a href="#toc-Integer-Overflow">Integer Overflow</a> <a class="hdr" href="#Integer-Overflow">§</a></h2>

      <h3 id="Default-Operations"><a href="#toc-Default-Operations">Default Operations</a> <a class="hdr" href="#Default-Operations">§</a></h3>

      <p>The following operators can cause integer overflow:</p>
      <ul>
          <li><code class="zig">+</code> (addition)</li>
          <li><code class="zig">-</code> (subtraction)</li>
          <li><code class="zig">-</code> (negation)</li>
          <li><code class="zig">*</code> (multiplication)</li>
          <li><code class="zig">/</code> (division)</li>
        <li><a href="#divTrunc">@divTrunc</a> (division)</li>
        <li><a href="#divFloor">@divFloor</a> (division)</li>
        <li><a href="#divExact">@divExact</a> (division)</li>
      </ul>
      <p>Example with addition at compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
    byte += <span class="tok-number">1</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:3:10: </span><span class="t31_1">error: </span><span class="t0_1">operation caused overflow</span>
    byte += 1;
         <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
    byte += <span class="tok-number">1</span>;
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{byte});
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3516 panic: integer overflow
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:5:10</span>: <span class="t2_0">0x22d510 in main (test)</span>
    byte += 1;
         <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204e4e in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204d22 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      
      <h3 id="Standard-Library-Math-Functions"><a href="#toc-Standard-Library-Math-Functions">Standard Library Math Functions</a> <a class="hdr" href="#Standard-Library-Math-Functions">§</a></h3>

      <p>These functions provided by the standard library return possible errors.</p>
      <ul>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.add</code></li>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.sub</code></li>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.mul</code></li>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divTrunc</code></li>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divFloor</code></li>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divExact</code></li>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.shl</code></li>
      </ul>
      <p>Example of catching an overflow for addition:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> math = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math;
<span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;

    byte = <span class="tok-kw">if</span> (math.add(<span class="tok-type">u8</span>, byte, <span class="tok-number">1</span>)) |result| result <span class="tok-kw">else</span> |err| {
        print(<span class="tok-str">&quot;unable to add one: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)});
        <span class="tok-kw">return</span> err;
    };

    print(<span class="tok-str">&quot;result: {}\n&quot;</span>, .{byte});
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
unable to add one: Overflow
error: Overflow
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/math.zig:420:5</span>: <span class="t2_0">0x234b20 in std.math.add (test)</span>
    return if (@addWithOverflow(T, a, b, &amp;answer)) error.Overflow else answer;
    <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:8:9</span>: <span class="t2_0">0x22d7eb in main (test)</span>
        return err;
        <span class="t32_1">^</span>
</code></pre>

      
      <h3 id="Builtin-Overflow-Functions"><a href="#toc-Builtin-Overflow-Functions">Builtin Overflow Functions</a> <a class="hdr" href="#Builtin-Overflow-Functions">§</a></h3>

      <p>
      These builtins return a <code class="zig"><span class="tok-type">bool</span></code> of whether or not overflow
      occurred, as well as returning the overflowed bits:
      </p>
      <ul>
          <li><a href="#addWithOverflow">@addWithOverflow</a></li>
          <li><a href="#subWithOverflow">@subWithOverflow</a></li>
          <li><a href="#mulWithOverflow">@mulWithOverflow</a></li>
          <li><a href="#shlWithOverflow">@shlWithOverflow</a></li>
      </ul>
      <p>
      Example of <a href="#addWithOverflow">@addWithOverflow</a>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;

    <span class="tok-kw">var</span> result: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">if</span> (<span class="tok-builtin">@addWithOverflow</span>(<span class="tok-type">u8</span>, byte, <span class="tok-number">10</span>, &amp;result)) {
        print(<span class="tok-str">&quot;overflowed result: {}\n&quot;</span>, .{result});
    } <span class="tok-kw">else</span> {
        print(<span class="tok-str">&quot;result: {}\n&quot;</span>, .{result});
    }
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
overflowed result: 9
</code></pre>

      
      <h3 id="Wrapping-Operations"><a href="#toc-Wrapping-Operations">Wrapping Operations</a> <a class="hdr" href="#Wrapping-Operations">§</a></h3>

      <p>
      These operations have guaranteed wraparound semantics.
      </p>
      <ul>
          <li><code class="zig">+%</code> (wraparound addition)</li>
          <li><code class="zig">-%</code> (wraparound subtraction)</li>
          <li><code class="zig">-%</code> (wraparound negation)</li>
          <li><code class="zig">*%</code> (wraparound multiplication)</li>
      </ul>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> minInt = std.math.minInt;
<span class="tok-kw">const</span> maxInt = std.math.maxInt;

<span class="tok-kw">test</span> <span class="tok-str">&quot;wraparound addition and subtraction&quot;</span> {
    <span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = maxInt(<span class="tok-type">i32</span>);
    <span class="tok-kw">const</span> min_val = x +% <span class="tok-number">1</span>;
    expect(min_val == minInt(<span class="tok-type">i32</span>));
    <span class="tok-kw">const</span> max_val = min_val -% <span class="tok-number">1</span>;
    expect(max_val == maxInt(<span class="tok-type">i32</span>));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test [1/1] test &quot;wraparound addition and subtraction&quot;... 

All 1 tests passed.
</code></pre>

      
      
      <h2 id="Exact-Left-Shift-Overflow"><a href="#toc-Exact-Left-Shift-Overflow">Exact Left Shift Overflow</a> <a class="hdr" href="#Exact-Left-Shift-Overflow">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> x = <span class="tok-builtin">@shlExact</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0b01010101</span>), <span class="tok-number">2</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:2:15: </span><span class="t31_1">error: </span><span class="t0_1">operation caused overflow</span>
    const x = @shlExact(@as(u8, 0b01010101), 2);
              <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">0b01010101</span>;
    <span class="tok-kw">var</span> y = <span class="tok-builtin">@shlExact</span>(x, <span class="tok-number">2</span>);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{y});
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3555 panic: left shift overflowed bits
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:5:13</span>: <span class="t2_0">0x22d53d in main (test)</span>
    var y = @shlExact(x, 2);
            <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204e5e in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204d32 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      
      <h2 id="Exact-Right-Shift-Overflow"><a href="#toc-Exact-Right-Shift-Overflow">Exact Right Shift Overflow</a> <a class="hdr" href="#Exact-Right-Shift-Overflow">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> x = <span class="tok-builtin">@shrExact</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">0b10101010</span>), <span class="tok-number">2</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:2:15: </span><span class="t31_1">error: </span><span class="t0_1">exact shift shifted out 1 bits</span>
    const x = @shrExact(@as(u8, 0b10101010), 2);
              <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">0b10101010</span>;
    <span class="tok-kw">var</span> y = <span class="tok-builtin">@shrExact</span>(x, <span class="tok-number">2</span>);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{y});
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3567 panic: right shift overflowed bits
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:5:13</span>: <span class="t2_0">0x22d53d in main (test)</span>
    var y = @shrExact(x, 2);
            <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204e5e in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204d32 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      
      <h2 id="Division-by-Zero"><a href="#toc-Division-by-Zero">Division by Zero</a> <a class="hdr" href="#Division-by-Zero">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> c = a / b;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:4:17: </span><span class="t31_1">error: </span><span class="t0_1">division by zero</span>
    const c = a / b;
                <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> c = a / b;
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{c});
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3579 panic: division by zero
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:6:15</span>: <span class="t2_0">0x22d519 in main (test)</span>
    var c = a / b;
              <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204e4e in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204d22 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      
      <h2 id="Remainder-Division-by-Zero"><a href="#toc-Remainder-Division-by-Zero">Remainder Division by Zero</a> <a class="hdr" href="#Remainder-Division-by-Zero">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">i32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> c = a % b;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:4:17: </span><span class="t31_1">error: </span><span class="t0_1">division by zero</span>
    const c = a % b;
                <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> c = a % b;
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{c});
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3592 panic: remainder division by zero or negative value
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:6:15</span>: <span class="t2_0">0x22d53b in main (test)</span>
    var c = a % b;
              <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204e4e in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204d22 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      
      <h2 id="Exact-Division-Remainder"><a href="#toc-Exact-Division-Remainder">Exact Division Remainder</a> <a class="hdr" href="#Exact-Division-Remainder">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">const</span> c = <span class="tok-builtin">@divExact</span>(a, b);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:4:15: </span><span class="t31_1">error: </span><span class="t0_1">exact division had a remainder</span>
    const c = @divExact(a, b);
              <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">var</span> c = <span class="tok-builtin">@divExact</span>(a, b);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{c});
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3604 panic: exact division produced remainder
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:6:13</span>: <span class="t2_0">0x22d55d in main (test)</span>
    var c = @divExact(a, b);
            <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204e4e in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204d22 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      
      <h2 id="Attempt-to-Unwrap-Null"><a href="#toc-Attempt-to-Unwrap-Null">Attempt to Unwrap Null</a> <a class="hdr" href="#Attempt-to-Unwrap-Null">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> number = optional_number.?;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:3:35: </span><span class="t31_1">error: </span><span class="t0_1">unable to unwrap null</span>
    const number = optional_number.?;
                                  <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">var</span> number = optional_number.?;
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{number});
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3617 panic: attempt to use null value
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:5:33</span>: <span class="t2_0">0x22d50c in main (test)</span>
    var number = optional_number.?;
                                <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204e4e in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204d22 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      <p>One way to avoid this crash is to test for null instead of assuming non-null, with
      the <code class="zig"><span class="tok-kw">if</span></code> expression:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">if</span> (optional_number) |number| {
        print(<span class="tok-str">&quot;got number: {}\n&quot;</span>, .{number});
    } <span class="tok-kw">else</span> {
        print(<span class="tok-str">&quot;it's null\n&quot;</span>, .{});
    }
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
it's null
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Optionals">Optionals</a></li>
</ul>

      
      <h2 id="Attempt-to-Unwrap-Error"><a href="#toc-Attempt-to-Unwrap-Error">Attempt to Unwrap Error</a> <a class="hdr" href="#Attempt-to-Unwrap-Error">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> number = getNumberOrFail() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:2:38: </span><span class="t31_1">error: </span><span class="t0_1">caught unexpected error 'UnableToReturnNumber'</span>
    const number = getNumberOrFail() catch unreachable;
                                     <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = getNumberOrFail() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{number});
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3637 panic: attempt to unwrap error: UnableToReturnNumber
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:9:5</span>: <span class="t2_0">0x2347ac in getNumberOrFail (test)</span>
    return error.UnableToReturnNumber;
    <span class="t32_1">^</span>
<span class="t37_1">???:?:?</span>: <span class="t2_0">0x20c8ac in ??? (???)</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:4:38</span>: <span class="t2_0">0x22d56b in main (test)</span>
    const number = getNumberOrFail() catch unreachable;
                                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204e6e in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204d42 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      <p>One way to avoid this crash is to test for an error instead of assuming a successful result, with
      the <code class="zig"><span class="tok-kw">if</span></code> expression:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> print = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.print;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = getNumberOrFail();

    <span class="tok-kw">if</span> (result) |number| {
        print(<span class="tok-str">&quot;got number: {}\n&quot;</span>, .{number});
    } <span class="tok-kw">else</span> |err| {
        print(<span class="tok-str">&quot;got error: {s}\n&quot;</span>, .{<span class="tok-builtin">@errorName</span>(err)});
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
got error: UnableToReturnNumber
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Errors">Errors</a></li>
</ul>

      
      <h2 id="Invalid-Error-Code"><a href="#toc-Invalid-Error-Code">Invalid Error Code</a> <a class="hdr" href="#Invalid-Error-Code">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> err = <span class="tok-kw">error</span>.AnError;
    <span class="tok-kw">const</span> number = <span class="tok-builtin">@errorToInt</span>(err) + <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> invalid_err = <span class="tok-builtin">@intToError</span>(number);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:4:25: </span><span class="t31_1">error: </span><span class="t0_1">integer value 11 represents no error</span>
    const invalid_err = @intToError(number);
                        <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> err = <span class="tok-kw">error</span>.AnError;
    <span class="tok-kw">var</span> number = <span class="tok-builtin">@errorToInt</span>(err) + <span class="tok-number">500</span>;
    <span class="tok-kw">var</span> invalid_err = <span class="tok-builtin">@intToError</span>(number);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{number});
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3658 panic: invalid error code
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:6:23</span>: <span class="t2_0">0x22d574 in main (test)</span>
    var invalid_err = @intToError(number);
                      <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204e7e in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204d52 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      
      <h2 id="Invalid-Enum-Cast"><a href="#toc-Invalid-Enum-Cast">Invalid Enum Cast</a> <a class="hdr" href="#Invalid-Enum-Cast">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    a,
    b,
    c,
};
<span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u2</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">const</span> b = <span class="tok-builtin">@intToEnum</span>(Foo, a);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:8:15: </span><span class="t31_1">error: </span><span class="t0_1">enum 'Foo' has no tag matching integer value 3</span>
    const b = @intToEnum(Foo, a);
              <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:1:13: </span><span class="t36_1">note: </span><span class="t0_1">'Foo' declared here</span>
const Foo = enum {
            <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    a,
    b,
    c,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u2</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">var</span> b = <span class="tok-builtin">@intToEnum</span>(Foo, a);
    std.debug.print(<span class="tok-str">&quot;value: {s}\n&quot;</span>, .{<span class="tok-builtin">@tagName</span>(b)});
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3670 panic: invalid enum value
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:11:13</span>: <span class="t2_0">0x22d58c in main (test)</span>
    var b = @intToEnum(Foo, a);
            <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204ebe in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204d92 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      

      <h2 id="Invalid-Error-Set-Cast"><a href="#toc-Invalid-Error-Set-Cast">Invalid Error Set Cast</a> <a class="hdr" href="#Invalid-Error-Set-Cast">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Set1 = <span class="tok-kw">error</span>{
    A,
    B,
};
<span class="tok-kw">const</span> Set2 = <span class="tok-kw">error</span>{
    A,
    C,
};
<span class="tok-kw">comptime</span> {
    _ = <span class="tok-builtin">@errSetCast</span>(Set2, Set1.B);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:10:9: </span><span class="t31_1">error: </span><span class="t0_1">error.B not a member of error set 'Set2'</span>
    _ = @errSetCast(Set2, Set1.B);
        <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Set1 = <span class="tok-kw">error</span>{
    A,
    B,
};
<span class="tok-kw">const</span> Set2 = <span class="tok-kw">error</span>{
    A,
    C,
};
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    foo(Set1.B);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(set1: Set1) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x = <span class="tok-builtin">@errSetCast</span>(Set2, set1);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{x});
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3682 panic: invalid error code
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:15:15</span>: <span class="t2_0">0x234783 in foo (test)</span>
    const x = @errSetCast(Set2, set1);
              <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:12:8</span>: <span class="t2_0">0x22d53d in main (test)</span>
    foo(Set1.B);
       <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204e9e in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204d72 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      

      <h2 id="Incorrect-Pointer-Alignment"><a href="#toc-Incorrect-Pointer-Alignment">Incorrect Pointer Alignment</a> <a class="hdr" href="#Incorrect-Pointer-Alignment">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> ptr = <span class="tok-builtin">@intToPtr</span>(*<span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">i32</span>, <span class="tok-number">0x1</span>);
    <span class="tok-kw">const</span> aligned = <span class="tok-builtin">@alignCast</span>(<span class="tok-number">4</span>, ptr);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:3:35: </span><span class="t31_1">error: </span><span class="t0_1">pointer address 0x1 is not aligned to 4 bytes</span>
    const aligned = @alignCast(4, ptr);
                                  <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:3:21: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
    const aligned = @alignCast(4, ptr);
                    <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> array <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = [_]<span class="tok-type">u32</span>{ <span class="tok-number">0x11111111</span>, <span class="tok-number">0x11111111</span> };
    <span class="tok-kw">const</span> bytes = mem.sliceAsBytes(array[<span class="tok-number">0</span>..]);
    <span class="tok-kw">if</span> (foo(bytes) != <span class="tok-number">0x11111111</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Wrong;
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(bytes: []<span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> slice4 = bytes[<span class="tok-number">1</span>..<span class="tok-number">5</span>];
    <span class="tok-kw">const</span> int_slice = mem.bytesAsSlice(<span class="tok-type">u32</span>, <span class="tok-builtin">@alignCast</span>(<span class="tok-number">4</span>, slice4));
    <span class="tok-kw">return</span> int_slice[<span class="tok-number">0</span>];
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3694 panic: incorrect alignment
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:9:59</span>: <span class="t2_0">0x234a4b in foo (test)</span>
    const int_slice = mem.bytesAsSlice(u32, @alignCast(4, slice4));
                                                          <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:5:12</span>: <span class="t2_0">0x22d6d9 in main (test)</span>
    if (foo(bytes) != 0x11111111) return error.Wrong;
           <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:420:37</span>: <span class="t2_0">0x204ed4 in std.start.posixCallMainAndExit (test)</span>
            const result = root.main() catch |err| {
                                    <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204d72 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      
      <h2 id="Wrong-Union-Field-Access"><a href="#toc-Wrong-Union-Field-Access">Wrong Union Field Access</a> <a class="hdr" href="#Wrong-Union-Field-Access">§</a></h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    f.float = <span class="tok-number">12.34</span>;
}

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:3:6: </span><span class="t31_1">error: </span><span class="t0_1">accessing union field 'float' while field 'int' is set</span>
    f.float = 12.34;
     <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    bar(&amp;f);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(f: *Foo) <span class="tok-type">void</span> {
    f.float = <span class="tok-number">12.34</span>;
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{f.float});
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3706 panic: access of inactive union field
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:14:6</span>: <span class="t2_0">0x241f1a in bar (test)</span>
    f.float = 12.34;
     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:10:8</span>: <span class="t2_0">0x23accc in main (test)</span>
    bar(&amp;f);
       <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x21261e in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x2124f2 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      <p>
      This safety is not available for <code class="zig"><span class="tok-kw">extern</span></code> or <code class="zig"><span class="tok-kw">packed</span></code> unions.
      </p>
      <p>
      To change the active field of a union, assign the entire union, like this:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    bar(&amp;f);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(f: *Foo) <span class="tok-type">void</span> {
    f.* = Foo{ .float = <span class="tok-number">12.34</span> };
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{f.float});
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
value: 1.23400001e+01
</code></pre>

      <p>
      To change the active field of a union when a meaningful value for the field is not known,
      use <a href="#undefined">undefined</a>, like this:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    f = Foo{ .float = <span class="tok-null">undefined</span> };
    bar(&amp;f);
    std.debug.print(<span class="tok-str">&quot;value: {}\n&quot;</span>, .{f.float});
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(f: *Foo) <span class="tok-type">void</span> {
    f.float = <span class="tok-number">12.34</span>;
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
value: 1.23400001e+01
</code></pre>

      <p>See also:</p><ul>
<li><a href="#union">union</a></li>
<li><a href="#extern-union">extern union</a></li>
</ul>

      

      <h2 id="Out-of-Bounds-Float-to-Integer-Cast"><a href="#toc-Out-of-Bounds-Float-to-Integer-Cast">Out of Bounds Float to Integer Cast</a> <a class="hdr" href="#Out-of-Bounds-Float-to-Integer-Cast">§</a></h2>

      <p>TODO</p>
      

      <h2 id="Pointer-Cast-Invalid-Null"><a href="#toc-Pointer-Cast-Invalid-Null">Pointer Cast Invalid Null</a> <a class="hdr" href="#Pointer-Cast-Invalid-Null">§</a></h2>

      <p>
      This happens when casting a pointer with the address 0 to a pointer which may not have the address 0.
      For example, <a href="#C-Pointers">C Pointers</a>, <a href="#Optional-Pointers">Optional Pointers</a>, and <a href="#allowzero">allowzero</a> pointers
      allow address zero, but normal <a href="#Pointers">Pointers</a> do not.
      </p>
      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> opt_ptr: ?*<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> ptr = <span class="tok-builtin">@ptrCast</span>(*<span class="tok-type">i32</span>, opt_ptr);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:3:17: </span><span class="t31_1">error: </span><span class="t0_1">null pointer casted to type '*i32'</span>
    const ptr = @ptrCast(*i32, opt_ptr);
                <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> opt_ptr: ?*<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">var</span> ptr = <span class="tok-builtin">@ptrCast</span>(*<span class="tok-type">i32</span>, opt_ptr);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
thread 3734 panic: cast causes pointer to be null
<span class="t37_1">/home/vsts/work/1/s/docgen_tmp/test.zig:3:15</span>: <span class="t2_0">0x22d4a0 in main (test)</span>
    var ptr = @ptrCast(*i32, opt_ptr);
              <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:410:22</span>: <span class="t2_0">0x204dde in std.start.posixCallMainAndExit (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/vsts/work/1/s/build/release/lib/zig/std/start.zig:238:5</span>: <span class="t2_0">0x204cb2 in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
(process terminated by signal)</code></pre>

      

      
      <h1 id="Memory"><a href="#toc-Memory">Memory</a> <a class="hdr" href="#Memory">§</a></h1>

      <p>
      The Zig language performs no memory management on behalf of the programmer. This is
      why Zig has no runtime, and why Zig code works seamlessly in so many environments,
      including real-time software, operating system kernels, embedded devices, and
      low latency servers. As a consequence, Zig programmers must always be able to answer
      the question:
      </p>
      <p><a href="#Where-are-the-bytes">Where are the bytes?</a></p>
      <p>
      Like Zig, the C programming language has manual memory management. However, unlike Zig,
      C has a default allocator - <code>malloc</code>, <code>realloc</code>, and <code>free</code>.
      When linking against libc, Zig exposes this allocator with <code class="zig">std.heap.c_allocator</code>.
      However, by convention, there is no default allocator in Zig. Instead, functions which need to
      allocate accept an <code class="zig">*Allocator</code> parameter. Likewise, data structures such as
      <code class="zig">std.ArrayList</code> accept an <code class="zig">*Allocator</code> parameter in
      their initialization functions:
      </p>
      <p class="file">allocator.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> Allocator = std.mem.Allocator;
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;using an allocator&quot;</span> {
    <span class="tok-kw">var</span> buffer: [<span class="tok-number">100</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> allocator = &amp;std.heap.FixedBufferAllocator.init(&amp;buffer).allocator;
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> concat(allocator, <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-str">&quot;bar&quot;</span>);
    expect(std.mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;foobar&quot;</span>, result));
}

<span class="tok-kw">fn</span> <span class="tok-fn">concat</span>(allocator: *Allocator, a: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ![]<span class="tok-type">u8</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, a.len + b.len);
    std.mem.copy(<span class="tok-type">u8</span>, result, a);
    std.mem.copy(<span class="tok-type">u8</span>, result[a.len..], b);
    <span class="tok-kw">return</span> result;
}</code></pre><pre><code class="shell">$ zig test allocator.zig
Test [1/1] test &quot;using an allocator&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      In the above example, 100 bytes of stack memory are used to initialize a
      <code class="zig">FixedBufferAllocator</code>, which is then passed to a function.
      As a convenience there is a global <code class="zig">FixedBufferAllocator</code>
      available for quick tests at <code class="zig">std.testing.allocator</code>,
      which will also do perform basic leak detection.
      </p>
      <p>
      Zig has a general purpose allocator available to be imported
      with <code class="zig">std.heap.GeneralPurposeAllocator</code>. However, it is still recommended to
      follow the <a href="#Choosing-an-Allocator">Choosing an Allocator</a> guide.
      </p>

      <h2 id="Choosing-an-Allocator"><a href="#toc-Choosing-an-Allocator">Choosing an Allocator</a> <a class="hdr" href="#Choosing-an-Allocator">§</a></h2>

      <p>What allocator to use depends on a number of factors. Here is a flow chart to help you decide:
      </p>
      <ol>
          <li>
              Are you making a library? In this case, best to accept an <code class="zig">*Allocator</code>
              as a parameter and allow your library's users to decide what allocator to use.
          </li>
          <li>Are you linking libc? In this case, <code class="zig">std.heap.c_allocator</code> is likely
              the right choice, at least for your main allocator.</li>
          <li>
              Is the maximum number of bytes that you will need bounded by a number known at
              <a href="#comptime">comptime</a>? In this case, use <code class="zig">std.heap.FixedBufferAllocator</code> or
              <code class="zig">std.heap.ThreadSafeFixedBufferAllocator</code> depending on whether you need
              thread-safety or not.
          </li>
          <li>
              Is your program a command line application which runs from start to end without any fundamental
              cyclical pattern (such as a video game main loop, or a web server request handler),
              such that it would make sense to free everything at once at the end?
              In this case, it is recommended to follow this pattern:
              <p class="file">cli_allocation.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    <span class="tok-kw">defer</span> arena.deinit();

    <span class="tok-kw">const</span> allocator = &amp;arena.allocator;

    <span class="tok-kw">const</span> ptr = <span class="tok-kw">try</span> allocator.create(<span class="tok-type">i32</span>);
    std.debug.print(<span class="tok-str">&quot;ptr={*}\n&quot;</span>, .{ptr});
}</code></pre><pre><code class="shell">$ zig build-exe cli_allocation.zig
$ ./cli_allocation
ptr=i32@7fbb484b7018
</code></pre>

              When using this kind of allocator, there is no need to free anything manually. Everything
              gets freed at once with the call to <code class="zig">arena.deinit()</code>.
          </li>
          <li>
              Are the allocations part of a cyclical pattern such as a video game main loop, or a web
              server request handler? If the allocations can all be freed at once, at the end of the cycle,
              for example once the video game frame has been fully rendered, or the web server request has
              been served, then <code class="zig">std.heap.ArenaAllocator</code> is a great candidate. As
              demonstrated in the previous bullet point, this allows you to free entire arenas at once.
              Note also that if an upper bound of memory can be established, then
              <code class="zig">std.heap.FixedBufferAllocator</code> can be used as a further optimization.
          </li>
          <li>
              Are you writing a test, and you want to make sure <code class="zig"><span class="tok-kw">error</span>.OutOfMemory</code>
              is handled correctly? In this case, use <code class="zig">std.testing.FailingAllocator</code>.
          </li>
          <li>
              Are you writing a test? In this case, use <code class="zig">std.testing.allocator</code>.
          </li>
          <li>
              Finally, if none of the above apply, you need a general purpose allocator.
              Zig's general purpose allocator is available as a function that takes a <a href="#comptime">comptime</a>
              <a href="#struct">struct</a> of configuration options and returns a type.
              Generally, you will set up one <code class="zig">std.heap.GeneralPurposeAllocator</code> in
              your main function, and then pass it or sub-allocators around to various parts of your
              application.
          </li>
          <li>
              You can also consider <a href="#Implementing-an-Allocator">Implementing an Allocator</a>.
          </li>
      </ol>
      

      <h2 id="Where-are-the-bytes"><a href="#toc-Where-are-the-bytes">Where are the bytes?</a> <a class="hdr" href="#Where-are-the-bytes">§</a></h2>

      <p>String literals such as <code class="zig"><span class="tok-str">&quot;foo&quot;</span></code> are in the global constant data section.
      This is why it is an error to pass a string literal to a mutable slice, like this:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(s: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {}

<span class="tok-kw">test</span> <span class="tok-str">&quot;string literal to mutable slice&quot;</span> {
    foo(<span class="tok-str">&quot;hello&quot;</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:4:9: </span><span class="t31_1">error: </span><span class="t0_1">expected type '[]u8', found '*const [5:0]u8'</span>
    foo(&quot;hello&quot;);
        <span class="t32_1">^</span>
</code></pre>

      <p>However if you make the slice constant, then it works:</p>
      <p class="file">strlit.zig</p><pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(s: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {}

<span class="tok-kw">test</span> <span class="tok-str">&quot;string literal to constant slice&quot;</span> {
    foo(<span class="tok-str">&quot;hello&quot;</span>);
}</code></pre><pre><code class="shell">$ zig test strlit.zig
Test [1/1] test &quot;string literal to constant slice&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      Just like string literals, <code class="zig"><span class="tok-kw">const</span></code> declarations, when the value is known at <a href="#comptime">comptime</a>,
      are stored in the global constant data section. Also <a href="#Compile-Time-Variables">Compile Time Variables</a> are stored
      in the global constant data section.
      </p>
      <p>
      <code class="zig"><span class="tok-kw">var</span></code> declarations inside functions are stored in the function's stack frame. Once a function returns,
      any <a href="#Pointers">Pointers</a> to variables in the function's stack frame become invalid references, and
      dereferencing them becomes unchecked <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      <p>
      <code class="zig"><span class="tok-kw">var</span></code> declarations at the top level or in <a href="#struct">struct</a> declarations are stored in the global
      data section.
      </p>
      <p>
      The location of memory allocated with <code class="zig">allocator.alloc</code> or
      <code class="zig">allocator.create</code> is determined by the allocator's implementation.
      </p>
      <p>TODO: thread local variables</p>
      

      <h2 id="Implementing-an-Allocator"><a href="#toc-Implementing-an-Allocator">Implementing an Allocator</a> <a class="hdr" href="#Implementing-an-Allocator">§</a></h2>

      <p>Zig programmers can implement their own allocators by fulfilling the Allocator interface.
      In order to do this one must read carefully the documentation comments in std/mem.zig and
      then supply a <code class="zig">reallocFn</code> and a <code class="zig">shrinkFn</code>.
      </p>
      <p>
      There are many example allocators to look at for inspiration. Look at std/heap.zig and
      at this
      <a href="https://github.com/andrewrk/zig-general-purpose-allocator/">work-in-progress general purpose allocator</a>.
      TODO: once <a href="https://github.com/ziglang/zig/issues/21">#21</a> is done, link to the docs
      here.
      </p>
      

      <h2 id="Heap-Allocation-Failure"><a href="#toc-Heap-Allocation-Failure">Heap Allocation Failure</a> <a class="hdr" href="#Heap-Allocation-Failure">§</a></h2>

      <p>
      Many programming languages choose to handle the possibility of heap allocation failure by
      unconditionally crashing. By convention, Zig programmers do not consider this to be a
      satisfactory solution. Instead, <code class="zig"><span class="tok-kw">error</span>.OutOfMemory</code> represents
      heap allocation failure, and Zig libraries return this error code whenever heap allocation
      failure prevented an operation from completing successfully.
      </p>
      <p>
      Some have argued that because some operating systems such as Linux have memory overcommit enabled by
      default, it is pointless to handle heap allocation failure. There are many problems with this reasoning:
      </p>
      <ul>
          <li>Only some operating systems have an overcommit feature.
              <ul>
                  <li>Linux has it enabled by default, but it is configurable.</li>
                  <li>Windows does not overcommit.</li>
                  <li>Embedded systems do not have overcommit.</li>
                  <li>Hobby operating systems may or may not have overcommit.</li>
              </ul>
          </li>
          <li>
              For real-time systems, not only is there no overcommit, but typically the maximum amount
              of memory per application is determined ahead of time.
          </li>
          <li>
              When writing a library, one of the main goals is code reuse. By making code handle
              allocation failure correctly, a library becomes eligible to be reused in
              more contexts.
          </li>
          <li>
              Although some software has grown to depend on overcommit being enabled, its existence
              is the source of countless user experience disasters. When a system with overcommit enabled,
              such as Linux on default settings, comes close to memory exhaustion, the system locks up
              and becomes unusable. At this point, the OOM Killer selects an application to kill
              based on heuristics. This non-deterministic decision often results in an important process
              being killed, and often fails to return the system back to working order.
          </li>
      </ul>
      

      <h2 id="Recursion"><a href="#toc-Recursion">Recursion</a> <a class="hdr" href="#Recursion">§</a></h2>

      <p>
      Recursion is a fundamental tool in modeling software. However it has an often-overlooked problem:
      unbounded memory allocation.
      </p>
      <p>
      Recursion is an area of active experimentation in Zig and so the documentation here is not final.
      You can read a
      <a href="https://ziglang.org/download/0.3.0/release-notes.html#recursion">summary of recursion status in the 0.3.0 release notes</a>.
      </p>
      <p>
      The short summary is that currently recursion works normally as you would expect. Although Zig code
      is not yet protected from stack overflow, it is planned that a future version of Zig will provide
      such protection, with some degree of cooperation from Zig code required.
      </p>
      

      <h2 id="Lifetime-and-Ownership"><a href="#toc-Lifetime-and-Ownership">Lifetime and Ownership</a> <a class="hdr" href="#Lifetime-and-Ownership">§</a></h2>

      <p>
      It is the Zig programmer's responsibility to ensure that a <a href="#Pointers">pointer</a> is not
      accessed when the memory pointed to is no longer available. Note that a <a href="#Slices">slice</a>
      is a form of pointer, in that it references other memory.
      </p>
      <p>
      In order to prevent bugs, there are some helpful conventions to follow when dealing with pointers.
      In general, when a function returns a pointer, the documentation for the function should explain
      who "owns" the pointer. This concept helps the programmer decide when it is appropriate, if ever,
      to free the pointer.
      </p>
      <p>
      For example, the function's documentation may say "caller owns the returned memory", in which case
      the code that calls the function must have a plan for when to free that memory. Probably in this situation,
      the function will accept an <code class="zig">*Allocator</code> parameter.
      </p>
      <p>
      Sometimes the lifetime of a pointer may be more complicated. For example, the
      <code class="zig">std.ArrayList(T).items</code> slice has a lifetime that remains
      valid until the next time the list is resized, such as by appending new elements.
      </p>
      <p>
      The API documentation for functions and data structures should take great care to explain
      the ownership and lifetime semantics of pointers. Ownership determines whose responsibility it
      is to free the memory referenced by the pointer, and lifetime determines the point at which
      the memory becomes inaccessible (lest <a href="#Undefined-Behavior">Undefined Behavior</a> occur).
      </p>
      

      
      <h1 id="Compile-Variables"><a href="#toc-Compile-Variables">Compile Variables</a> <a class="hdr" href="#Compile-Variables">§</a></h1>

      <p>
      Compile variables are accessible by importing the <code class="zig"><span class="tok-str">&quot;builtin&quot;</span></code> package,
      which the compiler makes available to every Zig source file. It contains
      compile-time constants such as the current target, endianness, and release mode.
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> separator = <span class="tok-kw">if</span> (builtin.os == builtin.Os.windows) <span class="tok-str">'\\'</span> <span class="tok-kw">else</span> <span class="tok-str">'/'</span>;</code></pre>
      <p>
      Example of what is imported with <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>)</code>:
      </p>
      <pre><code class="zig"><span class="tok-kw">usingnamespace</span> <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).builtin;
<span class="tok-comment">/// Deprecated</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> arch = Target.current.cpu.arch;
<span class="tok-comment">/// Deprecated</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> endian = Target.current.cpu.arch.endian();

<span class="tok-comment">/// Zig version. When writing code that supports multiple versions of Zig, prefer</span>
<span class="tok-comment">/// feature detection (i.e. with `@hasDecl` or `@hasField`) over version checks.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> zig_version = <span class="tok-kw">try</span> <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).SemanticVersion.parse(<span class="tok-str">&quot;0.8.0-dev.1860+1fada3746&quot;</span>);
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> zig_is_stage2 = <span class="tok-null">true</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> output_mode = OutputMode.Obj;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> link_mode = LinkMode.Static;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> is_test = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> single_threaded = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> abi = Abi.gnu;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> cpu: Cpu = Cpu{
    .arch = .x86_64,
    .model = &amp;Target.x86.cpu.skylake_avx512,
    .features = Target.x86.featureSet(&amp;[_]Target.x86.Feature{
        .@&quot;64bit&quot;,
        .@&quot;adx&quot;,
        .@&quot;aes&quot;,
        .@&quot;avx&quot;,
        .@&quot;avx2&quot;,
        .@&quot;avx512bw&quot;,
        .@&quot;avx512cd&quot;,
        .@&quot;avx512dq&quot;,
        .@&quot;avx512f&quot;,
        .@&quot;avx512vl&quot;,
        .@&quot;bmi&quot;,
        .@&quot;bmi2&quot;,
        .@&quot;clflushopt&quot;,
        .@&quot;cmov&quot;,
        .@&quot;cx16&quot;,
        .@&quot;cx8&quot;,
        .@&quot;ermsb&quot;,
        .@&quot;f16c&quot;,
        .@&quot;false_deps_popcnt&quot;,
        .@&quot;fast_15bytenop&quot;,
        .@&quot;fast_gather&quot;,
        .@&quot;fast_scalar_fsqrt&quot;,
        .@&quot;fast_shld_rotate&quot;,
        .@&quot;fast_variable_shuffle&quot;,
        .@&quot;fast_vector_fsqrt&quot;,
        .@&quot;fma&quot;,
        .@&quot;fsgsbase&quot;,
        .@&quot;fxsr&quot;,
        .@&quot;idivq_to_divl&quot;,
        .@&quot;invpcid&quot;,
        .@&quot;lzcnt&quot;,
        .@&quot;macrofusion&quot;,
        .@&quot;merge_to_threeway_branch&quot;,
        .@&quot;mmx&quot;,
        .@&quot;movbe&quot;,
        .@&quot;nopl&quot;,
        .@&quot;pclmul&quot;,
        .@&quot;popcnt&quot;,
        .@&quot;prefer_256_bit&quot;,
        .@&quot;prfchw&quot;,
        .@&quot;rdrnd&quot;,
        .@&quot;rdseed&quot;,
        .@&quot;rtm&quot;,
        .@&quot;sahf&quot;,
        .@&quot;slow_3ops_lea&quot;,
        .@&quot;sse&quot;,
        .@&quot;sse2&quot;,
        .@&quot;sse3&quot;,
        .@&quot;sse4_1&quot;,
        .@&quot;sse4_2&quot;,
        .@&quot;ssse3&quot;,
        .@&quot;vzeroupper&quot;,
        .@&quot;x87&quot;,
        .@&quot;xsave&quot;,
        .@&quot;xsavec&quot;,
        .@&quot;xsaveopt&quot;,
        .@&quot;xsaves&quot;,
    }),
};
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> os = Os{
    .tag = .linux,
    .version_range = .{ .linux = .{
        .range = .{
            .min = .{
                .major = <span class="tok-number">5</span>,
                .minor = <span class="tok-number">4</span>,
                .patch = <span class="tok-number">0</span>,
            },
            .max = .{
                .major = <span class="tok-number">5</span>,
                .minor = <span class="tok-number">4</span>,
                .patch = <span class="tok-number">0</span>,
            },
        },
        .glibc = .{
            .major = <span class="tok-number">2</span>,
            .minor = <span class="tok-number">17</span>,
            .patch = <span class="tok-number">0</span>,
        },
    }},
};
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> object_format = ObjectFormat.elf;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> mode = Mode.Debug;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> link_libc = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> link_libcpp = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_error_return_tracing = <span class="tok-null">true</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> valgrind_support = <span class="tok-null">true</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> position_independent_code = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> position_independent_executable = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> strip_debug_info = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> code_model = CodeModel.default;</code></pre>
      <p>See also:</p><ul>
<li><a href="#Build-Mode">Build Mode</a></li>
</ul>

      
      <h1 id="Root-Source-File"><a href="#toc-Root-Source-File">Root Source File</a> <a class="hdr" href="#Root-Source-File">§</a></h1>

      <p>TODO: explain how root source file finds other files</p>
      <p>TODO: pub fn main</p>
      <p>TODO: pub fn panic</p>
      <p>TODO: if linking with libc you can use export fn main</p>
      <p>TODO: order independent top level declarations</p>
      <p>TODO: lazy analysis</p>
      <p>TODO: using comptime { _ = @import() }</p>
      
      <h1 id="Zig-Test"><a href="#toc-Zig-Test">Zig Test</a> <a class="hdr" href="#Zig-Test">§</a></h1>

      <p>
      <code>zig test</code> is a tool that can be used to quickly build and run Zig code
      to make sure behavior meets expectations. <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).is_test</code>
      is available for code to detect whether the current build is a test build.
      </p>
      <p class="file">detect_test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> builtin = std.builtin;
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;builtin.is_test&quot;</span> {
    expect(builtin.is_test);
}</code></pre><pre><code class="shell">$ zig test detect_test.zig
Test [1/1] test &quot;builtin.is_test&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      Zig has lazy top level declaration analysis, which means that if a function is not called,
      or otherwise used, it is not analyzed. This means that there may be an undiscovered
      compile error in a function because it is never called.
      </p>
      <p class="file">unused_fn.zig</p><pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">unused</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-str">&quot;wrong return type&quot;</span>;
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;unused function&quot;</span> { }</code></pre><pre><code class="shell">$ zig test unused_fn.zig
Test [1/1] test &quot;unused function&quot;... 

All 1 tests passed.
</code></pre>

      <p>
      Note that, while in <a href="#Debug">Debug</a> and <a href="#ReleaseSafe">ReleaseSafe</a> modes, <a href="#unreachable">unreachable</a> emits a
      call to <a href="#panic">@panic</a>, in <a href="#ReleaseFast">ReleaseFast</a> and <a href="#ReleaseSmall">ReleaseSmall</a> modes, it is really
      undefined behavior. The implementation of <code class="zig">std.debug.assert</code> is as
      simple as:
      </p>
      <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>;
}</code></pre>
      <p>
      This means that when testing in ReleaseFast or ReleaseSmall mode, <code class="zig">assert</code>
      is not sufficient to check the result of a computation:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;assert in release fast mode&quot;</span> {
    assert(<span class="tok-null">false</span>);
}</code></pre>
      <p>
      When compiling this test in <a href="#ReleaseFast">ReleaseFast</a> mode, it invokes unchecked
      <a href="#Undefined-Behavior">Undefined Behavior</a>. Since that could do anything, this documentation
      cannot show you the output.
      </p>
      <p>
      Better practice for checking the output when testing is to use <code class="zig">std.testing.expect</code>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;expect in release fast mode&quot;</span> {
    expect(<span class="tok-null">false</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig -O ReleaseFast
Test [1/1] test &quot;expect in release fast mode&quot;... 
thread 3807 panic: test failure
error: the following test command crashed:
docgen_tmp/zig-cache/o/1ff0859384c59a7d907b1ce9d27729f9/test /home/vsts/work/1/s/build/release/bin/zig
</code></pre>

      <p>See the rest of the <code class="zig">std.testing</code> namespace for more available functions.</p>
      <p>
      <code>zig test</code> has a few command line parameters which affect the compilation. See
      <code>zig --help</code> for a full list. The most interesting one is <code>--test-filter [text]</code>.
      This makes the test build only include tests whose name contains the supplied filter text.
      Again, thanks to lazy analysis, this can allow you to narrow a build to only a few functions in
      isolation.
      </p>
      

      <h1 id="Zig-Build-System"><a href="#toc-Zig-Build-System">Zig Build System</a> <a class="hdr" href="#Zig-Build-System">§</a></h1>

      <p>
      The Zig Build System provides a cross-platform, dependency-free way to declare
      the logic required to build a project. With this system, the logic to build
      a project is written in a build.zig file, using the Zig Build System API to
      declare and configure build artifacts and other tasks.
      </p>
      <p>
      Some examples of tasks the build system can help with:
      </p>
      <ul>
        <li>Creating build artifacts by executing the Zig compiler. This includes
          building Zig source code as well as C and C++ source code.</li>
        <li>Capturing user-configured options and using those options to configure
          the build.</li>
        <li>Surfacing build configuration as <a href="#comptime">comptime</a> values by providing a
          file that can be <a href="#import">imported</a> by Zig code.</li>
        <li>Caching build artifacts to avoid unnecessarily repeating steps.</li>
        <li>Executing build artifacts or system-installed tools.</li>
        <li>Running tests and verifying the output of executing a build artifact matches
        the expected value.</li>
        <li>Running <code>zig fmt</code> on a codebase or a subset of it.</li>
        <li>Custom tasks.</li>
      </ul>
      <p>
      To use the build system, run <code class="shell">zig build --help</code>
      to see a command-line usage help menu. This will include project-specific
      options that were declared in the build.zig script.
      </p>
      
      <h2 id="Building-an-Executable"><a href="#toc-Building-an-Executable">Building an Executable</a> <a class="hdr" href="#Building-an-Executable">§</a></h2>

      <p>This <code>build.zig</code> file is automatically generated
        by <code>zig init-exe</code>.</p>
      <pre><code class="zig"><span class="tok-kw">const</span> Builder = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).build.Builder;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *Builder) <span class="tok-type">void</span> {
    <span class="tok-comment">// Standard target options allows the person running `zig build` to choose</span>
    <span class="tok-comment">// what target to build for. Here we do not override the defaults, which</span>
    <span class="tok-comment">// means any target is allowed, and the default is native. Other options</span>
    <span class="tok-comment">// for restricting supported target set are available.</span>
    <span class="tok-kw">const</span> target = b.standardTargetOptions(.{});

    <span class="tok-comment">// Standard release options allow the person running `zig build` to select</span>
    <span class="tok-comment">// between Debug, ReleaseSafe, ReleaseFast, and ReleaseSmall.</span>
    <span class="tok-kw">const</span> mode = b.standardReleaseOptions();

    <span class="tok-kw">const</span> exe = b.addExecutable(<span class="tok-str">&quot;example&quot;</span>, <span class="tok-str">&quot;src/main.zig&quot;</span>);
    exe.setTarget(target);
    exe.setBuildMode(mode);
    exe.install();

    <span class="tok-kw">const</span> run_cmd = exe.run();
    run_cmd.step.dependOn(b.getInstallStep());
    <span class="tok-kw">if</span> (b.args) |args| {
        run_cmd.addArgs(args);
    }

    <span class="tok-kw">const</span> run_step = b.step(<span class="tok-str">&quot;run&quot;</span>, <span class="tok-str">&quot;Run the app&quot;</span>);
    run_step.dependOn(&amp;run_cmd.step);
}</code></pre>
      

      <h2 id="Building-a-Library"><a href="#toc-Building-a-Library">Building a Library</a> <a class="hdr" href="#Building-a-Library">§</a></h2>

      <p>This <code>build.zig</code> file is automatically generated
        by <code>zig init-lib</code>.</p>
      <pre><code class="zig"><span class="tok-kw">const</span> Builder = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).build.Builder;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *Builder) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> mode = b.standardReleaseOptions();
    <span class="tok-kw">const</span> lib = b.addStaticLibrary(<span class="tok-str">&quot;example&quot;</span>, <span class="tok-str">&quot;src/main.zig&quot;</span>);
    lib.setBuildMode(mode);
    lib.install();

    <span class="tok-kw">var</span> main_tests = b.addTest(<span class="tok-str">&quot;src/main.zig&quot;</span>);
    main_tests.setBuildMode(mode);

    <span class="tok-kw">const</span> test_step = b.step(<span class="tok-str">&quot;test&quot;</span>, <span class="tok-str">&quot;Run library tests&quot;</span>);
    test_step.dependOn(&amp;main_tests.step);
}</code></pre>
      

      <h2 id="Compiling-C-Source-Code"><a href="#toc-Compiling-C-Source-Code">Compiling C Source Code</a> <a class="hdr" href="#Compiling-C-Source-Code">§</a></h2>

      <pre><code class="zig">lib.addCSourceFile(<span class="tok-str">&quot;src/lib.c&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{
    <span class="tok-str">&quot;-Wall&quot;</span>,
    <span class="tok-str">&quot;-Wextra&quot;</span>,
    <span class="tok-str">&quot;-Werror&quot;</span>,
});</code></pre>
      

      
      <h1 id="C"><a href="#toc-C">C</a> <a class="hdr" href="#C">§</a></h1>

      <p>
      Although Zig is independent of C, and, unlike most other languages, does not depend on libc,
      Zig acknowledges the importance of interacting with existing C code.
      </p>
      <p>
      There are a few ways that Zig facilitates C interop.
      </p>
      <h2 id="C-Type-Primitives"><a href="#toc-C-Type-Primitives">C Type Primitives</a> <a class="hdr" href="#C-Type-Primitives">§</a></h2>

      <p>
      These have guaranteed C ABI compatibility and can be used like any other type.
      </p>
      <ul>
          <li><code class="zig"><span class="tok-type">c_short</span></code></li>
          <li><code class="zig"><span class="tok-type">c_ushort</span></code></li>
          <li><code class="zig"><span class="tok-type">c_int</span></code></li>
          <li><code class="zig"><span class="tok-type">c_uint</span></code></li>
          <li><code class="zig"><span class="tok-type">c_long</span></code></li>
          <li><code class="zig"><span class="tok-type">c_ulong</span></code></li>
          <li><code class="zig"><span class="tok-type">c_longlong</span></code></li>
          <li><code class="zig"><span class="tok-type">c_ulonglong</span></code></li>
          <li><code class="zig"><span class="tok-type">c_longdouble</span></code></li>
          <li><code class="zig"><span class="tok-type">c_void</span></code></li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Primitive-Types">Primitive Types</a></li>
</ul>

      

      <h2 id="Import-from-C-Header-File"><a href="#toc-Import-from-C-Header-File">Import from C Header File</a> <a class="hdr" href="#Import-from-C-Header-File">§</a></h2>

      <p>
      The <code class="zig"><span class="tok-builtin">@cImport</span></code> builtin function can be used
      to directly import symbols from .h files:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> c = <span class="tok-builtin">@cImport</span>({
    <span class="tok-comment">// See https://github.com/ziglang/zig/issues/515</span>
    <span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;_NO_CRT_STDIO_INLINE&quot;</span>, <span class="tok-str">&quot;1&quot;</span>);
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;stdio.h&quot;</span>);
});
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    _ = c.printf(<span class="tok-str">&quot;hello\n&quot;</span>);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig -lc
$ ./test
hello
</code></pre>

      <p>
      The <code class="zig"><span class="tok-builtin">@cImport</span></code> function takes an expression as a parameter.
      This expression is evaluated at compile-time and is used to control
      preprocessor directives and include multiple .h files:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);

<span class="tok-kw">const</span> c = <span class="tok-builtin">@cImport</span>({
    <span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;NDEBUG&quot;</span>, builtin.mode == .ReleaseFast);
    <span class="tok-kw">if</span> (something) {
        <span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;_GNU_SOURCE&quot;</span>, {});
    }
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;stdlib.h&quot;</span>);
    <span class="tok-kw">if</span> (something) {
        <span class="tok-builtin">@cUndef</span>(<span class="tok-str">&quot;_GNU_SOURCE&quot;</span>);
    }
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;soundio.h&quot;</span>);
});</code></pre>
      <p>See also:</p><ul>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cInclude">@cInclude</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cUndef">@cUndef</a></li>
<li><a href="#import">@import</a></li>
</ul>

      

      <h2 id="C-Pointers"><a href="#toc-C-Pointers">C Pointers</a> <a class="hdr" href="#C-Pointers">§</a></h2>

      <p>
      This type is to be avoided whenever possible. The only valid reason for using a C pointer is in
      auto-generated code from translating C code.
      </p>
      <p>
      When importing C header files, it is ambiguous whether pointers should be translated as
      single-item pointers (<code class="zig">*T</code>) or many-item pointers (<code class="zig">[*]T</code>).
      C pointers are a compromise so that Zig code can utilize translated header files directly.
      </p>
      <p><code class="zig">[*c]T</code> - C pointer.</p>
      <ul>
        <li>Supports all the syntax of the other two pointer types.</li>
        <li>Coerces to other pointer types, as well as <a href="#Optional-Pointers">Optional Pointers</a>.
            When a C pointer is coerced to a non-optional pointer, safety-checked
            <a href="#Undefined-Behavior">Undefined Behavior</a> occurs if the address is 0.
        </li>
        <li>Allows address 0. On non-freestanding targets, dereferencing address 0 is safety-checked
            <a href="#Undefined-Behavior">Undefined Behavior</a>. Optional C pointers introduce another bit to keep track of
            null, just like <code class="zig">?<span class="tok-type">usize</span></code>. Note that creating an optional C pointer
            is unnecessary as one can use normal <a href="#Optional-Pointers">Optional Pointers</a>.
        </li>
        <li>Supports <a href="#Type-Coercion">Type Coercion</a> to and from integers.</li>
        <li>Supports comparison with integers.</li>
        <li>Does not support Zig-only pointer attributes such as alignment. Use normal <a href="#Pointers">Pointers</a>
        please!</li>
      </ul>
      <p>When a C pointer is pointing to a single struct (not an array), dereference the C pointer to
        access to the struct's fields or member data. That syntax looks like
        this: </p>
        <p><code class="zig">ptr_to_struct.*.struct_member</code></p>
        <p>This is comparable to doing <code class="zig">-&gt;</code> in C.</p>
        <p> When a C pointer is pointing to an array of structs, the syntax reverts to this:</p>
        <p><code class="zig">ptr_to_struct_array[index].struct_member</code></p>
      

      <h2 id="Exporting-a-C-Library"><a href="#toc-Exporting-a-C-Library">Exporting a C Library</a> <a class="hdr" href="#Exporting-a-C-Library">§</a></h2>

      <p>
      One of the primary use cases for Zig is exporting a library with the C ABI for other programming languages
      to call into. The <code class="zig"><span class="tok-kw">export</span></code> keyword in front of functions, variables, and types causes them to
      be part of the library API:
      </p>
      <p class="file">mathtest.zig</p>
      <pre><code class="zig"><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a + b;
}</code></pre>
      <p>To make a static library:</p>
      <pre><code class="shell">$ zig build-lib mathtest.zig
</code></pre>
      <p>To make a shared library:</p>
      <pre><code class="shell">$ zig build-lib mathtest.zig -dynamic
</code></pre>
      <p>Here is an example with the <a href="#Zig-Build-System">Zig Build System</a>:</p>
      <p class="file">test.c</p>
      <pre><code class="cpp">// This header is generated by zig from mathtest.zig
#include "mathtest.h"
#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    int32_t result = add(42, 1337);
    printf("%d\n", result);
    return 0;
}</code></pre>
      <p class="file">build.zig</p>
      <pre><code class="zig"><span class="tok-kw">const</span> Builder = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).build.Builder;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *Builder) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> lib = b.addSharedLibrary(<span class="tok-str">&quot;mathtest&quot;</span>, <span class="tok-str">&quot;mathtest.zig&quot;</span>, b.version(<span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>));

    <span class="tok-kw">const</span> exe = b.addExecutable(<span class="tok-str">&quot;test&quot;</span>, <span class="tok-null">null</span>);
    exe.addCSourceFile(<span class="tok-str">&quot;test.c&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{<span class="tok-str">&quot;-std=c99&quot;</span>});
    exe.linkLibrary(lib);
    exe.linkSystemLibrary(<span class="tok-str">&quot;c&quot;</span>);

    b.default_step.dependOn(&amp;exe.step);

    <span class="tok-kw">const</span> run_cmd = exe.run();

    <span class="tok-kw">const</span> test_step = b.step(<span class="tok-str">&quot;test&quot;</span>, <span class="tok-str">&quot;Test the program&quot;</span>);
    test_step.dependOn(&amp;run_cmd.step);
}</code></pre>
      <p class="file">terminal</p>
      <pre><code class="shell">$ zig build test
1379
</code></pre>
      <p>See also:</p><ul>
<li><a href="#export">export</a></li>
</ul>

      
      <h2 id="Mixing-Object-Files"><a href="#toc-Mixing-Object-Files">Mixing Object Files</a> <a class="hdr" href="#Mixing-Object-Files">§</a></h2>

      <p>
      You can mix Zig object files with any other object files that respect the C ABI. Example:
      </p>
      <p class="file">base64.zig</p>
      <pre><code class="zig"><span class="tok-kw">const</span> base64 = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).base64;

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">decode_base_64</span>(
    dest_ptr: [*]<span class="tok-type">u8</span>,
    dest_len: <span class="tok-type">usize</span>,
    source_ptr: [*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    source_len: <span class="tok-type">usize</span>,
) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> src = source_ptr[<span class="tok-number">0</span>..source_len];
    <span class="tok-kw">const</span> dest = dest_ptr[<span class="tok-number">0</span>..dest_len];
    <span class="tok-kw">const</span> base64_decoder = base64.standard.Decoder;
    <span class="tok-kw">const</span> decoded_size = base64_decoder.calcSizeForSlice(src) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    base64_decoder.decode(dest[<span class="tok-number">0</span>..decoded_size], src) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    <span class="tok-kw">return</span> decoded_size;
}</code></pre>
      <p class="file">test.c</p>
      <pre><code class="cpp">// This header is generated by zig from base64.zig
#include "base64.h"

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    const char *encoded = "YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz";
    char buf[200];

    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));
    buf[len] = 0;
    puts(buf);

    return 0;
}</code></pre>
      <p class="file">build.zig</p>
      <pre><code class="zig"><span class="tok-kw">const</span> Builder = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).build.Builder;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *Builder) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> obj = b.addObject(<span class="tok-str">&quot;base64&quot;</span>, <span class="tok-str">&quot;base64.zig&quot;</span>);

    <span class="tok-kw">const</span> exe = b.addExecutable(<span class="tok-str">&quot;test&quot;</span>, <span class="tok-null">null</span>);
    exe.addCSourceFile(<span class="tok-str">&quot;test.c&quot;</span>, &amp;[_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{<span class="tok-str">&quot;-std=c99&quot;</span>});
    exe.addObject(obj);
    exe.linkSystemLibrary(<span class="tok-str">&quot;c&quot;</span>);
    exe.install();
}</code></pre>
      <p class="file">terminal</p>
      <pre><code class="shell">$ zig build
$ ./zig-cache/bin/test
all your base are belong to us</code></pre>
      <p>See also:</p><ul>
<li><a href="#Targets">Targets</a></li>
<li><a href="#Zig-Build-System">Zig Build System</a></li>
</ul>

      
      
      <h1 id="WebAssembly"><a href="#toc-WebAssembly">WebAssembly</a> <a class="hdr" href="#WebAssembly">§</a></h1>

      <p>Zig supports building for WebAssembly out of the box.</p>
      <h2 id="Freestanding"><a href="#toc-Freestanding">Freestanding</a> <a class="hdr" href="#Freestanding">§</a></h2>

      <p>For host environments like the web browser and nodejs, build as a library using the freestanding OS target.
      Here's an example of running Zig code compiled to WebAssembly with nodejs.</p>
      <p class="file">math.zig</p><pre><code class="zig"><span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">print</span>(<span class="tok-type">i32</span>) <span class="tok-type">void</span>;

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">void</span> {
    print(a + b);
}</code></pre><pre><code class="shell">$ zig build-lib math.zig -target wasm32-freestanding
</code></pre>

      
      <p class="file">test.js</p>
    <pre><code>const fs = require('fs');
const source = fs.readFileSync("./math.wasm");
const typedArray = new Uint8Array(source);

WebAssembly.instantiate(typedArray, {
  env: {
    print: (result) =&gt; { console.log(`The result is ${result}`); }
  }}).then(result =&gt; {
  const add = result.instance.exports.add;
  add(1, 2);
});</code></pre>
    <pre><code>$ node test.js
The result is 3</code></pre>
      <h2 id="WASI"><a href="#toc-WASI">WASI</a> <a class="hdr" href="#WASI">§</a></h2>

      <p>Zig's support for WebAssembly System Interface (WASI) is under active development.
      Example of using the standard library and reading command line arguments:</p>
      <p class="file">args.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
    <span class="tok-kw">const</span> gpa = &amp;general_purpose_allocator.allocator;
    <span class="tok-kw">const</span> args = <span class="tok-kw">try</span> std.process.argsAlloc(gpa);
    <span class="tok-kw">defer</span> std.process.argsFree(gpa, args);

    <span class="tok-kw">for</span> (args) |arg, i| {
        std.debug.print(<span class="tok-str">&quot;{}: {s}\n&quot;</span>, .{ i, arg });
    }
}</code></pre><pre><code class="shell">$ zig build-exe args.zig -target wasm32-wasi</code></pre>

      <pre><code>$ wasmtime args.wasm 123 hello
0: args.wasm
1: 123
2: hello</code></pre>
      <p>A more interesting example would be extracting the list of preopens from the runtime.
      This is now supported in the standard library via <code class="zig">std.fs.wasi.PreopenList</code>:</p>
      <p class="file">preopens.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> PreopenList = std.fs.wasi.PreopenList;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};
    <span class="tok-kw">const</span> gpa = &amp;general_purpose_allocator.allocator;

    <span class="tok-kw">var</span> preopens = PreopenList.init(gpa);
    <span class="tok-kw">defer</span> preopens.deinit();

    <span class="tok-kw">try</span> preopens.populate();

    <span class="tok-kw">for</span> (preopens.asSlice()) |preopen, i| {
        std.debug.print(<span class="tok-str">&quot;{}: {}\n&quot;</span>, .{ i, preopen });
    }
}</code></pre><pre><code class="shell">$ zig build-exe preopens.zig -target wasm32-wasi</code></pre>

      <pre><code>$ wasmtime --dir=. preopens.wasm
0: Preopen{ .fd = 3, .type = PreopenType{ .Dir = '.' } }
</code></pre>
      
      
      <h1 id="Targets"><a href="#toc-Targets">Targets</a> <a class="hdr" href="#Targets">§</a></h1>

      <p>
      Zig supports generating code for all targets that LLVM supports. Here is
      what it looks like to execute <code>zig targets</code> on a Linux x86_64
      computer:
      </p>
      <pre><code class="shell">$ zig targets
Architectures:
  arm
    v8_4a
    v8_3a
    v8_2a
    v8_1a
    v8
    v8r
    v8m_baseline
    v8m_mainline
    v7
    v7em
    v7m
    v7s
    v7k
    v7ve
    v6
    v6m
    v6k
    v6t2
    v5
    v5te
    v4t
  armeb
    v8_4a
    v8_3a
    v8_2a
    v8_1a
    v8
    v8r
    v8m_baseline
    v8m_mainline
    v7
    v7em
    v7m
    v7s
    v7k
    v7ve
    v6
    v6m
    v6k
    v6t2
    v5
    v5te
    v4t
  aarch64
    v8_4a
    v8_3a
    v8_2a
    v8_1a
    v8
    v8r
    v8m_baseline
    v8m_mainline
  aarch64_be
    v8_4a
    v8_3a
    v8_2a
    v8_1a
    v8
    v8r
    v8m_baseline
    v8m_mainline
  avr
  bpfel
  bpfeb
  hexagon
  mips
  mipsel
  mips64
  mips64el
  msp430
  powerpc
  powerpc64
  powerpc64le
  r600
  amdgcn
  riscv32
  riscv64
  sparc
  sparcv9
  sparcel
  s390x
  thumb
    v8_4a
    v8_3a
    v8_2a
    v8_1a
    v8
    v8r
    v8m_baseline
    v8m_mainline
    v7
    v7em
    v7m
    v7s
    v7k
    v7ve
    v6
    v6m
    v6k
    v6t2
    v5
    v5te
    v4t
  thumbeb
    v8_4a
    v8_3a
    v8_2a
    v8_1a
    v8
    v8r
    v8m_baseline
    v8m_mainline
    v7
    v7em
    v7m
    v7s
    v7k
    v7ve
    v6
    v6m
    v6k
    v6t2
    v5
    v5te
    v4t
  i386
  x86_64 (native)
  xcore
  nvptx
  nvptx64
  lanai
  wasm32
  wasm64

Operating Systems:
  freestanding
  ananas
  cloudabi
  dragonfly
  freebsd
  fuchsia
  ios
  kfreebsd
  linux (native)
  lv2
  macos
  netbsd
  openbsd
  solaris
  windows
  haiku
  minix
  rtems
  nacl
  cnk
  aix
  cuda
  nvcl
  amdhsa
  ps4
  elfiamcu
  tvos
  watchos
  mesa3d
  contiki
  amdpal
  zen
  uefi

C ABIs:
  none
  gnu (native)
  gnuabin32
  gnuabi64
  gnueabi
  gnueabihf
  gnux32
  code16
  eabi
  eabihf
  android
  musl
  musleabi
  musleabihf
  msvc
  itanium
  cygnus
  coreclr
  simulator

Available libcs:
  aarch64_be-linux-gnu
  aarch64_be-linux-musl
  aarch64-linux-gnu
  aarch64-linux-musleabi
  armeb-linux-gnueabi
  armeb-linux-gnueabihf
  armeb-linux-musleabi
  armeb-linux-musleabihf
  arm-linux-gnueabi
  arm-linux-gnueabihf
  arm-linux-musleabi
  arm-linux-musleabihf
  i386-linux-gnu
  i386-linux-musl
  mips64el-linux-gnuabi64
  mips64el-linux-gnuabin32
  mips64el-linux-musl
  mips64-linux-gnuabi64
  mips64-linux-gnuabin32
  mips64-linux-musl
  mipsel-linux-gnu
  mipsel-linux-musl
  mips-linux-gnu
  mips-linux-musl
  nios2-linux-gnu
  powerpc64le-linux-gnu
  powerpc64le-linux-musl
  powerpc64-linux-gnu
  powerpc64-linux-musl
  powerpc-linux-gnu
  powerpc-linux-musl
  riscv32-linux-musl
  riscv64-linux-gnu
  riscv64-linux-musl
  s390x-linux-gnu
  s390x-linux-musl
  sparc-linux-gnu
  sparcv9-linux-gnu
  wasm32-freestanding-musl
  x86_64-linux-gnu
  x86_64-linux-gnux32
  x86_64-linux-musl</code></pre>
      <p>
      The Zig Standard Library (<code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>)</code>) has architecture, environment, and operating system
      abstractions, and thus takes additional work to support more platforms.
      Not all standard library code requires operating system abstractions, however,
      so things such as generic data structures work on all above platforms.
      </p>
      <p>The current list of targets supported by the Zig Standard Library is:</p>
      <ul>
      <li>Linux x86_64</li>
      <li>Windows x86_64</li>
      <li>macOS x86_64</li>
      </ul>
      
      <h1 id="Style-Guide"><a href="#toc-Style-Guide">Style Guide</a> <a class="hdr" href="#Style-Guide">§</a></h1>

      <p>
These coding conventions are not enforced by the compiler, but they are shipped in
this documentation along with the compiler in order to provide a point of
reference, should anyone wish to point to an authority on agreed upon Zig
coding style.
      </p>
      <h2 id="Whitespace"><a href="#toc-Whitespace">Whitespace</a> <a class="hdr" href="#Whitespace">§</a></h2>

      <ul>
        <li>
          4 space indentation
        </li>
        <li>
          Open braces on same line, unless you need to wrap.
        </li>
        <li>If a list of things is longer than 2, put each item on its own line and
          exercise the ability to put an extra comma at the end.
        </li>
        <li>
          Line length: aim for 100; use common sense.
        </li>
      </ul>
      
      <h2 id="Names"><a href="#toc-Names">Names</a> <a class="hdr" href="#Names">§</a></h2>

      <p>
      Roughly speaking: <code class="zig">camelCaseFunctionName</code>, <code class="zig">TitleCaseTypeName</code>,
              <code class="zig">snake_case_variable_name</code>. More precisely:
      </p>
      <ul>
        <li>
            If <code class="zig">x</code> is a <code class="zig"><span class="tok-type">type</span></code>
            then <code class="zig">x</code> should be <code class="zig">TitleCase</code>, unless it
            is a <code class="zig"><span class="tok-kw">struct</span></code> with 0 fields and is never meant to be instantiated,
            in which case it is considered to be a "namespace" and uses <code class="zig">snake_case</code>.
        </li>
        <li>
            If <code class="zig">x</code> is callable, and <code class="zig">x</code>'s return type is
            <code class="zig"><span class="tok-type">type</span></code>, then <code class="zig">x</code> should be <code class="zig">TitleCase</code>.
        </li>
        <li>
            If <code class="zig">x</code> is otherwise callable, then <code class="zig">x</code> should
            be <code class="zig">camelCase</code>.
        </li>
        <li>
            Otherwise, <code class="zig">x</code> should be <code class="zig">snake_case</code>.
        </li>
      </ul>
      <p>
      Acronyms, initialisms, proper nouns, or any other word that has capitalization
      rules in written English are subject to naming conventions just like any other
      word. Even acronyms that are only 2 letters long are subject to these
      conventions.
      </p>
      <p>
      File names fall into two categories: types and namespaces. If the file
      (implicity a struct) has top level fields, it should be named like any
      other struct with fields using <code class="zig">TitleCase</code>. Otherwise,
      it should use <code class="zig">snake_case</code>. Directory names should be
      <code class="zig">snake_case</code>.
      </p>
      <p>
      These are general rules of thumb; if it makes sense to do something different,
      do what makes sense. For example, if there is an established convention such as
      <code class="zig">ENOENT</code>, follow the established convention.
      </p>
      
      <h2 id="Examples"><a href="#toc-Examples">Examples</a> <a class="hdr" href="#Examples">§</a></h2>

      <pre><code class="zig"><span class="tok-kw">const</span> namespace_name = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dir_name/file_name.zig&quot;</span>);
<span class="tok-kw">const</span> TypeName = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dir_name/TypeName.zig&quot;</span>);
<span class="tok-kw">var</span> global_var: <span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">const</span> const_name = <span class="tok-number">42</span>;
<span class="tok-kw">const</span> primitive_type_alias = <span class="tok-type">f32</span>;
<span class="tok-kw">const</span> string_alias = []<span class="tok-type">u8</span>;

<span class="tok-kw">const</span> StructName = <span class="tok-kw">struct</span> {
    field: <span class="tok-type">i32</span>,
};
<span class="tok-kw">const</span> StructAlias = StructName;

<span class="tok-kw">fn</span> <span class="tok-fn">functionName</span>(param_name: TypeName) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> functionPointer = functionName;
    functionPointer();
    functionPointer = otherFunction;
    functionPointer();
}
<span class="tok-kw">const</span> functionAlias = functionName;

<span class="tok-kw">fn</span> <span class="tok-fn">ListTemplateFunction</span>(<span class="tok-kw">comptime</span> ChildType: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> fixed_size: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> List(ChildType, fixed_size);
}

<span class="tok-kw">fn</span> <span class="tok-fn">ShortList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        field_name: [n]T,
        <span class="tok-kw">fn</span> <span class="tok-fn">methodName</span>() <span class="tok-type">void</span> {}
    };
}

<span class="tok-comment">// The word XML loses its casing when used in Zig identifiers.</span>
<span class="tok-kw">const</span> xml_document =
    <span class="tok-str">\\&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</span>    <span class="tok-str">\\&lt;document&gt;
</span>    <span class="tok-str">\\&lt;/document&gt;
</span>;
<span class="tok-kw">const</span> XmlParser = <span class="tok-kw">struct</span> {
    field: <span class="tok-type">i32</span>,
};

<span class="tok-comment">// The initials BE (Big Endian) are just another word in Zig identifier names.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">readU32Be</span>() <span class="tok-type">u32</span> {}</code></pre>
      <p>
      See the Zig Standard Library for more examples.
      </p>
      
      
      <h1 id="Source-Encoding"><a href="#toc-Source-Encoding">Source Encoding</a> <a class="hdr" href="#Source-Encoding">§</a></h1>

      <p>Zig source code is encoded in UTF-8. An invalid UTF-8 byte sequence results in a compile error.</p>
      <p>Throughout all zig source code (including in comments), some code points are never allowed:</p>
      <ul>
        <li>Ascii control characters, except for U+000a (LF), U+000d (CR), and U+0009 (HT): U+0000 - U+0008, U+000b - U+000c, U+000e - U+0001f, U+007f.</li>
        <li>Non-Ascii Unicode line endings: U+0085 (NEL), U+2028 (LS), U+2029 (PS).</li>
      </ul>
      <p>
      LF (byte value 0x0a, code point U+000a, <code class="zig"><span class="tok-str">'\n'</span></code>) is the line terminator in Zig source code.
      This byte value terminates every line of zig source code except the last line of the file.
      It is recommended that non-empty source files end with an empty line, which means the last byte would be 0x0a (LF).
      </p>
      <p>
      Each LF may be immediately preceded by a single CR (byte value 0x0d, code point U+000d, <code class="zig"><span class="tok-str">'\r'</span></code>)
      to form a Windows style line ending, but this is discouraged.
      A CR in any other context is not allowed.
      </p>
      <p>
      HT hard tabs (byte value 0x09, code point U+0009, <code class="zig"><span class="tok-str">'\t'</span></code>) are interchangeable with
      SP spaces (byte value 0x20, code point U+0020, <code class="zig"><span class="tok-str">' '</span></code>) as a token separator,
      but use of hard tabs is discouraged. See <a href="#Grammar">Grammar</a>.
      </p>
      <p>
      Note that running <code>zig fmt</code> on a source file will implement all recommendations mentioned here.
      Note also that the stage1 compiler does <a href="https://github.com/ziglang/zig/wiki/FAQ#why-does-zig-force-me-to-use-spaces-instead-of-tabs">not yet support CR or HT</a> control characters.
      </p>
      <p>
      Note that a tool reading Zig source code can make assumptions if the source code is assumed to be correct Zig code.
      For example, when identifying the ends of lines, a tool can use a naive search such as <code>/\n/</code>,
      or an <a href="https://msdn.microsoft.com/en-us/library/dd409797.aspx">advanced</a>
      search such as <code>/\r\n?|[\n\u0085\u2028\u2029]/</code>, and in either case line endings will be correctly identified.
      For another example, when identifying the whitespace before the first token on a line,
      a tool can either use a naive search such as <code>/[ \t]/</code>,
      or an <a href="https://tc39.es/ecma262/#sec-characterclassescape">advanced</a> search such as <code>/\s/</code>,
      and in either case whitespace will be correctly identified.
      </p>
      

      <h1 id="Keyword-Reference"><a href="#toc-Keyword-Reference">Keyword Reference</a> <a class="hdr" href="#Keyword-Reference">§</a></h1>

      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Keyword
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">align</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">align</span></code> can be used to specify the alignment of a pointer.
            It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function.
            <ul>
              <li>See also <a href="#Alignment">Alignment</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">allowzero</span></code></pre>
          </td>
          <td>
            The pointer attribute <code class="zig"><span class="tok-kw">allowzero</span></code> allows a pointer to have address zero.
            <ul>
              <li>See also <a href="#allowzero">allowzero</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">and</span></code></pre>
          </td>
          <td>
            The boolean operator <code class="zig"><span class="tok-kw">and</span></code>.
            <ul>
              <li>See also <a href="#Operators">Operators</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">anyframe</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">anyframe</span></code> can be used as a type for variables which hold pointers to function frames.
            <ul>
              <li>See also <a href="#Async-Functions">Async Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">anytype</span></code></pre>
          </td>
          <td>
            Function parameters and struct fields can be declared with <code class="zig"><span class="tok-kw">anytype</span></code> in place of the type.
            The type will be inferred where the function is called or the struct is instantiated.
            <ul>
              <li>See also <a href="#Function-Parameter-Type-Inference">Function Parameter Type Inference</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">asm</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">asm</span></code> begins an inline assembly expression. This allows for directly controlling the machine code generated on compilation.
            <ul>
              <li>See also <a href="#Assembly">Assembly</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">async</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">async</span></code> can be used before a function call to get a pointer to the function's frame when it suspends.
            <ul>
              <li>See also <a href="#Async-Functions">Async Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">await</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">await</span></code> can be used to suspend the current function until the frame provided after the <code class="zig"><span class="tok-kw">await</span></code> completes.
            <code class="zig"><span class="tok-kw">await</span></code> copies the value returned from the target function's frame to the caller.
            <ul>
              <li>See also <a href="#Async-Functions">Async Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">break</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">break</span></code> can be used with a block label to return a value from the block.
            It can also be used to exit a loop before iteration completes naturally.
            <ul>
              <li>See also <a href="#blocks">blocks</a>, <a href="#while">while</a>, <a href="#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">catch</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">catch</span></code> can be used to evaluate an expression if the expression before it evaluates to an error.
            The expression after the <code class="zig"><span class="tok-kw">catch</span></code> can optionally capture the error value.
            <ul>
              <li>See also <a href="#catch">catch</a>, <a href="#Operators">Operators</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">comptime</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">comptime</span></code> before a declaration can be used to label variables or function parameters as known at compile time.
            It can also be used to guarantee an expression is run at compile time.
            <ul>
              <li>See also <a href="#comptime">comptime</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">const</span></code> declares a variable that can not be modified.
            Used as a pointer attribute, it denotes the value referenced by the pointer cannot be modified.
            <ul>
              <li>See also <a href="#Variables">Variables</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">continue</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">continue</span></code> can be used in a loop to jump back to the beginning of the loop.
            <ul>
              <li>See also <a href="#while">while</a>, <a href="#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">defer</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">defer</span></code> will execute an expression when control flow leaves the current block.
            <ul>
              <li>See also <a href="#defer">defer</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">else</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">else</span></code> can be used to provide an alternate branch for <code class="zig"><span class="tok-kw">if</span></code>, <code class="zig"><span class="tok-kw">switch</span></code>,
            <code class="zig"><span class="tok-kw">while</span></code>, and <code class="zig"><span class="tok-kw">for</span></code> expressions.
            <ul>
              <li>If used after an if expression, the else branch will be executed if the test value returns false, null, or an error.</li>
              <li>If used within a switch expression, the else branch will be executed if the test value matches no other cases.</li>
              <li>If used after a loop expression, the else branch will be executed if the loop finishes without breaking.</li>
              <li>See also <a href="#if">if</a>, <a href="#switch">switch</a>, <a href="#while">while</a>, <a href="#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">enum</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">enum</span></code> defines an enum type.
            <ul>
              <li>See also <a href="#enum">enum</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">errdefer</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">errdefer</span></code> will execute an expression when control flow leaves the current block if the function returns an error.
            <ul>
              <li>See also <a href="#errdefer">errdefer</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">error</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">error</span></code> defines an error type.
            <ul>
              <li>See also <a href="#Errors">Errors</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">export</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">export</span></code> makes a function or variable externally visible in the generated object file.
            Exported functions default to the C calling convention.
            <ul>
              <li>See also <a href="#Functions">Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">extern</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">extern</span></code> can be used to declare a function or variable that will be resolved at link time, when linking statically
            or at runtime, when linking dynamically.
            <ul>
              <li>See also <a href="#Functions">Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-null">false</span></code></pre>
          </td>
          <td>
            The boolean value <code class="zig"><span class="tok-null">false</span></code>.
            <ul>
              <li>See also <a href="#Primitive-Values">Primitive Values</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">fn</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">fn</span></code> declares a function.
            <ul>
              <li>See also <a href="#Functions">Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">for</span></code></pre>
          </td>
          <td>
            A <code class="zig"><span class="tok-kw">for</span></code> expression can be used to iterate over the elements of a slice, array, or tuple.
            <ul>
              <li>See also <a href="#for">for</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">if</span></code></pre>
          </td>
          <td>
            An <code class="zig"><span class="tok-kw">if</span></code> expression can test boolean expressions, optional values, or error unions.
            For optional values or error unions, the if expression can capture the unwrapped value.
            <ul>
              <li>See also <a href="#if">if</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">inline</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">inline</span></code> can be used to label a loop expression such that it will be unrolled at compile time.
            It can also be used to force a function to be inlined at all call sites.
            <ul>
              <li>See also <a href="#inline-while">inline while</a>, <a href="#inline-for">inline for</a>, <a href="#Functions">Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">noalias</span></code></pre>
          </td>
          <td>
            The <code class="zig"><span class="tok-kw">noalias</span></code> keyword.
            <ul>
              <li>TODO add documentation for noalias</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">nosuspend</span></code></pre>
          </td>
          <td>
            The <code class="zig"><span class="tok-kw">nosuspend</span></code> keyword can be used in front of a block, statement or expression, to mark a scope where no suspension points are reached.
            In particular, inside a <code class="zig"><span class="tok-kw">nosuspend</span></code> scope:
            <ul>
              <li>Using the <code class="zig"><span class="tok-kw">suspend</span></code> keyword results in a compile error.</li>
              <li>Using <code class="zig"><span class="tok-kw">await</span></code> on a function frame which hasn't completed yet results in safety-checked <a href="#Undefined-Behavior">Undefined Behavior</a>.</li>
              <li>Calling an async function may result in safety-checked <a href="#Undefined-Behavior">Undefined Behavior</a>, because it's equivalent to <code>await async some_async_fn()</code>, which contains an <code class="zig"><span class="tok-kw">await</span></code>.</li>
            </ul>
            Code inside a <code class="zig"><span class="tok-kw">nosuspend</span></code> scope does not cause the enclosing function to become an <a href="#Async-Functions">async function</a>.
            <ul>
              <li>See also <a href="#Async-Functions">Async Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-null">null</span></code></pre>
          </td>
          <td>
            The optional value <code class="zig"><span class="tok-null">null</span></code>.
            <ul>
              <li>See also <a href="#null">null</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">or</span></code></pre>
          </td>
          <td>
            The boolean operator <code class="zig"><span class="tok-kw">or</span></code>.
            <ul>
              <li>See also <a href="#Operators">Operators</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">orelse</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">orelse</span></code> can be used to evaluate an expression if the expression before it evaluates to null.
            <ul>
              <li>See also <a href="#Optionals">Optionals</a>, <a href="#Operators">Operators</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">packed</span></code></pre>
          </td>
          <td>
            The <code class="zig"><span class="tok-kw">packed</span></code> keyword before a struct definition changes the struct's in-memory layout
            to the guaranteed <code class="zig"><span class="tok-kw">packed</span></code> layout.
            <ul>
              <li>See also <a href="#packed-struct">packed struct</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">pub</span></code></pre>
          </td>
          <td>
            The <code class="zig"><span class="tok-kw">pub</span></code> in front of a top level declaration makes the declaration available
            to reference from a different file than the one it is declared in.
            <ul>
              <li>See also <a href="#import">import</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">resume</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">resume</span></code> will continue execution of a function frame after the point the function was suspended.
            <ul>
              <li>See also <a href="#Suspend-and-Resume">Suspend and Resume</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">return</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">return</span></code> exits a function with a value.
            <ul>
              <li>See also <a href="#Functions">Functions</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">linksection</span></code></pre>
          </td>
          <td>
            The <code class="zig"><span class="tok-kw">linksection</span></code> keyword.
            <ul>
              <li>TODO add documentation for linksection</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">struct</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">struct</span></code> defines a struct.
            <ul>
              <li>See also <a href="#struct">struct</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">suspend</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">suspend</span></code> will cause control flow to return to the call site or resumer of the function.
            <code class="zig"><span class="tok-kw">suspend</span></code> can also be used before a block within a function,
            to allow the function access to its frame before control flow returns to the call site.
            <ul>
              <li>See also <a href="#Suspend-and-Resume">Suspend and Resume</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">switch</span></code></pre>
          </td>
          <td>
            A <code class="zig"><span class="tok-kw">switch</span></code> expression can be used to test values of a common type.
            <code class="zig"><span class="tok-kw">switch</span></code> cases can capture field values of a <a href="#Tagged-union">Tagged union</a>.
            <ul>
              <li>See also <a href="#switch">switch</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">test</span></code></pre>
          </td>
          <td>
            The <code class="zig"><span class="tok-kw">test</span></code> keyword can be used to denote a top-level block of code
            used to make sure behavior meets expectations.
            <ul>
              <li>See also <a href="#Zig-Test">Zig Test</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">threadlocal</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">threadlocal</span></code> can be used to specify a variable as thread-local.
            <ul>
              <li>See also <a href="#Thread-Local-Variables">Thread Local Variables</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-null">true</span></code></pre>
          </td>
          <td>
            The boolean value <code class="zig"><span class="tok-null">true</span></code>.
            <ul>
              <li>See also <a href="#Primitive-Values">Primitive Values</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">try</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">try</span></code> evaluates an error union expression.
            If it is an error, it returns from the current function with the same error.
            Otherwise, the expression results in the unwrapped value.
            <ul>
              <li>See also <a href="#try">try</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-null">undefined</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-null">undefined</span></code> can be used to leave a value uninitialized.
            <ul>
              <li>See also <a href="#undefined">undefined</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">union</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">union</span></code> defines a union.
            <ul>
              <li>See also <a href="#union">union</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">unreachable</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">unreachable</span></code> can be used to assert that control flow will never happen upon a particular location.
            Depending on the build mode, <code class="zig"><span class="tok-kw">unreachable</span></code> may emit a panic.
            <ul>
              <li>Emits a panic in <code class="zig">Debug</code> and <code class="zig">ReleaseSafe</code> mode, or when using <code>zig test</code>.</li>
              <li>Does not emit a panic in <code class="zig">ReleaseFast</code> mode, unless <code>zig test</code> is being used.</li>
              <li>See also <a href="#unreachable">unreachable</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">usingnamespace</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">usingnamespace</span></code> is a top-level declaration that imports all the public declarations of the operand,
            which must be a struct, union, or enum, into the current scope.
            <ul>
              <li>See also <a href="#usingnamespace">usingnamespace</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">var</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">var</span></code> declares a variable that may be modified.
            <ul>
              <li>See also <a href="#Variables">Variables</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">volatile</span></code></pre>
          </td>
          <td>
            <code class="zig"><span class="tok-kw">volatile</span></code> can be used to denote loads or stores of a pointer have side effects.
            It can also modify an inline assembly expression to denote it has side effects.
            <ul>
              <li>See also <a href="#volatile">volatile</a>, <a href="#Assembly">Assembly</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre><code class="zig"><span class="tok-kw">while</span></code></pre>
          </td>
          <td>
            A <code class="zig"><span class="tok-kw">while</span></code> expression can be used to repeatedly test a boolean, optional, or error union expression,
            and cease looping when that expression evaluates to false, null, or an error, respectively.
            <ul>
              <li>See also <a href="#while">while</a></li>
            </ul>
          </td>
        </tr>
      </table>
      </div>
      

      <h1 id="Grammar"><a href="#toc-Grammar">Grammar</a> <a class="hdr" href="#Grammar">§</a></h1>

      <pre><code>Root &lt;- skip ContainerMembers eof

# *** Top level ***
ContainerMembers
    &lt;- TestDecl ContainerMembers
     / TopLevelComptime ContainerMembers
     / KEYWORD_pub? TopLevelDecl ContainerMembers
     / ContainerField COMMA ContainerMembers
     / ContainerField
     /

TestDecl &lt;- KEYWORD_test STRINGLITERALSINGLE Block

TopLevelComptime &lt;- KEYWORD_comptime BlockExpr

TopLevelDecl
    &lt;- (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE? / (KEYWORD_inline / KEYWORD_noinline))? FnProto (SEMICOLON / Block)
     / (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE?)? KEYWORD_threadlocal? VarDecl
     / KEYWORD_usingnamespace Expr SEMICOLON

FnProto &lt;- KEYWORD_fn IDENTIFIER? LPAREN ParamDeclList RPAREN ByteAlign? LinkSection? CallConv? EXCLAMATIONMARK? (KEYWORD_anytype / TypeExpr)

VarDecl &lt;- (KEYWORD_const / KEYWORD_var) IDENTIFIER (COLON TypeExpr)? ByteAlign? LinkSection? (EQUAL Expr)? SEMICOLON

ContainerField &lt;- KEYWORD_comptime? IDENTIFIER (COLON TypeExpr ByteAlign?)? (EQUAL Expr)?

# *** Block Level ***
Statement
    &lt;- KEYWORD_comptime? VarDecl
     / KEYWORD_comptime BlockExprStatement
     / KEYWORD_nosuspend BlockExprStatement
     / KEYWORD_suspend (SEMICOLON / BlockExprStatement)
     / KEYWORD_defer BlockExprStatement
     / KEYWORD_errdefer BlockExprStatement
     / IfStatement
     / LabeledStatement
     / SwitchExpr
     / AssignExpr SEMICOLON

IfStatement
    &lt;- IfPrefix BlockExpr ( KEYWORD_else Payload? Statement )?
     / IfPrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )

LabeledStatement &lt;- BlockLabel? (Block / LoopStatement)

LoopStatement &lt;- KEYWORD_inline? (ForStatement / WhileStatement)

ForStatement
    &lt;- ForPrefix BlockExpr ( KEYWORD_else Statement )?
     / ForPrefix AssignExpr ( SEMICOLON / KEYWORD_else Statement )

WhileStatement
    &lt;- WhilePrefix BlockExpr ( KEYWORD_else Payload? Statement )?
     / WhilePrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )

BlockExprStatement
    &lt;- BlockExpr
     / AssignExpr SEMICOLON

BlockExpr &lt;- BlockLabel? Block

# *** Expression Level ***
AssignExpr &lt;- Expr (AssignOp Expr)?

Expr &lt;- BoolOrExpr

BoolOrExpr &lt;- BoolAndExpr (KEYWORD_or BoolAndExpr)*

BoolAndExpr &lt;- CompareExpr (KEYWORD_and CompareExpr)*

CompareExpr &lt;- BitwiseExpr (CompareOp BitwiseExpr)?

BitwiseExpr &lt;- BitShiftExpr (BitwiseOp BitShiftExpr)*

BitShiftExpr &lt;- AdditionExpr (BitShiftOp AdditionExpr)*

AdditionExpr &lt;- MultiplyExpr (AdditionOp MultiplyExpr)*

MultiplyExpr &lt;- PrefixExpr (MultiplyOp PrefixExpr)*

PrefixExpr &lt;- PrefixOp* PrimaryExpr

PrimaryExpr
    &lt;- AsmExpr
     / IfExpr
     / KEYWORD_break BreakLabel? Expr?
     / KEYWORD_comptime Expr
     / KEYWORD_nosuspend Expr
     / KEYWORD_continue BreakLabel?
     / KEYWORD_resume Expr
     / KEYWORD_return Expr?
     / BlockLabel? LoopExpr
     / Block
     / CurlySuffixExpr

IfExpr &lt;- IfPrefix Expr (KEYWORD_else Payload? Expr)?

Block &lt;- LBRACE Statement* RBRACE

LoopExpr &lt;- KEYWORD_inline? (ForExpr / WhileExpr)

ForExpr &lt;- ForPrefix Expr (KEYWORD_else Expr)?

WhileExpr &lt;- WhilePrefix Expr (KEYWORD_else Payload? Expr)?

CurlySuffixExpr &lt;- TypeExpr InitList?

InitList
    &lt;- LBRACE FieldInit (COMMA FieldInit)* COMMA? RBRACE
     / LBRACE Expr (COMMA Expr)* COMMA? RBRACE
     / LBRACE RBRACE

TypeExpr &lt;- PrefixTypeOp* ErrorUnionExpr

ErrorUnionExpr &lt;- SuffixExpr (EXCLAMATIONMARK TypeExpr)?

SuffixExpr
    &lt;- KEYWORD_async PrimaryTypeExpr SuffixOp* FnCallArguments
     / PrimaryTypeExpr (SuffixOp / FnCallArguments)*

PrimaryTypeExpr
    &lt;- BUILTINIDENTIFIER FnCallArguments
     / CHAR_LITERAL
     / ContainerDecl
     / DOT IDENTIFIER
     / DOT InitList
     / ErrorSetDecl
     / FLOAT
     / FnProto
     / GroupedExpr
     / LabeledTypeExpr
     / IDENTIFIER
     / IfTypeExpr
     / INTEGER
     / KEYWORD_comptime TypeExpr
     / KEYWORD_error DOT IDENTIFIER
     / KEYWORD_false
     / KEYWORD_null
     / KEYWORD_anyframe
     / KEYWORD_true
     / KEYWORD_undefined
     / KEYWORD_unreachable
     / STRINGLITERAL
     / SwitchExpr

ContainerDecl &lt;- (KEYWORD_extern / KEYWORD_packed)? ContainerDeclAuto

ErrorSetDecl &lt;- KEYWORD_error LBRACE IdentifierList RBRACE

GroupedExpr &lt;- LPAREN Expr RPAREN

IfTypeExpr &lt;- IfPrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?

LabeledTypeExpr
    &lt;- BlockLabel Block
     / BlockLabel? LoopTypeExpr

LoopTypeExpr &lt;- KEYWORD_inline? (ForTypeExpr / WhileTypeExpr)

ForTypeExpr &lt;- ForPrefix TypeExpr (KEYWORD_else TypeExpr)?

WhileTypeExpr &lt;- WhilePrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?

SwitchExpr &lt;- KEYWORD_switch LPAREN Expr RPAREN LBRACE SwitchProngList RBRACE

# *** Assembly ***
AsmExpr &lt;- KEYWORD_asm KEYWORD_volatile? LPAREN STRINGLITERAL AsmOutput? RPAREN

AsmOutput &lt;- COLON AsmOutputList AsmInput?

AsmOutputItem &lt;- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN (MINUSRARROW TypeExpr / IDENTIFIER) RPAREN

AsmInput &lt;- COLON AsmInputList AsmClobbers?

AsmInputItem &lt;- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN Expr RPAREN

AsmClobbers &lt;- COLON StringList

# *** Helper grammar ***
BreakLabel &lt;- COLON IDENTIFIER

BlockLabel &lt;- IDENTIFIER COLON

FieldInit &lt;- DOT IDENTIFIER EQUAL Expr

WhileContinueExpr &lt;- COLON LPAREN AssignExpr RPAREN

LinkSection &lt;- KEYWORD_linksection LPAREN Expr RPAREN

CallConv &lt;- KEYWORD_callconv LPAREN Expr RPAREN

ParamDecl &lt;- (KEYWORD_noalias / KEYWORD_comptime)? (IDENTIFIER COLON)? ParamType

ParamType
    &lt;- KEYWORD_anytype
     / DOT3
     / TypeExpr

# Control flow prefixes
IfPrefix &lt;- KEYWORD_if LPAREN Expr RPAREN PtrPayload?

WhilePrefix &lt;- KEYWORD_while LPAREN Expr RPAREN PtrPayload? WhileContinueExpr?

ForPrefix &lt;- KEYWORD_for LPAREN Expr RPAREN PtrIndexPayload

# Payloads
Payload &lt;- PIPE IDENTIFIER PIPE

PtrPayload &lt;- PIPE ASTERISK? IDENTIFIER PIPE

PtrIndexPayload &lt;- PIPE ASTERISK? IDENTIFIER (COMMA IDENTIFIER)? PIPE


# Switch specific
SwitchProng &lt;- SwitchCase EQUALRARROW PtrPayload? AssignExpr

SwitchCase
    &lt;- SwitchItem (COMMA SwitchItem)* COMMA?
     / KEYWORD_else

SwitchItem &lt;- Expr (DOT3 Expr)?

# Operators
AssignOp
    &lt;- ASTERISKEQUAL
     / SLASHEQUAL
     / PERCENTEQUAL
     / PLUSEQUAL
     / MINUSEQUAL
     / LARROW2EQUAL
     / RARROW2EQUAL
     / AMPERSANDEQUAL
     / CARETEQUAL
     / PIPEEQUAL
     / ASTERISKPERCENTEQUAL
     / PLUSPERCENTEQUAL
     / MINUSPERCENTEQUAL
     / EQUAL

CompareOp
    &lt;- EQUALEQUAL
     / EXCLAMATIONMARKEQUAL
     / LARROW
     / RARROW
     / LARROWEQUAL
     / RARROWEQUAL

BitwiseOp
    &lt;- AMPERSAND
     / CARET
     / PIPE
     / KEYWORD_orelse
     / KEYWORD_catch Payload?

BitShiftOp
    &lt;- LARROW2
     / RARROW2

AdditionOp
    &lt;- PLUS
     / MINUS
     / PLUS2
     / PLUSPERCENT
     / MINUSPERCENT

MultiplyOp
    &lt;- PIPE2
     / ASTERISK
     / SLASH
     / PERCENT
     / ASTERISK2
     / ASTERISKPERCENT

PrefixOp
    &lt;- EXCLAMATIONMARK
     / MINUS
     / TILDE
     / MINUSPERCENT
     / AMPERSAND
     / KEYWORD_try
     / KEYWORD_await

PrefixTypeOp
    &lt;- QUESTIONMARK
     / KEYWORD_anyframe MINUSRARROW
     / ArrayTypeStart (ByteAlign / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*
     / PtrTypeStart (KEYWORD_align LPAREN Expr (COLON INTEGER COLON INTEGER)? RPAREN / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*

SuffixOp
    &lt;- LBRACKET Expr (DOT2 Expr?)? RBRACKET
     / DOT IDENTIFIER
     / DOTASTERISK
     / DOTQUESTIONMARK

FnCallArguments &lt;- LPAREN ExprList RPAREN

# Ptr specific
ArrayTypeStart &lt;- LBRACKET Expr? (COLON Expr)? RBRACKET

PtrTypeStart
    &lt;- ASTERISK
     / ASTERISK2
     / LBRACKET ASTERISK (LETTERC / COLON Expr)? RBRACKET

# ContainerDecl specific
ContainerDeclAuto &lt;- ContainerDeclType LBRACE ContainerMembers RBRACE

ContainerDeclType
    &lt;- KEYWORD_struct
     / KEYWORD_opaque
     / KEYWORD_enum (LPAREN Expr RPAREN)?
     / KEYWORD_union (LPAREN (KEYWORD_enum (LPAREN Expr RPAREN)? / Expr) RPAREN)?

# Alignment
ByteAlign &lt;- KEYWORD_align LPAREN Expr RPAREN

# Lists
IdentifierList &lt;- (IDENTIFIER COMMA)* IDENTIFIER?

SwitchProngList &lt;- (SwitchProng COMMA)* SwitchProng?

AsmOutputList &lt;- (AsmOutputItem COMMA)* AsmOutputItem?

AsmInputList &lt;- (AsmInputItem COMMA)* AsmInputItem?

StringList &lt;- (STRINGLITERAL COMMA)* STRINGLITERAL?

ParamDeclList &lt;- (ParamDecl COMMA)* ParamDecl?

ExprList &lt;- (Expr COMMA)* Expr?

# *** Tokens ***
eof &lt;- !.
eol &lt;- ('\r'? '\n') | eof
hex &lt;- [0-9a-fA-F]
hex_ &lt;- ('_'/hex)
dec &lt;- [0-9]
dec_ &lt;- ('_'/dec)

dec_int &lt;- dec (dec_* dec)?
hex_int &lt;- hex (hex_* dec)?

char_escape
    &lt;- '\\x' hex hex
     / '\\u{' hex+ '}'
     / '\\' [nr\\t'&quot;]
char_char
    &lt;- char_escape
     / [^\\'\r\n]
string_char
    &lt;- char_escape
     / [^\\&quot;\r\n]

line_comment &lt;- '//'[^\r\n]* eol
line_string &lt;- ('\\\\' [^\r\n]* eol skip)+
skip &lt;- ([ \t] / eol / line_comment)*

CHAR_LITERAL &lt;- &quot;'&quot; char_char &quot;'&quot; skip
FLOAT
    &lt;- '0x' hex_* hex '.' hex_int ([pP] [-+]? hex_int)? skip
     /      dec_int   '.' dec_int ([eE] [-+]? dec_int)? skip
     / '0x' hex_* hex '.'? [pP] [-+]? hex_int skip
     /      dec_int   '.'? [eE] [-+]? dec_int skip
INTEGER
    &lt;- '0b' [_01]*  [01]  skip
     / '0o' [_0-7]* [0-7] skip
     / '0x' hex_* hex skip
     /      dec_int   skip
STRINGLITERALSINGLE &lt;- '&quot;' string_char* '&quot;' skip
STRINGLITERAL
    &lt;- STRINGLITERALSINGLE
     / line_string skip
IDENTIFIER
    &lt;- !keyword [A-Za-z_] [A-Za-z0-9_]* skip
     / '@&quot;' string_char* '&quot;' skip
BUILTINIDENTIFIER &lt;- '@'[A-Za-z_][A-Za-z0-9_]* skip


AMPERSAND            &lt;- '&amp;'      ![=]      skip
AMPERSANDEQUAL       &lt;- '&amp;='               skip
ASTERISK             &lt;- '*'      ![*%=]    skip
ASTERISK2            &lt;- '**'               skip
ASTERISKEQUAL        &lt;- '*='               skip
ASTERISKPERCENT      &lt;- '*%'     ![=]      skip
ASTERISKPERCENTEQUAL &lt;- '*%='              skip
CARET                &lt;- '^'      ![=]      skip
CARETEQUAL           &lt;- '^='               skip
COLON                &lt;- ':'                skip
COMMA                &lt;- ','                skip
DOT                  &lt;- '.'      ![*.?]    skip
DOT2                 &lt;- '..'     ![.]      skip
DOT3                 &lt;- '...'              skip
DOTASTERISK          &lt;- '.*'               skip
DOTQUESTIONMARK      &lt;- '.?'               skip
EQUAL                &lt;- '='      ![&gt;=]     skip
EQUALEQUAL           &lt;- '=='               skip
EQUALRARROW          &lt;- '=&gt;'               skip
EXCLAMATIONMARK      &lt;- '!'      ![=]      skip
EXCLAMATIONMARKEQUAL &lt;- '!='               skip
LARROW               &lt;- '&lt;'      ![&lt;=]     skip
LARROW2              &lt;- '&lt;&lt;'     ![=]      skip
LARROW2EQUAL         &lt;- '&lt;&lt;='              skip
LARROWEQUAL          &lt;- '&lt;='               skip
LBRACE               &lt;- '{'                skip
LBRACKET             &lt;- '['                skip
LPAREN               &lt;- '('                skip
MINUS                &lt;- '-'      ![%=&gt;]    skip
MINUSEQUAL           &lt;- '-='               skip
MINUSPERCENT         &lt;- '-%'     ![=]      skip
MINUSPERCENTEQUAL    &lt;- '-%='              skip
MINUSRARROW          &lt;- '-&gt;'               skip
PERCENT              &lt;- '%'      ![=]      skip
PERCENTEQUAL         &lt;- '%='               skip
PIPE                 &lt;- '|'      ![|=]     skip
PIPE2                &lt;- '||'               skip
PIPEEQUAL            &lt;- '|='               skip
PLUS                 &lt;- '+'      ![%+=]    skip
PLUS2                &lt;- '++'               skip
PLUSEQUAL            &lt;- '+='               skip
PLUSPERCENT          &lt;- '+%'     ![=]      skip
PLUSPERCENTEQUAL     &lt;- '+%='              skip
LETTERC              &lt;- 'c'                skip
QUESTIONMARK         &lt;- '?'                skip
RARROW               &lt;- '&gt;'      ![&gt;=]     skip
RARROW2              &lt;- '&gt;&gt;'     ![=]      skip
RARROW2EQUAL         &lt;- '&gt;&gt;='              skip
RARROWEQUAL          &lt;- '&gt;='               skip
RBRACE               &lt;- '}'                skip
RBRACKET             &lt;- ']'                skip
RPAREN               &lt;- ')'                skip
SEMICOLON            &lt;- ';'                skip
SLASH                &lt;- '/'      ![=]      skip
SLASHEQUAL           &lt;- '/='               skip
TILDE                &lt;- '~'                skip

end_of_word &lt;- ![a-zA-Z0-9_] skip
KEYWORD_align       &lt;- 'align'       end_of_word
KEYWORD_allowzero   &lt;- 'allowzero'   end_of_word
KEYWORD_and         &lt;- 'and'         end_of_word
KEYWORD_anyframe    &lt;- 'anyframe'    end_of_word
KEYWORD_anytype     &lt;- 'anytype'     end_of_word
KEYWORD_asm         &lt;- 'asm'         end_of_word
KEYWORD_async       &lt;- 'async'       end_of_word
KEYWORD_await       &lt;- 'await'       end_of_word
KEYWORD_break       &lt;- 'break'       end_of_word
KEYWORD_callconv    &lt;- 'callconv'    end_of_word
KEYWORD_catch       &lt;- 'catch'       end_of_word
KEYWORD_comptime    &lt;- 'comptime'    end_of_word
KEYWORD_const       &lt;- 'const'       end_of_word
KEYWORD_continue    &lt;- 'continue'    end_of_word
KEYWORD_defer       &lt;- 'defer'       end_of_word
KEYWORD_else        &lt;- 'else'        end_of_word
KEYWORD_enum        &lt;- 'enum'        end_of_word
KEYWORD_errdefer    &lt;- 'errdefer'    end_of_word
KEYWORD_error       &lt;- 'error'       end_of_word
KEYWORD_export      &lt;- 'export'      end_of_word
KEYWORD_extern      &lt;- 'extern'      end_of_word
KEYWORD_false       &lt;- 'false'       end_of_word
KEYWORD_fn          &lt;- 'fn'          end_of_word
KEYWORD_for         &lt;- 'for'         end_of_word
KEYWORD_if          &lt;- 'if'          end_of_word
KEYWORD_inline      &lt;- 'inline'      end_of_word
KEYWORD_noalias     &lt;- 'noalias'     end_of_word
KEYWORD_nosuspend   &lt;- 'nosuspend'   end_of_word
KEYWORD_noinline    &lt;- 'noinline'    end_of_word
KEYWORD_null        &lt;- 'null'        end_of_word
KEYWORD_opaque      &lt;- 'opaque'      end_of_word
KEYWORD_or          &lt;- 'or'          end_of_word
KEYWORD_orelse      &lt;- 'orelse'      end_of_word
KEYWORD_packed      &lt;- 'packed'      end_of_word
KEYWORD_pub         &lt;- 'pub'         end_of_word
KEYWORD_resume      &lt;- 'resume'      end_of_word
KEYWORD_return      &lt;- 'return'      end_of_word
KEYWORD_linksection &lt;- 'linksection' end_of_word
KEYWORD_struct      &lt;- 'struct'      end_of_word
KEYWORD_suspend     &lt;- 'suspend'     end_of_word
KEYWORD_switch      &lt;- 'switch'      end_of_word
KEYWORD_test        &lt;- 'test'        end_of_word
KEYWORD_threadlocal &lt;- 'threadlocal' end_of_word
KEYWORD_true        &lt;- 'true'        end_of_word
KEYWORD_try         &lt;- 'try'         end_of_word
KEYWORD_undefined   &lt;- 'undefined'   end_of_word
KEYWORD_union       &lt;- 'union'       end_of_word
KEYWORD_unreachable &lt;- 'unreachable' end_of_word
KEYWORD_usingnamespace &lt;- 'usingnamespace' end_of_word
KEYWORD_var         &lt;- 'var'         end_of_word
KEYWORD_volatile    &lt;- 'volatile'    end_of_word
KEYWORD_while       &lt;- 'while'       end_of_word

keyword &lt;- KEYWORD_align / KEYWORD_allowzero / KEYWORD_and / KEYWORD_anyframe
         / KEYWORD_anytype / KEYWORD_asm / KEYWORD_async / KEYWORD_await
         / KEYWORD_break / KEYWORD_callconv / KEYWORD_catch / KEYWORD_comptime
         / KEYWORD_const / KEYWORD_continue / KEYWORD_defer / KEYWORD_else
         / KEYWORD_enum / KEYWORD_errdefer / KEYWORD_error / KEYWORD_export
         / KEYWORD_extern / KEYWORD_false / KEYWORD_fn / KEYWORD_for / KEYWORD_if
         / KEYWORD_inline / KEYWORD_noalias / KEYWORD_nosuspend / KEYWORD_noinline
         / KEYWORD_null / KEYWORD_opaque / KEYWORD_or / KEYWORD_orelse / KEYWORD_packed
         / KEYWORD_pub / KEYWORD_resume / KEYWORD_return / KEYWORD_linksection
         / KEYWORD_struct / KEYWORD_suspend / KEYWORD_switch
         / KEYWORD_test / KEYWORD_threadlocal / KEYWORD_true / KEYWORD_try
         / KEYWORD_undefined / KEYWORD_union / KEYWORD_unreachable
         / KEYWORD_usingnamespace / KEYWORD_var / KEYWORD_volatile / KEYWORD_while
</code></pre>
      
      <h1 id="Zen"><a href="#toc-Zen">Zen</a> <a class="hdr" href="#Zen">§</a></h1>

      <ul>
        <li>Communicate intent precisely.</li>
        <li>Edge cases matter.</li>
        <li>Favor reading code over writing code.</li>
        <li>Only one obvious way to do things.</li>
        <li>Runtime crashes are better than bugs.</li>
        <li>Compile errors are better than runtime crashes.</li>
        <li>Incremental improvements.</li>
        <li>Avoid local maximums.</li>
        <li>Reduce the amount one must remember.</li>
        <li>Focus on code rather than style.</li>
        <li>Resource allocation may fail; resource deallocation must succeed.</li>
        <li>Memory is a resource.</li>
        <li>Together we serve the users.</li>
      </ul>
      
      </div></div>
    </div>
  </body>
</html>
