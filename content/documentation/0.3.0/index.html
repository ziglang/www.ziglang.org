<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Documentation - The Zig Programming Language</title>
    <style type="text/css">
      table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
      }
      th, td {
        padding: 0.1em;
      }
      .t0_1, .t37, .t37_1 {
        font-weight: bold;
      }
      .t2_0 {
        color: grey;
      }
      .t31_1 {
        color: red;
      }
      .t32_1 {
        color: green;
      }
      .t36_1 {
        color: #0086b3;
      }
      .file {
        text-decoration: underline;
      }
      code {
        font-size: 12pt;
      }
      pre > code {
        display: block;
        overflow: auto;

        overflow-x: auto;
        padding: 0.5em;
        color: #333;
        background: #f8f8f8;
      }
      .table-wrapper {
        width: 100%;
        overflow-y: auto;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #998;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      /* Desktop */
      @media screen and (min-width: 56.25em) {
        #nav {
          width: 20em;
          height: 100%;
          position: fixed;
          overflow-y: scroll;
          left: 0;
          top: 2em;
          padding-left: 1em;
        }
        #contents {
          max-width: 60em;
          padding-left: 22em;
          padding: 1em;
          padding-left: 24em;
        }
      }
      /* Mobile */
      @media screen and (max-width: 56.25em) {
        body, code {
          font-size: small;
        }
        #nav {
          border-bottom: 1px solid grey;
        }
      }
    </style>
  </head>
  <body>
<a href="https://ziglang.org/documentation/0.1.1">0.1.1</a> |
<a href="https://ziglang.org/documentation/0.2.0">0.2.0</a> |
0.3.0 |
<a href="https://ziglang.org/documentation/0.4.0">0.4.0</a> |
<a href="https://ziglang.org/documentation/0.5.0">0.5.0</a> |
<a href="https://ziglang.org/documentation/0.6.0">0.6.0</a> |
<a href="https://ziglang.org/documentation/0.7.1">0.7.1</a> |
<a href="https://ziglang.org/documentation/0.8.1">0.8.1</a> |
<a href="https://ziglang.org/documentation/0.9.1">0.9.1</a> |
<a href="https://ziglang.org/documentation/0.10.1">0.10.1</a> |
<a href="https://ziglang.org/documentation/0.11.0/">0.11.0</a> |
<a href="https://ziglang.org/documentation/0.12.0/">0.12.0</a> |
<a href="https://ziglang.org/documentation/master">master</a>
    <div id="nav">
      <h3>Index</h3>
      

    <ul>
        <li><a href="#Introduction">Introduction</a></li>
        <li><a href="#Hello-World">Hello World</a></li>
        <li><a href="#Comments">Comments</a>
        <ul>
            <li><a href="#Doc-comments">Doc comments</a></li>
        </ul></li>
        <li><a href="#Values">Values</a>
        <ul>
            <li><a href="#Primitive-Types">Primitive Types</a></li>
            <li><a href="#Primitive-Values">Primitive Values</a></li>
            <li><a href="#String-Literals">String Literals</a>
            <ul>
                <li><a href="#Escape-Sequences">Escape Sequences</a></li>
                <li><a href="#Multiline-String-Literals">Multiline String Literals</a></li>
            </ul></li>
            <li><a href="#Assignment">Assignment</a>
            <ul>
                <li><a href="#undefined">undefined</a></li>
            </ul></li>
        </ul></li>
        <li><a href="#Integers">Integers</a>
        <ul>
            <li><a href="#Integer-Literals">Integer Literals</a></li>
            <li><a href="#Runtime-Integer-Values">Runtime Integer Values</a></li>
        </ul></li>
        <li><a href="#Floats">Floats</a>
        <ul>
            <li><a href="#Float-Literals">Float Literals</a></li>
            <li><a href="#Floating-Point-Operations">Floating Point Operations</a></li>
        </ul></li>
        <li><a href="#Operators">Operators</a>
        <ul>
            <li><a href="#Table-of-Operators">Table of Operators</a></li>
            <li><a href="#Precedence">Precedence</a></li>
        </ul></li>
        <li><a href="#Arrays">Arrays</a></li>
        <li><a href="#Pointers">Pointers</a>
        <ul>
            <li><a href="#Alignment">Alignment</a></li>
            <li><a href="#Type-Based-Alias-Analysis">Type Based Alias Analysis</a></li>
        </ul></li>
        <li><a href="#Slices">Slices</a></li>
        <li><a href="#struct">struct</a>
        <ul>
            <li><a href="#packed-struct">packed struct</a></li>
            <li><a href="#struct-Naming">struct Naming</a></li>
        </ul></li>
        <li><a href="#enum">enum</a>
        <ul>
            <li><a href="#extern-enum">extern enum</a></li>
            <li><a href="#packed-enum">packed enum</a></li>
        </ul></li>
        <li><a href="#union">union</a></li>
        <li><a href="#blocks">blocks</a></li>
        <li><a href="#switch">switch</a></li>
        <li><a href="#while">while</a>
        <ul>
            <li><a href="#Labeled-while">Labeled while</a></li>
            <li><a href="#while-with-Optionals">while with Optionals</a></li>
            <li><a href="#while-with-Error-Unions">while with Error Unions</a></li>
            <li><a href="#inline-while">inline while</a></li>
        </ul></li>
        <li><a href="#for">for</a>
        <ul>
            <li><a href="#Labeled-for">Labeled for</a></li>
            <li><a href="#inline-for">inline for</a></li>
        </ul></li>
        <li><a href="#if">if</a></li>
        <li><a href="#defer">defer</a></li>
        <li><a href="#unreachable">unreachable</a>
        <ul>
            <li><a href="#Basics">Basics</a></li>
            <li><a href="#At-Compile-Time">At Compile-Time</a></li>
        </ul></li>
        <li><a href="#noreturn">noreturn</a></li>
        <li><a href="#Functions">Functions</a>
        <ul>
            <li><a href="#Pass-by-value-Parameters">Pass-by-value Parameters</a></li>
            <li><a href="#Function-Reflection">Function Reflection</a></li>
        </ul></li>
        <li><a href="#Errors">Errors</a>
        <ul>
            <li><a href="#Error-Set-Type">Error Set Type</a>
            <ul>
                <li><a href="#The-Global-Error-Set">The Global Error Set</a></li>
            </ul></li>
            <li><a href="#Error-Union-Type">Error Union Type</a>
            <ul>
                <li><a href="#catch">catch</a></li>
                <li><a href="#try">try</a></li>
                <li><a href="#errdefer">errdefer</a></li>
                <li><a href="#Merging-Error-Sets">Merging Error Sets</a></li>
                <li><a href="#Inferred-Error-Sets">Inferred Error Sets</a></li>
            </ul></li>
            <li><a href="#Error-Return-Traces">Error Return Traces</a>
            <ul>
                <li><a href="#Implementation-Details">Implementation Details</a></li>
            </ul></li>
        </ul></li>
        <li><a href="#Optionals">Optionals</a>
        <ul>
            <li><a href="#Optional-Type">Optional Type</a></li>
            <li><a href="#null">null</a></li>
        </ul></li>
        <li><a href="#Casting">Casting</a>
        <ul>
            <li><a href="#Implicit-Casts">Implicit Casts</a>
            <ul>
                <li><a href="#Implicit-Cast-Stricter-Qualification">Implicit Cast: Stricter Qualification</a></li>
                <li><a href="#Implicit-Cast-Integer-and-Float-Widening">Implicit Cast: Integer and Float Widening</a></li>
                <li><a href="#Implicit-Cast-Arrays">Implicit Cast: Arrays</a></li>
                <li><a href="#Implicit-Cast-Optionals">Implicit Cast: Optionals</a></li>
                <li><a href="#Implicit-Cast-T-to-ET">Implicit Cast: T to E!T</a></li>
                <li><a href="#Implicit-Cast-E-to-ET">Implicit Cast: E to E!T</a></li>
                <li><a href="#Implicit-Cast-comptime_int-to-const-integer">Implicit Cast: comptime_int to *const integer</a></li>
                <li><a href="#Implicit-Cast-comptime_float-to-const-float">Implicit Cast: comptime_float to *const float</a></li>
                <li><a href="#Implicit-Cast-compile-time-known-numbers">Implicit Cast: compile-time known numbers</a></li>
                <li><a href="#Implicit-Cast-union-to-enum">Implicit Cast: union to enum</a></li>
                <li><a href="#Implicit-Cast-enum-to-union">Implicit Cast: enum to union</a></li>
                <li><a href="#Implicit-Cast-T-to-T-when-sizeOfT--">Implicit Cast: T to *T when @sizeOf(T) == 0</a></li>
                <li><a href="#Implicit-Cast-undefined">Implicit Cast: undefined</a></li>
                <li><a href="#Implicit-Cast-T-to-const-T">Implicit Cast: T to *const T</a></li>
            </ul></li>
            <li><a href="#Explicit-Casts">Explicit Casts</a></li>
            <li><a href="#Peer-Type-Resolution">Peer Type Resolution</a></li>
        </ul></li>
        <li><a href="#void">void</a></li>
        <li><a href="#comptime">comptime</a>
        <ul>
            <li><a href="#Introducing-the-Compile-Time-Concept">Introducing the Compile-Time Concept</a>
            <ul>
                <li><a href="#Compile-Time-Parameters">Compile-Time Parameters</a></li>
                <li><a href="#Compile-Time-Variables">Compile-Time Variables</a></li>
                <li><a href="#Compile-Time-Expressions">Compile-Time Expressions</a></li>
            </ul></li>
            <li><a href="#Generic-Data-Structures">Generic Data Structures</a></li>
            <li><a href="#Case-Study-printf-in-Zig">Case Study: printf in Zig</a></li>
        </ul></li>
        <li><a href="#Assembly">Assembly</a></li>
        <li><a href="#Atomics">Atomics</a></li>
        <li><a href="#Coroutines">Coroutines</a>
        <ul>
            <li><a href="#Minimal-Coroutine-Example">Minimal Coroutine Example</a></li>
            <li><a href="#Suspend-and-Resume">Suspend and Resume</a>
            <ul>
                <li><a href="#Resuming-from-Suspend-Blocks">Resuming from Suspend Blocks</a></li>
            </ul></li>
            <li><a href="#Await">Await</a></li>
            <li><a href="#Open-Issues">Open Issues</a></li>
        </ul></li>
        <li><a href="#Builtin-Functions">Builtin Functions</a>
        <ul>
            <li><a href="#addWithOverflow">@addWithOverflow</a></li>
            <li><a href="#ArgType">@ArgType</a></li>
            <li><a href="#atomicLoad">@atomicLoad</a></li>
            <li><a href="#atomicRmw">@atomicRmw</a></li>
            <li><a href="#bitCast">@bitCast</a></li>
            <li><a href="#bitOffsetOf">@bitOffsetOf</a></li>
            <li><a href="#breakpoint">@breakpoint</a></li>
            <li><a href="#byteOffsetOf">@byteOffsetOf</a></li>
            <li><a href="#alignCast">@alignCast</a></li>
            <li><a href="#alignOf">@alignOf</a></li>
            <li><a href="#boolToInt">@boolToInt</a></li>
            <li><a href="#bytesToSlice">@bytesToSlice</a></li>
            <li><a href="#cDefine">@cDefine</a></li>
            <li><a href="#cImport">@cImport</a></li>
            <li><a href="#cInclude">@cInclude</a></li>
            <li><a href="#cUndef">@cUndef</a></li>
            <li><a href="#clz">@clz</a></li>
            <li><a href="#cmpxchgStrong">@cmpxchgStrong</a></li>
            <li><a href="#cmpxchgWeak">@cmpxchgWeak</a></li>
            <li><a href="#compileError">@compileError</a></li>
            <li><a href="#compileLog">@compileLog</a></li>
            <li><a href="#ctz">@ctz</a></li>
            <li><a href="#divExact">@divExact</a></li>
            <li><a href="#divFloor">@divFloor</a></li>
            <li><a href="#divTrunc">@divTrunc</a></li>
            <li><a href="#embedFile">@embedFile</a></li>
            <li><a href="#enumToInt">@enumToInt</a></li>
            <li><a href="#errSetCast">@errSetCast</a></li>
            <li><a href="#errorName">@errorName</a></li>
            <li><a href="#errorReturnTrace">@errorReturnTrace</a></li>
            <li><a href="#errorToInt">@errorToInt</a></li>
            <li><a href="#export">@export</a></li>
            <li><a href="#fence">@fence</a></li>
            <li><a href="#field">@field</a></li>
            <li><a href="#fieldParentPtr">@fieldParentPtr</a></li>
            <li><a href="#floatCast">@floatCast</a></li>
            <li><a href="#floatToInt">@floatToInt</a></li>
            <li><a href="#frameAddress">@frameAddress</a></li>
            <li><a href="#handle">@handle</a></li>
            <li><a href="#import">@import</a></li>
            <li><a href="#inlineCall">@inlineCall</a></li>
            <li><a href="#intCast">@intCast</a></li>
            <li><a href="#intToEnum">@intToEnum</a></li>
            <li><a href="#intToError">@intToError</a></li>
            <li><a href="#intToFloat">@intToFloat</a></li>
            <li><a href="#intToPtr">@intToPtr</a></li>
            <li><a href="#IntType">@IntType</a></li>
            <li><a href="#maxValue">@maxValue</a></li>
            <li><a href="#memberCount">@memberCount</a></li>
            <li><a href="#memberName">@memberName</a></li>
            <li><a href="#memberType">@memberType</a></li>
            <li><a href="#memcpy">@memcpy</a></li>
            <li><a href="#memset">@memset</a></li>
            <li><a href="#minValue">@minValue</a></li>
            <li><a href="#mod">@mod</a></li>
            <li><a href="#mulWithOverflow">@mulWithOverflow</a></li>
            <li><a href="#newStackCall">@newStackCall</a></li>
            <li><a href="#noInlineCall">@noInlineCall</a></li>
            <li><a href="#OpaqueType">@OpaqueType</a></li>
            <li><a href="#panic">@panic</a></li>
            <li><a href="#popCount">@popCount</a></li>
            <li><a href="#ptrCast">@ptrCast</a></li>
            <li><a href="#ptrToInt">@ptrToInt</a></li>
            <li><a href="#rem">@rem</a></li>
            <li><a href="#returnAddress">@returnAddress</a></li>
            <li><a href="#setAlignStack">@setAlignStack</a></li>
            <li><a href="#setCold">@setCold</a></li>
            <li><a href="#setRuntimeSafety">@setRuntimeSafety</a></li>
            <li><a href="#setEvalBranchQuota">@setEvalBranchQuota</a></li>
            <li><a href="#setFloatMode">@setFloatMode</a></li>
            <li><a href="#setGlobalLinkage">@setGlobalLinkage</a></li>
            <li><a href="#shlExact">@shlExact</a></li>
            <li><a href="#shlWithOverflow">@shlWithOverflow</a></li>
            <li><a href="#shrExact">@shrExact</a></li>
            <li><a href="#sizeOf">@sizeOf</a></li>
            <li><a href="#sliceToBytes">@sliceToBytes</a></li>
            <li><a href="#sqrt">@sqrt</a></li>
            <li><a href="#subWithOverflow">@subWithOverflow</a></li>
            <li><a href="#tagName">@tagName</a></li>
            <li><a href="#TagType">@TagType</a></li>
            <li><a href="#This">@This</a></li>
            <li><a href="#truncate">@truncate</a></li>
            <li><a href="#typeId">@typeId</a></li>
            <li><a href="#typeInfo">@typeInfo</a></li>
            <li><a href="#typeName">@typeName</a></li>
            <li><a href="#typeOf">@typeOf</a></li>
        </ul></li>
        <li><a href="#Build-Mode">Build Mode</a>
        <ul>
            <li><a href="#Debug">Debug</a></li>
            <li><a href="#ReleaseFast">ReleaseFast</a></li>
            <li><a href="#ReleaseSafe">ReleaseSafe</a></li>
            <li><a href="#ReleaseSmall">ReleaseSmall</a></li>
        </ul></li>
        <li><a href="#Undefined-Behavior">Undefined Behavior</a>
        <ul>
            <li><a href="#Reaching-Unreachable-Code">Reaching Unreachable Code</a></li>
            <li><a href="#Index-out-of-Bounds">Index out of Bounds</a></li>
            <li><a href="#Cast-Negative-Number-to-Unsigned-Integer">Cast Negative Number to Unsigned Integer</a></li>
            <li><a href="#Cast-Truncates-Data">Cast Truncates Data</a></li>
            <li><a href="#Integer-Overflow">Integer Overflow</a>
            <ul>
                <li><a href="#Default-Operations">Default Operations</a></li>
                <li><a href="#Standard-Library-Math-Functions">Standard Library Math Functions</a></li>
                <li><a href="#Builtin-Overflow-Functions">Builtin Overflow Functions</a></li>
                <li><a href="#Wrapping-Operations">Wrapping Operations</a></li>
            </ul></li>
            <li><a href="#Exact-Left-Shift-Overflow">Exact Left Shift Overflow</a></li>
            <li><a href="#Exact-Right-Shift-Overflow">Exact Right Shift Overflow</a></li>
            <li><a href="#Division-by-Zero">Division by Zero</a></li>
            <li><a href="#Remainder-Division-by-Zero">Remainder Division by Zero</a></li>
            <li><a href="#Exact-Division-Remainder">Exact Division Remainder</a></li>
            <li><a href="#Slice-Widen-Remainder">Slice Widen Remainder</a></li>
            <li><a href="#Attempt-to-Unwrap-Null">Attempt to Unwrap Null</a></li>
            <li><a href="#Attempt-to-Unwrap-Error">Attempt to Unwrap Error</a></li>
            <li><a href="#Invalid-Error-Code">Invalid Error Code</a></li>
            <li><a href="#Invalid-Enum-Cast">Invalid Enum Cast</a></li>
            <li><a href="#Invalid-Error-Set-Cast">Invalid Error Set Cast</a></li>
            <li><a href="#Incorrect-Pointer-Alignment">Incorrect Pointer Alignment</a></li>
            <li><a href="#Wrong-Union-Field-Access">Wrong Union Field Access</a></li>
            <li><a href="#Out-of-Bounds-Float-To-Integer-Cast">Out of Bounds Float To Integer Cast</a></li>
        </ul></li>
        <li><a href="#Memory">Memory</a></li>
        <li><a href="#Compile-Variables">Compile Variables</a></li>
        <li><a href="#Root-Source-File">Root Source File</a></li>
        <li><a href="#Zig-Test">Zig Test</a></li>
        <li><a href="#Zig-Build-System">Zig Build System</a></li>
        <li><a href="#C">C</a>
        <ul>
            <li><a href="#C-Type-Primitives">C Type Primitives</a></li>
            <li><a href="#C-String-Literals">C String Literals</a></li>
            <li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
            <li><a href="#Exporting-a-C-Library">Exporting a C Library</a></li>
            <li><a href="#Mixing-Object-Files">Mixing Object Files</a></li>
        </ul></li>
        <li><a href="#Targets">Targets</a></li>
        <li><a href="#Style-Guide">Style Guide</a>
        <ul>
            <li><a href="#Whitespace">Whitespace</a></li>
            <li><a href="#Names">Names</a></li>
            <li><a href="#Examples">Examples</a></li>
        </ul></li>
        <li><a href="#Source-Encoding">Source Encoding</a></li>
        <li><a href="#Grammar">Grammar</a></li>
        <li><a href="#Zen">Zen</a></li>
    </ul>

    </div>
    <div id="contents">
      <h1 id="Introduction">Introduction</h1>

      <p>
      Zig is an open-source programming language designed for <strong>robustness</strong>,
      <strong>optimality</strong>, and <strong>clarity</strong>.
      </p>
      <ul>
        <li><strong>Robust</strong> - behavior is correct even for edge cases such as out of memory.</li>
        <li><strong>Optimal</strong> - write programs the best way they can behave and perform.</li>
        <li><strong>Clear</strong> - precisely communicate your intent to the compiler and other programmers. The language imposes a low overhead to reading code.</li>
      </ul>
      <p>
      Often the most efficient way to learn something new is to see examples, so
      this documentation shows how to use each of Zig's features. It is
      all on one page so you can search with your browser's search tool.
      </p>
      <p>
      The code samples in this document are compiled and tested as part of the main test suite of Zig.
      This HTML document depends on no external files, so you can use it offline.
      </p>
      
      <h1 id="Hello-World">Hello World</h1>


      <p class="file">hello.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-comment">// If this program is run without stdout attached, exit with an error.</span>
    <span class="tok-kw">var</span> stdout_file = <span class="tok-kw">try</span> std.io.getStdOut();
    <span class="tok-comment">// If this program encounters pipe failure when printing to stdout, exit</span>
    <span class="tok-comment">// with an error.</span>
    <span class="tok-kw">try</span> stdout_file.write(<span class="tok-str">&quot;Hello, world!\n&quot;</span>);
}</code></pre><pre><code class="shell">$ zig build-exe hello.zig
$ ./hello
Hello, world!
</code></pre>

      <p>
      Usually you don't want to write to stdout. You want to write to stderr. And you
      don't care if it fails. It's more like a <em>warning message</em> that you want
      to emit. For that you can use a simpler API:
      </p>
      <p class="file">hello.zig</p><pre><code class="zig"><span class="tok-kw">const</span> warn = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.warn;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    warn(<span class="tok-str">&quot;Hello, world!\n&quot;</span>);
}</code></pre><pre><code class="shell">$ zig build-exe hello.zig
$ ./hello
Hello, world!
</code></pre>

      <p>
      Note that we also left off the <code class="zig">!</code> from the return type.
      In Zig, if your main function cannot fail, you must use the <code class="zig"><span class="tok-type">void</span></code> return type.
      </p>
      <p>See also:</p><ul>
<li><a href="#Values">Values</a></li>
<li><a href="#import">@import</a></li>
<li><a href="#Errors">Errors</a></li>
<li><a href="#Root-Source-File">Root Source File</a></li>
</ul>

      
      <h1 id="Comments">Comments</h1>

      <p class="file">comments.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;comments&quot;</span> {
    <span class="tok-comment">// Comments in Zig start with &quot;//&quot; and end at the next LF byte (end of line).</span>
    <span class="tok-comment">// The below line is a comment, and won't be executed.</span>

    <span class="tok-comment">//assert(false);</span>

    <span class="tok-kw">const</span> x = <span class="tok-null">true</span>;  <span class="tok-comment">// another comment</span>
    assert(x);
}</code></pre><pre><code class="shell">$ zig test comments.zig
Test 1/1 comments...OK
All tests passed.
</code></pre>

      <p>
      There are no multiline comments in Zig (e.g. like <code class="c">/* */</code>
      comments in C).  This helps allow Zig to have the property that each line
      of code can be tokenized out of context.
      </p>
      <h2 id="Doc-comments">Doc comments</h2>

      <p>
      A doc comment is one that begins with exactly three slashes (i.e.
      <code class="zig"><span class="tok-comment">///</span></code> but not <code class="zig"><span class="tok-comment">////</span></code>);
      multiple doc comments in a row are merged together to form a multiline
      doc comment.  The doc comment documents whatever immediately follows it.
      </p>
      <pre><code class="zig"><span class="tok-comment">/// A structure for storing a timestamp, with nanosecond precision (this is a</span>
<span class="tok-comment">/// multiline doc comment).</span>
<span class="tok-kw">const</span> Timestamp = <span class="tok-kw">struct</span> {
    <span class="tok-comment">/// The number of seconds since the epoch (this is also a doc comment).</span>
    seconds: <span class="tok-type">i64</span>,  <span class="tok-comment">// signed so we can represent pre-1970 (not a doc comment)</span>
    <span class="tok-comment">/// The number of nanoseconds past the second (doc comment again).</span>
    nanos: <span class="tok-type">u32</span>,

    <span class="tok-comment">/// Returns a `Timestamp` struct representing the Unix epoch; that is, the</span>
    <span class="tok-comment">/// moment of 1970 Jan 1 00:00:00 UTC (this is a doc comment too).</span>
    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">unixEpoch</span>() Timestamp {
        <span class="tok-kw">return</span> Timestamp{
            .seconds = <span class="tok-number">0</span>,
            .nanos = <span class="tok-number">0</span>,
        };
    }
};</code></pre>
      <p>
      Doc comments are only allowed in certain places; eventually, it will
      become a compile error have a doc comment in an unexpected place, such as
      in the middle of an expression, or just before a non-doc comment.
      </p>
      
      
      <h1 id="Values">Values</h1>

      <p class="file">values.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> warn = std.debug.warn;
<span class="tok-kw">const</span> os = std.os;
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-comment">// integers</span>
    <span class="tok-kw">const</span> one_plus_one: <span class="tok-type">i32</span> = <span class="tok-number">1</span> + <span class="tok-number">1</span>;
    warn(<span class="tok-str">&quot;1 + 1 = {}\n&quot;</span>, one_plus_one);

    <span class="tok-comment">// floats</span>
    <span class="tok-kw">const</span> seven_div_three: <span class="tok-type">f32</span> = <span class="tok-number">7.0</span> / <span class="tok-number">3.0</span>;
    warn(<span class="tok-str">&quot;7.0 / 3.0 = {}\n&quot;</span>, seven_div_three);

    <span class="tok-comment">// boolean</span>
    warn(<span class="tok-str">&quot;{}\n{}\n{}\n&quot;</span>,
        <span class="tok-null">true</span> <span class="tok-kw">and</span> <span class="tok-null">false</span>,
        <span class="tok-null">true</span> <span class="tok-kw">or</span> <span class="tok-null">false</span>,
        !<span class="tok-null">true</span>);
    
    <span class="tok-comment">// optional</span>
    <span class="tok-kw">var</span> optional_value: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>;
    assert(optional_value == <span class="tok-null">null</span>);

    warn(<span class="tok-str">&quot;\noptional 1\ntype: {}\nvalue: {}\n&quot;</span>,
        <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@typeOf</span>(optional_value)), optional_value);

    optional_value = <span class="tok-str">&quot;hi&quot;</span>;
    assert(optional_value != <span class="tok-null">null</span>);

    warn(<span class="tok-str">&quot;\noptional 2\ntype: {}\nvalue: {}\n&quot;</span>,
        <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@typeOf</span>(optional_value)), optional_value);

    <span class="tok-comment">// error union</span>
    <span class="tok-kw">var</span> number_or_error: <span class="tok-kw">error</span>!<span class="tok-type">i32</span> = <span class="tok-kw">error</span>.ArgNotFound;

    warn(<span class="tok-str">&quot;\nerror union 1\ntype: {}\nvalue: {}\n&quot;</span>,
        <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@typeOf</span>(number_or_error)), number_or_error);
 
    number_or_error = <span class="tok-number">1234</span>;

    warn(<span class="tok-str">&quot;\nerror union 2\ntype: {}\nvalue: {}\n&quot;</span>,
        <span class="tok-builtin">@typeName</span>(<span class="tok-builtin">@typeOf</span>(number_or_error)), number_or_error);
}</code></pre><pre><code class="shell">$ zig build-exe values.zig
$ ./values
1 + 1 = 2
7.0 / 3.0 = 2.33333325e+00
false
true
false

optional 1
type: ?[]const u8
value: null

optional 2
type: ?[]const u8
value: hi

error union 1
type: error!i32
value: error.ArgNotFound

error union 2
type: error!i32
value: 1234
</code></pre>

      <h2 id="Primitive-Types">Primitive Types</h2>

      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Name
          </th>
          <th>
            C Equivalent
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">i8</span></code></td>
          <td><code class="c">int8_t</code></td>
          <td>signed 8-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">u8</span></code></td>
          <td><code class="c">uint8_t</code></td>
          <td>unsigned 8-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">i16</span></code></td>
          <td><code class="c">int16_t</code></td>
          <td>signed 16-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">u16</span></code></td>
          <td><code class="c">uint16_t</code></td>
          <td>unsigned 16-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">i32</span></code></td>
          <td><code class="c">int32_t</code></td>
          <td>signed 32-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">u32</span></code></td>
          <td><code class="c">uint32_t</code></td>
          <td>unsigned 32-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">i64</span></code></td>
          <td><code class="c">int64_t</code></td>
          <td>signed 64-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">u64</span></code></td>
          <td><code class="c">uint64_t</code></td>
          <td>unsigned 64-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">i128</span></code></td>
          <td><code class="c">__int128</code></td>
          <td>signed 128-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">u128</span></code></td>
          <td><code class="c">unsigned __int128</code></td>
          <td>unsigned 128-bit integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">isize</span></code></td>
          <td><code class="c">intptr_t</code></td>
          <td>signed pointer sized integer</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">usize</span></code></td>
          <td><code class="c">uintptr_t</code></td>
          <td>unsigned pointer sized integer</td>
        </tr>

        <tr>
            <td><code class="zig"><span class="tok-type">c_short</span></code></td>
          <td><code class="c">short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_ushort</span></code></td>
          <td><code class="c">unsigned short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_int</span></code></td>
          <td><code class="c">int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_uint</span></code></td>
          <td><code class="c">unsigned int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_long</span></code></td>
          <td><code class="c">long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_ulong</span></code></td>
          <td><code class="c">unsigned long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_longlong</span></code></td>
          <td><code class="c">long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_ulonglong</span></code></td>
          <td><code class="c">unsigned long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_longdouble</span></code></td>
          <td><code class="c">long double</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">c_void</span></code></td>
          <td><code class="c">void</code></td>
          <td>for ABI compatibility with C</td>
        </tr>

        <tr>
            <td><code class="zig"><span class="tok-type">f16</span></code></td>
          <td><code class="c">_Float16</code></td>
          <td>16-bit floating point (10-bit mantissa) IEEE-754-2008 binary16</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">f32</span></code></td>
          <td><code class="c">float</code></td>
          <td>32-bit floating point (23-bit mantissa) IEEE-754-2008 binary32</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">f64</span></code></td>
          <td><code class="c">double</code></td>
          <td>64-bit floating point (52-bit mantissa) IEEE-754-2008 binary64</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">f128</span></code></td>
            <td><code class="c">_Float128</code></td>
          <td>128-bit floating point (112-bit mantissa) IEEE-754-2008 binary128</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">bool</span></code></td>
          <td><code class="c">bool</code></td>
          <td><code class="zig"><span class="tok-null">true</span></code> or <code class="zig"><span class="tok-null">false</span></code></td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">void</span></code></td>
          <td>(none)</td>
          <td>0 bit type</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">noreturn</span></code></td>
          <td>(none)</td>
          <td>the type of <code class="zig"><span class="tok-kw">break</span></code>, <code class="zig"><span class="tok-kw">continue</span></code>, <code class="zig"><span class="tok-kw">return</span></code>, <code class="zig"><span class="tok-kw">unreachable</span></code>, and <code class="zig"><span class="tok-kw">while</span> (<span class="tok-null">true</span>) {}</code></td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">type</span></code></td>
          <td>(none)</td>
          <td>the type of types</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-kw">error</span></code></td>
          <td>(none)</td>
          <td>an error code</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">comptime_int</span></code></td>
          <td>(none)</td>
          <td>Only allowed for <a href="#comptime">comptime</a>-known values. The type of integer literals.</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-type">comptime_float</span></code></td>
          <td>(none)</td>
          <td>Only allowed for <a href="#comptime">comptime</a>-known values. The type of float literals.</td>
        </tr>
      </table>
      </div>
      <p>
      In addition to the integer types above, arbitrary bit-width integers can be referenced by using
      an identifier of <code>i</code> or </code>u</code> followed by digits. For example, the identifier
      <code class="zig"><span class="tok-type">i7</span></code> refers to a signed 7-bit integer.
      </p>
      <p>See also:</p><ul>
<li><a href="#Integers">Integers</a></li>
<li><a href="#Floats">Floats</a></li>
<li><a href="#void">void</a></li>
<li><a href="#Errors">Errors</a></li>
</ul>

      
      <h2 id="Primitive-Values">Primitive Values</h2>

      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Name
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-null">true</span></code> and <code class="zig"><span class="tok-null">false</span></code></td>
            <td><code class="zig"><span class="tok-type">bool</span></code> values</td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-null">null</span></code></td>
            <td>used to set an optional type to <code class="zig"><span class="tok-null">null</span></code></td>
        </tr>
        <tr>
            <td><code class="zig"><span class="tok-null">undefined</span></code></td>
          <td>used to leave a value unspecified</td>
        </tr>
      </table>
      </div>
      <p>See also:</p><ul>
<li><a href="#Optionals">Optionals</a></li>
<li><a href="#undefined">undefined</a></li>
</ul>

      
      <h2 id="String-Literals">String Literals</h2>

      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;

<span class="tok-kw">test</span> <span class="tok-str">&quot;string literals&quot;</span> {
    <span class="tok-comment">// In Zig a string literal is an array of bytes.</span>
    <span class="tok-kw">const</span> normal_bytes = <span class="tok-str">&quot;hello&quot;</span>;
    assert(<span class="tok-builtin">@typeOf</span>(normal_bytes) == [<span class="tok-number">5</span>]<span class="tok-type">u8</span>);
    assert(normal_bytes.len == <span class="tok-number">5</span>);
    assert(normal_bytes[<span class="tok-number">1</span>] == <span class="tok-str">'e'</span>);
    assert(<span class="tok-str">'e'</span> == <span class="tok-str">'\x65'</span>);
    assert(mem.eql(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">&quot;h\x65llo&quot;</span>));

    <span class="tok-comment">// A C string literal is a null terminated pointer.</span>
    <span class="tok-kw">const</span> null_terminated_bytes = <span class="tok-str">c&quot;hello&quot;</span>;
    assert(<span class="tok-builtin">@typeOf</span>(null_terminated_bytes) == [*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>);
    assert(null_terminated_bytes[<span class="tok-number">5</span>] == <span class="tok-number">0</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 string literals...OK
All tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Arrays">Arrays</a></li>
<li><a href="#Zig-Test">Zig Test</a></li>
</ul>

      <h3 id="Escape-Sequences">Escape Sequences</h3>

      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Escape Sequence
          </th>
          <th>
            Name
          </th>
        </tr>
        <tr>
            <td><code>\n</code></td>
          <td>Newline</td>
        </tr>
        <tr>
            <td><code>\r</code></td>
          <td>Carriage Return</td>
        </tr>
        <tr>
            <td><code>\t</code></td>
          <td>Tab</td>
        </tr>
        <tr>
            <td><code>\\</code></td>
          <td>Backslash</td>
        </tr>
        <tr>
            <td><code>\'</code></td>
          <td>Single Quote</td>
        </tr>
        <tr>
            <td><code>\"</code></td>
          <td>Double Quote</td>
        </tr>
        <tr>
            <td><code>\xNN</code></td>
          <td>hexadecimal 8-bit character code (2 digits)</td>
        </tr>
        <tr>
            <td><code>\uNNNN</code></td>
          <td>hexadecimal 16-bit Unicode character code UTF-8 encoded (4 digits)</td>
        </tr>
        <tr>
            <td><code>\UNNNNNN</code></td>
          <td>hexadecimal 24-bit Unicode character code UTF-8 encoded (6 digits)</td>
        </tr>
      </table>
      </div>
      <p>Note that the maximum valid Unicode point is <code class="zig"><span class="tok-number">0x10ffff</span></code>.</p>
      
      <h3 id="Multiline-String-Literals">Multiline String Literals</h3>

      <p>
      Multiline string literals have no escapes and can span across multiple lines.
      To start a multiline string literal, use the <code class="zig"><span class="tok-str">\\</span></code> token. Just like a comment,
      the string literal goes until the end of the line. The end of the line is
      not included in the string literal.
      However, if the next line begins with <code class="zig"><span class="tok-str">\\</span></code> then a newline is appended and
      the string literal continues.
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> hello_world_in_c =
    <span class="tok-str">\\#include &lt;stdio.h&gt;
</span>    <span class="tok-str">\\
</span>    <span class="tok-str">\\int main(int argc, char **argv) {
</span>    <span class="tok-str">\\    printf(&quot;hello world\n&quot;);
</span>    <span class="tok-str">\\    return 0;
</span>    <span class="tok-str">\\}
</span>;</code></pre>
      <p>
      For a multiline C string literal, prepend <code>c</code> to each <code class="zig"><span class="tok-str">\\</span></code>:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> c_string_literal =
    <span class="tok-str">c\\#include &lt;stdio.h&gt;
</span>    <span class="tok-str">c\\
</span>    <span class="tok-str">c\\int main(int argc, char **argv) {
</span>    <span class="tok-str">c\\    printf(&quot;hello world\n&quot;);
</span>    <span class="tok-str">c\\    return 0;
</span>    <span class="tok-str">c\\}
</span>;</code></pre>
      <p>
      In this example the variable <code class="zig">c_string_literal</code> has type <code class="zig">[*]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code> and
      has a terminating null byte.
      </p>
      <p>See also:</p><ul>
<li><a href="#embedFile">@embedFile</a></li>
</ul>

      
      
      <h2 id="Assignment">Assignment</h2>

      <p>Use the <code class="zig"><span class="tok-kw">const</span></code> keyword to assign a value to an identifier:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> x = <span class="tok-number">1234</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {
    <span class="tok-comment">// It works at global scope as well as inside functions.</span>
    <span class="tok-kw">const</span> y = <span class="tok-number">5678</span>;

    <span class="tok-comment">// Once assigned, an identifier cannot be changed.</span>
    y += <span class="tok-number">1</span>;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;assignment&quot;</span> {
    foo();
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:8:7: </span><span class="t31_1">error:</span><span class="t0_1"> cannot assign to constant</span>
    y += 1;
      <span class="t32_1">^</span>
</code></pre>

      <p><code class="zig"><span class="tok-kw">const</span></code> applies to all of the bytes that the identifier immediately addresses. <a href="#Pointers">Pointers</a> have their own const-ness.</p>
      <p>If you need a variable that you can modify, use the <code class="zig"><span class="tok-kw">var</span></code> keyword:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;var&quot;</span> {
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">5678</span>;

    y += <span class="tok-number">1</span>;

    assert(y == <span class="tok-number">5679</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 var...OK
All tests passed.
</code></pre>

      <p>Variables must be initialized:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;initialization&quot;</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span>;

    x = <span class="tok-number">1</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:5: </span><span class="t31_1">error:</span><span class="t0_1"> variables must be initialized</span>
    var x: i32;
    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:5: </span><span class="t31_1">error:</span><span class="t0_1"> use of undeclared identifier 'x'</span>
    x = 1;
    <span class="t32_1">^</span>
</code></pre>

      <h3 id="undefined">undefined</h3>

      <p>Use <code class="zig"><span class="tok-null">undefined</span></code> to leave variables uninitialized:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;init with undefined&quot;</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
    x = <span class="tok-number">1</span>;
    assert(x == <span class="tok-number">1</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 init with undefined...OK
All tests passed.
</code></pre>

      <p>
      <code class="zig"><span class="tok-null">undefined</span></code> can be <a href="#Implicit-Casts">implicitly cast</a> to any type.
          Once this happens, it is no longer possible to detect that the value is <code class="zig"><span class="tok-null">undefined</span></code>.
              <code class="zig"><span class="tok-null">undefined</span></code> means the value could be anything, even something that is nonsense
                  according to the type. Translated into English, <code class="zig"><span class="tok-null">undefined</span></code> means "Not a meaningful
      value. Using this value would be a bug. The value will be unused, or overwritten before being used."
      </p>
      <p>
      In <a href="#Debug">Debug</a> mode, Zig writes <code class="zig"><span class="tok-number">0xaa</span></code> bytes to undefined memory. This is to catch
      bugs early, and to help detect use of undefined memory in a debugger.
      </p>
      
      
      
      <h1 id="Integers">Integers</h1>

      <h2 id="Integer-Literals">Integer Literals</h2>

      <pre><code class="zig"><span class="tok-kw">const</span> decimal_int = <span class="tok-number">98222</span>;
<span class="tok-kw">const</span> hex_int = <span class="tok-number">0xff</span>;
<span class="tok-kw">const</span> another_hex_int = <span class="tok-number">0xFF</span>;
<span class="tok-kw">const</span> octal_int = <span class="tok-number">0o755</span>;
<span class="tok-kw">const</span> binary_int = <span class="tok-number">0b11110000</span>;</code></pre>
      
      <h2 id="Runtime-Integer-Values">Runtime Integer Values</h2>

      <p>
      Integer literals have no size limitation, and if any undefined behavior occurs,
      the compiler catches it.
      </p>
      <p>
      However, once an integer value is no longer known at compile-time, it must have a
      known size, and is vulnerable to undefined behavior.
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">divide</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a / b;
}</code></pre>
      <p>
      In this function, values <code class="zig">a</code> and <code class="zig">b</code> are known only at runtime,
      and thus this division operation is vulnerable to both integer overflow and
      division by zero.
      </p>
      <p>
      Operators such as <code class="zig">+</code> and <code class="zig">-</code> cause undefined behavior on
              integer overflow. Also available are operations such as <code class="zig">+%</code> and
                  <code class="zig">-%</code> which are defined to have wrapping arithmetic on all targets.
      </p>
      <p>See also:</p><ul>
<li><a href="#Integer-Overflow">Integer Overflow</a></li>
<li><a href="#Division-by-Zero">Division by Zero</a></li>
<li><a href="#Wrapping-Operations">Wrapping Operations</a></li>
</ul>

      
      
      <h1 id="Floats">Floats</h1>

      <p>Zig has the following floating point types:</p>
      <ul>
          <li><code class="zig"><span class="tok-type">f16</span></code> - IEEE-754-2008 binary16</li>
          <li><code class="zig"><span class="tok-type">f32</span></code> - IEEE-754-2008 binary32</li>
          <li><code class="zig"><span class="tok-type">f64</span></code> - IEEE-754-2008 binary64</li>
          <li><code class="zig"><span class="tok-type">f128</span></code> - IEEE-754-2008 binary128</li>
          <li><code class="zig"><span class="tok-type">c_longdouble</span></code> - matches <code class="c">long double</code> for the target C ABI</li>
      </ul>
      <h2 id="Float-Literals">Float Literals</h2>

      <p>
      Float literals have type <code class="zig"><span class="tok-type">comptime_float</span></code> which is guaranteed to hold at least all possible values
      that the largest other floating point type can hold. Float literals <a href="#Implicit-Casts">implicitly cast</a> to any other type.
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> floating_point = <span class="tok-number">123.0E+77</span>;
<span class="tok-kw">const</span> another_float = <span class="tok-number">123.0</span>;
<span class="tok-kw">const</span> yet_another = <span class="tok-number">123.0e+77</span>;

<span class="tok-kw">const</span> hex_floating_point = <span class="tok-number">0x103.70p-5</span>;
<span class="tok-kw">const</span> another_hex_float = <span class="tok-number">0x103.70</span>;
<span class="tok-kw">const</span> yet_another_hex_float = <span class="tok-number">0x103.70P-5</span>;</code></pre>
      
      <h2 id="Floating-Point-Operations">Floating Point Operations</h2>

      <p>By default floating point operations use <code class="zig">Strict</code> mode,
          but you can switch to <code class="zig">Optimized</code> mode on a per-block basis:</p>
      <p class="file">foo.zig</p><pre><code class="zig"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> big = <span class="tok-type">f64</span>(<span class="tok-number">1</span> &lt;&lt; <span class="tok-number">40</span>);

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_strict</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span> {
    <span class="tok-kw">return</span> x + big - big;
}

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_optimized</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span> {
    <span class="tok-builtin">@setFloatMode</span>(builtin.FloatMode.Optimized);
    <span class="tok-kw">return</span> x + big - big;
}</code></pre><pre><code class="shell">$ zig build-obj foo.zig --release-fast</code></pre>

      <p>For this test we have to separate code into two object files -
      otherwise the optimizer figures out all the values at compile-time,
      which operates in strict mode.</p>
      <p class="file">float_mode.zig</p><pre><code class="zig"><span class="tok-kw">const</span> warn = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.warn;

<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_strict</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span>;
<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo_optimized</span>(x: <span class="tok-type">f64</span>) <span class="tok-type">f64</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x = <span class="tok-number">0.001</span>;
    warn(<span class="tok-str">&quot;optimized = {}\n&quot;</span>, foo_optimized(x));
    warn(<span class="tok-str">&quot;strict = {}\n&quot;</span>, foo_strict(x));
}</code></pre><pre><code class="shell">$ zig build-exe float_mode.zig --object foo.o
$ ./float_mode
optimized = 1.0e-03
strict = 9.765625e-04
</code></pre>

      <p>See also:</p><ul>
<li><a href="#setFloatMode">@setFloatMode</a></li>
<li><a href="#Division-by-Zero">Division by Zero</a></li>
</ul>

      
      
      <h1 id="Operators">Operators</h1>

      <h2 id="Table-of-Operators">Table of Operators</h2>

      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Syntax
          </th>
          <th>
            Relevant Types
          </th>
          <th>
            Description
          </th>
          <th>
            Example
          </th>
        </tr>
        <tr>
          <td><pre><code class="zig">a + b
a += b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>Addition.
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#addWithOverflow">@addWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">2</span> + <span class="tok-number">5</span> == <span class="tok-number">7</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a +% b
a +%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Wrapping Addition.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#addWithOverflow">@addWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-type">u32</span>(<span class="tok-builtin">@maxValue</span>(<span class="tok-type">u32</span>)) +% <span class="tok-number">1</span> == <span class="tok-number">0</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a - b
a -= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>Subtraction.
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#subWithOverflow">@subWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">2</span> - <span class="tok-number">5</span> == -<span class="tok-number">3</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a -% b
a -%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Wrapping Subtraction.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#subWithOverflow">@subWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-type">u32</span>(<span class="tok-number">0</span>) -% <span class="tok-number">1</span> == <span class="tok-builtin">@maxValue</span>(<span class="tok-type">u32</span>)</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">-a</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
            Negation.
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">-<span class="tok-number">1</span> == <span class="tok-number">0</span> - <span class="tok-number">1</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">-%a</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            Wrapping Negation.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig">-%<span class="tok-type">i32</span>(<span class="tok-builtin">@minValue</span>(<span class="tok-type">i32</span>)) == <span class="tok-builtin">@minValue</span>(<span class="tok-type">i32</span>)</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a * b
a *= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>Multiplication.
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#mulWithOverflow">@mulWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">2</span> * <span class="tok-number">5</span> == <span class="tok-number">10</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a *% b
a *%= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Wrapping Multiplication.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
              <li>See also <a href="#mulWithOverflow">@mulWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-type">u8</span>(<span class="tok-number">200</span>) *% <span class="tok-number">2</span> == <span class="tok-number">144</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a / b
a /= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>Divison.
            <ul>
              <li>Can cause <a href="#Default-Operations">overflow</a> for integers.</li>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for integers.</li>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for floats in <a href="#Floating-Point-Operations">FloatMode.Optimized Mode</a>.</li>
              <li>For non-compile-time-known signed integers, must use
                <a href="#divTrunc">@divTrunc</a>,
                <a href="#divFloor">@divFloor</a>, or
                <a href="#divExact">@divExact</a> instead of <code class="zig">/</code>.
              </li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">10</span> / <span class="tok-number">5</span> == <span class="tok-number">2</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a % b
a %= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>Remainder Division.
            <ul>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for integers.</li>
              <li>Can cause <a href="#Division-by-Zero">Division by Zero</a> for floats in <a href="#Floating-Point-Operations">FloatMode.Optimized Mode</a>.</li>
              <li>For non-compile-time-known signed integers, must use
                <a href="#rem">@rem</a> or
                <a href="#mod">@mod</a> instead of <code class="zig">%</code>.
              </li>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">10</span> % <span class="tok-number">3</span> == <span class="tok-number">1</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &lt;&lt; b
a &lt;&lt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Bit Shift Left.
            <ul>
                <li><code class="zig">b</code> must be <a href="#comptime">comptime-known</a> or have a type with log2 number of bits as <code class="zig">a</code>.</li>
              <li>See also <a href="#shlExact">@shlExact</a>.</li>
              <li>See also <a href="#shlWithOverflow">@shlWithOverflow</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">1</span> &lt;&lt; <span class="tok-number">8</span> == <span class="tok-number">256</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &gt;&gt; b
a &gt;&gt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Bit Shift Right.
            <ul>
                <li><code class="zig">b</code> must be <a href="#comptime">comptime-known</a> or have a type with log2 number of bits as <code class="zig">a</code>.</li>
              <li>See also <a href="#shrExact">@shrExact</a>.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">10</span> &gt;&gt; <span class="tok-number">1</span> == <span class="tok-number">5</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &amp; b
a &amp;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Bitwise AND.
            <ul>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">0b011</span> &amp;amp; <span class="tok-number">0b101</span> == <span class="tok-number">0b001</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a | b
a |= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Bitwise OR.
            <ul>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">0b010</span> | <span class="tok-number">0b100</span> == <span class="tok-number">0b110</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a ^ b
a ^= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>Bitwise XOR.
            <ul>
              <li>Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.</li>
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-number">0b011</span> ^ <span class="tok-number">0b101</span> == <span class="tok-number">0b110</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">~a</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
            </ul>
          </td>
          <td>
            Bitwise NOT.
          </td>
          <td>
            <pre><code class="zig">~<span class="tok-type">u8</span>(<span class="tok-number">0b0101111</span>) == <span class="tok-number">0b1010000</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a <span class="tok-kw">orelse</span> b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Optionals">Optionals</a></li>
            </ul>
          </td>
          <td>If <code class="zig">a</code> is <code class="zig"><span class="tok-null">null</span></code>,
                      returns <code class="zig">b</code> ("default value"),
                          otherwise returns the unwrapped value of <code class="zig">a</code>.
                              Note that <code class="zig">b</code> may be a value of type <a href="#noreturn">noreturn</a>.
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
<span class="tok-kw">const</span> unwrapped = value <span class="tok-kw">orelse</span> <span class="tok-number">1234</span>;
unwrapped == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a.?</code></pre></td>
          <td>
            <ul>
              <li><a href="#Optionals">Optionals</a></li>
            </ul>
          </td>
          <td>
            Equivalent to:
            <pre><code class="zig">a <span class="tok-kw">orelse</span> <span class="tok-kw">unreachable</span></code></pre>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-number">5678</span>;
value.? == <span class="tok-number">5678</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a <span class="tok-kw">catch</span> b
a <span class="tok-kw">catch</span> |err| b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Errors">Error Unions</a></li>
            </ul>
          </td>
          <td>If <code class="zig">a</code> is an <code class="zig"><span class="tok-kw">error</span></code>,
                      returns <code class="zig">b</code> ("default value"),
                          otherwise returns the unwrapped value of <code class="zig">a</code>.
                              Note that <code class="zig">b</code> may be a value of type <a href="#noreturn">noreturn</a>.
                                  <code class="zig">err</code> is the <code class="zig"><span class="tok-kw">error</span></code> and is in scope of the expression <code class="zig">b</code>.
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> value: <span class="tok-kw">error</span>!<span class="tok-type">u32</span> = <span class="tok-kw">error</span>.Broken;
<span class="tok-kw">const</span> unwrapped = value <span class="tok-kw">catch</span> <span class="tok-number">1234</span>;
unwrapped == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a <span class="tok-kw">and</span> b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td>
              If <code class="zig">a</code> is <code class="zig"><span class="tok-null">false</span></code>, returns <code class="zig"><span class="tok-null">false</span></code>
                          without evaluating <code class="zig">b</code>. Otherwise, returns <code class="zig">b</code>.
          </td>
          <td>
            <pre><code class="zig"><span class="tok-null">false</span> <span class="tok-kw">and</span> <span class="tok-null">true</span> == <span class="tok-null">false</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a <span class="tok-kw">or</span> b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td>
              If <code class="zig">a</code> is <code class="zig"><span class="tok-null">true</span></code>, returns <code class="zig"><span class="tok-null">true</span></code>
                          without evaluating <code class="zig">b</code>. Otherwise, returns <code class="zig">b</code>.
          </td>
          <td>
            <pre><code class="zig"><span class="tok-null">false</span> <span class="tok-kw">or</span> <span class="tok-null">true</span> == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">!a</code></pre></td>
          <td>
            <ul>
              <li><a href="#Primitive-Types">bool</a></li>
            </ul>
          </td>
          <td>
            Boolean NOT.
          </td>
          <td>
            <pre><code class="zig">!<span class="tok-null">false</span> == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a == b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
              <li><a href="#Primitive-Types">bool</a></li>
              <li><a href="#Primitive-Types">type</a></li>
            </ul>
          </td>
          <td>
              Returns <code class="zig"><span class="tok-null">true</span></code> if a and b are equal, otherwise returns <code class="zig"><span class="tok-null">false</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code class="zig">(<span class="tok-number">1</span> == <span class="tok-number">1</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a == <span class="tok-null">null</span></code></pre></td>
          <td>
            <ul>
              <li><a href="#Optionals">Optionals</a></li>
            </ul>
          </td>
          <td>
              Returns <code class="zig"><span class="tok-null">true</span></code> if a is <code class="zig"><span class="tok-null">null</span></code>, otherwise returns <code class="zig"><span class="tok-null">false</span></code>.
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> value: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
value == <span class="tok-null">null</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a != b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
              <li><a href="#Primitive-Types">bool</a></li>
              <li><a href="#Primitive-Types">type</a></li>
            </ul>
          </td>
          <td>
              Returns <code class="zig"><span class="tok-null">false</span></code> if a and b are equal, otherwise returns <code class="zig"><span class="tok-null">true</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code class="zig">(<span class="tok-number">1</span> != <span class="tok-number">1</span>) == <span class="tok-null">false</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &gt; b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code class="zig"><span class="tok-null">true</span></code> if a is greater than b, otherwise returns <code class="zig"><span class="tok-null">false</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code class="zig">(<span class="tok-number">2</span> &gt; <span class="tok-number">1</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &gt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code class="zig"><span class="tok-null">true</span></code> if a is greater than or equal to b, otherwise returns <code class="zig"><span class="tok-null">false</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code class="zig">(<span class="tok-number">2</span> &gt;= <span class="tok-number">1</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &lt; b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code class="zig"><span class="tok-null">true</span></code> if a is less than b, otherwise returns <code class="zig"><span class="tok-null">false</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code class="zig">(<span class="tok-number">1</span> &lt; <span class="tok-number">2</span>) == <span class="tok-null">true</span></code>></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a &lt;= b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Integers">Integers</a></li>
              <li><a href="#Floats">Floats</a></li>
            </ul>
          </td>
          <td>
              Returns <code class="zig"><span class="tok-null">true</span></code> if a is less than or equal to b, otherwise returns <code class="zig"><span class="tok-null">false</span></code>.
            Invokes <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for the operands.
          </td>
          <td>
            <pre><code class="zig">(<span class="tok-number">1</span> &lt;= <span class="tok-number">2</span>) == <span class="tok-null">true</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a ++ b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Arrays">Arrays</a></li>
            </ul>
          </td>
          <td>
            Array concatenation.
            <ul>
                <li>Only available when <code class="zig">a</code> and <code class="zig">b</code> are <a href="#comptime">compile-time known</a>.
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;
<span class="tok-kw">const</span> array1 = []<span class="tok-type">u32</span>{<span class="tok-number">1</span>,<span class="tok-number">2</span>};
<span class="tok-kw">const</span> array2 = []<span class="tok-type">u32</span>{<span class="tok-number">3</span>,<span class="tok-number">4</span>};
<span class="tok-kw">const</span> together = array1 ++ array2;
mem.eql(<span class="tok-type">u32</span>, together, []<span class="tok-type">u32</span>{<span class="tok-number">1</span>,<span class="tok-number">2</span>,<span class="tok-number">3</span>,<span class="tok-number">4</span>})</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a ** b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Arrays">Arrays</a></li>
            </ul>
          </td>
          <td>
            Array multiplication.
            <ul>
                <li>Only available when <code class="zig">a</code> and <code class="zig">b</code> are <a href="#comptime">compile-time known</a>.
            </ul>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;
<span class="tok-kw">const</span> pattern = <span class="tok-str">&quot;ab&quot;</span> ** <span class="tok-number">3</span>;
mem.eql(<span class="tok-type">u8</span>, pattern, <span class="tok-str">&quot;ababab&quot;</span>)</code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a.*</code></pre></td>
          <td>
            <ul>
              <li><a href="#Pointers">Pointers</a></li>
            </ul>
          </td>
          <td>
            Pointer dereference.
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> x: <span class="tok-type">u32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> ptr = &amp;x;
x.* == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">&amp;amp;a</code></pre></td>
          <td>
            All types
          </td>
          <td>
            Address of.
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> x: <span class="tok-type">u32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> ptr = &amp;x;
x.* == <span class="tok-number">1234</span></code></pre>
          </td>
        </tr>
        <tr>
          <td><pre><code class="zig">a || b</code></pre></td>
          <td>
            <ul>
              <li><a href="#Error-Set-Type">Error Set Type</a></li>
            </ul>
          </td>
          <td>
              <a href="#Merging-Error-Sets">Merging Error Sets</a>
          </td>
          <td>
            <pre><code class="zig"><span class="tok-kw">const</span> A = <span class="tok-kw">error</span>{One};
<span class="tok-kw">const</span> B = <span class="tok-kw">error</span>{Two};
(A || B) == <span class="tok-kw">error</span>{One, Two}</code></pre>
          </td>
        </tr>
      </table>
      </div>
      
      <h2 id="Precedence">Precedence</h2>

      <pre><code class="zig">x() x[] x.y
a!b
!x -x -%x ~x &amp;x ?x
x{} x.* x.?
! * / % ** *% ||
+ - ++ +% -%
&lt;&lt; &gt;&gt;
&amp;
^
|
== != &lt; &gt; &lt;= &gt;=
<span class="tok-kw">and</span>
<span class="tok-kw">or</span>
<span class="tok-kw">orelse</span> <span class="tok-kw">catch</span>
= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</code></pre>
      
      
      <h1 id="Arrays">Arrays</h1>

      <p class="file">arrays.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;

<span class="tok-comment">// array literal</span>
<span class="tok-kw">const</span> message = []<span class="tok-type">u8</span>{ <span class="tok-str">'h'</span>, <span class="tok-str">'e'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'l'</span>, <span class="tok-str">'o'</span> };

<span class="tok-comment">// get the size of an array</span>
<span class="tok-kw">comptime</span> {
    assert(message.len == <span class="tok-number">5</span>);
}

<span class="tok-comment">// a string literal is an array literal</span>
<span class="tok-kw">const</span> same_message = <span class="tok-str">&quot;hello&quot;</span>;

<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, message, same_message));
    assert(<span class="tok-builtin">@typeOf</span>(message) == <span class="tok-builtin">@typeOf</span>(same_message));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;iterate over an array&quot;</span> {
    <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (message) |byte| {
        sum += byte;
    }
    assert(sum == <span class="tok-type">usize</span>(<span class="tok-str">'h'</span>) + <span class="tok-type">usize</span>(<span class="tok-str">'e'</span>) + <span class="tok-type">usize</span>(<span class="tok-str">'l'</span>) * <span class="tok-number">2</span> + <span class="tok-type">usize</span>(<span class="tok-str">'o'</span>));
}

<span class="tok-comment">// modifiable array</span>
<span class="tok-kw">var</span> some_integers: [<span class="tok-number">100</span>]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;modify an array&quot;</span> {
    <span class="tok-kw">for</span> (some_integers) |*item, i| {
        item.* = <span class="tok-builtin">@intCast</span>(<span class="tok-type">i32</span>, i);
    }
    assert(some_integers[<span class="tok-number">10</span>] == <span class="tok-number">10</span>);
    assert(some_integers[<span class="tok-number">99</span>] == <span class="tok-number">99</span>);
}

<span class="tok-comment">// array concatenation works if the values are known</span>
<span class="tok-comment">// at compile time</span>
<span class="tok-kw">const</span> part_one = []<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
<span class="tok-kw">const</span> part_two = []<span class="tok-type">i32</span>{ <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> };
<span class="tok-kw">const</span> all_of_it = part_one ++ part_two;
<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">i32</span>, all_of_it, []<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> }));
}

<span class="tok-comment">// remember that string literals are arrays</span>
<span class="tok-kw">const</span> hello = <span class="tok-str">&quot;hello&quot;</span>;
<span class="tok-kw">const</span> world = <span class="tok-str">&quot;world&quot;</span>;
<span class="tok-kw">const</span> hello_world = hello ++ <span class="tok-str">&quot; &quot;</span> ++ world;
<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, hello_world, <span class="tok-str">&quot;hello world&quot;</span>));
}

<span class="tok-comment">// ** does repeating patterns</span>
<span class="tok-kw">const</span> pattern = <span class="tok-str">&quot;ab&quot;</span> ** <span class="tok-number">3</span>;
<span class="tok-kw">comptime</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, pattern, <span class="tok-str">&quot;ababab&quot;</span>));
}

<span class="tok-comment">// initialize an array to zero</span>
<span class="tok-kw">const</span> all_zero = []<span class="tok-type">u16</span>{<span class="tok-number">0</span>} ** <span class="tok-number">10</span>;

<span class="tok-kw">comptime</span> {
    assert(all_zero.len == <span class="tok-number">10</span>);
    assert(all_zero[<span class="tok-number">5</span>] == <span class="tok-number">0</span>);
}

<span class="tok-comment">// use compile-time code to initialize an array</span>
<span class="tok-kw">var</span> fancy_array = init: {
    <span class="tok-kw">var</span> initial_value: [<span class="tok-number">10</span>]Point = <span class="tok-null">undefined</span>;
    <span class="tok-kw">for</span> (initial_value) |*pt, i| {
        pt.* = Point{
            .x = <span class="tok-builtin">@intCast</span>(<span class="tok-type">i32</span>, i),
            .y = <span class="tok-builtin">@intCast</span>(<span class="tok-type">i32</span>, i) * <span class="tok-number">2</span>,
        };
    }
    <span class="tok-kw">break</span> :init initial_value;
};
<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">i32</span>,
    y: <span class="tok-type">i32</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;compile-time array initalization&quot;</span> {
    assert(fancy_array[<span class="tok-number">4</span>].x == <span class="tok-number">4</span>);
    assert(fancy_array[<span class="tok-number">4</span>].y == <span class="tok-number">8</span>);
}

<span class="tok-comment">// call a function to initialize an array</span>
<span class="tok-kw">var</span> more_points = []Point{makePoint(<span class="tok-number">3</span>)} ** <span class="tok-number">10</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">makePoint</span>(x: <span class="tok-type">i32</span>) Point {
    <span class="tok-kw">return</span> Point{
        .x = x,
        .y = x * <span class="tok-number">2</span>,
    };
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;array initialization with function calls&quot;</span> {
    assert(more_points[<span class="tok-number">4</span>].x == <span class="tok-number">3</span>);
    assert(more_points[<span class="tok-number">4</span>].y == <span class="tok-number">6</span>);
    assert(more_points.len == <span class="tok-number">10</span>);
}</code></pre><pre><code class="shell">$ zig test arrays.zig
Test 1/4 iterate over an array...OK
Test 2/4 modify an array...OK
Test 3/4 compile-time array initalization...OK
Test 4/4 array initialization with function calls...OK
All tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#for">for</a></li>
<li><a href="#Slices">Slices</a></li>
</ul>

      
      <h1 id="Pointers">Pointers</h1>

      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;address of syntax&quot;</span> {
    <span class="tok-comment">// Get the address of a variable:</span>
    <span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> x_ptr = &amp;x;

    <span class="tok-comment">// Deference a pointer:</span>
    assert(x_ptr.* == <span class="tok-number">1234</span>);

    <span class="tok-comment">// When you get the address of a const variable, you get a const pointer.</span>
    assert(<span class="tok-builtin">@typeOf</span>(x_ptr) == *<span class="tok-kw">const</span> <span class="tok-type">i32</span>);

    <span class="tok-comment">// If you want to mutate the value, you'd need an address of a mutable variable:</span>
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">5678</span>;
    <span class="tok-kw">const</span> y_ptr = &amp;y;
    assert(<span class="tok-builtin">@typeOf</span>(y_ptr) == *<span class="tok-type">i32</span>);
    y_ptr.* += <span class="tok-number">1</span>;
    assert(y_ptr.* == <span class="tok-number">5679</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer array access&quot;</span> {
    <span class="tok-comment">// Taking an address of an individual element gives a</span>
    <span class="tok-comment">// pointer to a single item. This kind of pointer</span>
    <span class="tok-comment">// does not support pointer arithmetic.</span>
    <span class="tok-kw">var</span> array = []<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span> };
    <span class="tok-kw">const</span> ptr = &amp;array[<span class="tok-number">2</span>];
    assert(<span class="tok-builtin">@typeOf</span>(ptr) == *<span class="tok-type">u8</span>);

    assert(array[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);
    ptr.* += <span class="tok-number">1</span>;
    assert(array[<span class="tok-number">2</span>] == <span class="tok-number">4</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer slicing&quot;</span> {
    <span class="tok-comment">// In Zig, we prefer slices over pointers to null-terminated arrays.</span>
    <span class="tok-comment">// You can turn an array into a slice using slice syntax:</span>
    <span class="tok-kw">var</span> array = []<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span>, <span class="tok-number">9</span>, <span class="tok-number">10</span> };
    <span class="tok-kw">const</span> slice = array[<span class="tok-number">2</span>..<span class="tok-number">4</span>];
    assert(slice.len == <span class="tok-number">2</span>);

    <span class="tok-comment">// Slices have bounds checking and are therefore protected</span>
    <span class="tok-comment">// against this kind of undefined behavior. This is one reason</span>
    <span class="tok-comment">// we prefer slices to pointers.</span>
    assert(array[<span class="tok-number">3</span>] == <span class="tok-number">4</span>);
    slice[<span class="tok-number">1</span>] += <span class="tok-number">1</span>;
    assert(array[<span class="tok-number">3</span>] == <span class="tok-number">5</span>);
}

<span class="tok-kw">comptime</span> {
    <span class="tok-comment">// Pointers work at compile-time too, as long as you don't use</span>
    <span class="tok-comment">// @ptrCast.</span>
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> ptr = &amp;x;
    ptr.* += <span class="tok-number">1</span>;
    x += <span class="tok-number">1</span>;
    assert(ptr.* == <span class="tok-number">3</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;@ptrToInt and @intToPtr&quot;</span> {
    <span class="tok-comment">// To convert an integer address into a pointer, use @intToPtr:</span>
    <span class="tok-kw">const</span> ptr = <span class="tok-builtin">@intToPtr</span>(*<span class="tok-type">i32</span>, <span class="tok-number">0xdeadbeef</span>);

    <span class="tok-comment">// To convert a pointer to an integer, use @ptrToInt:</span>
    <span class="tok-kw">const</span> addr = <span class="tok-builtin">@ptrToInt</span>(ptr);

    assert(<span class="tok-builtin">@typeOf</span>(addr) == <span class="tok-type">usize</span>);
    assert(addr == <span class="tok-number">0xdeadbeef</span>);
}

<span class="tok-kw">comptime</span> {
    <span class="tok-comment">// Zig is able to do this at compile-time, as long as</span>
    <span class="tok-comment">// ptr is never dereferenced.</span>
    <span class="tok-kw">const</span> ptr = <span class="tok-builtin">@intToPtr</span>(*<span class="tok-type">i32</span>, <span class="tok-number">0xdeadbeef</span>);
    <span class="tok-kw">const</span> addr = <span class="tok-builtin">@ptrToInt</span>(ptr);
    assert(<span class="tok-builtin">@typeOf</span>(addr) == <span class="tok-type">usize</span>);
    assert(addr == <span class="tok-number">0xdeadbeef</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;volatile&quot;</span> {
    <span class="tok-comment">// In Zig, loads and stores are assumed to not have side effects.</span>
    <span class="tok-comment">// If a given load or store should have side effects, such as</span>
    <span class="tok-comment">// Memory Mapped Input/Output (MMIO), use `volatile`:</span>
    <span class="tok-kw">const</span> mmio_ptr = <span class="tok-builtin">@intToPtr</span>(*<span class="tok-kw">volatile</span> <span class="tok-type">u8</span>, <span class="tok-number">0x12345678</span>);

    <span class="tok-comment">// Now loads and stores with mmio_ptr are guaranteed to all happen</span>
    <span class="tok-comment">// and in the same order as in source code.</span>
    assert(<span class="tok-builtin">@typeOf</span>(mmio_ptr) == *<span class="tok-kw">volatile</span> <span class="tok-type">u8</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;optional pointers&quot;</span> {
    <span class="tok-comment">// Pointers cannot be null. If you want a null pointer, use the optional</span>
    <span class="tok-comment">// prefix `?` to make the pointer type optional.</span>
    <span class="tok-kw">var</span> ptr: ?*<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    ptr = &amp;x;

    assert(ptr.?.* == <span class="tok-number">1</span>);

    <span class="tok-comment">// Optional pointers are the same size as normal pointers, because pointer</span>
    <span class="tok-comment">// value 0 is used as the null value.</span>
    assert(<span class="tok-builtin">@sizeOf</span>(?*<span class="tok-type">i32</span>) == <span class="tok-builtin">@sizeOf</span>(*<span class="tok-type">i32</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer casting&quot;</span> {
    <span class="tok-comment">// To convert one pointer type to another, use @ptrCast. This is an unsafe</span>
    <span class="tok-comment">// operation that Zig cannot protect you against. Use @ptrCast only when other</span>
    <span class="tok-comment">// conversions are not possible.</span>
    <span class="tok-kw">const</span> bytes <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">u32</span>)) = []<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span> };
    <span class="tok-kw">const</span> u32_ptr = <span class="tok-builtin">@ptrCast</span>(*<span class="tok-kw">const</span> <span class="tok-type">u32</span>, &amp;bytes);
    assert(u32_ptr.* == <span class="tok-number">0x12121212</span>);

    <span class="tok-comment">// Even this example is contrived - there are better ways to do the above than</span>
    <span class="tok-comment">// pointer casting. For example, using a slice narrowing cast:</span>
    <span class="tok-kw">const</span> u32_value = <span class="tok-builtin">@bytesToSlice</span>(<span class="tok-type">u32</span>, bytes[<span class="tok-number">0</span>..])[<span class="tok-number">0</span>];
    assert(u32_value == <span class="tok-number">0x12121212</span>);

    <span class="tok-comment">// And even another way, the most straightforward way to do it:</span>
    assert(<span class="tok-builtin">@bitCast</span>(<span class="tok-type">u32</span>, bytes) == <span class="tok-number">0x12121212</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer child type&quot;</span> {
    <span class="tok-comment">// pointer types have a `child` field which tells you the type they point to.</span>
    assert((*<span class="tok-type">u32</span>).Child == <span class="tok-type">u32</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/8 address of syntax...OK
Test 2/8 pointer array access...OK
Test 3/8 pointer slicing...OK
Test 4/8 @ptrToInt and @intToPtr...OK
Test 5/8 volatile...OK
Test 6/8 optional pointers...OK
Test 7/8 pointer casting...OK
Test 8/8 pointer child type...OK
All tests passed.
</code></pre>

      <h2 id="Alignment">Alignment</h2>

      <p>
      Each type has an <strong>alignment</strong> - a number of bytes such that,
      when a value of the type is loaded from or stored to memory,
      the memory address must be evenly divisible by this number. You can use
      <a href="#alignOf">@alignOf</a> to find out this value for any type.
      </p>
      <p>
      Alignment depends on the CPU architecture, but is always a power of two, and
      less than <code class="zig"><span class="tok-number">1</span> &lt;&lt; <span class="tok-number">29</span></code>.
      </p>
      <p>
      In Zig, a pointer type has an alignment value. If the value is equal to the
      alignment of the underlying type, it can be omitted from the type:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;variable alignment&quot;</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">const</span> align_of_i32 = <span class="tok-builtin">@alignOf</span>(<span class="tok-builtin">@typeOf</span>(x));
    assert(<span class="tok-builtin">@typeOf</span>(&amp;x) == *<span class="tok-type">i32</span>);
    assert(*<span class="tok-type">i32</span> == *<span class="tok-kw">align</span>(align_of_i32) <span class="tok-type">i32</span>);
    <span class="tok-kw">if</span> (builtin.arch == builtin.Arch.x86_64) {
        assert((*<span class="tok-type">i32</span>).alignment == <span class="tok-number">4</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 variable alignment...OK
All tests passed.
</code></pre>

      <p>In the same way that a <code class="zig">*<span class="tok-type">i32</span></code> can be <a href="#Implicit-Casts">implicitly cast</a> to a
          <code class="zig">*<span class="tok-kw">const</span> <span class="tok-type">i32</span></code>, a pointer with a larger alignment can be implicitly
      cast to a pointer with a smaller alignment, but not vice versa.
      </p>
      <p>
      You can specify alignment on variables and functions. If you do this, then
      pointers to them get the specified alignment:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">var</span> foo: <span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = <span class="tok-number">100</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;global variable alignment&quot;</span> {
    assert(<span class="tok-builtin">@typeOf</span>(&amp;foo).alignment == <span class="tok-number">4</span>);
    assert(<span class="tok-builtin">@typeOf</span>(&amp;foo) == *<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>);
    <span class="tok-kw">const</span> slice = (*[<span class="tok-number">1</span>]<span class="tok-type">u8</span>)(&amp;foo)[<span class="tok-number">0</span>..];
    assert(<span class="tok-builtin">@typeOf</span>(slice) == []<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">derp</span>() <span class="tok-kw">align</span>(<span class="tok-builtin">@sizeOf</span>(<span class="tok-type">usize</span>) * <span class="tok-number">2</span>) <span class="tok-type">i32</span> { <span class="tok-kw">return</span> <span class="tok-number">1234</span>; }
<span class="tok-kw">fn</span> <span class="tok-fn">noop1</span>() <span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">void</span> {}
<span class="tok-kw">fn</span> <span class="tok-fn">noop4</span>() <span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">void</span> {}

<span class="tok-kw">test</span> <span class="tok-str">&quot;function alignment&quot;</span> {
    assert(derp() == <span class="tok-number">1234</span>);
    assert(<span class="tok-builtin">@typeOf</span>(noop1) == <span class="tok-kw">fn</span>() <span class="tok-kw">align</span>(<span class="tok-number">1</span>) <span class="tok-type">void</span>);
    assert(<span class="tok-builtin">@typeOf</span>(noop4) == <span class="tok-kw">fn</span>() <span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">void</span>);
    noop1();
    noop4();
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/2 global variable alignment...OK
Test 2/2 function alignment...OK
All tests passed.
</code></pre>

      <p>
      If you have a pointer or a slice that has a small alignment, but you know that it actually
      has a bigger alignment, use <a href="#alignCast">@alignCast</a> to change the
      pointer into a more aligned pointer. This is a no-op at runtime, but inserts a
      <a href="#Incorrect-Pointer-Alignment">safety check</a>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer alignment safety&quot;</span> {
    <span class="tok-kw">var</span> array <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = []<span class="tok-type">u32</span>{ <span class="tok-number">0x11111111</span>, <span class="tok-number">0x11111111</span> };
    <span class="tok-kw">const</span> bytes = <span class="tok-builtin">@sliceToBytes</span>(array[<span class="tok-number">0</span>..]);
    assert(foo(bytes) == <span class="tok-number">0x11111111</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(bytes: []<span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> slice4 = bytes[<span class="tok-number">1</span>..<span class="tok-number">5</span>];
    <span class="tok-kw">const</span> int_slice = <span class="tok-builtin">@bytesToSlice</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@alignCast</span>(<span class="tok-number">4</span>, slice4));
    <span class="tok-kw">return</span> int_slice[<span class="tok-number">0</span>];
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 pointer alignment safety...incorrect alignment
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:10:56</span>: <span class="t2_0">0x2052bf in ??? (test)</span>
    const int_slice = @bytesToSlice(u32, @alignCast(4, slice4));
                                                       <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:6:15</span>: <span class="t2_0">0x2050a7 in ??? (test)</span>
    assert(foo(bytes) == 0x11111111);
              <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/test_runner.zig:13:25</span>: <span class="t2_0">0x222aca in ??? (test)</span>
        if (test_fn.func()) |_| {
                        <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:96:22</span>: <span class="t2_0">0x22287b in ??? (test)</span>
            root.main() catch |err| {
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x2227f5 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x222658 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222510 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>

Tests failed. Use the following command to reproduce the failure:
/home/andy/dev/zig/docgen_tmp/test
</code></pre>

      
      <h2 id="Type-Based-Alias-Analysis">Type Based Alias Analysis</h2>

      <p>Zig uses Type Based Alias Analysis (also known as Strict Aliasing) to
      perform some optimizations. This means that pointers of different types must
      not alias the same memory, with the exception of <code class="zig"><span class="tok-type">u8</span></code>. Pointers to
          <code class="zig"><span class="tok-type">u8</span></code> can alias any memory.
      </p>
      <p>As an example, this code produces undefined behavior:</p>
      <pre><code class="zig"><span class="tok-builtin">@ptrCast</span>(*<span class="tok-type">u32</span>, <span class="tok-type">f32</span>(<span class="tok-number">12.34</span>)).*</code></pre>
      <p>Instead, use <a href="#bitCast">@bitCast</a>:
      <pre><code class="zig"><span class="tok-builtin">@bitCast</span>(<span class="tok-type">u32</span>, <span class="tok-type">f32</span>(<span class="tok-number">12.34</span>))</code></pre>
      <p>As an added benefit, the <code class="zig"><span class="tok-builtin">@bitCast</span></code> version works at compile-time.</p>
      <p>See also:</p><ul>
<li><a href="#Slices">Slices</a></li>
<li><a href="#Memory">Memory</a></li>
</ul>

      
      
      <h1 id="Slices">Slices</h1>

      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;basic slices&quot;</span> {
    <span class="tok-kw">var</span> array = []<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-comment">// A slice is a pointer and a length. The difference between an array and</span>
    <span class="tok-comment">// a slice is that the array's length is part of the type and known at</span>
    <span class="tok-comment">// compile-time, whereas the slice's length is known at runtime.</span>
    <span class="tok-comment">// Both can be accessed with the `len` field.</span>
    <span class="tok-kw">const</span> slice = array[<span class="tok-number">0</span>..array.len];
    assert(&amp;slice[<span class="tok-number">0</span>] == &amp;array[<span class="tok-number">0</span>]);
    assert(slice.len == array.len);

    <span class="tok-comment">// Using the address-of operator on a slice gives a pointer to a single</span>
    <span class="tok-comment">// item, while using the `ptr` field gives an unknown length pointer.</span>
    assert(<span class="tok-builtin">@typeOf</span>(slice.ptr) == [*]<span class="tok-type">i32</span>);
    assert(<span class="tok-builtin">@typeOf</span>(&amp;slice[<span class="tok-number">0</span>]) == *<span class="tok-type">i32</span>);
    assert(<span class="tok-builtin">@ptrToInt</span>(slice.ptr) == <span class="tok-builtin">@ptrToInt</span>(&amp;slice[<span class="tok-number">0</span>]));

    <span class="tok-comment">// Slices have array bounds checking. If you try to access something out</span>
    <span class="tok-comment">// of bounds, you'll get a safety check failure:</span>
    slice[<span class="tok-number">10</span>] += <span class="tok-number">1</span>;

    <span class="tok-comment">// Note that `slice.ptr` does not invoke safety checking, while `&amp;slice[0]`</span>
    <span class="tok-comment">// asserts that the slice has len &gt;= 1.</span>
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 basic slices...index out of bounds
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:21:10</span>: <span class="t2_0">0x205156 in ??? (test)</span>
    slice[10] += 1;
         <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/test_runner.zig:13:25</span>: <span class="t2_0">0x222a8a in ??? (test)</span>
        if (test_fn.func()) |_| {
                        <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:96:22</span>: <span class="t2_0">0x22283b in ??? (test)</span>
            root.main() catch |err| {
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x2227b5 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x222618 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x2224d0 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>

Tests failed. Use the following command to reproduce the failure:
/home/andy/dev/zig/docgen_tmp/test
</code></pre>

      <p>This is one reason we prefer slices to pointers.</p>
      <p class="file">slices.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;
<span class="tok-kw">const</span> fmt = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).fmt;

<span class="tok-kw">test</span> <span class="tok-str">&quot;using slices for strings&quot;</span> {
    <span class="tok-comment">// Zig has no concept of strings. String literals are arrays of u8, and</span>
    <span class="tok-comment">// in general the string type is []u8 (slice of u8).</span>
    <span class="tok-comment">// Here we implicitly cast [5]u8 to []const u8</span>
    <span class="tok-kw">const</span> hello: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hello&quot;</span>;
    <span class="tok-kw">const</span> world: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;&quot;</span>;

    <span class="tok-kw">var</span> all_together: [<span class="tok-number">100</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-comment">// You can use slice syntax on an array to convert an array into a slice.</span>
    <span class="tok-kw">const</span> all_together_slice = all_together[<span class="tok-number">0</span>..];
    <span class="tok-comment">// String concatenation example.</span>
    <span class="tok-kw">const</span> hello_world = <span class="tok-kw">try</span> fmt.bufPrint(all_together_slice, <span class="tok-str">&quot;{} {}&quot;</span>, hello, world);

    <span class="tok-comment">// Generally, you can use UTF-8 and not worry about whether something is a</span>
    <span class="tok-comment">// string. If you don't need to deal with individual characters, no need</span>
    <span class="tok-comment">// to decode.</span>
    assert(mem.eql(<span class="tok-type">u8</span>, hello_world, <span class="tok-str">&quot;hello &quot;</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;slice pointer&quot;</span> {
    <span class="tok-kw">var</span> array: [<span class="tok-number">10</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">const</span> ptr = &amp;array;

    <span class="tok-comment">// You can use slicing syntax to convert a pointer into a slice:</span>
    <span class="tok-kw">const</span> slice = ptr[<span class="tok-number">0</span>..<span class="tok-number">5</span>];
    slice[<span class="tok-number">2</span>] = <span class="tok-number">3</span>;
    assert(slice[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);
    <span class="tok-comment">// The slice is mutable because we sliced a mutable pointer.</span>
    assert(<span class="tok-builtin">@typeOf</span>(slice) == []<span class="tok-type">u8</span>);

    <span class="tok-comment">// You can also slice a slice:</span>
    <span class="tok-kw">const</span> slice2 = slice[<span class="tok-number">2</span>..<span class="tok-number">3</span>];
    assert(slice2.len == <span class="tok-number">1</span>);
    assert(slice2[<span class="tok-number">0</span>] == <span class="tok-number">3</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;slice widening&quot;</span> {
    <span class="tok-comment">// Zig supports slice widening and slice narrowing. Cast a slice of u8</span>
    <span class="tok-comment">// to a slice of anything else, and Zig will perform the length conversion.</span>
    <span class="tok-kw">const</span> array <span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">u32</span>)) = []<span class="tok-type">u8</span>{ <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x12</span>, <span class="tok-number">0x13</span>, <span class="tok-number">0x13</span>, <span class="tok-number">0x13</span>, <span class="tok-number">0x13</span> };
    <span class="tok-kw">const</span> slice = <span class="tok-builtin">@bytesToSlice</span>(<span class="tok-type">u32</span>, array[<span class="tok-number">0</span>..]);
    assert(slice.len == <span class="tok-number">2</span>);
    assert(slice[<span class="tok-number">0</span>] == <span class="tok-number">0x12121212</span>);
    assert(slice[<span class="tok-number">1</span>] == <span class="tok-number">0x13131313</span>);
}</code></pre><pre><code class="shell">$ zig test slices.zig
Test 1/3 using slices for strings...OK
Test 2/3 slice pointer...OK
Test 3/3 slice widening...OK
All tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Pointers">Pointers</a></li>
<li><a href="#for">for</a></li>
<li><a href="#Arrays">Arrays</a></li>
</ul>

      
      <h1 id="struct">struct</h1>

      <p class="file">structs.zig</p><pre><code class="zig"><span class="tok-comment">// Declare a struct.</span>
<span class="tok-comment">// Zig gives no guarantees about the order of fields and whether or</span>
<span class="tok-comment">// not there will be padding.</span>
<span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">f32</span>,
    y: <span class="tok-type">f32</span>,
};

<span class="tok-comment">// Maybe we want to pass it to OpenGL so we want to be particular about</span>
<span class="tok-comment">// how the bytes are arranged.</span>
<span class="tok-kw">const</span> Point2 = <span class="tok-kw">packed</span> <span class="tok-kw">struct</span> {
    x: <span class="tok-type">f32</span>,
    y: <span class="tok-type">f32</span>,
};


<span class="tok-comment">// Declare an instance of a struct.</span>
<span class="tok-kw">const</span> p = Point {
    .x = <span class="tok-number">0.12</span>,
    .y = <span class="tok-number">0.34</span>,
};

<span class="tok-comment">// Maybe we're not ready to fill out some of the fields.</span>
<span class="tok-kw">var</span> p2 = Point {
    .x = <span class="tok-number">0.12</span>,
    .y = <span class="tok-null">undefined</span>,
};

<span class="tok-comment">// Structs can have methods</span>
<span class="tok-comment">// Struct methods are not special, they are only namespaced</span>
<span class="tok-comment">// functions that you can call with dot syntax.</span>
<span class="tok-kw">const</span> Vec3 = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">f32</span>,
    y: <span class="tok-type">f32</span>,
    z: <span class="tok-type">f32</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(x: <span class="tok-type">f32</span>, y: <span class="tok-type">f32</span>, z: <span class="tok-type">f32</span>) Vec3 {
        <span class="tok-kw">return</span> Vec3 {
            .x = x,
            .y = y,
            .z = z,
        };
    }

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">dot</span>(self: *<span class="tok-kw">const</span> Vec3, other: *<span class="tok-kw">const</span> Vec3) <span class="tok-type">f32</span> {
        <span class="tok-kw">return</span> self.x * other.x + self.y * other.y + self.z * other.z;
    }
};

<span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;
<span class="tok-kw">test</span> <span class="tok-str">&quot;dot product&quot;</span> {
    <span class="tok-kw">const</span> v1 = Vec3.init(<span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>, <span class="tok-number">0.0</span>);
    <span class="tok-kw">const</span> v2 = Vec3.init(<span class="tok-number">0.0</span>, <span class="tok-number">1.0</span>, <span class="tok-number">0.0</span>);
    assert(v1.dot(v2) == <span class="tok-number">0.0</span>);

    <span class="tok-comment">// Other than being available to call with dot syntax, struct methods are</span>
    <span class="tok-comment">// not special. You can reference them as any other declaration inside</span>
    <span class="tok-comment">// the struct:</span>
    assert(Vec3.dot(v1, v2) == <span class="tok-number">0.0</span>);
}

<span class="tok-comment">// Structs can have global declarations.</span>
<span class="tok-comment">// Structs can have 0 fields.</span>
<span class="tok-kw">const</span> Empty = <span class="tok-kw">struct</span> {
    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> PI = <span class="tok-number">3.14</span>;
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;struct namespaced variable&quot;</span> {
    assert(Empty.PI == <span class="tok-number">3.14</span>);
    assert(<span class="tok-builtin">@sizeOf</span>(Empty) == <span class="tok-number">0</span>);

    <span class="tok-comment">// you can still instantiate an empty struct</span>
    <span class="tok-kw">const</span> does_nothing = Empty {};
}

<span class="tok-comment">// struct field order is determined by the compiler for optimal performance.</span>
<span class="tok-comment">// however, you can still calculate a struct base pointer given a field pointer:</span>
<span class="tok-kw">fn</span> <span class="tok-fn">setYBasedOnX</span>(x: *<span class="tok-type">f32</span>, y: <span class="tok-type">f32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> point = <span class="tok-builtin">@fieldParentPtr</span>(Point, <span class="tok-str">&quot;x&quot;</span>, x);
    point.y = y;
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;field parent pointer&quot;</span> {
    <span class="tok-kw">var</span> point = Point {
        .x = <span class="tok-number">0.1234</span>,
        .y = <span class="tok-number">0.5678</span>,
    };
    setYBasedOnX(&amp;point.x, <span class="tok-number">0.9</span>);
    assert(point.y == <span class="tok-number">0.9</span>);
}

<span class="tok-comment">// You can return a struct from a function. This is how we do generics</span>
<span class="tok-comment">// in Zig:</span>
<span class="tok-kw">fn</span> <span class="tok-fn">LinkedList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
            prev: ?*Node,
            next: ?*Node,
            data: T,
        };

        first: ?*Node,
        last:  ?*Node,
        len:   <span class="tok-type">usize</span>,
    };
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;linked list&quot;</span> {
    <span class="tok-comment">// Functions called at compile-time are memoized. This means you can</span>
    <span class="tok-comment">// do this:</span>
    assert(LinkedList(<span class="tok-type">i32</span>) == LinkedList(<span class="tok-type">i32</span>));

    <span class="tok-kw">var</span> list = LinkedList(<span class="tok-type">i32</span>) {
        .first = <span class="tok-null">null</span>,
        .last = <span class="tok-null">null</span>,
        .len = <span class="tok-number">0</span>,
    };
    assert(list.len == <span class="tok-number">0</span>);

    <span class="tok-comment">// Since types are first class values you can instantiate the type</span>
    <span class="tok-comment">// by assigning it to a variable:</span>
    <span class="tok-kw">const</span> ListOfInts = LinkedList(<span class="tok-type">i32</span>);
    assert(ListOfInts == LinkedList(<span class="tok-type">i32</span>));

    <span class="tok-kw">var</span> node = ListOfInts.Node {
        .prev = <span class="tok-null">null</span>,
        .next = <span class="tok-null">null</span>,
        .data = <span class="tok-number">1234</span>,
    };
    <span class="tok-kw">var</span> list2 = LinkedList(<span class="tok-type">i32</span>) {
        .first = &amp;node,
        .last = &amp;node,
        .len = <span class="tok-number">1</span>,
    };
    assert(list2.first.?.data == <span class="tok-number">1234</span>);
}</code></pre><pre><code class="shell">$ zig test structs.zig
Test 1/4 dot product...OK
Test 2/4 struct namespaced variable...OK
Test 3/4 field parent pointer...OK
Test 4/4 linked list...OK
All tests passed.
</code></pre>

      <h2 id="packed-struct">packed struct</h2>

      <p><code class="zig"><span class="tok-kw">packed</span></code> structs have guaranteed in-memory layout.</p>
      <p>TODO bit fields</p>
      <p>TODO alignment</p>
      <p>TODO endianness</p>
      <p>TODO @bitOffsetOf and @byteOffsetOf</p>
      <p>TODO mention how volatile loads and stores of bit packed fields could be more efficient when
      done by hand instead of with packed struct</p>
      
      <h2 id="struct-Naming">struct Naming</h2>

      <p>Since all structs are anonymous, Zig infers the type name based on a few rules.</p>
      <ul>
          <li>If the struct is in the initialization expression of a variable, it gets named after
          that variable.</li>
          <li>If the struct is in the <code class="zig"><span class="tok-kw">return</span></code> expression, it gets named after
          the function it is returning from, with the parameter values serialized.</li>
          <li>Otherwise, the struct gets a name such as <code>(anonymous struct at file.zig:7:38)</code>.</li>
      </ul>
      <p class="file">struct_name.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {};
    std.debug.warn(<span class="tok-str">&quot;variable: {}\n&quot;</span>, <span class="tok-builtin">@typeName</span>(Foo));
    std.debug.warn(<span class="tok-str">&quot;anonymous: {}\n&quot;</span>, <span class="tok-builtin">@typeName</span>(<span class="tok-kw">struct</span> {}));
    std.debug.warn(<span class="tok-str">&quot;function: {}\n&quot;</span>, <span class="tok-builtin">@typeName</span>(List(<span class="tok-type">i32</span>)));
}

<span class="tok-kw">fn</span> <span class="tok-fn">List</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        x: T,
    };
}</code></pre><pre><code class="shell">$ zig build-exe struct_name.zig
$ ./struct_name
variable: Foo
anonymous: (anonymous struct at /home/andy/dev/zig/docgen_tmp/struct_name.zig:6:49)
function: List(i32)
</code></pre>

      
      <p>See also:</p><ul>
<li><a href="#comptime">comptime</a></li>
<li><a href="#fieldParentPtr">@fieldParentPtr</a></li>
</ul>

      
      <h1 id="enum">enum</h1>

      <p class="file">enums.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;

<span class="tok-comment">// Declare an enum.</span>
<span class="tok-kw">const</span> Type = <span class="tok-kw">enum</span> {
    Ok,
    NotOk,
};

<span class="tok-comment">// Declare a specific instance of the enum variant.</span>
<span class="tok-kw">const</span> c = Type.Ok;

<span class="tok-comment">// If you want access to the ordinal value of an enum, you</span>
<span class="tok-comment">// can specify the tag type.</span>
<span class="tok-kw">const</span> Value = <span class="tok-kw">enum</span>(<span class="tok-type">u2</span>) {
    Zero,
    One,
    Two,
};

<span class="tok-comment">// Now you can cast between u2 and Value.</span>
<span class="tok-comment">// The ordinal value starts from 0, counting up for each member.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;enum ordinal value&quot;</span> {
    assert(<span class="tok-builtin">@enumToInt</span>(Value.Zero) == <span class="tok-number">0</span>);
    assert(<span class="tok-builtin">@enumToInt</span>(Value.One) == <span class="tok-number">1</span>);
    assert(<span class="tok-builtin">@enumToInt</span>(Value.Two) == <span class="tok-number">2</span>);
}

<span class="tok-comment">// You can override the ordinal value for an enum.</span>
<span class="tok-kw">const</span> Value2 = <span class="tok-kw">enum</span>(<span class="tok-type">u32</span>) {
    Hundred = <span class="tok-number">100</span>,
    Thousand = <span class="tok-number">1000</span>,
    Million = <span class="tok-number">1000000</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;set enum ordinal value&quot;</span> {
    assert(<span class="tok-builtin">@enumToInt</span>(Value2.Hundred) == <span class="tok-number">100</span>);
    assert(<span class="tok-builtin">@enumToInt</span>(Value2.Thousand) == <span class="tok-number">1000</span>);
    assert(<span class="tok-builtin">@enumToInt</span>(Value2.Million) == <span class="tok-number">1000000</span>);
}

<span class="tok-comment">// Enums can have methods, the same as structs and unions.</span>
<span class="tok-comment">// Enum methods are not special, they are only namespaced</span>
<span class="tok-comment">// functions that you can call with dot syntax.</span>
<span class="tok-kw">const</span> Suit = <span class="tok-kw">enum</span> {
    Clubs,
    Spades,
    Diamonds,
    Hearts,

    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isClubs</span>(self: Suit) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> self == Suit.Clubs;
    }
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;enum method&quot;</span> {
    <span class="tok-kw">const</span> p = Suit.Spades;
    assert(!p.isClubs());
}

<span class="tok-comment">// An enum variant of different types can be switched upon.</span>
<span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    String,
    Number,
    None,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;enum variant switch&quot;</span> {
    <span class="tok-kw">const</span> p = Foo.Number;
    <span class="tok-kw">const</span> what_is_it = <span class="tok-kw">switch</span> (p) {
        Foo.String =&gt; <span class="tok-str">&quot;this is a string&quot;</span>,
        Foo.Number =&gt; <span class="tok-str">&quot;this is a number&quot;</span>,
        Foo.None =&gt; <span class="tok-str">&quot;this is a none&quot;</span>,
    };
    assert(mem.eql(<span class="tok-type">u8</span>, what_is_it, <span class="tok-str">&quot;this is a number&quot;</span>));
}

<span class="tok-comment">// @TagType can be used to access the integer tag type of an enum.</span>
<span class="tok-kw">const</span> Small = <span class="tok-kw">enum</span> {
    One,
    Two,
    Three,
    Four,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;@TagType&quot;</span> {
    assert(<span class="tok-builtin">@TagType</span>(Small) == <span class="tok-type">u2</span>);
}

<span class="tok-comment">// @memberCount tells how many fields an enum has:</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;@memberCount&quot;</span> {
    assert(<span class="tok-builtin">@memberCount</span>(Small) == <span class="tok-number">4</span>);
}

<span class="tok-comment">// @memberName tells the name of a field in an enum:</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;@memberName&quot;</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@memberName</span>(Small, <span class="tok-number">1</span>), <span class="tok-str">&quot;Two&quot;</span>));
}

<span class="tok-comment">// @tagName gives a []const u8 representation of an enum value:</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;@tagName&quot;</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@tagName</span>(Small.Three), <span class="tok-str">&quot;Three&quot;</span>));
}</code></pre><pre><code class="shell">$ zig test enums.zig
Test 1/8 enum ordinal value...OK
Test 2/8 set enum ordinal value...OK
Test 3/8 enum method...OK
Test 4/8 enum variant switch...OK
Test 5/8 @TagType...OK
Test 6/8 @memberCount...OK
Test 7/8 @memberName...OK
Test 8/8 @tagName...OK
All tests passed.
</code></pre>

      <h2 id="extern-enum">extern enum</h2>

      <p>
      By default, enums are not guaranteed to be compatible with the C ABI:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> { A, B, C };
<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">entry</span>(foo: Foo) <span class="tok-type">void</span> { }</code></pre><pre><code class="shell">$ zig build-obj test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:22: </span><span class="t31_1">error:</span><span class="t0_1"> parameter of type 'Foo' not allowed in function with calling convention 'ccc'</span>
export fn entry(foo: Foo) void { 
                     <span class="t32_1">^</span>

</code></pre>
</code></pre>

      <p>
      For a C-ABI-compatible enum, use <code class="zig"><span class="tok-kw">extern</span> <span class="tok-kw">enum</span></code>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Foo = <span class="tok-kw">extern</span> <span class="tok-kw">enum</span> { A, B, C };
<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">entry</span>(foo: Foo) <span class="tok-type">void</span> { }</code></pre><pre><code class="shell">$ zig build-obj test.zig</code></pre>

      
      <h2 id="packed-enum">packed enum</h2>

      <p>By default, the size of enums is not guaranteed.</p>
      <p><code class="zig"><span class="tok-kw">packed</span> <span class="tok-kw">enum</span></code> causes the size of the enum to be the same as the size of the integer tag type
      of the enum:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;packed enum&quot;</span> {
    <span class="tok-kw">const</span> Number = <span class="tok-kw">packed</span> <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {
        One,
        Two,
        Three,
    };
    std.debug.assert(<span class="tok-builtin">@sizeOf</span>(Number) == <span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u8</span>));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 packed enum...OK
All tests passed.
</code></pre>

      
      <p>See also:</p><ul>
<li><a href="#memberName">@memberName</a></li>
<li><a href="#memberCount">@memberCount</a></li>
<li><a href="#tagName">@tagName</a></li>
<li><a href="#sizeOf">@sizeOf</a></li>
</ul>

      
      <h1 id="union">union</h1>

      <p class="file">union.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;
<span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;

<span class="tok-comment">// A union has only 1 active field at a time.</span>
<span class="tok-kw">const</span> Payload = <span class="tok-kw">union</span> {
    Int: <span class="tok-type">i64</span>,
    Float: <span class="tok-type">f64</span>,
    Bool: <span class="tok-type">bool</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;simple union&quot;</span> {
    <span class="tok-kw">var</span> payload = Payload {.Int = <span class="tok-number">1234</span>};
    <span class="tok-comment">// payload.Float = 12.34; // ERROR! field not active</span>
    assert(payload.Int == <span class="tok-number">1234</span>);
    <span class="tok-comment">// You can activate another field by assigning the entire union.</span>
    payload = Payload {.Float = <span class="tok-number">12.34</span>};
    assert(payload.Float == <span class="tok-number">12.34</span>);
}

<span class="tok-comment">// Unions can be given an enum tag type:</span>
<span class="tok-kw">const</span> ComplexTypeTag = <span class="tok-kw">enum</span> { Ok, NotOk }; 
<span class="tok-kw">const</span> ComplexType = <span class="tok-kw">union</span>(ComplexTypeTag) {
    Ok: <span class="tok-type">u8</span>,
    NotOk: <span class="tok-type">void</span>,
};

<span class="tok-comment">// Declare a specific instance of the union variant.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;declare union value&quot;</span> {
    <span class="tok-kw">const</span> c = ComplexType { .Ok = <span class="tok-number">0</span> };
    assert(ComplexTypeTag(c) == ComplexTypeTag.Ok);
}

<span class="tok-comment">// @TagType can be used to access the enum tag type of a union.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;@TagType&quot;</span> {
    assert(<span class="tok-builtin">@TagType</span>(ComplexType) == ComplexTypeTag);
}

<span class="tok-comment">// Unions can be made to infer the enum tag type.</span>
<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    String: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    Number: <span class="tok-type">u64</span>,

    <span class="tok-comment">// void can be omitted when inferring enum tag type.</span>
    None,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;union variant switch&quot;</span> {
    <span class="tok-kw">const</span> p = Foo { .Number = <span class="tok-number">54</span> };
    <span class="tok-kw">const</span> what_is_it = <span class="tok-kw">switch</span> (p) {
        <span class="tok-comment">// Capture by reference</span>
        Foo.String =&gt; |*x| blk: {
            <span class="tok-kw">break</span> :blk <span class="tok-str">&quot;this is a string&quot;</span>;
        },

        <span class="tok-comment">// Capture by value</span>
        Foo.Number =&gt; |x| blk: {
            assert(x == <span class="tok-number">54</span>);
            <span class="tok-kw">break</span> :blk <span class="tok-str">&quot;this is a number&quot;</span>;
        },

        Foo.None =&gt; blk: {
            <span class="tok-kw">break</span> :blk <span class="tok-str">&quot;this is a none&quot;</span>;
        },
    };
    assert(mem.eql(<span class="tok-type">u8</span>, what_is_it, <span class="tok-str">&quot;this is a number&quot;</span>));
}

<span class="tok-comment">// Unions can have methods just like structs and enums:</span>

<span class="tok-kw">const</span> Variant = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    Int: <span class="tok-type">i32</span>,
    Bool: <span class="tok-type">bool</span>,

    <span class="tok-kw">fn</span> <span class="tok-fn">truthy</span>(self: *<span class="tok-kw">const</span> Variant) <span class="tok-type">bool</span> {
        <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (self.*) {
            Variant.Int =&gt; |x_int| x_int != <span class="tok-number">0</span>,
            Variant.Bool =&gt; |x_bool| x_bool,
        };
    }
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;union method&quot;</span> {
    <span class="tok-kw">var</span> v1 = Variant { .Int = <span class="tok-number">1</span> };
    <span class="tok-kw">var</span> v2 = Variant { .Bool = <span class="tok-null">false</span> };

    assert(v1.truthy());
    assert(!v2.truthy());
}


<span class="tok-kw">const</span> Small = <span class="tok-kw">union</span> {
    A: <span class="tok-type">i32</span>,
    B: <span class="tok-type">bool</span>,
    C: <span class="tok-type">u8</span>,
};

<span class="tok-comment">// @memberCount tells how many fields a union has:</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;@memberCount&quot;</span> {
    assert(<span class="tok-builtin">@memberCount</span>(Small) == <span class="tok-number">3</span>);
}

<span class="tok-comment">// @memberName tells the name of a field in an enum:</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;@memberName&quot;</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@memberName</span>(Small, <span class="tok-number">1</span>), <span class="tok-str">&quot;B&quot;</span>));
}

<span class="tok-comment">// @tagName gives a []const u8 representation of an enum value,</span>
<span class="tok-comment">// but only if the union has an enum tag type.</span>
<span class="tok-kw">const</span> Small2 = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
    A: <span class="tok-type">i32</span>,
    B: <span class="tok-type">bool</span>,
    C: <span class="tok-type">u8</span>,
};
<span class="tok-kw">test</span> <span class="tok-str">&quot;@tagName&quot;</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, <span class="tok-builtin">@tagName</span>(Small2.C), <span class="tok-str">&quot;C&quot;</span>));
}</code></pre><pre><code class="shell">$ zig test union.zig
Test 1/8 simple union...OK
Test 2/8 declare union value...OK
Test 3/8 @TagType...OK
Test 4/8 union variant switch...OK
Test 5/8 union method...OK
Test 6/8 @memberCount...OK
Test 7/8 @memberName...OK
Test 8/8 @tagName...OK
All tests passed.
</code></pre>

      <p>
      Unions with an enum tag are generated as a struct with a tag field and union field. Zig
      sorts the order of the tag and union field by the largest alignment.
      </p>
      
      <h1 id="blocks">blocks</h1>

      <p>
      Blocks are used to limit the scope of variable declarations:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;access variable after block scope&quot;</span> {
    {
        <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    }
    x += <span class="tok-number">1</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:5: </span><span class="t31_1">error:</span><span class="t0_1"> use of undeclared identifier 'x'</span>
    x += 1;
    <span class="t32_1">^</span>
</code></pre>

      <p>Blocks are expressions. When labeled, <code class="zig"><span class="tok-kw">break</span></code> can be used
      to return a value from the block:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;labeled break from labeled block expression&quot;</span> {
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">123</span>;

    <span class="tok-kw">const</span> x = blk: {
        y += <span class="tok-number">1</span>;
        <span class="tok-kw">break</span> :blk y;
    };
    assert(x == <span class="tok-number">124</span>);
    assert(y == <span class="tok-number">124</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 labeled break from labeled block expression...OK
All tests passed.
</code></pre>

      <p>Here, <code class="zig">blk</code> can be any name.</p>
      <p>See also:</p><ul>
<li><a href="#Labeled-while">Labeled while</a></li>
<li><a href="#Labeled-for">Labeled for</a></li>
</ul>

      
      <h1 id="switch">switch</h1>

      <p class="file">switch.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;switch simple&quot;</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u64</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> zz: <span class="tok-type">u64</span> = <span class="tok-number">103</span>;

    <span class="tok-comment">// All branches of a switch expression must be able to be coerced to a</span>
    <span class="tok-comment">// common type.</span>
    <span class="tok-comment">//</span>
    <span class="tok-comment">// Branches cannot fallthrough. If fallthrough behavior is desired, combine</span>
    <span class="tok-comment">// the cases and use an if.</span>
    <span class="tok-kw">const</span> b = <span class="tok-kw">switch</span> (a) {
        <span class="tok-comment">// Multiple cases can be combined via a ','</span>
        <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span> =&gt; <span class="tok-number">0</span>,

        <span class="tok-comment">// Ranges can be specified using the ... syntax. These are inclusive</span>
        <span class="tok-comment">// both ends.</span>
        <span class="tok-number">5</span> ... <span class="tok-number">100</span> =&gt; <span class="tok-number">1</span>,

        <span class="tok-comment">// Branches can be arbitrarily complex.</span>
        <span class="tok-number">101</span> =&gt; blk: {
            <span class="tok-kw">const</span> c: <span class="tok-type">u64</span> = <span class="tok-number">5</span>;
            <span class="tok-kw">break</span> :blk c * <span class="tok-number">2</span> + <span class="tok-number">1</span>;
        },

        <span class="tok-comment">// Switching on arbitrary expressions is allowed as long as the</span>
        <span class="tok-comment">// expression is known at compile-time.</span>
        zz =&gt; zz,
        <span class="tok-kw">comptime</span> blk: {
            <span class="tok-kw">const</span> d: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
            <span class="tok-kw">const</span> e: <span class="tok-type">u32</span> = <span class="tok-number">100</span>;
            <span class="tok-kw">break</span> :blk d + e;
        } =&gt; <span class="tok-number">107</span>,

        <span class="tok-comment">// The else branch catches everything not already captured.</span>
        <span class="tok-comment">// Else branches are mandatory unless the entire range of values</span>
        <span class="tok-comment">// is handled.</span>
        <span class="tok-kw">else</span> =&gt; <span class="tok-number">9</span>,
    };

    assert(b == <span class="tok-number">1</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;switch enum&quot;</span> {
    <span class="tok-kw">const</span> Item = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
        A: <span class="tok-type">u32</span>,
        C: <span class="tok-kw">struct</span> { x: <span class="tok-type">u8</span>, y: <span class="tok-type">u8</span> },
        D,
    };

    <span class="tok-kw">var</span> a = Item { .A = <span class="tok-number">3</span> };

    <span class="tok-comment">// Switching on more complex enums is allowed.</span>
    <span class="tok-kw">const</span> b = <span class="tok-kw">switch</span> (a) {
        <span class="tok-comment">// A capture group is allowed on a match, and will return the enum</span>
        <span class="tok-comment">// value matched.</span>
        Item.A =&gt; |item| item,

        <span class="tok-comment">// A reference to the matched value can be obtained using `*` syntax.</span>
        Item.C =&gt; |*item| blk: {
            item.*.x += <span class="tok-number">1</span>;
            <span class="tok-kw">break</span> :blk <span class="tok-number">6</span>;
        },

        <span class="tok-comment">// No else is required if the types cases was exhaustively handled</span>
        Item.D =&gt; <span class="tok-number">8</span>,
    };

    assert(b == <span class="tok-number">3</span>);
}

<span class="tok-comment">// Switch expressions can be used outside a function:</span>
<span class="tok-kw">const</span> os_msg = <span class="tok-kw">switch</span> (builtin.os) {
    builtin.Os.linux =&gt; <span class="tok-str">&quot;we found a linux user&quot;</span>,
    <span class="tok-kw">else</span> =&gt; <span class="tok-str">&quot;not a linux user&quot;</span>,
};

<span class="tok-comment">// Inside a function, switch statements implicitly are compile-time</span>
<span class="tok-comment">// evaluated if the target expression is compile-time known.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;switch inside function&quot;</span> {
    <span class="tok-kw">switch</span> (builtin.os) {
        builtin.Os.fuchsia =&gt; {
            <span class="tok-comment">// On an OS other than fuchsia, block is not even analyzed,</span>
            <span class="tok-comment">// so this compile error is not triggered.</span>
            <span class="tok-comment">// On fuchsia this compile error would be triggered.</span>
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;fuchsia not supported&quot;</span>);
        },
        <span class="tok-kw">else</span> =&gt; {},
    }
}</code></pre><pre><code class="shell">$ zig test switch.zig
Test 1/3 switch simple...OK
Test 2/3 switch enum...OK
Test 3/3 switch inside function...OK
All tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#comptime">comptime</a></li>
<li><a href="#enum">enum</a></li>
<li><a href="#compileError">@compileError</a></li>
<li><a href="#Compile-Variables">Compile Variables</a></li>
</ul>

      
      <h1 id="while">while</h1>

      <p>
      A while loop is used to repeatedly execute an expression until
      some condition is no longer true.
      </p>
      <p class="file">while.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while basic&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) {
        i += <span class="tok-number">1</span>;
    }
    assert(i == <span class="tok-number">10</span>);
}</code></pre><pre><code class="shell">$ zig test while.zig
Test 1/1 while basic...OK
All tests passed.
</code></pre>

      <p>
      Use <code class="zig"><span class="tok-kw">break</span></code> to exit a while loop early.
      </p>
      <p class="file">while.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while break&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">if</span> (i == <span class="tok-number">10</span>)
            <span class="tok-kw">break</span>;
        i += <span class="tok-number">1</span>;
    }
    assert(i == <span class="tok-number">10</span>);
}</code></pre><pre><code class="shell">$ zig test while.zig
Test 1/1 while break...OK
All tests passed.
</code></pre>

      <p>
      Use <code class="zig"><span class="tok-kw">continue</span></code> to jump back to the beginning of the loop.
      </p>
      <p class="file">while.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while continue&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        i += <span class="tok-number">1</span>;
        <span class="tok-kw">if</span> (i &lt; <span class="tok-number">10</span>)
            <span class="tok-kw">continue</span>;
        <span class="tok-kw">break</span>;
    }
    assert(i == <span class="tok-number">10</span>);
}</code></pre><pre><code class="shell">$ zig test while.zig
Test 1/1 while continue...OK
All tests passed.
</code></pre>

      <p>
      While loops support a continue expression which is executed when the loop
      is continued. The <code class="zig"><span class="tok-kw">continue</span></code> keyword respects this expression.
      </p>
      <p class="file">while.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while loop continue expression&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {}
    assert(i == <span class="tok-number">10</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;while loop continue expression, more complicated&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> j: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">while</span> (i * j &lt; <span class="tok-number">2000</span>) : ({ i *= <span class="tok-number">2</span>; j *= <span class="tok-number">3</span>; }) {
        <span class="tok-kw">const</span> my_ij = i * j;
        assert(my_ij &lt; <span class="tok-number">2000</span>);
    }
}</code></pre><pre><code class="shell">$ zig test while.zig
Test 1/2 while loop continue expression...OK
Test 2/2 while loop continue expression, more complicated...OK
All tests passed.
</code></pre>

      <p>
      While loops are expressions. The result of the expression is the
      result of the <code class="zig"><span class="tok-kw">else</span></code> clause of a while loop, which is executed when
      the condition of the while loop is tested as false.
      </p>
      <p>
      <code class="zig"><span class="tok-kw">break</span></code>, like <code class="zig"><span class="tok-kw">return</span></code>, accepts a value
              parameter. This is the result of the <code class="zig"><span class="tok-kw">while</span></code> expression.
                  When you <code class="zig"><span class="tok-kw">break</span></code> from a while loop, the <code class="zig"><span class="tok-kw">else</span></code> branch is not
      evaluated.
      </p>
      <p class="file">while.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while else&quot;</span> {
    assert(rangeHasNumber(<span class="tok-number">0</span>, <span class="tok-number">10</span>, <span class="tok-number">5</span>));
    assert(!rangeHasNumber(<span class="tok-number">0</span>, <span class="tok-number">10</span>, <span class="tok-number">15</span>));
}

<span class="tok-kw">fn</span> <span class="tok-fn">rangeHasNumber</span>(begin: <span class="tok-type">usize</span>, end: <span class="tok-type">usize</span>, number: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">var</span> i = begin;
    <span class="tok-kw">return</span> <span class="tok-kw">while</span> (i &lt; end) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (i == number) {
            <span class="tok-kw">break</span> <span class="tok-null">true</span>;
        }
    } <span class="tok-kw">else</span> <span class="tok-null">false</span>;
}</code></pre><pre><code class="shell">$ zig test while.zig
Test 1/1 while else...OK
All tests passed.
</code></pre>

      <h2 id="Labeled-while">Labeled while</h2>

      <p>When a <code class="zig"><span class="tok-kw">while</span></code> loop is labeled, it can be referenced from a <code class="zig"><span class="tok-kw">break</span></code>
              or <code class="zig"><span class="tok-kw">continue</span></code> from within a nested loop:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;nested break&quot;</span> {
    outer: <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">break</span> :outer;
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;nested continue&quot;</span> {
    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    outer: <span class="tok-kw">while</span> (i &lt; <span class="tok-number">10</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {
            <span class="tok-kw">continue</span> :outer;
        }
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/2 nested break...OK
Test 2/2 nested continue...OK
All tests passed.
</code></pre>

      
      <h2 id="while-with-Optionals">while with Optionals</h2>

      <p>
      Just like <a href="#if">if</a> expressions, while loops can take an optional as the
      condition and capture the payload. When <a href="#null">null</a> is encountered the loop
      exits.
      </p>
      <p>
      When the <code class="zig">|x|</code> syntax is present on a <code class="zig"><span class="tok-kw">while</span></code> expression,
      the while condition must have an <a href="#Optional-Type">Optional Type</a>.
      </p>
      <p>
      The <code class="zig"><span class="tok-kw">else</span></code> branch is allowed on optional iteration. In this case, it will
      be executed on the first null value encountered.
      </p>
      <p class="file">while.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while null capture&quot;</span> {
    <span class="tok-kw">var</span> sum1: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    numbers_left = <span class="tok-number">3</span>;
    <span class="tok-kw">while</span> (eventuallyNullSequence()) |value| {
        sum1 += value;
    }
    assert(sum1 == <span class="tok-number">3</span>);

    <span class="tok-kw">var</span> sum2: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    numbers_left = <span class="tok-number">3</span>;
    <span class="tok-kw">while</span> (eventuallyNullSequence()) |value| {
        sum2 += value;
    } <span class="tok-kw">else</span> {
        assert(sum1 == <span class="tok-number">3</span>);
    }
}

<span class="tok-kw">var</span> numbers_left: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">eventuallyNullSequence</span>() ?<span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (numbers_left == <span class="tok-number">0</span>) <span class="tok-null">null</span> <span class="tok-kw">else</span> blk: {
        numbers_left -= <span class="tok-number">1</span>;
        <span class="tok-kw">break</span> :blk numbers_left;
    };
}</code></pre><pre><code class="shell">$ zig test while.zig
Test 1/1 while null capture...OK
All tests passed.
</code></pre>

      

      <h2 id="while-with-Error-Unions">while with Error Unions</h2>

      <p>
      Just like <a href="#if">if</a> expressions, while loops can take an error union as
      the condition and capture the payload or the error code. When the
      condition results in an error code the else branch is evaluated and
      the loop is finished.
      </p>
      <p>
      When the <code class="zig"><span class="tok-kw">else</span> |x|</code> syntax is present on a <code class="zig"><span class="tok-kw">while</span></code> expression,
      the while condition must have an <a href="#Error-Union-Type">Error Union Type</a>.
      </p>
      <p class="file">while.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;while error union capture&quot;</span> {
    <span class="tok-kw">var</span> sum1: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    numbers_left = <span class="tok-number">3</span>;
    <span class="tok-kw">while</span> (eventuallyErrorSequence()) |value| {
        sum1 += value;
    } <span class="tok-kw">else</span> |err| {
        assert(err == <span class="tok-kw">error</span>.ReachedZero);
    }
}

<span class="tok-kw">var</span> numbers_left: <span class="tok-type">u32</span> = <span class="tok-null">undefined</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">eventuallyErrorSequence</span>() <span class="tok-kw">error</span>!<span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (numbers_left == <span class="tok-number">0</span>) <span class="tok-kw">error</span>.ReachedZero <span class="tok-kw">else</span> blk: {
        numbers_left -= <span class="tok-number">1</span>;
        <span class="tok-kw">break</span> :blk numbers_left;
    };
}</code></pre><pre><code class="shell">$ zig test while.zig
Test 1/1 while error union capture...OK
All tests passed.
</code></pre>

      

      <h2 id="inline-while">inline while</h2>

      <p>
      While loops can be inlined. This causes the loop to be unrolled, which
      allows the code to do some things which only work at compile time,
      such as use types as first class values.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;inline while loop&quot;</span> {
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; <span class="tok-number">3</span>) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">const</span> T = <span class="tok-kw">switch</span> (i) {
            <span class="tok-number">0</span> =&gt; <span class="tok-type">f32</span>,
            <span class="tok-number">1</span> =&gt; <span class="tok-type">i8</span>,
            <span class="tok-number">2</span> =&gt; <span class="tok-type">bool</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
        sum += typeNameLength(T);
    }
    assert(sum == <span class="tok-number">9</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">typeNameLength</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@typeName</span>(T).len;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 inline while loop...OK
All tests passed.
</code></pre>

      <p>
      It is recommended to use <code class="zig"><span class="tok-kw">inline</span></code> loops only for one of these reasons:
      </p>
      <ul>
        <li>You need the loop to execute at <a href="#comptime">comptime</a> for the semantics to work.</li>
        <li>
        You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.
        </li>
      </ul>
      
      <p>See also:</p><ul>
<li><a href="#if">if</a></li>
<li><a href="#Optionals">Optionals</a></li>
<li><a href="#Errors">Errors</a></li>
<li><a href="#comptime">comptime</a></li>
<li><a href="#unreachable">unreachable</a></li>
</ul>

      
      <h1 id="for">for</h1>

      <p class="file">for.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;for basics&quot;</span> {
    <span class="tok-kw">const</span> items = []<span class="tok-type">i32</span> { <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">0</span> };
    <span class="tok-kw">var</span> sum: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;

    <span class="tok-comment">// For loops iterate over slices and arrays.</span>
    <span class="tok-kw">for</span> (items) |value| {
        <span class="tok-comment">// Break and continue are supported.</span>
        <span class="tok-kw">if</span> (value == <span class="tok-number">0</span>) {
            <span class="tok-kw">continue</span>;
        }
        sum += value;
    }
    assert(sum == <span class="tok-number">16</span>);

    <span class="tok-comment">// To iterate over a portion of a slice, reslice.</span>
    <span class="tok-kw">for</span> (items[<span class="tok-number">0</span>..<span class="tok-number">1</span>]) |value| {
        sum += value;
    }
    assert(sum == <span class="tok-number">20</span>);

    <span class="tok-comment">// To access the index of iteration, specify a second capture value.</span>
    <span class="tok-comment">// This is zero-indexed.</span>
    <span class="tok-kw">var</span> sum2: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (items) |value, i| {
        assert(<span class="tok-builtin">@typeOf</span>(i) == <span class="tok-type">usize</span>);
        sum2 += <span class="tok-builtin">@intCast</span>(<span class="tok-type">i32</span>, i);
    }
    assert(sum2 == <span class="tok-number">10</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;for reference&quot;</span> {
    <span class="tok-kw">var</span> items = []<span class="tok-type">i32</span> { <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">2</span> };

    <span class="tok-comment">// Iterate over the slice by reference by</span>
    <span class="tok-comment">// specifying that the capture value is a pointer.</span>
    <span class="tok-kw">for</span> (items) |*value| {
        value.* += <span class="tok-number">1</span>;
    }

    assert(items[<span class="tok-number">0</span>] == <span class="tok-number">4</span>);
    assert(items[<span class="tok-number">1</span>] == <span class="tok-number">5</span>);
    assert(items[<span class="tok-number">2</span>] == <span class="tok-number">3</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;for else&quot;</span> {
    <span class="tok-comment">// For allows an else attached to it, the same as a while loop.</span>
    <span class="tok-kw">var</span> items = []?<span class="tok-type">i32</span> { <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-null">null</span>, <span class="tok-number">5</span> };

    <span class="tok-comment">// For loops can also be used as expressions.</span>
    <span class="tok-kw">var</span> sum: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> result = <span class="tok-kw">for</span> (items) |value| {
        <span class="tok-kw">if</span> (value == <span class="tok-null">null</span>) {
            <span class="tok-kw">break</span> <span class="tok-number">9</span>;
        } <span class="tok-kw">else</span> {
            sum += value.?;
        }
    } <span class="tok-kw">else</span> blk: {
        assert(sum == <span class="tok-number">7</span>);
        <span class="tok-kw">break</span> :blk sum;
    };
}</code></pre><pre><code class="shell">$ zig test for.zig
Test 1/3 for basics...OK
Test 2/3 for reference...OK
Test 3/3 for else...OK
All tests passed.
</code></pre>

      <h2 id="Labeled-for">Labeled for</h2>

      <p>When a <code class="zig"><span class="tok-kw">for</span></code> loop is labeled, it can be referenced from a <code class="zig"><span class="tok-kw">break</span></code>
              or <code class="zig"><span class="tok-kw">continue</span></code> from within a nested loop:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;nested break&quot;</span> {
    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    outer: <span class="tok-kw">for</span> ([]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }) |_| {
        <span class="tok-kw">for</span> ([]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }) |_| {
            count += <span class="tok-number">1</span>;
            <span class="tok-kw">break</span> :outer;
        }
    }
    assert(count == <span class="tok-number">1</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;nested continue&quot;</span> {
    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    outer: <span class="tok-kw">for</span> ([]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>, <span class="tok-number">6</span>, <span class="tok-number">7</span>, <span class="tok-number">8</span> }) |_| {
        <span class="tok-kw">for</span> ([]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> }) |_| {
            count += <span class="tok-number">1</span>;
            <span class="tok-kw">continue</span> :outer;
        }
    }

    assert(count == <span class="tok-number">8</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/2 nested break...OK
Test 2/2 nested continue...OK
All tests passed.
</code></pre>

      
      <h2 id="inline-for">inline for</h2>

      <p>
      For loops can be inlined. This causes the loop to be unrolled, which
      allows the code to do some things which only work at compile time,
      such as use types as first class values.
      The capture value and iterator value of inlined for loops are
      compile-time known.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;inline for loop&quot;</span> {
    <span class="tok-kw">const</span> nums = []<span class="tok-type">i32</span>{<span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">6</span>};
    <span class="tok-kw">var</span> sum: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (nums) |i| {
        <span class="tok-kw">const</span> T = <span class="tok-kw">switch</span> (i) {
            <span class="tok-number">2</span> =&gt; <span class="tok-type">f32</span>,
            <span class="tok-number">4</span> =&gt; <span class="tok-type">i8</span>,
            <span class="tok-number">6</span> =&gt; <span class="tok-type">bool</span>,
            <span class="tok-kw">else</span> =&gt; <span class="tok-kw">unreachable</span>,
        };
        sum += typeNameLength(T);
    }
    assert(sum == <span class="tok-number">9</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">typeNameLength</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">usize</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@typeName</span>(T).len;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 inline for loop...OK
All tests passed.
</code></pre>

      <p>
      It is recommended to use <code class="zig"><span class="tok-kw">inline</span></code> loops only for one of these reasons:
      </p>
      <ul>
        <li>You need the loop to execute at <a href="#comptime">comptime</a> for the semantics to work.</li>
        <li>
        You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.
        </li>
      </ul>
      
      <p>See also:</p><ul>
<li><a href="#while">while</a></li>
<li><a href="#comptime">comptime</a></li>
<li><a href="#Arrays">Arrays</a></li>
<li><a href="#Slices">Slices</a></li>
</ul>

      
      <h1 id="if">if</h1>

      <p class="file">if.zig</p><pre><code class="zig"><span class="tok-comment">// If expressions have three uses, corresponding to the three types:</span>
<span class="tok-comment">// * bool</span>
<span class="tok-comment">// * ?T</span>
<span class="tok-comment">// * error!T</span>

<span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;if boolean&quot;</span> {
    <span class="tok-comment">// If expressions test boolean conditions.</span>
    <span class="tok-kw">const</span> a: <span class="tok-type">u32</span> = <span class="tok-number">5</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u32</span> = <span class="tok-number">4</span>;
    <span class="tok-kw">if</span> (a != b) {
        assert(<span class="tok-null">true</span>);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a == <span class="tok-number">9</span>) {
        <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-comment">// If expressions are used instead of a ternary expression.</span>
    <span class="tok-kw">const</span> result = <span class="tok-kw">if</span> (a != b) <span class="tok-number">47</span> <span class="tok-kw">else</span> <span class="tok-number">3089</span>;
    assert(result == <span class="tok-number">47</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;if optional&quot;</span> {
    <span class="tok-comment">// If expressions test for null.</span>

    <span class="tok-kw">const</span> a: ?<span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (a) |value| {
        assert(value == <span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">const</span> b: ?<span class="tok-type">u32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">if</span> (b) |value| {
        <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> {
        assert(<span class="tok-null">true</span>);
    }

    <span class="tok-comment">// The else is not required.</span>
    <span class="tok-kw">if</span> (a) |value| {
        assert(value == <span class="tok-number">0</span>);
    }

    <span class="tok-comment">// To test against null only, use the binary equality operator.</span>
    <span class="tok-kw">if</span> (b == <span class="tok-null">null</span>) {
        assert(<span class="tok-null">true</span>);
    }

    <span class="tok-comment">// Access the value by reference using a pointer capture.</span>
    <span class="tok-kw">var</span> c: ?<span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">if</span> (c) |*value| {
        value.* = <span class="tok-number">2</span>;
    }

    <span class="tok-kw">if</span> (c) |value| {
        assert(value == <span class="tok-number">2</span>);
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">unreachable</span>;
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;if error union&quot;</span> {
    <span class="tok-comment">// If expressions test for errors.</span>
    <span class="tok-comment">// Note the |err| capture on the else.</span>

    <span class="tok-kw">const</span> a: <span class="tok-kw">error</span>!<span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">if</span> (a) |value| {
        assert(value == <span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">const</span> b: <span class="tok-kw">error</span>!<span class="tok-type">u32</span> = <span class="tok-kw">error</span>.BadValue;
    <span class="tok-kw">if</span> (b) |value| {
        <span class="tok-kw">unreachable</span>;
    } <span class="tok-kw">else</span> |err| {
        assert(err == <span class="tok-kw">error</span>.BadValue);
    }

    <span class="tok-comment">// The else and |err| capture is strictly required.</span>
    <span class="tok-kw">if</span> (a) |value| {
        assert(value == <span class="tok-number">0</span>);
    } <span class="tok-kw">else</span> |_| {}

    <span class="tok-comment">// To check only the error value, use an empty block expression.</span>
    <span class="tok-kw">if</span> (b) |_| {} <span class="tok-kw">else</span> |err| {
        assert(err == <span class="tok-kw">error</span>.BadValue);
    }

    <span class="tok-comment">// Access the value by reference using a pointer capture.</span>
    <span class="tok-kw">var</span> c: <span class="tok-kw">error</span>!<span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">if</span> (c) |*value| {
        value.* = <span class="tok-number">9</span>;
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">unreachable</span>;
    }

    <span class="tok-kw">if</span> (c) |value| {
        assert(value == <span class="tok-number">9</span>);
    } <span class="tok-kw">else</span> |err| {
        <span class="tok-kw">unreachable</span>;
    }
}</code></pre><pre><code class="shell">$ zig test if.zig
Test 1/3 if boolean...OK
Test 2/3 if optional...OK
Test 3/3 if error union...OK
All tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Optionals">Optionals</a></li>
<li><a href="#Errors">Errors</a></li>
</ul>

      
      <h1 id="defer">defer</h1>

      <p class="file">defer.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;
<span class="tok-kw">const</span> warn = std.debug.warn;

<span class="tok-comment">// defer will execute an expression at the end of the current scope.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">deferExample</span>() <span class="tok-type">usize</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;

    {
        <span class="tok-kw">defer</span> a = <span class="tok-number">2</span>;
        a = <span class="tok-number">1</span>;
    }
    assert(a == <span class="tok-number">2</span>);

    a = <span class="tok-number">5</span>;
    <span class="tok-kw">return</span> a;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;defer basics&quot;</span> {
    assert(deferExample() == <span class="tok-number">5</span>);
}

<span class="tok-comment">// If multiple defer statements are specified, they will be executed in</span>
<span class="tok-comment">// the reverse order they were run.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">deferUnwindExample</span>() <span class="tok-type">void</span> {
    warn(<span class="tok-str">&quot;\n&quot;</span>);

    <span class="tok-kw">defer</span> {
        warn(<span class="tok-str">&quot;1 &quot;</span>);
    }
    <span class="tok-kw">defer</span> {
        warn(<span class="tok-str">&quot;2 &quot;</span>);
    }
    <span class="tok-kw">if</span> (<span class="tok-null">false</span>) {
        <span class="tok-comment">// defers are not run if they are never executed.</span>
        <span class="tok-kw">defer</span> {
            warn(<span class="tok-str">&quot;3 &quot;</span>);
        }
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;defer unwinding&quot;</span> {
    deferUnwindExample();
}

<span class="tok-comment">// The errdefer keyword is similar to defer, but will only execute if the</span>
<span class="tok-comment">// scope returns with an error.</span>
<span class="tok-comment">//</span>
<span class="tok-comment">// This is especially useful in allowing a function to clean up properly</span>
<span class="tok-comment">// on error, and replaces goto error handling tactics as seen in c.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">deferErrorExample</span>(is_error: <span class="tok-type">bool</span>) !<span class="tok-type">void</span> {
    warn(<span class="tok-str">&quot;\nstart of function\n&quot;</span>);

    <span class="tok-comment">// This will always be executed on exit</span>
    <span class="tok-kw">defer</span> {
        warn(<span class="tok-str">&quot;end of function\n&quot;</span>);
    }

    <span class="tok-kw">errdefer</span> {
        warn(<span class="tok-str">&quot;encountered an error!\n&quot;</span>);
    }

    <span class="tok-kw">if</span> (is_error) {
        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.DeferError;
    }
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;errdefer unwinding&quot;</span> {
    _ = deferErrorExample(<span class="tok-null">false</span>);
    _ = deferErrorExample(<span class="tok-null">true</span>);
}</code></pre><pre><code class="shell">$ zig test defer.zig
Test 1/3 defer basics...OK
Test 2/3 defer unwinding...
2 1 OK
Test 3/3 errdefer unwinding...
start of function
end of function

start of function
encountered an error!
end of function
OK
All tests passed.
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Errors">Errors</a></li>
</ul>

      
      <h1 id="unreachable">unreachable</h1>

      <p>
      In <code class="zig">Debug</code> and <code class="zig">ReleaseSafe</code> mode, and when using <code>zig test</code>,
      <code class="zig"><span class="tok-kw">unreachable</span></code> emits a call to <code class="zig">panic</code> with the message <code>reached unreachable code</code>.
      </p>
      <p>
      In <code class="zig">ReleaseFast</code> mode, the optimizer uses the assumption that <code class="zig"><span class="tok-kw">unreachable</span></code> code
      will never be hit to perform optimizations. However, <code>zig test</code> even in <code class="zig">ReleaseFast</code> mode
                  still emits <code class="zig"><span class="tok-kw">unreachable</span></code> as calls to <code class="zig">panic</code>.
      </p>
      <h2 id="Basics">Basics</h2>

      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-comment">// unreachable is used to assert that control flow will never happen upon a</span>
<span class="tok-comment">// particular location:</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;basic math&quot;</span> {
    <span class="tok-kw">const</span> x = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> y = <span class="tok-number">2</span>;
    <span class="tok-kw">if</span> (x + y != <span class="tok-number">3</span>) {
        <span class="tok-kw">unreachable</span>;
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 basic math...OK
All tests passed.
</code></pre>

      <p>In fact, this is how assert is implemented:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>; <span class="tok-comment">// assertion failure</span>
}

<span class="tok-comment">// This test will fail because we hit unreachable.</span>
<span class="tok-kw">test</span> <span class="tok-str">&quot;this will fail&quot;</span> {
    assert(<span class="tok-null">false</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 this will fail...reached unreachable code
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:14</span>: <span class="t2_0">0x2051c9 in ??? (test)</span>
    if (!ok) unreachable; // assertion failure
             <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:7:11</span>: <span class="t2_0">0x20504b in ??? (test)</span>
    assert(false);
          <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/test_runner.zig:13:25</span>: <span class="t2_0">0x22297a in ??? (test)</span>
        if (test_fn.func()) |_| {
                        <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:96:22</span>: <span class="t2_0">0x22272b in ??? (test)</span>
            root.main() catch |err| {
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x2226a5 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x222508 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x2223c0 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>

Tests failed. Use the following command to reproduce the failure:
/home/andy/dev/zig/docgen_tmp/test
</code></pre>

      
      <h2 id="At-Compile-Time">At Compile-Time</h2>

      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;type of unreachable&quot;</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-comment">// The type of unreachable is noreturn.</span>

        <span class="tok-comment">// However this assertion will still fail because</span>
        <span class="tok-comment">// evaluating unreachable at compile-time is a compile error.</span>

        assert(<span class="tok-builtin">@typeOf</span>(<span class="tok-kw">unreachable</span>) == <span class="tok-type">noreturn</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:10:16: </span><span class="t31_1">error:</span><span class="t0_1"> unreachable code</span>
        assert(@typeOf(unreachable) == noreturn);
               <span class="t32_1">^</span>
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Zig-Test">Zig Test</a></li>
<li><a href="#Build-Mode">Build Mode</a></li>
<li><a href="#comptime">comptime</a></li>
</ul>

      
      
      <h1 id="noreturn">noreturn</h1>

      <p>
      <code class="zig"><span class="tok-type">noreturn</span></code> is the type of:
      </p>
      <ul>
          <li><code class="zig"><span class="tok-kw">break</span></code></li>
          <li><code class="zig"><span class="tok-kw">continue</span></code></li>
          <li><code class="zig"><span class="tok-kw">return</span></code></li>
          <li><code class="zig"><span class="tok-kw">unreachable</span></code></li>
          <li><code class="zig"><span class="tok-kw">while</span> (<span class="tok-null">true</span>) {}</code></li>
      </ul>
      <p>When resolving types together, such as <code class="zig"><span class="tok-kw">if</span></code> clauses or <code class="zig"><span class="tok-kw">switch</span></code> prongs,
              the <code class="zig"><span class="tok-type">noreturn</span></code> type is compatible with every other type. Consider:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(condition: <span class="tok-type">bool</span>, b: <span class="tok-type">u32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> a = <span class="tok-kw">if</span> (condition) b <span class="tok-kw">else</span> <span class="tok-kw">return</span>;
    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;do something with a&quot;</span>);
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;noreturn&quot;</span> {
    foo(<span class="tok-null">false</span>, <span class="tok-number">1</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 noreturn...OK
All tests passed.
</code></pre>

      <p>Another use case for <code class="zig"><span class="tok-type">noreturn</span></code> is the <code class="zig">exit</code> function:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">extern</span> <span class="tok-str">&quot;kernel32&quot;</span> <span class="tok-kw">stdcallcc</span> <span class="tok-kw">fn</span> <span class="tok-fn">ExitProcess</span>(exit_code: <span class="tok-type">c_uint</span>) <span class="tok-type">noreturn</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;foo&quot;</span> {
    <span class="tok-kw">const</span> value = bar() <span class="tok-kw">catch</span> ExitProcess(<span class="tok-number">1</span>);
    assert(value == <span class="tok-number">1234</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>() <span class="tok-kw">error</span>!<span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}

<span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;</code></pre><pre><code class="shell">$ zig test test.zig
Created /home/andy/dev/zig/docgen_tmp/test but skipping execution because it is non-native.
</code></pre>

      
      <h1 id="Functions">Functions</h1>

      <p class="file">functions.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-comment">// Functions are declared like this</span>
<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> {
    <span class="tok-kw">if</span> (a == <span class="tok-number">0</span>) {
        <span class="tok-comment">// You can still return manually if needed.</span>
        <span class="tok-kw">return</span> b;
    }

    <span class="tok-kw">return</span> a + b;
}

<span class="tok-comment">// The export specifier makes a function externally visible in the generated</span>
<span class="tok-comment">// object file, and makes it use the C ABI.</span>
<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub</span>(a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> { <span class="tok-kw">return</span> a - b; }

<span class="tok-comment">// The extern specifier is used to declare a function that will be resolved</span>
<span class="tok-comment">// at link time, when linking statically, or at runtime, when linking</span>
<span class="tok-comment">// dynamically.</span>
<span class="tok-comment">// The stdcallcc specifier changes the calling convention of the function.</span>
<span class="tok-kw">extern</span> <span class="tok-str">&quot;kernel32&quot;</span> <span class="tok-kw">stdcallcc</span> <span class="tok-kw">fn</span> <span class="tok-fn">ExitProcess</span>(exit_code: <span class="tok-type">u32</span>) <span class="tok-type">noreturn</span>;
<span class="tok-kw">extern</span> <span class="tok-str">&quot;c&quot;</span> <span class="tok-kw">fn</span> <span class="tok-fn">atan2</span>(a: <span class="tok-type">f64</span>, b: <span class="tok-type">f64</span>) <span class="tok-type">f64</span>;

<span class="tok-comment">// The @setCold builtin tells the optimizer that a function is rarely called.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">abort</span>() <span class="tok-type">noreturn</span> {
    <span class="tok-builtin">@setCold</span>(<span class="tok-null">true</span>);
    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {}
}

<span class="tok-comment">// nakedcc makes a function not have any function prologue or epilogue.</span>
<span class="tok-comment">// This can be useful when integrating with assembly.</span>
<span class="tok-kw">nakedcc</span> <span class="tok-kw">fn</span> <span class="tok-fn">_start</span>() <span class="tok-type">noreturn</span> {
    abort();
}

<span class="tok-comment">// The pub specifier allows the function to be visible when importing.</span>
<span class="tok-comment">// Another file can use @import and call sub2</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">sub2</span>(a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> { <span class="tok-kw">return</span> a - b; }

<span class="tok-comment">// Functions can be used as values and are equivalent to pointers.</span>
<span class="tok-kw">const</span> call2_op = <span class="tok-kw">fn</span> (a: <span class="tok-type">i8</span>, b: <span class="tok-type">i8</span>) <span class="tok-type">i8</span>;
<span class="tok-kw">fn</span> <span class="tok-fn">do_op</span>(fn_call: call2_op, op1: <span class="tok-type">i8</span>, op2: <span class="tok-type">i8</span>) <span class="tok-type">i8</span> {
    <span class="tok-kw">return</span> fn_call(op1, op2);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;function&quot;</span> {
    assert(do_op(add, <span class="tok-number">5</span>, <span class="tok-number">6</span>) == <span class="tok-number">11</span>);
    assert(do_op(sub2, <span class="tok-number">5</span>, <span class="tok-number">6</span>) == -<span class="tok-number">1</span>);
}</code></pre><pre><code class="shell">$ zig test functions.zig
Test 1/1 function...OK
All tests passed.
</code></pre>

      <p>Function values are like pointers:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">comptime</span> {
    assert(<span class="tok-builtin">@typeOf</span>(foo) == <span class="tok-kw">fn</span>()<span class="tok-type">void</span>);
    assert(<span class="tok-builtin">@sizeOf</span>(<span class="tok-kw">fn</span>()<span class="tok-type">void</span>) == <span class="tok-builtin">@sizeOf</span>(?<span class="tok-kw">fn</span>()<span class="tok-type">void</span>));
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> { }</code></pre><pre><code class="shell">$ zig build-obj test.zig</code></pre>

      <h2 id="Pass-by-value-Parameters">Pass-by-value Parameters</h2>

      <p>
      In Zig, structs, unions, and enums with payloads can be passed directly to a function:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">i32</span>,
    y: <span class="tok-type">i32</span>,
};

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(point: Point) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> point.x + point.y;
}

<span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;pass aggregate type by non-copy value to function&quot;</span> {
    assert(foo(Point{ .x = <span class="tok-number">1</span>, .y = <span class="tok-number">2</span> }) == <span class="tok-number">3</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 pass aggregate type by non-copy value to function...OK
All tests passed.
</code></pre>

      <p>
      In this case, the value may be passed by reference, or by value, whichever way
      Zig decides will be faster.
      </p>
      <p>
      For extern functions, Zig follows the C ABI for passing structs and unions by value.
      </p>
      
      <h2 id="Function-Reflection">Function Reflection</h2>

      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;fn reflection&quot;</span> {
    assert(<span class="tok-builtin">@typeOf</span>(assert).ReturnType == <span class="tok-type">void</span>);
    assert(<span class="tok-builtin">@typeOf</span>(assert).is_var_args == <span class="tok-null">false</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 fn reflection...OK
All tests passed.
</code></pre>

      
      
      <h1 id="Errors">Errors</h1>

      <h2 id="Error-Set-Type">Error Set Type</h2>

      <p>
      An error set is like an <a href="#enum">enum</a>.
      However, each error name across the entire compilation gets assigned an unsigned integer
      greater than 0. You are allowed to declare the same error name more than once, and if you do, it
      gets assigned the same integer value.
      </p>
      <p>
      The number of unique error values across the entire compilation should determine the size of the error set type.
      However right now it is hard coded to be a <code class="zig"><span class="tok-type">u16</span></code>. See <a href="https://github.com/ziglang/zig/issues/786">#768</a>.
      </p>
      <p>
      You can <a href="#Implicit-Casts">implicitly cast</a> an error from a subset to its superset:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> FileOpenError = <span class="tok-kw">error</span> {
    AccessDenied,
    OutOfMemory,
    FileNotFound,
};

<span class="tok-kw">const</span> AllocationError = <span class="tok-kw">error</span> {
    OutOfMemory,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;implicit cast subset to superset&quot;</span> {
    <span class="tok-kw">const</span> err = foo(AllocationError.OutOfMemory);
    std.debug.assert(err == FileOpenError.OutOfMemory);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(err: AllocationError) FileOpenError {
    <span class="tok-kw">return</span> err;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 implicit cast subset to superset...OK
All tests passed.
</code></pre>

      <p>
      But you cannot implicitly cast an error from a superset to a subset:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> FileOpenError = <span class="tok-kw">error</span> {
    AccessDenied,
    OutOfMemory,
    FileNotFound,
};

<span class="tok-kw">const</span> AllocationError = <span class="tok-kw">error</span> {
    OutOfMemory,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;implicit cast superset to subset&quot;</span> {
    foo(FileOpenError.OutOfMemory) <span class="tok-kw">catch</span> {};
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(err: FileOpenError) AllocationError {
    <span class="tok-kw">return</span> err;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:16:12: </span><span class="t31_1">error:</span><span class="t0_1"> expected type 'AllocationError', found 'FileOpenError'</span>
    return err;
           <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:5: </span><span class="t36_1">note:</span><span class="t0_1"> 'error.AccessDenied' not a member of destination error set</span>
    AccessDenied,
    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:5: </span><span class="t36_1">note:</span><span class="t0_1"> 'error.FileNotFound' not a member of destination error set</span>
    FileNotFound,
    <span class="t32_1">^</span>
</code></pre>

      <p>
      There is a shortcut for declaring an error set with only 1 value, and then getting that value:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> err = <span class="tok-kw">error</span>.FileNotFound;</code></pre>
      <p>This is equivalent to:</p>
      <pre><code class="zig"><span class="tok-kw">const</span> err = (<span class="tok-kw">error</span> {FileNotFound}).FileNotFound;</code></pre>
      <p>
      This becomes useful when using <a href="#Inferred-Error-Sets">Inferred Error Sets</a>.
      </p>
      <h3 id="The-Global-Error-Set">The Global Error Set</h3>

      <p><code class="zig"><span class="tok-kw">error</span></code> refers to the global error set.
      This is the error set that contains all errors in the entire compilation unit.
      It is a superset of all other error sets and a subset of none of them.
      </p>
      <p>
      You can implicitly cast any error set to the global one, and you can explicitly
      cast an error of global error set to a non-global one. This inserts a language-level
      assert to make sure the error value is in fact in the destination error set.
      </p>
      <p>
      The global error set should generally be avoided because it prevents the
      compiler from knowing what errors are possible at compile-time. Knowing
      the error set at compile-time is better for generated documentation and
      helpful error messages, such as forgetting a possible error value in a <a href="#switch">switch</a>.
      </p>
      
      
      <h2 id="Error-Union-Type">Error Union Type</h2>

      <p>
      An error set type and normal type can be combined with the <code class="zig">!</code>
      binary operator to form an error union type. You are likely to use an
      error union type more often than an error set type by itself.
      </p>
      <p>
      Here is a function to parse a string into a 64-bit integer:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">parseU64</span>(buf: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, radix: <span class="tok-type">u8</span>) !<span class="tok-type">u64</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u64</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">for</span> (buf) |c| {
        <span class="tok-kw">const</span> digit = charToDigit(c);

        <span class="tok-kw">if</span> (digit &gt;= radix) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidChar;
        }

        <span class="tok-comment">// x *= radix</span>
        <span class="tok-kw">if</span> (<span class="tok-builtin">@mulWithOverflow</span>(<span class="tok-type">u64</span>, x, radix, &amp;x)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
        }

        <span class="tok-comment">// x += digit</span>
        <span class="tok-kw">if</span> (<span class="tok-builtin">@addWithOverflow</span>(<span class="tok-type">u64</span>, x, digit, &amp;x)) {
            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Overflow;
        }
    }

    <span class="tok-kw">return</span> x;
}

<span class="tok-kw">fn</span> <span class="tok-fn">charToDigit</span>(c: <span class="tok-type">u8</span>) <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (c) {
        <span class="tok-str">'0'</span> ... <span class="tok-str">'9'</span> =&gt; c - <span class="tok-str">'0'</span>,
        <span class="tok-str">'A'</span> ... <span class="tok-str">'Z'</span> =&gt; c - <span class="tok-str">'A'</span> + <span class="tok-number">10</span>,
        <span class="tok-str">'a'</span> ... <span class="tok-str">'z'</span> =&gt; c - <span class="tok-str">'a'</span> + <span class="tok-number">10</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@maxValue</span>(<span class="tok-type">u8</span>),
    };
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;parse u64&quot;</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> parseU64(<span class="tok-str">&quot;1234&quot;</span>, <span class="tok-number">10</span>);
    <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert(result == <span class="tok-number">1234</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 parse u64...OK
All tests passed.
</code></pre>

      <p>
      Notice the return type is <code class="zig">!<span class="tok-type">u64</span></code>. This means that the function
      either returns an unsigned 64 bit integer, or an error. We left off the error set
      to the left of the <code class="zig">!</code>, so the error set is inferred.
      </p>
      <p>
      Within the function definition, you can see some return statements that return
      an error, and at the bottom a return statement that returns a <code class="zig"><span class="tok-type">u64</span></code>.
          Both types <a href="#Implicit-Casts">implicitly cast</a> to <code class="zig"><span class="tok-kw">error</span>!<span class="tok-type">u64</span></code>.
      </p>
      <p>
      What it looks like to use this function varies depending on what you're
      trying to do. One of the following:
      </p>
      <ul>
        <li>You want to provide a default value if it returned an error.</li>
        <li>If it returned an error then you want to return the same error.</li>
        <li>You know with complete certainty it will not return an error, so want to unconditionally unwrap it.</li>
        <li>You want to take a different action for each possible error.</li>
      </ul>
      <h3 id="catch">catch</h3>

      <p>If you want to provide a default value, you can use the <code class="zig"><span class="tok-kw">catch</span></code> binary operator:</p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = parseU64(str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-number">13</span>;
    <span class="tok-comment">// ...</span>
}</code></pre>
      <p>
      In this code, <code class="zig">number</code> will be equal to the successfully parsed string, or
          a default value of 13. The type of the right hand side of the binary <code class="zig"><span class="tok-kw">catch</span></code> operator must
              match the unwrapped error union type, or be of type <code class="zig"><span class="tok-type">noreturn</span></code>.
      </p>
      
      <h3 id="try">try</h3>

      <p>Let's say you wanted to return the error if you got one, otherwise continue with the
      function logic:</p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = parseU64(str, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> |err| <span class="tok-kw">return</span> err;
    <span class="tok-comment">// ...</span>
}</code></pre>
      <p>
      There is a shortcut for this. The <code class="zig"><span class="tok-kw">try</span></code> expression:
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = <span class="tok-kw">try</span> parseU64(str, <span class="tok-number">10</span>);
    <span class="tok-comment">// ...</span>
}</code></pre>
      <p>
      <code class="zig"><span class="tok-kw">try</span></code> evaluates an error union expression. If it is an error, it returns
      from the current function with the same error. Otherwise, the expression results in
      the unwrapped value.
      </p>
      
      <p>
        Maybe you know with complete certainty that an expression will never be an error.
        In this case you can do this:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> number = parseU64(<span class="tok-str">&quot;1234&quot;</span>, <span class="tok-number">10</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</code></pre>
      <p>
      Here we know for sure that "1234" will parse successfully. So we put the
      <code class="zig"><span class="tok-kw">unreachable</span></code> value on the right hand side. <code class="zig"><span class="tok-kw">unreachable</span></code> generates
      a panic in Debug and ReleaseSafe modes and undefined behavior in ReleaseFast mode. So, while we're debugging the
      application, if there <em>was</em> a surprise error here, the application would crash
      appropriately.
      </p>
      <p>
      Finally, you may want to take a different action for every situation. For that, we combine
      the <a href="#if">if</a> and <a href="#switch">switch</a> expression:
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(str: []<span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (parseU64(str, <span class="tok-number">10</span>)) |number| {
        doSomethingWithNumber(number);
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Overflow =&gt; {
            <span class="tok-comment">// handle overflow...</span>
        },
        <span class="tok-comment">// we promise that InvalidChar won't happen (or crash in debug mode if it does)</span>
        <span class="tok-kw">error</span>.InvalidChar =&gt; <span class="tok-kw">unreachable</span>,
    }
}</code></pre>
      <h3 id="errdefer">errdefer</h3>

      <p>
      The other component to error handling is defer statements.
      In addition to an unconditional <a href="#defer">defer</a>, Zig has <code class="zig"><span class="tok-kw">errdefer</span></code>,
      which evaluates the deferred expression on block exit path if and only if
      the function returned with an error from the block.
      </p>
      <p>
      Example:
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">createFoo</span>(param: <span class="tok-type">i32</span>) !Foo {
    <span class="tok-kw">const</span> foo = <span class="tok-kw">try</span> tryToAllocateFoo();
    <span class="tok-comment">// now we have allocated foo. we need to free it if the function fails.</span>
    <span class="tok-comment">// but we want to return it if the function succeeds.</span>
    <span class="tok-kw">errdefer</span> deallocateFoo(foo);

    <span class="tok-kw">const</span> tmp_buf = allocateTmpBuffer() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OutOfMemory;
    <span class="tok-comment">// tmp_buf is truly a temporary resource, and we for sure want to clean it up</span>
    <span class="tok-comment">// before this block leaves scope</span>
    <span class="tok-kw">defer</span> deallocateTmpBuffer(tmp_buf);

    <span class="tok-kw">if</span> (param &gt; <span class="tok-number">1337</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidParam;

    <span class="tok-comment">// here the errdefer will not run since we're returning success from the function.</span>
    <span class="tok-comment">// but the defer will run!</span>
    <span class="tok-kw">return</span> foo;
}</code></pre>
      <p>
      The neat thing about this is that you get robust error handling without
      the verbosity and cognitive overhead of trying to make sure every exit path
      is covered. The deallocation code is always directly following the allocation code.
      </p>
      
      <p>
      A couple of other tidbits about error handling:
      </p>
      <ul>
        <li>These primitives give enough expressiveness that it's completely practical
            to have failing to check for an error be a compile error. If you really want
            to ignore the error, you can add <code class="zig"><span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span></code> and
            get the added benefit of crashing in Debug and ReleaseSafe modes if your assumption was wrong.
        </li>
        <li>
          Since Zig understands error types, it can pre-weight branches in favor of
          errors not occuring. Just a small optimization benefit that is not available
          in other languages.
        </li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#defer">defer</a></li>
<li><a href="#if">if</a></li>
<li><a href="#switch">switch</a></li>
</ul>


      <p>An error union is created with the <code class="zig">!</code> binary operator.
      You can use compile-time reflection to access the child type of an error union:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;error union&quot;</span> {
    <span class="tok-kw">var</span> foo: <span class="tok-kw">error</span>!<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;

    <span class="tok-comment">// Implicitly cast from child type of an error union:</span>
    foo = <span class="tok-number">1234</span>;

    <span class="tok-comment">// Implicitly cast from an error set:</span>
    foo = <span class="tok-kw">error</span>.SomeError;

    <span class="tok-comment">// Use compile-time reflection to access the payload type of an error union:</span>
    <span class="tok-kw">comptime</span> assert(<span class="tok-builtin">@typeOf</span>(foo).Payload == <span class="tok-type">i32</span>);

    <span class="tok-comment">// Use compile-time reflection to access the error set type of an error union:</span>
    <span class="tok-kw">comptime</span> assert(<span class="tok-builtin">@typeOf</span>(foo).ErrorSet == <span class="tok-kw">error</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 error union...OK
All tests passed.
</code></pre>

      <h3 id="Merging-Error-Sets">Merging Error Sets</h3>

      <p>
      Use the <code class="zig">||</code> operator to merge two error sets together. The resulting
      error set contains the errors of both error sets. Doc comments from the left-hand
      side override doc comments from the right-hand side. In this example, the doc
      comments for <code class="zig">C.PathNotFound</code> is <code>A doc comment</code>.
      </p>
      <p>
      This is especially useful for functions which return different error sets depending
      on <a href="#comptime">comptime</a> branches. For example, the Zig standard library uses
      <code class="zig">LinuxFileOpenError || WindowsFileOpenError</code> for the error set of opening
      files.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> A = <span class="tok-kw">error</span>{
    NotDir,

    <span class="tok-comment">/// A doc comment</span>
    PathNotFound,
};
<span class="tok-kw">const</span> B = <span class="tok-kw">error</span>{
    OutOfMemory,

    <span class="tok-comment">/// B doc comment</span>
    PathNotFound,
};

<span class="tok-kw">const</span> C = A || B;

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() C!<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.NotDir;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;merge error sets&quot;</span> {
    <span class="tok-kw">if</span> (foo()) {
        <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unexpected&quot;</span>);
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.OutOfMemory =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unexpected&quot;</span>),
        <span class="tok-kw">error</span>.PathNotFound =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;unexpected&quot;</span>),
        <span class="tok-kw">error</span>.NotDir =&gt; {},
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 merge error sets...OK
All tests passed.
</code></pre>

      
      <h3 id="Inferred-Error-Sets">Inferred Error Sets</h3>

      <p>
      Because many functions in Zig return a possible error, Zig supports inferring the error set.
      To infer the error set for a function, use this syntax:
      </p>
<p class="file">test.zig</p><pre><code class="zig"><span class="tok-comment">// With an inferred error set</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add_inferred</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) !T {
    <span class="tok-kw">var</span> answer: T = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@addWithOverflow</span>(T, a, b, &amp;answer)) <span class="tok-kw">error</span>.Overflow <span class="tok-kw">else</span> answer;
}

<span class="tok-comment">// With an explicit error set</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">add_explicit</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) Error!T {
    <span class="tok-kw">var</span> answer: T = <span class="tok-null">undefined</span>;
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@addWithOverflow</span>(T, a, b, &amp;answer)) <span class="tok-kw">error</span>.Overflow <span class="tok-kw">else</span> answer;
}

<span class="tok-kw">const</span> Error = <span class="tok-kw">error</span> {
    Overflow,
};

<span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;inferred error set&quot;</span> {
    <span class="tok-kw">if</span> (add_inferred(<span class="tok-type">u8</span>, <span class="tok-number">255</span>, <span class="tok-number">1</span>)) |_| <span class="tok-kw">unreachable</span> <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.Overflow =&gt; {}, <span class="tok-comment">// ok</span>
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 inferred error set...OK
All tests passed.
</code></pre>

      <p>
      When a function has an inferred error set, that function becomes generic and thus it becomes
      trickier to do certain things with it, such as obtain a function pointer, or have an error
      set that is consistent across different build targets. Additionally, inferred error sets
      are incompatible with recursion.
      </p>
      <p>
      In these situations, it is recommended to use an explicit error set. You can generally start
      with an empty error set and let compile errors guide you toward completing the set.
      </p>
      <p>
      These limitations may be overcome in a future version of Zig.
      </p>
      
      
      <h2 id="Error-Return-Traces">Error Return Traces</h2>

      <p>
      Error Return Traces show all the points in the code that an error was returned to the calling function. This makes it practical to use <a href="#try">try</a> everywhere and then still be able to know what happened if an error ends up bubbling all the way out of your application.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> foo(<span class="tok-number">12</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: <span class="tok-type">i32</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (x &gt;= <span class="tok-number">5</span>) {
        <span class="tok-kw">try</span> bar();
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">try</span> bang2();
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (baz()) {
        <span class="tok-kw">try</span> quux();
    } <span class="tok-kw">else</span> |err| <span class="tok-kw">switch</span> (err) {
        <span class="tok-kw">error</span>.FileNotFound =&gt; <span class="tok-kw">try</span> hello(),
        <span class="tok-kw">else</span> =&gt; <span class="tok-kw">try</span> another(),
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">baz</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> bang1();
}

<span class="tok-kw">fn</span> <span class="tok-fn">quux</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">hello</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">another</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> bang1();
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang1</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.FileNotFound;
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang2</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.PermissionDenied;
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
error: PermissionDenied
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:39:5</span>: <span class="t2_0">0x222bc9 in ??? (test)</span>
    return error.FileNotFound;
    <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:23:5</span>: <span class="t2_0">0x222aad in ??? (test)</span>
    try bang1();
    <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:43:5</span>: <span class="t2_0">0x222a79 in ??? (test)</span>
    return error.PermissionDenied;
    <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:31:5</span>: <span class="t2_0">0x222b9d in ??? (test)</span>
    try bang2();
    <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:17:31</span>: <span class="t2_0">0x222a49 in ??? (test)</span>
        error.FileNotFound =&gt; try hello(),
                              <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:7:9</span>: <span class="t2_0">0x22293a in ??? (test)</span>
        try bar();
        <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:5</span>: <span class="t2_0">0x2227e2 in ??? (test)</span>
    try foo(12);
    <span class="t32_1">^</span>
</code></pre>

      <p>
      Look closely at this example. This is no stack trace.
      </p>
      <p>
      You can see that the final error bubbled up was <code class="zig">PermissionDenied</code>,
          but the original error that started this whole thing was <code class="zig">FileNotFound</code>. In the <code class="zig">bar</code> function, the code handles the original error code,
      and then returns another one, from the switch statement. Error Return Traces make this clear, whereas a stack trace would look like this:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    foo(<span class="tok-number">12</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: <span class="tok-type">i32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (x &gt;= <span class="tok-number">5</span>) {
        bar();
    } <span class="tok-kw">else</span> {
        bang2();
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (baz()) {
        quux();
    } <span class="tok-kw">else</span> {
        hello();
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">baz</span>() <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> bang1();
}

<span class="tok-kw">fn</span> <span class="tok-fn">quux</span>() <span class="tok-type">void</span> {
    bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">hello</span>() <span class="tok-type">void</span> {
    bang2();
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang1</span>() <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-null">false</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">bang2</span>() <span class="tok-type">void</span> {
    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;PermissionDenied&quot;</span>);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
PermissionDenied
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:38:5</span>: <span class="t2_0">0x222734 in ??? (test)</span>
    @panic(&quot;PermissionDenied&quot;);
    <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:30:10</span>: <span class="t2_0">0x222779 in ??? (test)</span>
    bang2();
         <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:17:14</span>: <span class="t2_0">0x22271b in ??? (test)</span>
        hello();
             <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:7:12</span>: <span class="t2_0">0x2226e6 in ??? (test)</span>
        bar();
           <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:8</span>: <span class="t2_0">0x2226ce in ??? (test)</span>
    foo(12);
       <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      <p>
      Here, the stack trace does not explain how the control
      flow in <code class="zig">bar</code> got to the <code class="zig">hello()</code> call.
      One would have to open a debugger or further instrument the application
      in order to find out. The error return trace, on the other hand, 
      shows exactly how the error bubbled up.
      </p>
      <p>
      This debugging feature makes it easier to iterate quickly on code that
      robustly handles all error conditions. This means that Zig developers
      will naturally find themselves writing correct, robust code in order
      to increase their development pace.
      </p>
      <p>
      Error Return Traces are enabled by default in <a href="#Debug">Debug</a> and <a href="#ReleaseSafe">ReleaseSafe</a> builds and disabled by default in <a href="#ReleaseFast">ReleaseFast</a> and <a href="#ReleaseSmall">ReleaseSmall</a> builds.
      </p>
      <p>
      There are a few ways to activate this error return tracing feature:
      </p>
      <ul>
        <li>Return an error from main</li>
        <li>An error makes its way to <code class="zig"><span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span></code> and you have not overridden the default panic handler</li>
        <li>Use <a href="#errorReturnTrace">errorReturnTrace</a> to access the current return trace. You can use <code class="zig">std.debug.dumpStackTrace</code> to print it. This function returns comptime-known <a href="#null">null</a> when building without error return tracing support.</li>
      </ul>
      <h3 id="Implementation-Details">Implementation Details</h3>

      <p>
      To analyze performance cost, there are two cases:
      </p>
      <ul>
        <li>when no errors are returned</li>
        <li>when returning errors</li>
      </ul>
      <p>
      For the case when no errors are returned, the cost is a single memory write operation, only in the first non-failable function in the call graph that calls a failable function, i.e. when a function returning <code class="zig"><span class="tok-type">void</span></code> calls a function returning <code class="zig"><span class="tok-kw">error</span></code>.
      This is to initialize this struct in the stack memory:
      </p>
      <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StackTrace = <span class="tok-kw">struct</span> {
    index: <span class="tok-type">usize</span>,
    instruction_addresses: [N]<span class="tok-type">usize</span>,
};</code></pre>
      <p>
      Here, N is the maximum function call depth as determined by call graph analysis. Recursion is ignored and counts for 2.
      </p>
      <p>
      A pointer to <code class="zig">StackTrace</code> is passed as a secret parameter to every function that can return an error, but it's always the first parameter, so it can likely sit in a register and stay there.
      </p>
      <p>
      That's it for the path when no errors occur. It's practically free in terms of performance.
      </p>
      <p>
      When generating the code for a function that returns an error, just before the <code class="zig"><span class="tok-kw">return</span></code> statement (only for the <code class="zig"><span class="tok-kw">return</span></code> statements that return errors), Zig generates a call to this function:
      </p>
      <pre><code class="zig"><span class="tok-comment">// marked as &quot;no-inline&quot; in LLVM IR</span>
<span class="tok-kw">fn</span> <span class="tok-fn">__zig_return_error</span>(stack_trace: *StackTrace) <span class="tok-type">void</span> {
    stack_trace.instruction_addresses[stack_trace.index] = <span class="tok-builtin">@returnAddress</span>();
    stack_trace.index = (stack_trace.index + <span class="tok-number">1</span>) % N;
}</code></pre>
      <p>
      The cost is 2 math operations plus some memory reads and writes. The memory accessed is constrained and should remain cached for the duration of the error return bubbling.
      </p>
      <p>
      As for code size cost, 1 function call before a return statement is no big deal. Even so,
      I have <a href="https://github.com/ziglang/zig/issues/690">a plan</a> to make the call to
      <code class="zig">__zig_return_error</code> a tail call, which brings the code size cost down to actually zero. What is a return statement in code without error return tracing can become a jump instruction in code with error return tracing.
      </p>
      
      
      
      <h1 id="Optionals">Optionals</h1>

      <p>
      One area that Zig provides safety without compromising efficiency or
      readability is with the optional type.
      </p>
      <p>
      The question mark symbolizes the optional type. You can convert a type to an optional
      type by putting a question mark in front of it, like this:
      </p>
      <pre><code class="zig"><span class="tok-comment">// normal integer</span>
<span class="tok-kw">const</span> normal_int: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;

<span class="tok-comment">// optional integer</span>
<span class="tok-kw">const</span> optional_int: ?<span class="tok-type">i32</span> = <span class="tok-number">5678</span>;</code></pre>
      <p>
      Now the variable <code class="zig">optional_int</code> could be an <code class="zig"><span class="tok-type">i32</span></code>, or <code class="zig"><span class="tok-null">null</span></code>.
      </p>
      <p>
      Instead of integers, let's talk about pointers. Null references are the source of many runtime
      exceptions, and even stand accused of being
      <a href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/">the worst mistake of computer science</a>.
      </p>
      <p>Zig does not have them.</p>
      <p>
      Instead, you can use an optional pointer. This secretly compiles down to a normal pointer,
      since we know we can use 0 as the null value for the optional type. But the compiler
      can check your work and make sure you don't assign null to something that can't be null.
      </p>
      <p>
      Typically the downside of not having null is that it makes the code more verbose to
      write. But, let's compare some equivalent C code and Zig code.
      </p>
      <p>
      Task: call malloc, if the result is null, return null.
      </p>
      <p>C code</p>
      <pre><code class="cpp">// malloc prototype included for reference
void *malloc(size_t size);

struct Foo *do_a_thing(void) {
    char *ptr = malloc(1234);
    if (!ptr) return NULL;
    // ...
}</code></pre>
      <p>Zig code</p>
      <pre><code class="zig"><span class="tok-comment">// malloc prototype included for reference</span>
<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">malloc</span>(size: size_t) ?*<span class="tok-type">u8</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>() ?*Foo {
    <span class="tok-kw">const</span> ptr = malloc(<span class="tok-number">1234</span>) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    <span class="tok-comment">// ...</span>
}</code></pre>
      <p>
        Here, Zig is at least as convenient, if not more, than C. And, the type of "ptr"
        is <code class="zig">*<span class="tok-type">u8</span></code> <em>not</em> <code class="zig">?*<span class="tok-type">u8</span></code>. The <code class="zig"><span class="tok-kw">orelse</span></code> keyword
                    unwrapped the optional type and therefore <code class="zig">ptr</code> is guaranteed to be non-null everywhere
        it is used in the function.
      </p>
      <p>
        The other form of checking against NULL you might see looks like this:
      </p>
      <pre><code class="cpp">void do_a_thing(struct Foo *foo) {
    // do some stuff

    if (foo) {
        do_something_with_foo(foo);
    }

    // do some stuff
}</code></pre>
      <p>
        In Zig you can accomplish the same thing:
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">doAThing</span>(optional_foo: ?*Foo) <span class="tok-type">void</span> {
    <span class="tok-comment">// do some stuff</span>

    <span class="tok-kw">if</span> (optional_foo) |foo| {
      doSomethingWithFoo(foo);
    }

    <span class="tok-comment">// do some stuff</span>
}</code></pre>
      <p>
      Once again, the notable thing here is that inside the if block,
      <code class="zig">foo</code> is no longer an optional pointer, it is a pointer, which
      cannot be null.
      </p>
      <p>
      One benefit to this is that functions which take pointers as arguments can
      be annotated with the "nonnull" attribute - <code>__attribute__((nonnull))</code> in
      <a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html">GCC</a>.
      The optimizer can sometimes make better decisions knowing that pointer arguments
      cannot be null.
      </p>
      <h2 id="Optional-Type">Optional Type</h2>

      <p>An optional is created by putting <code class="zig">?</code> in front of a type. You can use compile-time
      reflection to access the child type of an optional:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;optional type&quot;</span> {
    <span class="tok-comment">// Declare an optional and implicitly cast from null:</span>
    <span class="tok-kw">var</span> foo: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-comment">// Implicitly cast from child type of an optional</span>
    foo = <span class="tok-number">1234</span>;

    <span class="tok-comment">// Use compile-time reflection to access the child type of the optional:</span>
    <span class="tok-kw">comptime</span> assert(<span class="tok-builtin">@typeOf</span>(foo).Child == <span class="tok-type">i32</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 optional type...OK
All tests passed.
</code></pre>

      
      <h2 id="null">null</h2>

      <p>
      Just like <a href="#undefined">undefined</a>, <code class="zig"><span class="tok-null">null</span></code> has its own type, and the only way to use it is to
      cast it to a different type:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> optional_value: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;</code></pre>
      
      
      <h1 id="Casting">Casting</h1>

      <p>
      A <strong>type cast</strong> converts a value of one type to another.
      Zig has <a href="#Implicit-Casts">Implicit Casts</a> for conversions that are known to be completely safe and unambiguous,
      and <a href="#Explicit-Casts">Explicit Casts</a> for conversions that one would not want to happen on accident.
      There is also a third kind of type conversion called <a href="#Peer-Type-Resolution">Peer Type Resolution</a> for
      the case when a result type must be decided given multiple operand types.
      </p>
      <h2 id="Implicit-Casts">Implicit Casts</h2>

      <p>
      An implicit cast occurs when one type is expected, but different type is provided:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;implicit cast - variable declaration&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u8</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u16</span> = a;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;implicit cast - function call&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u8</span> = <span class="tok-number">1</span>;
    foo(a);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(b: <span class="tok-type">u16</span>) <span class="tok-type">void</span> {}

<span class="tok-kw">test</span> <span class="tok-str">&quot;implicit cast - invoke a type as a function&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u8</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> b = <span class="tok-type">u16</span>(a);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/3 implicit cast - variable declaration...OK
Test 2/3 implicit cast - function call...OK
Test 3/3 implicit cast - invoke a type as a function...OK
All tests passed.
</code></pre>

      <p>
      Implicit casts are only allowed when it is completely unambiguous how to get from one type to another,
      and the transformation is guaranteed to be safe.
      </p>
      <h3 id="Implicit-Cast-Stricter-Qualification">Implicit Cast: Stricter Qualification</h3>

      <p>
      Values which have the same representation at runtime can be cast to increase the strictness
      of the qualifiers, no matter how nested the qualifiers are:
      </p>
      <ul>
          <li><code class="zig"><span class="tok-kw">const</span></code> - non-const to const is allowed</li>
          <li><code class="zig"><span class="tok-kw">volatile</span></code> - non-volatile to volatile is allowed</li>
          <li><code class="zig"><span class="tok-kw">align</span></code> - bigger to smaller alignment is allowed </li>
          <li><a href="#Error-Set-Type">error sets</a> to supersets is allowed</li>
      </ul>
      <p>
      These casts are no-ops at runtime since the value representation does not change.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;implicit cast - const qualification&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> b: *<span class="tok-type">i32</span> = &amp;a;
    foo(b);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(a: *<span class="tok-kw">const</span> <span class="tok-type">i32</span>) <span class="tok-type">void</span> {}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 implicit cast - const qualification...OK
All tests passed.
</code></pre>

      <p>
      In addition, pointers implicitly cast to const optional pointers:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;
<span class="tok-kw">const</span> mem = std.mem;

<span class="tok-kw">test</span> <span class="tok-str">&quot;cast *[1][*]const u8 to [*]const ?[*]const u8&quot;</span> {
    <span class="tok-kw">const</span> window_name = [<span class="tok-number">1</span>][*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{<span class="tok-str">c&quot;window name&quot;</span>};
    <span class="tok-kw">const</span> x: [*]<span class="tok-kw">const</span> ?[*]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = &amp;window_name;
    assert(mem.eql(<span class="tok-type">u8</span>, std.cstr.toSliceConst(x[<span class="tok-number">0</span>].?), <span class="tok-str">&quot;window name&quot;</span>));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 cast *[1][*]const u8 to [*]const ?[*]const u8...OK
All tests passed.
</code></pre>

      
      <h3 id="Implicit-Cast-Integer-and-Float-Widening">Implicit Cast: Integer and Float Widening</h3>

      <p>
      <a href="#Integers">Integers</a> implicitly cast to integer types which can represent every value of the old type, and likewise
      <a href="#Floats">Floats</a> implicitly cast to float types which can represent every value of the old type.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;
<span class="tok-kw">const</span> mem = std.mem;

<span class="tok-kw">test</span> <span class="tok-str">&quot;integer widening&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u8</span> = <span class="tok-number">250</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u16</span> = a;
    <span class="tok-kw">var</span> c: <span class="tok-type">u32</span> = b;
    <span class="tok-kw">var</span> d: <span class="tok-type">u64</span> = c;
    <span class="tok-kw">var</span> e: <span class="tok-type">u64</span> = d;
    <span class="tok-kw">var</span> f: <span class="tok-type">u128</span> = e;
    assert(f == a);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;implicit unsigned integer to signed integer&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u8</span> = <span class="tok-number">250</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">i16</span> = a;
    assert(b == <span class="tok-number">250</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;float widening&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">f16</span> = <span class="tok-number">12.34</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">f32</span> = a;
    <span class="tok-kw">var</span> c: <span class="tok-type">f64</span> = b;
    <span class="tok-kw">var</span> d: <span class="tok-type">f128</span> = c;
    assert(d == a);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/3 integer widening...OK
Test 2/3 implicit unsigned integer to signed integer...OK
Test 3/3 float widening...OK
All tests passed.
</code></pre>

      
      <h3 id="Implicit-Cast-Arrays">Implicit Cast: Arrays</h3>

      <p>TODO: [N]T to []const T</p>
      <p>TODO: *const [N]T to []const T</p>
      <p>TODO: [N]T to *const []const T</p>
      <p>TODO: [N]T to ?[]const T</p>
      <p>TODO: *[N]T to []T</p>
      <p>TODO: *[N]T to [*]T</p>
      <p>TODO: *[N]T to ?[*]T</p>
      <p>TODO: *T to *[1]T</p>
      <p>TODO: [N]T to E![]const T</p>
      
      <h3 id="Implicit-Cast-Optionals">Implicit Cast: Optionals</h3>

      <p>TODO: T to ?T</p>
      <p>TODO: T to E!?T</p>
      <p>TODO: null to ?T</p>
      
      <h3 id="Implicit-Cast-T-to-ET">Implicit Cast: T to E!T</h3>

      <p>TODO</p>
      
      <h3 id="Implicit-Cast-E-to-ET">Implicit Cast: E to E!T</h3>

      <p>TODO</p>
      
      <h3 id="Implicit-Cast-comptime_int-to-const-integer">Implicit Cast: comptime_int to *const integer</h3>

      <p>TODO</p>
      
      <h3 id="Implicit-Cast-comptime_float-to-const-float">Implicit Cast: comptime_float to *const float</h3>

      <p>TODO</p>
      
      <h3 id="Implicit-Cast-compile-time-known-numbers">Implicit Cast: compile-time known numbers</h3>

      <p>TODO</p>
      
      <h3 id="Implicit-Cast-union-to-enum">Implicit Cast: union to enum</h3>

      <p>TODO</p>
      
      <h3 id="Implicit-Cast-enum-to-union">Implicit Cast: enum to union</h3>

      <p>TODO</p>
      
      <h3 id="Implicit-Cast-T-to-T-when-sizeOfT--">Implicit Cast: T to *T when @sizeOf(T) == 0</h3>

      <p>TODO</p>
      
      <h3 id="Implicit-Cast-undefined">Implicit Cast: undefined</h3>

      <p>TODO</p>
      
      <h3 id="Implicit-Cast-T-to-const-T">Implicit Cast: T to *const T</h3>

      <p>TODO</p>
      
      

      <h2 id="Explicit-Casts">Explicit Casts</h2>

      <p>
      Explicit casts are performed via <a href="#Builtin-Functions">Builtin Functions</a>.
      Some explicit casts are safe; some are not.
      Some explicit casts perform language-level assertions; some do not.
      Some explicit casts are no-ops at runtime; some are not.
      </p>
      <ul>
          <li><a href="#bitCast">@bitCast</a> - change type but maintain bit representation</li>
          <li><a href="#alignCast">@alignCast</a> - make a pointer have more alignment</li>
          <li><a href="#boolToInt">@boolToInt</a> - convert true to 1 and false to 0</li>
          <li><a href="#bytesToSlice">@bytesToSlice</a> - convert a slice of bytes to a slice of another type</li>
          <li><a href="#enumToInt">@enumToInt</a> - obtain the integer tag value of an enum or tagged union</li>
          <li><a href="#errSetCast">@errSetCast</a> - convert to a smaller error set</li>
          <li><a href="#errorToInt">@errorToInt</a> - obtain the integer value of an error code</li>
          <li><a href="#floatCast">@floatCast</a> - convert a larger float to a smaller float</li>
          <li><a href="#floatToInt">@floatToInt</a> - obtain the integer part of a float value</li>
          <li><a href="#intCast">@intCast</a> - convert between integer types</li>
          <li><a href="#intToEnum">@intToEnum</a> - obtain an enum value based on its integer tag value</li>
          <li><a href="#intToError">@intToError</a> - obtain an error code based on its integer value</li>
          <li><a href="#intToFloat">@intToFloat</a> - convert an integer to a float value</li>
          <li><a href="#intToPtr">@intToPtr</a> - convert an address to a pointer</li>
          <li><a href="#ptrCast">@ptrCast</a> - convert between pointer types</li>
          <li><a href="#ptrToInt">@ptrToInt</a> - obtain the address of a pointer</li>
          <li><a href="#sliceToBytes">@sliceToBytes</a> - convert a slice of anything to a slice of bytes</li>
          <li><a href="#truncate">@truncate</a> - convert between integer types, chopping off bits</li>
      </ul>
      

      <h2 id="Peer-Type-Resolution">Peer Type Resolution</h2>

      <p>Peer Type Resolution occurs in these places:</p>
      <ul>
        <li><a href="#switch">switch</a> expressions</li>
        <li><a href="#if">if</a> expressions</li>
        <li><a href="#while">while</a> expressions</li>
        <li><a href="#for">for</a> expressions</li>
        <li>Multiple break statements in a block</li>
        <li>Some <a href="#Table-of-Operators">binary operations</a></li>
      </ul>
      <p>
      This kind of type resolution chooses a type that all peer types can implicitly cast into. Here are
      some examples:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;
<span class="tok-kw">const</span> mem = std.mem;

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer resolve int widening&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">i8</span> = <span class="tok-number">12</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">i16</span> = <span class="tok-number">34</span>;
    <span class="tok-kw">var</span> c = a + b;
    assert(c == <span class="tok-number">46</span>);
    assert(<span class="tok-builtin">@typeOf</span>(c) == <span class="tok-type">i16</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer resolve arrays of different size to const slice&quot;</span> {
    assert(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">true</span>), <span class="tok-str">&quot;true&quot;</span>));
    assert(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">false</span>), <span class="tok-str">&quot;false&quot;</span>));
    <span class="tok-kw">comptime</span> assert(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">true</span>), <span class="tok-str">&quot;true&quot;</span>));
    <span class="tok-kw">comptime</span> assert(mem.eql(<span class="tok-type">u8</span>, boolToStr(<span class="tok-null">false</span>), <span class="tok-str">&quot;false&quot;</span>));
}
<span class="tok-kw">fn</span> <span class="tok-fn">boolToStr</span>(b: <span class="tok-type">bool</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (b) <span class="tok-str">&quot;true&quot;</span> <span class="tok-kw">else</span> <span class="tok-str">&quot;false&quot;</span>;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer resolve array and const slice&quot;</span> {
    testPeerResolveArrayConstSlice(<span class="tok-null">true</span>);
    <span class="tok-kw">comptime</span> testPeerResolveArrayConstSlice(<span class="tok-null">true</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">testPeerResolveArrayConstSlice</span>(b: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> value1 = <span class="tok-kw">if</span> (b) <span class="tok-str">&quot;aoeu&quot;</span> <span class="tok-kw">else</span> ([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>)(<span class="tok-str">&quot;zz&quot;</span>);
    <span class="tok-kw">const</span> value2 = <span class="tok-kw">if</span> (b) ([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>)(<span class="tok-str">&quot;zz&quot;</span>) <span class="tok-kw">else</span> <span class="tok-str">&quot;aoeu&quot;</span>;
    assert(mem.eql(<span class="tok-type">u8</span>, value1, <span class="tok-str">&quot;aoeu&quot;</span>));
    assert(mem.eql(<span class="tok-type">u8</span>, value2, <span class="tok-str">&quot;zz&quot;</span>));
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer type resolution: ?T and T&quot;</span> {
    assert(peerTypeTAndOptionalT(<span class="tok-null">true</span>, <span class="tok-null">false</span>).? == <span class="tok-number">0</span>);
    assert(peerTypeTAndOptionalT(<span class="tok-null">false</span>, <span class="tok-null">false</span>).? == <span class="tok-number">3</span>);
    <span class="tok-kw">comptime</span> {
        assert(peerTypeTAndOptionalT(<span class="tok-null">true</span>, <span class="tok-null">false</span>).? == <span class="tok-number">0</span>);
        assert(peerTypeTAndOptionalT(<span class="tok-null">false</span>, <span class="tok-null">false</span>).? == <span class="tok-number">3</span>);
    }
}
<span class="tok-kw">fn</span> <span class="tok-fn">peerTypeTAndOptionalT</span>(c: <span class="tok-type">bool</span>, b: <span class="tok-type">bool</span>) ?<span class="tok-type">usize</span> {
    <span class="tok-kw">if</span> (c) {
        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (b) <span class="tok-null">null</span> <span class="tok-kw">else</span> <span class="tok-type">usize</span>(<span class="tok-number">0</span>);
    }

    <span class="tok-kw">return</span> <span class="tok-type">usize</span>(<span class="tok-number">3</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;peer type resolution: [0]u8 and []const u8&quot;</span> {
    assert(peerTypeEmptyArrayAndSlice(<span class="tok-null">true</span>, <span class="tok-str">&quot;hi&quot;</span>).len == <span class="tok-number">0</span>);
    assert(peerTypeEmptyArrayAndSlice(<span class="tok-null">false</span>, <span class="tok-str">&quot;hi&quot;</span>).len == <span class="tok-number">1</span>);
    <span class="tok-kw">comptime</span> {
        assert(peerTypeEmptyArrayAndSlice(<span class="tok-null">true</span>, <span class="tok-str">&quot;hi&quot;</span>).len == <span class="tok-number">0</span>);
        assert(peerTypeEmptyArrayAndSlice(<span class="tok-null">false</span>, <span class="tok-str">&quot;hi&quot;</span>).len == <span class="tok-number">1</span>);
    }
}
<span class="tok-kw">fn</span> <span class="tok-fn">peerTypeEmptyArrayAndSlice</span>(a: <span class="tok-type">bool</span>, slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (a) {
        <span class="tok-kw">return</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>{};
    }

    <span class="tok-kw">return</span> slice[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;peer type resolution: [0]u8, []const u8, and error![]u8&quot;</span> {
    {
        <span class="tok-kw">var</span> data = <span class="tok-str">&quot;hi&quot;</span>;
        <span class="tok-kw">const</span> slice = data[<span class="tok-number">0</span>..];
        assert((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">true</span>, slice)).len == <span class="tok-number">0</span>);
        assert((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">false</span>, slice)).len == <span class="tok-number">1</span>);
    }
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> data = <span class="tok-str">&quot;hi&quot;</span>;
        <span class="tok-kw">const</span> slice = data[<span class="tok-number">0</span>..];
        assert((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">true</span>, slice)).len == <span class="tok-number">0</span>);
        assert((<span class="tok-kw">try</span> peerTypeEmptyArrayAndSliceAndError(<span class="tok-null">false</span>, slice)).len == <span class="tok-number">1</span>);
    }
}
<span class="tok-kw">fn</span> <span class="tok-fn">peerTypeEmptyArrayAndSliceAndError</span>(a: <span class="tok-type">bool</span>, slice: []<span class="tok-type">u8</span>) <span class="tok-kw">error</span>![]<span class="tok-type">u8</span> {
    <span class="tok-kw">if</span> (a) {
        <span class="tok-kw">return</span> []<span class="tok-type">u8</span>{};
    }

    <span class="tok-kw">return</span> slice[<span class="tok-number">0</span>..<span class="tok-number">1</span>];
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/6 peer resolve int widening...OK
Test 2/6 peer resolve arrays of different size to const slice...OK
Test 3/6 peer resolve array and const slice...OK
Test 4/6 peer type resolution: ?T and T...OK
Test 5/6 peer type resolution: [0]u8 and []const u8...OK
Test 6/6 peer type resolution: [0]u8, []const u8, and error![]u8...OK
All tests passed.
</code></pre>

      
      

      <h1 id="void">void</h1>

      <p>
      <code class="zig"><span class="tok-type">void</span></code> represents a type that has no value. Code that makes use of void values is
      not included in the final generated code:
      </p>
      <pre><code class="zig"><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">entry</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">void</span> = {};
    <span class="tok-kw">var</span> y: <span class="tok-type">void</span> = {};
    x = y;
}</code></pre>
      <p>When this turns into LLVM IR, there is no code generated in the body of <code class="zig">entry</code>,
      even in debug mode. For example, on x86_64:</p>
      <pre><code>0000000000000010 &lt;entry&gt;:
  10:	55                   	push   %rbp
  11:	48 89 e5             	mov    %rsp,%rbp
  14:	5d                   	pop    %rbp
  15:	c3                   	retq   </code></pre>
      <p>These assembly instructions do not have any code associated with the void values -
      they only perform the function call prologue and epilog.</p>
      <p>
      <code class="zig"><span class="tok-type">void</span></code> can be useful for instantiating generic types. For example, given a
          <code class="zig">Map(Key, Value)</code>, one can pass <code class="zig"><span class="tok-type">void</span></code> for the <code class="zig">Value</code>
                      type to make it into a <code class="zig">Set</code>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;turn HashMap into a set with void&quot;</span> {
    <span class="tok-kw">var</span> map = std.HashMap(<span class="tok-type">i32</span>, <span class="tok-type">void</span>, hash_i32, eql_i32).init(std.debug.global_allocator);
    <span class="tok-kw">defer</span> map.deinit();

    _ = <span class="tok-kw">try</span> map.put(<span class="tok-number">1</span>, {});
    _ = <span class="tok-kw">try</span> map.put(<span class="tok-number">2</span>, {});

    assert(map.contains(<span class="tok-number">2</span>));
    assert(!map.contains(<span class="tok-number">3</span>));

    _ = map.remove(<span class="tok-number">2</span>);
    assert(!map.contains(<span class="tok-number">2</span>));
}

<span class="tok-kw">fn</span> <span class="tok-fn">hash_i32</span>(x: <span class="tok-type">i32</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@bitCast</span>(<span class="tok-type">u32</span>, x);
}

<span class="tok-kw">fn</span> <span class="tok-fn">eql_i32</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> a == b;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 turn HashMap into a set with void...OK
All tests passed.
</code></pre>

      <p>Note that this is different than using a dummy value for the hash map value.
      By using <code class="zig"><span class="tok-type">void</span></code> as the type of the value, the hash map entry type has no value field, and
      thus the hash map takes up less space. Further, all the code that deals with storing and loading the
      value is deleted, as seen above.
      </p>
      <p>
      <code class="zig"><span class="tok-type">void</span></code> is distinct from <code class="zig"><span class="tok-type">c_void</span></code>, which is defined like this:
              <code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> <span class="tok-type">c_void</span> = <span class="tok-builtin">@OpaqueType</span>();</code>.
                  <code class="zig"><span class="tok-type">void</span></code> has a known size of 0 bytes, and <code class="zig"><span class="tok-type">c_void</span></code> has an unknown, but non-zero, size.
      </p>
      <p>
      Expressions of type <code class="zig"><span class="tok-type">void</span></code> are the only ones whose value can be ignored. For example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;ignoring expression value&quot;</span> {
    foo();
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:8: </span><span class="t31_1">error:</span><span class="t0_1"> expression value is ignored</span>
    foo();
       <span class="t32_1">^</span>
</code></pre>

      <p>However, if the expression has type <code class="zig"><span class="tok-type">void</span></code>:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;ignoring expression value&quot;</span> {
    foo();
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 ignoring expression value...OK
All tests passed.
</code></pre>

      

      <h1 id="comptime">comptime</h1>

      <p>
      Zig places importance on the concept of whether an expression is known at compile-time.
      There are a few different places this concept is used, and these building blocks are used
      to keep the language small, readable, and powerful.
      </p>
      <h2 id="Introducing-the-Compile-Time-Concept">Introducing the Compile-Time Concept</h2>

      <h3 id="Compile-Time-Parameters">Compile-Time Parameters</h3>

      <p>
      Compile-time parameters is how Zig implements generics. It is compile-time duck typing.
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a &gt; b) a <span class="tok-kw">else</span> b;
}
<span class="tok-kw">fn</span> <span class="tok-fn">gimmeTheBiggerFloat</span>(a: <span class="tok-type">f32</span>, b: <span class="tok-type">f32</span>) <span class="tok-type">f32</span> {
    <span class="tok-kw">return</span> max(<span class="tok-type">f32</span>, a, b);
}
<span class="tok-kw">fn</span> <span class="tok-fn">gimmeTheBiggerInteger</span>(a: <span class="tok-type">u64</span>, b: <span class="tok-type">u64</span>) <span class="tok-type">u64</span> {
    <span class="tok-kw">return</span> max(<span class="tok-type">u64</span>, a, b);
}</code></pre>
      <p>
      In Zig, types are first-class citizens. They can be assigned to variables, passed as parameters to functions,
      and returned from functions. However, they can only be used in expressions which are known at <em>compile-time</em>,
      which is why the parameter <code class="zig">T</code> in the above snippet must be marked with <code class="zig"><span class="tok-kw">comptime</span></code>.
      </p>
      <p>
      A <code class="zig"><span class="tok-kw">comptime</span></code> parameter means that:
      </p>
      <ul>
        <li>At the callsite, the value must be known at compile-time, or it is a compile error.</li>
        <li>In the function definition, the value is known at compile-time.</li>
      </ul>
      <p>
      </p>
      <p>
      For example, if we were to introduce another function to the above snippet:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a &gt; b) a <span class="tok-kw">else</span> b;
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;try to pass a runtime type&quot;</span> {
    foo(<span class="tok-null">false</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(condition: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = max(
        <span class="tok-kw">if</span> (condition) <span class="tok-type">f32</span> <span class="tok-kw">else</span> <span class="tok-type">u64</span>,
        <span class="tok-number">1234</span>,
        <span class="tok-number">5678</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:1:29: </span><span class="t31_1">error:</span><span class="t0_1"> unable to evaluate constant expression</span>
fn max(comptime T: type, a: T, b: T) T {
                            <span class="t32_1">^</span>
</code></pre>

      <p>
      This is an error because the programmer attempted to pass a value only known at run-time
      to a function which expects a value known at compile-time.
      </p>
      <p>
      Another way to get an error is if we pass a type that violates the type checker when the
      function is analyzed. This is what it means to have <em>compile-time duck typing</em>.
      </p>
      <p>
      For example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (a &gt; b) a <span class="tok-kw">else</span> b;
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;try to compare bools&quot;</span> {
    _ = max(<span class="tok-type">bool</span>, <span class="tok-null">true</span>, <span class="tok-null">false</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:18: </span><span class="t31_1">error:</span><span class="t0_1"> operator not allowed for type 'bool'</span>
    return if (a &gt; b) a else b;
                 <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:12: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    _ = max(bool, true, false);
           <span class="t32_1">^</span>
</code></pre>

      <p>
      On the flip side, inside the function definition with the <code class="zig"><span class="tok-kw">comptime</span></code> parameter, the
      value is known at compile-time. This means that we actually could make this work for the bool type
      if we wanted to:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T) T {
    <span class="tok-kw">if</span> (T == <span class="tok-type">bool</span>) {
        <span class="tok-kw">return</span> a <span class="tok-kw">or</span> b;
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (a &gt; b) {
        <span class="tok-kw">return</span> a;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> b;
    }
}
<span class="tok-kw">test</span> <span class="tok-str">&quot;try to compare bools&quot;</span> {
    <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert(max(<span class="tok-type">bool</span>, <span class="tok-null">false</span>, <span class="tok-null">true</span>) == <span class="tok-null">true</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 try to compare bools...OK
All tests passed.
</code></pre>

      <p>
      This works because Zig implicitly inlines <code class="zig"><span class="tok-kw">if</span></code> expressions when the condition
      is known at compile-time, and the compiler guarantees that it will skip analysis of
      the branch not taken.
      </p>
      <p>
      This means that the actual function generated for <code class="zig">max</code> in this situation looks like
      this:
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">max</span>(a: <span class="tok-type">bool</span>, b: <span class="tok-type">bool</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> a <span class="tok-kw">or</span> b;
}</code></pre>
      <p>
      All the code that dealt with compile-time known values is eliminated and we are left with only
      the necessary run-time code to accomplish the task.
      </p>
      <p>
      This works the same way for <code class="zig"><span class="tok-kw">switch</span></code> expressions - they are implicitly inlined
      when the target expression is compile-time known.
      </p>
      
      <h3 id="Compile-Time-Variables">Compile-Time Variables</h3>

      <p>
      In Zig, the programmer can label variables as <code class="zig"><span class="tok-kw">comptime</span></code>. This guarantees to the compiler
      that every load and store of the variable is performed at compile-time. Any violation of this results in a
      compile error.
      </p>
      <p>
      This combined with the fact that we can <code class="zig"><span class="tok-kw">inline</span></code> loops allows us to write
      a function which is partially evaluated at compile-time and partially at run-time.
      </p>
      <p>
      For example:
      </p>
      <p class="file">comptime_vars.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">const</span> CmdFn = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    func: <span class="tok-kw">fn</span>(<span class="tok-type">i32</span>) <span class="tok-type">i32</span>,
};

<span class="tok-kw">const</span> cmd_fns = []CmdFn{
    CmdFn {.name = <span class="tok-str">&quot;one&quot;</span>, .func = one},
    CmdFn {.name = <span class="tok-str">&quot;two&quot;</span>, .func = two},
    CmdFn {.name = <span class="tok-str">&quot;three&quot;</span>, .func = three},
};
<span class="tok-kw">fn</span> <span class="tok-fn">one</span>(value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> { <span class="tok-kw">return</span> value + <span class="tok-number">1</span>; }
<span class="tok-kw">fn</span> <span class="tok-fn">two</span>(value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> { <span class="tok-kw">return</span> value + <span class="tok-number">2</span>; }
<span class="tok-kw">fn</span> <span class="tok-fn">three</span>(value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> { <span class="tok-kw">return</span> value + <span class="tok-number">3</span>; }

<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(<span class="tok-kw">comptime</span> prefix_char: <span class="tok-type">u8</span>, start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (i &lt; cmd_fns.len) : (i += <span class="tok-number">1</span>) {
        <span class="tok-kw">if</span> (cmd_fns[i].name[<span class="tok-number">0</span>] == prefix_char) {
            result = cmd_fns[i].func(result);
        }
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;perform fn&quot;</span> {
    assert(performFn(<span class="tok-str">'t'</span>, <span class="tok-number">1</span>) == <span class="tok-number">6</span>);
    assert(performFn(<span class="tok-str">'o'</span>, <span class="tok-number">0</span>) == <span class="tok-number">1</span>);
    assert(performFn(<span class="tok-str">'w'</span>, <span class="tok-number">99</span>) == <span class="tok-number">99</span>);
}</code></pre><pre><code class="shell">$ zig test comptime_vars.zig
Test 1/1 perform fn...OK
All tests passed.
</code></pre>

      <p>
      This example is a bit contrived, because the compile-time evaluation component is unnecessary;
      this code would work fine if it was all done at run-time. But it does end up generating
      different code. In this example, the function <code class="zig">performFn</code> is generated three different times,
          for the different values of <code class="zig">prefix_char</code> provided:
      </p>
      <pre><code class="zig"><span class="tok-comment">// From the line:</span>
<span class="tok-comment">// assert(performFn('t', 1) == 6);</span>
<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    result = two(result);
    result = three(result);
    <span class="tok-kw">return</span> result;
}</code></pre>
      <pre><code class="zig"><span class="tok-comment">// From the line:</span>
<span class="tok-comment">// assert(performFn('o', 0) == 1);</span>
<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    result = one(result);
    <span class="tok-kw">return</span> result;
}</code></pre>
      <pre><code class="zig"><span class="tok-comment">// From the line:</span>
<span class="tok-comment">// assert(performFn('w', 99) == 99);</span>
<span class="tok-kw">fn</span> <span class="tok-fn">performFn</span>(start_value: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = start_value;
    <span class="tok-kw">return</span> result;
}</code></pre>
      <p>
      Note that this happens even in a debug build; in a release build these generated functions still
      pass through rigorous LLVM optimizations. The important thing to note, however, is not that this
      is a way to write more optimized code, but that it is a way to make sure that what <em>should</em> happen
      at compile-time, <em>does</em> happen at compile-time. This catches more errors and as demonstrated
      later in this article, allows expressiveness that in other languages requires using macros,
      generated code, or a preprocessor to accomplish.
      </p>
      
      <h3 id="Compile-Time-Expressions">Compile-Time Expressions</h3>

      <p>
      In Zig, it matters whether a given expression is known at compile-time or run-time. A programmer can
      use a <code class="zig"><span class="tok-kw">comptime</span></code> expression to guarantee that the expression will be evaluated at compile-time.
      If this cannot be accomplished, the compiler will emit an error. For example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">exit</span>() <span class="tok-type">noreturn</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;foo&quot;</span> {
    <span class="tok-kw">comptime</span> {
        exit();
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:9: </span><span class="t31_1">error:</span><span class="t0_1"> unable to evaluate constant expression</span>
        exit();
        <span class="t32_1">^</span>
</code></pre>

      <p>
      It doesn't make sense that a program could call <code class="zig">exit()</code> (or any other external function)
          at compile-time, so this is a compile error. However, a <code class="zig"><span class="tok-kw">comptime</span></code> expression does much
      more than sometimes cause a compile error.
      </p>
      <p>
      Within a <code class="zig"><span class="tok-kw">comptime</span></code> expression:
      </p>
      <ul>
          <li>All variables are <code class="zig"><span class="tok-kw">comptime</span></code> variables.</li>
          <li>All <code class="zig"><span class="tok-kw">if</span></code>, <code class="zig"><span class="tok-kw">while</span></code>, <code class="zig"><span class="tok-kw">for</span></code>, and <code class="zig"><span class="tok-kw">switch</span></code>
          expressions are evaluated at compile-time, or emit a compile error if this is not possible.</li>
        <li>All function calls cause the compiler to interpret the function at compile-time, emitting a
          compile error if the function tries to do something that has global run-time side effects.</li>
      </ul>
      <p>
      This means that a programmer can create a function which is called both at compile-time and run-time, with
      no modification to the function required.
      </p>
      <p>
      Let's look at an example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">u32</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">if</span> (index &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> index;
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;fibonacci&quot;</span> {
    <span class="tok-comment">// test fibonacci at run-time</span>
    assert(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);

    <span class="tok-comment">// test fibonacci at compile-time</span>
    <span class="tok-kw">comptime</span> {
        assert(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 fibonacci...OK
All tests passed.
</code></pre>

      <p>
      Imagine if we had forgotten the base case of the recursive function and tried to run the tests:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">u32</span>) <span class="tok-type">u32</span> {
    <span class="tok-comment">//if (index &lt; 2) return index;</span>
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;fibonacci&quot;</span> {
    <span class="tok-kw">comptime</span> {
        assert(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:28: </span><span class="t31_1">error:</span><span class="t0_1"> operation caused overflow</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                           <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:10:25: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
        assert(fibonacci(7) == 13);
                        <span class="t32_1">^</span>
</code></pre>

      <p>
      The compiler produces an error which is a stack trace from trying to evaluate the
      function at compile-time.
      </p>
      <p>
      Luckily, we used an unsigned integer, and so when we tried to subtract 1 from 0, it triggered
      undefined behavior, which is always a compile error if the compiler knows it happened.
      But what would have happened if we used a signed integer?
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-comment">//if (index &lt; 2) return index;</span>
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;fibonacci&quot;</span> {
    <span class="tok-kw">comptime</span> {
        assert(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">13</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t31_1">error:</span><span class="t0_1"> evaluation exceeded 1000 backwards branches</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:21: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    return fibonacci(index - 1) + fibonacci(index - 2);
                    <span class="t32_1">^</span>
</code></pre>

      <p>
      The compiler noticed that evaluating this function at compile-time took a long time,
      and thus emitted a compile error and gave up. If the programmer wants to increase
      the budget for compile-time computation, they can use a built-in function called
      <a href="#setEvalBranchQuota">@setEvalBranchQuota</a> to change the default number 1000 to something else.
      </p>
      <p>
      What if we fix the base case, but put the wrong value in the <code class="zig">assert</code> line?
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">fn</span> <span class="tok-fn">fibonacci</span>(index: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">if</span> (index &lt; <span class="tok-number">2</span>) <span class="tok-kw">return</span> index;
    <span class="tok-kw">return</span> fibonacci(index - <span class="tok-number">1</span>) + fibonacci(index - <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;fibonacci&quot;</span> {
    <span class="tok-kw">comptime</span> {
        assert(fibonacci(<span class="tok-number">7</span>) == <span class="tok-number">99999</span>);
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/build/lib/zig/std/debug/index.zig:118:13: </span><span class="t31_1">error:</span><span class="t0_1"> encountered @panic at compile-time</span>
            @panic(&quot;assertion failure&quot;);
            <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:10:15: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
        assert(fibonacci(7) == 99999);
              <span class="t32_1">^</span>
</code></pre>

      <p>
      What happened is Zig started interpreting the <code class="zig">assert</code> function with the
          parameter <code class="zig">ok</code> set to <code class="zig"><span class="tok-null">false</span></code>. When the interpreter hit
                  <code class="zig"><span class="tok-kw">unreachable</span></code> it emitted a compile error, because reaching unreachable
      code is undefined behavior, and undefined behavior causes a compile error if it is detected
      at compile-time.
      </p>

      <p>
      In the global scope (outside of any function), all expressions are implicitly
      <code class="zig"><span class="tok-kw">comptime</span></code> expressions. This means that we can use functions to
      initialize complex static data. For example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> first_25_primes = firstNPrimes(<span class="tok-number">25</span>);
<span class="tok-kw">const</span> sum_of_first_25_primes = sum(first_25_primes);

<span class="tok-kw">fn</span> <span class="tok-fn">firstNPrimes</span>(<span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) [n]<span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> prime_list: [n]<span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> next_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> test_number: <span class="tok-type">i32</span> = <span class="tok-number">2</span>;
    <span class="tok-kw">while</span> (next_index &lt; prime_list.len) : (test_number += <span class="tok-number">1</span>) {
        <span class="tok-kw">var</span> test_prime_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
        <span class="tok-kw">var</span> is_prime = <span class="tok-null">true</span>;
        <span class="tok-kw">while</span> (test_prime_index &lt; next_index) : (test_prime_index += <span class="tok-number">1</span>) {
            <span class="tok-kw">if</span> (test_number % prime_list[test_prime_index] == <span class="tok-number">0</span>) {
                is_prime = <span class="tok-null">false</span>;
                <span class="tok-kw">break</span>;
            }
        }
        <span class="tok-kw">if</span> (is_prime) {
            prime_list[next_index] = test_number;
            next_index += <span class="tok-number">1</span>;
        }
    }
    <span class="tok-kw">return</span> prime_list;
}

<span class="tok-kw">fn</span> <span class="tok-fn">sum</span>(numbers: []<span class="tok-kw">const</span> <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> result: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">for</span> (numbers) |x| {
        result += x;
    }
    <span class="tok-kw">return</span> result;
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;variable values&quot;</span> {
    <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert(sum_of_first_25_primes == <span class="tok-number">1060</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 variable values...OK
All tests passed.
</code></pre>

      <p>
      When we compile this program, Zig generates the constants
      with the answer pre-computed. Here are the lines from the generated LLVM IR:
      </p>
      <pre><code class="llvm">@0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97]
@1 = internal unnamed_addr constant i32 1060</code></pre>
      <p>
      Note that we did not have to do anything special with the syntax of these functions. For example,
      we could call the <code class="zig">sum</code> function as is with a slice of numbers whose length and values were
      only known at run-time.
      </p>
      
      
      <h2 id="Generic-Data-Structures">Generic Data Structures</h2>

      <p>
      Zig uses these capabilities to implement generic data structures without introducing any
      special-case syntax. If you followed along so far, you may already know how to create a
      generic data structure.
      </p>
      <p>
      Here is an example of a generic <code class="zig">List</code> data structure, that we will instantiate with
          the type <code class="zig"><span class="tok-type">i32</span></code>. In Zig we refer to the type as <code class="zig">List(<span class="tok-type">i32</span>)</code>.
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">List</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        items: []T,
        len: <span class="tok-type">usize</span>,
    };
}</code></pre>
      <p>
      That's it. It's a function that returns an anonymous <code class="zig"><span class="tok-kw">struct</span></code>. For the purposes of error messages
          and debugging, Zig infers the name <code class="zig"><span class="tok-str">&quot;List(i32)&quot;</span></code> from the function name and parameters invoked when creating
      the anonymous struct.
      </p>
      <p>
      To keep the language small and uniform, all aggregate types in Zig are anonymous. To give a type
      a name, we assign it to a constant:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {
    next: *Node,
    name: []<span class="tok-type">u8</span>,
};</code></pre>
      <p>
      This works because all top level declarations are order-independent, and as long as there isn't
      an actual infinite regression, values can refer to themselves, directly or indirectly. In this case,
      <code class="zig">Node</code> refers to itself as a pointer, which is not actually an infinite regression, so
      it works fine.
      </p>
      
      <h2 id="Case-Study-printf-in-Zig">Case Study: printf in Zig</h2>

      <p>
      Putting all of this together, let's see how <code class="zig">printf</code> works in Zig.
      </p>
      <p class="file">printf.zig</p><pre><code class="zig"><span class="tok-kw">const</span> warn = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.warn;

<span class="tok-kw">const</span> a_number: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> a_string = <span class="tok-str">&quot;foobar&quot;</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    warn(<span class="tok-str">&quot;here is a string: '{}' here is a number: {}\n&quot;</span>, a_string, a_number);
}</code></pre><pre><code class="shell">$ zig build-exe printf.zig
$ ./printf
here is a string: 'foobar' here is a number: 1234
</code></pre>


      <p>
      Let's crack open the implementation of this and see how it works:
      </p>

      <pre><code class="zig"><span class="tok-comment">/// Calls print and then flushes the buffer.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printf</span>(self: *OutStream, <span class="tok-kw">comptime</span> format: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: ...) <span class="tok-kw">error</span>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> State = <span class="tok-kw">enum</span> {
        Start,
        OpenBrace,
        CloseBrace,
    };

    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> start_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> state = State.Start;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> next_arg: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (format) |c, i| {
        <span class="tok-kw">switch</span> (state) {
            State.Start =&gt; <span class="tok-kw">switch</span> (c) {
                <span class="tok-str">'{'</span> =&gt; {
                    <span class="tok-kw">if</span> (start_index &lt; i) <span class="tok-kw">try</span> self.write(format[start_index..i]);
                    state = State.OpenBrace;
                },
                <span class="tok-str">'}'</span> =&gt; {
                    <span class="tok-kw">if</span> (start_index &lt; i) <span class="tok-kw">try</span> self.write(format[start_index..i]);
                    state = State.CloseBrace;
                },
                <span class="tok-kw">else</span> =&gt; {},
            },
            State.OpenBrace =&gt; <span class="tok-kw">switch</span> (c) {
                <span class="tok-str">'{'</span> =&gt; {
                    state = State.Start;
                    start_index = i;
                },
                <span class="tok-str">'}'</span> =&gt; {
                    <span class="tok-kw">try</span> self.printValue(args[next_arg]);
                    next_arg += <span class="tok-number">1</span>;
                    state = State.Start;
                    start_index = i + <span class="tok-number">1</span>;
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unknown format character: &quot;</span> ++ c),
            },
            State.CloseBrace =&gt; <span class="tok-kw">switch</span> (c) {
                <span class="tok-str">'}'</span> =&gt; {
                    state = State.Start;
                    start_index = i;
                },
                <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Single '}' encountered in format string&quot;</span>),
            },
        }
    }
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">if</span> (args.len != next_arg) {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unused arguments&quot;</span>);
        }
        <span class="tok-kw">if</span> (state != State.Start) {
            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Incomplete format string: &quot;</span> ++ format);
        }
    }
    <span class="tok-kw">if</span> (start_index &lt; format.len) {
        <span class="tok-kw">try</span> self.write(format[start_index..format.len]);
    }
    <span class="tok-kw">try</span> self.flush();
}</code></pre>
      <p>
      This is a proof of concept implementation; the actual function in the standard library has more
      formatting capabilities.
      </p>
      <p>
      Note that this is not hard-coded into the Zig compiler; this is userland code in the standard library.
      </p>
      <p>
      When this function is analyzed from our example code above, Zig partially evaluates the function
      and emits a function that actually looks like this:
      </p>
      <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printf</span>(self: *OutStream, arg0: <span class="tok-type">i32</span>, arg1: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">try</span> self.write(<span class="tok-str">&quot;here is a string: '&quot;</span>);
    <span class="tok-kw">try</span> self.printValue(arg0);
    <span class="tok-kw">try</span> self.write(<span class="tok-str">&quot;' here is a number: &quot;</span>);
    <span class="tok-kw">try</span> self.printValue(arg1);
    <span class="tok-kw">try</span> self.write(<span class="tok-str">&quot;\n&quot;</span>);
    <span class="tok-kw">try</span> self.flush();
}</code></pre>
      <p>
      <code class="zig">printValue</code> is a function that takes a parameter of any type, and does different things depending
      on the type:
      </p>
      <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">printValue</span>(self: *OutStream, value: <span class="tok-kw">var</span>) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> T = <span class="tok-builtin">@typeOf</span>(value);
    <span class="tok-kw">if</span> (<span class="tok-builtin">@isInteger</span>(T)) {
        <span class="tok-kw">return</span> self.printInt(T, value);
    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (<span class="tok-builtin">@isFloat</span>(T)) {
        <span class="tok-kw">return</span> self.printFloat(T, value);
    } <span class="tok-kw">else</span> {
        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Unable to print type '&quot;</span> ++ <span class="tok-builtin">@typeName</span>(T) ++ <span class="tok-str">&quot;'&quot;</span>);
    }
}</code></pre>
      <p>
      And now, what happens if we give too many arguments to <code class="zig">printf</code>?
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> warn = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.warn;

<span class="tok-kw">const</span> a_number: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> a_string = <span class="tok-str">&quot;foobar&quot;</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;printf too many arguments&quot;</span> {
    warn(<span class="tok-str">&quot;here is a string: '{}' here is a number: {}\n&quot;</span>,
        a_string, a_number, a_number);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/build/lib/zig/std/fmt/index.zig:95:13: </span><span class="t31_1">error:</span><span class="t0_1"> Unused arguments</span>
            @compileError(&quot;Unused arguments&quot;);
            <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/build/lib/zig/std/io.zig:227:34: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
            return std.fmt.format(self, Error, self.writeFn, format, args);
                                 <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/build/lib/zig/std/debug/index.zig:46:17: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    stderr.print(fmt, args) catch return;
                <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:7:9: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    warn(&quot;here is a string: '{}' here is a number: {}\n&quot;,
        <span class="t32_1">^</span>
</code></pre>

      <p>
      Zig gives programmers the tools needed to protect themselves against their own mistakes.
      </p>
      <p>
      Zig doesn't care whether the format argument is a string literal,
      only that it is a compile-time known value that is implicitly castable to a <code class="zig">[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code>:
      </p>
      <p class="file">printf.zig</p><pre><code class="zig"><span class="tok-kw">const</span> warn = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.warn;

<span class="tok-kw">const</span> a_number: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
<span class="tok-kw">const</span> a_string = <span class="tok-str">&quot;foobar&quot;</span>;
<span class="tok-kw">const</span> fmt = <span class="tok-str">&quot;here is a string: '{}' here is a number: {}\n&quot;</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    warn(fmt, a_string, a_number);
}</code></pre><pre><code class="shell">$ zig build-exe printf.zig
$ ./printf
here is a string: 'foobar' here is a number: 1234
</code></pre>

      <p>
      This works fine.
      </p>
      <p>
      Zig does not special case string formatting in the compiler and instead exposes enough power to accomplish this
      task in userland. It does so without introducing another language on top of Zig, such as
      a macro language or a preprocessor language. It's Zig all the way down.
      </p>
      
      <p>See also:</p><ul>
<li><a href="#inline-while">inline while</a></li>
<li><a href="#inline-for">inline for</a></li>
</ul>

      
      <h1 id="Assembly">Assembly</h1>

      <p>TODO: example of inline assembly</p>
      <p>TODO: example of module level assembly</p>
      <p>TODO: example of using inline assembly return value</p>
      <p>TODO: example of using inline assembly assigning values to variables</p>
      
      <h1 id="Atomics">Atomics</h1>

      <p>TODO: @fence()</p>
      <p>TODO: @atomic rmw</p>
      <p>TODO: builtin atomic memory ordering enum</p>
      
      <h1 id="Coroutines">Coroutines</h1>

      <p>
      A coroutine is a generalization of a function.
      </p>
      <p>
      When you call a function, it creates a stack frame,
      and then the function runs until it reaches a return
      statement, and then the stack frame is destroyed.
      At the callsite, the next line of code does not run
      until the function returns.
      </p>
      <p>
      A coroutine is like a function, but it can be suspended
      and resumed any number of times, and then it must be
      explicitly destroyed. When a coroutine suspends, it
      returns to the resumer.
      </p>
      <h2 id="Minimal-Coroutine-Example">Minimal Coroutine Example</h2>

      <p>
      Declare a coroutine with the <code class="zig"><span class="tok-kw">async</span></code> keyword.
      The expression in angle brackets must evaluate to a struct
      which has these fields:
      </p>
      <ul>
          <li><code class="zig">allocFn: <span class="tok-kw">fn</span> (self: *Allocator, byte_count: <span class="tok-type">usize</span>, alignment: <span class="tok-type">u29</span>) Error![]<span class="tok-type">u8</span></code> - where <code class="zig">Error</code> can be any error set.</li>
          <li><code class="zig">freeFn: <span class="tok-kw">fn</span> (self: *Allocator, old_mem: []<span class="tok-type">u8</span>) <span class="tok-type">void</span></code></li>
      </ul>
      <p>
      You may notice that this corresponds to the <code class="zig">std.mem.Allocator</code> interface.
      This makes it convenient to integrate with existing allocators. Note, however,
      that the language feature does not depend on the standard library, and any struct which
      has these fields is allowed.
      </p>
      <p>
      Omitting the angle bracket expression when defining an async function makes
      the function generic. Zig will infer the allocator type when the async function is called.
      </p>
      <p>
      Call a coroutine with the <code class="zig"><span class="tok-kw">async</span></code> keyword. Here, the expression in angle brackets
      is a pointer to the allocator struct that the coroutine expects.
      </p>
      <p>
      The result of an async function call is a <code class="zig"><span class="tok-kw">promise</span>-&gt;T</code> type, where <code class="zig">T</code>
      is the return type of the async function. Once a promise has been created, it must be
      consumed, either with <code class="zig"><span class="tok-kw">cancel</span></code> or <code class="zig"><span class="tok-kw">await</span></code>:
      </p>
      <p>
      Async functions start executing when created, so in the following example, the entire
      async function completes before it is canceled:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;create a coroutine and cancel it&quot;</span> {
    <span class="tok-kw">const</span> p = <span class="tok-kw">try</span> <span class="tok-kw">async</span>&lt;std.debug.global_allocator&gt; simpleAsyncFn();
    <span class="tok-kw">comptime</span> assert(<span class="tok-builtin">@typeOf</span>(p) == <span class="tok-kw">promise</span>-&gt;<span class="tok-type">void</span>);
    <span class="tok-kw">cancel</span> p;
    assert(x == <span class="tok-number">2</span>);
}
<span class="tok-kw">async</span>&lt;*std.mem.Allocator&gt; <span class="tok-kw">fn</span> <span class="tok-fn">simpleAsyncFn</span>() <span class="tok-type">void</span> {
    x += <span class="tok-number">1</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 create a coroutine and cancel it...OK
All tests passed.
</code></pre>

      
      <h2 id="Suspend-and-Resume">Suspend and Resume</h2>

      <p>
      At any point, an async function may suspend itself. This causes control flow to
      return to the caller or resumer. The following code demonstrates where control flow
      goes:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;coroutine suspend, resume, cancel&quot;</span> {
    seq(<span class="tok-str">'a'</span>);
    <span class="tok-kw">const</span> p = <span class="tok-kw">try</span> <span class="tok-kw">async</span>&lt;std.debug.global_allocator&gt; testAsyncSeq();
    seq(<span class="tok-str">'c'</span>);
    <span class="tok-kw">resume</span> p;
    seq(<span class="tok-str">'f'</span>);
    <span class="tok-kw">cancel</span> p;
    seq(<span class="tok-str">'g'</span>);

    assert(std.mem.eql(<span class="tok-type">u8</span>, points, <span class="tok-str">&quot;abcdefg&quot;</span>));
}
<span class="tok-kw">async</span> <span class="tok-kw">fn</span> <span class="tok-fn">testAsyncSeq</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">defer</span> seq(<span class="tok-str">'e'</span>);

    seq(<span class="tok-str">'b'</span>);
    <span class="tok-kw">suspend</span>;
    seq(<span class="tok-str">'d'</span>);
}
<span class="tok-kw">var</span> points = []<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-str">&quot;abcdefg&quot;</span>.len;
<span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">seq</span>(c: <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    points[index] = c;
    index += <span class="tok-number">1</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 coroutine suspend, resume, cancel...OK
All tests passed.
</code></pre>

      <p>
      When an async function suspends itself, it must be sure that it will be
      resumed or canceled somehow, for example by registering its promise handle
      in an event loop. Use a suspend capture block to gain access to the
      promise:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;coroutine suspend with block&quot;</span> {
    <span class="tok-kw">const</span> p = <span class="tok-kw">try</span> <span class="tok-kw">async</span>&lt;std.debug.global_allocator&gt; testSuspendBlock();
    std.debug.assert(!result);
    <span class="tok-kw">resume</span> a_promise;
    std.debug.assert(result);
    <span class="tok-kw">cancel</span> p;
}

<span class="tok-kw">var</span> a_promise: <span class="tok-kw">promise</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">var</span> result = <span class="tok-null">false</span>;
<span class="tok-kw">async</span> <span class="tok-kw">fn</span> <span class="tok-fn">testSuspendBlock</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">suspend</span> {
        <span class="tok-kw">comptime</span> assert(<span class="tok-builtin">@typeOf</span>(<span class="tok-builtin">@handle</span>()) == <span class="tok-kw">promise</span>-&gt;<span class="tok-type">void</span>);
        a_promise = <span class="tok-builtin">@handle</span>();
    }
    result = <span class="tok-null">true</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 coroutine suspend with block...OK
All tests passed.
</code></pre>

      <p>
      Every suspend point in an async function represents a point at which the coroutine
      could be destroyed. If that happens, <code class="zig"><span class="tok-kw">defer</span></code> expressions that are in
          scope are run, as well as <code class="zig"><span class="tok-kw">errdefer</span></code> expressions.
      </p>
      <p>
      <a href="#Await">Await</a> counts as a suspend point.
      </p>
      <h3 id="Resuming-from-Suspend-Blocks">Resuming from Suspend Blocks</h3>

      <p>
      Upon entering a <code class="zig"><span class="tok-kw">suspend</span></code> block, the coroutine is already considered
      suspended, and can be resumed. For example, if you started another kernel thread,
      and had that thread call <code class="zig"><span class="tok-kw">resume</span></code> on the promise handle provided by the
          <code class="zig"><span class="tok-kw">suspend</span></code> block, the new thread would begin executing after the suspend
      block, while the old thread continued executing the suspend block.
      </p>
      <p>
      However, the coroutine can be directly resumed from the suspend block, in which case it
      never returns to its resumer and continues executing.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;resume from suspend&quot;</span> {
    <span class="tok-kw">var</span> buf: [<span class="tok-number">500</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> a = &amp;std.heap.FixedBufferAllocator.init(buf[<span class="tok-number">0</span>..]).allocator;
    <span class="tok-kw">var</span> my_result: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> p = <span class="tok-kw">try</span> <span class="tok-kw">async</span>&lt;a&gt; testResumeFromSuspend(&amp;my_result);
    <span class="tok-kw">cancel</span> p;
    std.debug.assert(my_result == <span class="tok-number">2</span>);
}
<span class="tok-kw">async</span> <span class="tok-kw">fn</span> <span class="tok-fn">testResumeFromSuspend</span>(my_result: *<span class="tok-type">i32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">suspend</span> {
        <span class="tok-kw">resume</span> <span class="tok-builtin">@handle</span>();
    }
    my_result.* += <span class="tok-number">1</span>;
    <span class="tok-kw">suspend</span>;
    my_result.* += <span class="tok-number">1</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 resume from suspend...OK
All tests passed.
</code></pre>

      <p>
      This is guaranteed to be a tail call, and therefore will not cause a new stack frame.
      </p>
      
      
      <h2 id="Await">Await</h2>

      <p>
      The <code class="zig"><span class="tok-kw">await</span></code> keyword is used to coordinate with an async function's
          <code class="zig"><span class="tok-kw">return</span></code> statement.
      </p>
      <p>
      <code class="zig"><span class="tok-kw">await</span></code> is valid only in an <code class="zig"><span class="tok-kw">async</span></code> function, and it takes
      as an operand a promise handle.
      If the async function associated with the promise handle has already returned, 
      then <code class="zig"><span class="tok-kw">await</span></code> destroys the target async function, and gives the return value.
          Otherwise, <code class="zig"><span class="tok-kw">await</span></code> suspends the current async function, registering its
      promise handle with the target coroutine. It becomes the target coroutine's responsibility
      to have ensured that it will be resumed or destroyed. When the target coroutine reaches
      its return statement, it gives the return value to the awaiter, destroys itself, and then
      resumes the awaiter.
      </p>
      <p>
      A promise handle must be consumed exactly once after it is created, either by <code class="zig"><span class="tok-kw">cancel</span></code> or <code class="zig"><span class="tok-kw">await</span></code>.
      </p>
      <p>
      <code class="zig"><span class="tok-kw">await</span></code> counts as a suspend point, and therefore at every <code class="zig"><span class="tok-kw">await</span></code>,
              a coroutine can be potentially destroyed, which would run <code class="zig"><span class="tok-kw">defer</span></code> and <code class="zig"><span class="tok-kw">errdefer</span></code> expressions.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">var</span> a_promise: <span class="tok-kw">promise</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">var</span> final_result: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;coroutine await&quot;</span> {
    seq(<span class="tok-str">'a'</span>);
    <span class="tok-kw">const</span> p = <span class="tok-kw">async</span>&lt;std.debug.global_allocator&gt; amain() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    seq(<span class="tok-str">'f'</span>);
    <span class="tok-kw">resume</span> a_promise;
    seq(<span class="tok-str">'i'</span>);
    assert(final_result == <span class="tok-number">1234</span>);
    assert(std.mem.eql(<span class="tok-type">u8</span>, seq_points, <span class="tok-str">&quot;abcdefghi&quot;</span>));
}
<span class="tok-kw">async</span> <span class="tok-kw">fn</span> <span class="tok-fn">amain</span>() <span class="tok-type">void</span> {
    seq(<span class="tok-str">'b'</span>);
    <span class="tok-kw">const</span> p = <span class="tok-kw">async</span> another() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    seq(<span class="tok-str">'e'</span>);
    final_result = <span class="tok-kw">await</span> p;
    seq(<span class="tok-str">'h'</span>);
}
<span class="tok-kw">async</span> <span class="tok-kw">fn</span> <span class="tok-fn">another</span>() <span class="tok-type">i32</span> {
    seq(<span class="tok-str">'c'</span>);
    <span class="tok-kw">suspend</span> {
        seq(<span class="tok-str">'d'</span>);
        a_promise = <span class="tok-builtin">@handle</span>();
    }
    seq(<span class="tok-str">'g'</span>);
    <span class="tok-kw">return</span> <span class="tok-number">1234</span>;
}

<span class="tok-kw">var</span> seq_points = []<span class="tok-type">u8</span>{<span class="tok-number">0</span>} ** <span class="tok-str">&quot;abcdefghi&quot;</span>.len;
<span class="tok-kw">var</span> seq_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;

<span class="tok-kw">fn</span> <span class="tok-fn">seq</span>(c: <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    seq_points[seq_index] = c;
    seq_index += <span class="tok-number">1</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 coroutine await...OK
All tests passed.
</code></pre>

      <p>
      In general, <code class="zig"><span class="tok-kw">suspend</span></code> is lower level than <code class="zig"><span class="tok-kw">await</span></code>. Most application
              code will use only <code class="zig"><span class="tok-kw">async</span></code> and <code class="zig"><span class="tok-kw">await</span></code>, but event loop
                      implementations will make use of <code class="zig"><span class="tok-kw">suspend</span></code> internally.
      </p>
      
      <h2 id="Open-Issues">Open Issues</h2>

      <p>
      There are a few issues with coroutines that are considered unresolved. Best be aware of them,
      as the situation is likely to change before 1.0.0:
      </p>
      <ul>
          <li>Async functions have optimizations disabled - even in release modes - due to an
              <a href="https://github.com/ziglang/zig/issues/802">LLVM bug</a>.
          </li>
          <li>
              There are some situations where we can know statically that there will not be
              memory allocation failure, but Zig still forces us to handle it.
              TODO file an issue for this and link it here.
          </li>
          <li>
              Zig does not take advantage of LLVM's allocation elision optimization for
              coroutines. It crashed LLVM when I tried to do it the first time. This is
              related to the other 2 bullet points here. See
              <a href="https://github.com/ziglang/zig/issues/802">#802</a>.
          </li>
      </ul>
      
      
      
      <h1 id="Builtin-Functions">Builtin Functions</h1>

      <p>
      Builtin functions are provided by the compiler and are prefixed with <code>@</code>.
      The <code class="zig"><span class="tok-kw">comptime</span></code> keyword on a parameter means that the parameter must be known
      at compile time.
      </p>
      <h2 id="addWithOverflow">@addWithOverflow</h2>

      <pre><code class="zig"><span class="tok-builtin">@addWithOverflow</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T, result: *T) <span class="tok-type">bool</span></code></pre>
      <p>
      Performs <code class="zig">result.* = a + b</code>. If overflow or underflow occurs,
          stores the overflowed bits in <code class="zig">result</code> and returns <code class="zig"><span class="tok-null">true</span></code>.
                  If no overflow or underflow occurs, returns <code class="zig"><span class="tok-null">false</span></code>.
      </p>
      
      <h2 id="ArgType">@ArgType</h2>

      <pre><code class="zig"><span class="tok-builtin">@ArgType</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <span class="tok-type">type</span></code></pre>
      <p>
      This builtin function takes a function type and returns the type of the parameter at index <code class="zig">n</code>.
      </p>
      <p>
      <code class="zig">T</code> must be a function type.
      </p>
      <p>
      Note: This function is deprecated. Use <a href="#typeInfo">@typeInfo</a> instead.
      </p>
      
      <h2 id="atomicLoad">@atomicLoad</h2>

      <pre><code class="zig"><span class="tok-builtin">@atomicLoad</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *<span class="tok-kw">const</span> T, <span class="tok-kw">comptime</span> ordering: builtin.AtomicOrder) T</code></pre>
      <p>
      This builtin function atomically dereferences a pointer and returns the value.
      </p>
      <p>
      <code class="zig">T</code> must be a pointer type, a <code class="zig"><span class="tok-type">bool</span></code>,
      or an integer whose bit count meets these requirements:
      </p>
      <ul>
          <li>At least 8</li>
          <li>At most the same as usize</li>
          <li>Power of 2</li>
      </ul>
      <p>
      TODO right now bool is not accepted. Also I think we could make non powers of 2 work fine, maybe
      we can remove this restriction
      </p>
      
      <h2 id="atomicRmw">@atomicRmw</h2>

      <pre><code class="zig"><span class="tok-builtin">@atomicRmw</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, <span class="tok-kw">comptime</span> op: builtin.AtomicRmwOp, operand: T, <span class="tok-kw">comptime</span> ordering: builtin.AtomicOrder) T</code></pre>
      <p>
      This builtin function atomically modifies memory and then returns the previous value.
      </p>
      <p>
      <code class="zig">T</code> must be a pointer type, a <code class="zig"><span class="tok-type">bool</span></code>,
      or an integer whose bit count meets these requirements:
      </p>
      <ul>
          <li>At least 8</li>
          <li>At most the same as usize</li>
          <li>Power of 2</li>
      </ul>
      <p>
      TODO right now bool is not accepted. Also I think we could make non powers of 2 work fine, maybe
      we can remove this restriction
      </p>
      
      <h2 id="bitCast">@bitCast</h2>

      <pre><code class="zig"><span class="tok-builtin">@bitCast</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, value: <span class="tok-kw">var</span>) DestType</code></pre>
      <p>
      Converts a value of one type to another type.
      </p>
      <p>
      Asserts that <code class="zig"><span class="tok-builtin">@sizeOf</span>(<span class="tok-builtin">@typeOf</span>(value)) == <span class="tok-builtin">@sizeOf</span>(DestType)</code>.
      </p>
      <p>
      Asserts that <code class="zig"><span class="tok-builtin">@typeId</span>(DestType) != <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).TypeId.Pointer</code>. Use <code class="zig"><span class="tok-builtin">@ptrCast</span></code> or <code class="zig"><span class="tok-builtin">@intToPtr</span></code> if you need this.
      </p>
      <p>
      Can be used for these things for example:
      </p>
      <ul>
          <li>Convert <code class="zig"><span class="tok-type">f32</span></code> to <code class="zig"><span class="tok-type">u32</span></code> bits</li>
          <li>Convert <code class="zig"><span class="tok-type">i32</span></code> to <code class="zig"><span class="tok-type">u32</span></code> preserving twos complement</li>
      </ul>
      <p>
      Works at compile-time if <code class="zig">value</code> is known at compile time. It's a compile error to bitcast a struct to a scalar type of the same size since structs have undefined layout. However if the struct is packed then it works.
      </p>
      
      <h2 id="bitOffsetOf">@bitOffsetOf</h2>

      <pre><code class="zig"><span class="tok-builtin">@bitOffsetOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field_name: [] <span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      Returns the bit offset of a field relative to its containing struct.
      </p>
      <p>
      For non <a href="#packed-struct">packed structs</a>, this will always be divisible by <code class="zig"><span class="tok-number">8</span></code>.
      For packed structs, non-byte-aligned fields will share a byte offset, but they will have different
      bit offsets.
      </p>
      <p>See also:</p><ul>
<li><a href="#byteOffsetOf">@byteOffsetOf</a></li>
</ul>

      
      <h2 id="breakpoint">@breakpoint</h2>

      <pre><code class="zig"><span class="tok-builtin">@breakpoint</span>()</code></pre>
      <p>
      This function inserts a platform-specific debug trap instruction which causes
      debuggers to break there.
      </p>
      <p>
      This function is only valid within function scope.
      </p>

      
      <h2 id="byteOffsetOf">@byteOffsetOf</h2>

      <pre><code class="zig"><span class="tok-builtin">@byteOffsetOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field_name: [] <span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      Returns the byte offset of a field relative to its containing struct.
      </p>
      <p>See also:</p><ul>
<li><a href="#bitOffsetOf">@bitOffsetOf</a></li>
</ul>

      
      <h2 id="alignCast">@alignCast</h2>

      <pre><code class="zig"><span class="tok-builtin">@alignCast</span>(<span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>, ptr: <span class="tok-kw">var</span>) <span class="tok-kw">var</span></code></pre>
      <p>
      <code class="zig">ptr</code> can be <code class="zig">*T</code>, <code class="zig"><span class="tok-kw">fn</span>()</code>, <code class="zig">?*T</code>,
                      <code class="zig">?<span class="tok-kw">fn</span>()</code>, or <code class="zig">[]T</code>. It returns the same type as <code class="zig">ptr</code>
      except with the alignment adjusted to the new value.
      </p>
      <p>A <a href="#Incorrect-Pointer-Alignment">pointer alignment safety check</a> is added
      to the generated code to make sure the pointer is aligned as promised.</p>

      
      <h2 id="alignOf">@alignOf</h2>

      <pre><code class="zig"><span class="tok-builtin">@alignOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      This function returns the number of bytes that this type should be aligned to
      for the current target to match the C ABI. When the child type of a pointer has
      this alignment, the alignment can be omitted from the type.
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;
<span class="tok-kw">comptime</span> {
    assert(*<span class="tok-type">u32</span> == *<span class="tok-kw">align</span>(<span class="tok-builtin">@alignOf</span>(<span class="tok-type">u32</span>)) <span class="tok-type">u32</span>);
}</code></pre>
      <p>
      The result is a target-specific compile time constant. It is guaranteed to be
      less than or equal to <a href="#sizeOf">@sizeOf(T)</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Alignment">Alignment</a></li>
</ul>

      

      <h2 id="boolToInt">@boolToInt</h2>

      <pre><code class="zig"><span class="tok-builtin">@boolToInt</span>(value: <span class="tok-type">bool</span>) <span class="tok-type">u1</span></code></pre>
      <p>
      Converts <code class="zig"><span class="tok-null">true</span></code> to <code class="zig"><span class="tok-type">u1</span>(<span class="tok-number">1</span>)</code> and <code class="zig"><span class="tok-null">false</span></code> to
                  <code class="zig"><span class="tok-type">u1</span>(<span class="tok-number">0</span>)</code>.
      </p>
      <p>
      If the value is known at compile-time, the return type is <code class="zig"><span class="tok-type">comptime_int</span></code>
          instead of <code class="zig"><span class="tok-type">u1</span></code>.
      </p>
      

      <h2 id="bytesToSlice">@bytesToSlice</h2>

      <pre><code class="zig"><span class="tok-builtin">@bytesToSlice</span>(<span class="tok-kw">comptime</span> Element: <span class="tok-type">type</span>, bytes: []<span class="tok-type">u8</span>) []Element</code></pre>
      <p>
      Converts a slice of bytes or array of bytes into a slice of <code class="zig">Element</code>.
      The resulting slice has the same <a href="#Pointers">pointer</a> properties as the parameter.
      </p>
      <p>
      Attempting to convert a number of bytes with a length that does not evenly divide into a slice of
      elements results in safety-protected <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      

      <h2 id="cDefine">@cDefine</h2>

      <pre><code class="zig"><span class="tok-builtin">@cDefine</span>(<span class="tok-kw">comptime</span> name: []<span class="tok-type">u8</span>, value)</code></pre>
      <p>
      This function can only occur inside <code class="zig"><span class="tok-builtin">@cImport</span></code>.
      </p>
      <p>
      This appends <code>#define $name $value</code> to the <code class="zig"><span class="tok-builtin">@cImport</span></code>
      temporary buffer.
      </p>
      <p>
      To define without a value, like this:
      </p>
      <pre><code class="c">#define _GNU_SOURCE</code></pre>
      <p>
      Use the void value, like this:
      </p>
      <pre><code class="zig"><span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;_GNU_SOURCE&quot;</span>, {})</code></pre>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cInclude">@cInclude</a></li>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cUndef">@cUndef</a></li>
<li><a href="#void">void</a></li>
</ul>

      
      <h2 id="cImport">@cImport</h2>

      <pre><code class="zig"><span class="tok-builtin">@cImport</span>(expression) (namespace)</code></pre>
      <p>
      This function parses C code and imports the functions, types, variables, and
      compatible macro definitions into the result namespace.
      </p>
      <p>
      <code class="zig">expression</code> is interpreted at compile time. The builtin functions
          <code class="zig"><span class="tok-builtin">@cInclude</span></code>, <code class="zig"><span class="tok-builtin">@cDefine</span></code>, and <code class="zig"><span class="tok-builtin">@cUndef</span></code> work
      within this expression, appending to a temporary buffer which is then parsed as C code.
      </p>
      <p>
      Usually you should only have one <code class="zig"><span class="tok-builtin">@cImport</span></code> in your entire application, because it saves the compiler
      from invoking clang multiple times, and prevents inline functions from being duplicated.
      </p>
      <p>
      Reasons for having multiple <code class="zig"><span class="tok-builtin">@cImport</span></code> expressions would be:
      </p>
      <ul>
          <li>To avoid a symbol collision, for example if foo.h and bar.h both <code>#define CONNECTION_COUNT</code></li>
        <li>To analyze the C code with different preprocessor defines</li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cInclude">@cInclude</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cUndef">@cUndef</a></li>
</ul>

      
      <h2 id="cInclude">@cInclude</h2>

      <pre><code class="zig"><span class="tok-builtin">@cInclude</span>(<span class="tok-kw">comptime</span> path: []<span class="tok-type">u8</span>)</code></pre>
      <p>
      This function can only occur inside <code class="zig"><span class="tok-builtin">@cImport</span></code>.
      </p>
      <p>
      This appends <code>#include <$path>\n</code> to the <code class="zig">c_import</code>
      temporary buffer.
      </p>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cUndef">@cUndef</a></li>
</ul>

      
      <h2 id="cUndef">@cUndef</h2>

      <pre><code class="zig"><span class="tok-builtin">@cUndef</span>(<span class="tok-kw">comptime</span> name: []<span class="tok-type">u8</span>)</code></pre>
      <p>
      This function can only occur inside <code class="zig"><span class="tok-builtin">@cImport</span></code>.
      </p>
      <p>
      This appends <code>#undef $name</code> to the <code class="zig"><span class="tok-builtin">@cImport</span></code>
      temporary buffer.
      </p>
      <p>See also:</p><ul>
<li><a href="#Import-from-C-Header-File">Import from C Header File</a></li>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cInclude">@cInclude</a></li>
</ul>

      
      <h2 id="clz">@clz</h2>

      <pre><code class="zig"><span class="tok-builtin">@clz</span>(x: T) U</code></pre>
      <p>
      This function counts the number of leading zeroes in <code class="zig">x</code> which is an integer
          type <code class="zig">T</code>.
      </p>
      <p>
      The return type <code class="zig">U</code> is an unsigned integer with the minimum number
          of bits that can represent the value <code class="zig">T.bit_count</code>.
      </p>
      <p>
      If <code class="zig">x</code> is zero, <code class="zig"><span class="tok-builtin">@clz</span></code> returns <code class="zig">T.bit_count</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#ctz">@ctz</a></li>
<li><a href="#popCount">@popCount</a></li>
</ul>

      
      <h2 id="cmpxchgStrong">@cmpxchgStrong</h2>

      <pre><code class="zig"><span class="tok-builtin">@cmpxchgStrong</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T</code></pre>
      <p>
      This function performs a strong atomic compare exchange operation. It's the equivalent of this code,
      except atomic:
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">cmpxchgStrongButNotAtomic</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T) ?T {
    <span class="tok-kw">const</span> old_value = ptr.*;
    <span class="tok-kw">if</span> (old_value == expected_value) {
        ptr.* = new_value;
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> old_value;
    }
}</code></pre>
      <p>
      If you are using cmpxchg in a loop, <a href="#cmpxchgWeak">@cmpxchgWeak</a> is the better choice, because it can be implemented
      more efficiently in machine instructions.
      </p>
      <p>
      <code class="zig">AtomicOrder</code> can be found with <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).AtomicOrder</code>.
      </p>
      <p><code class="zig"><span class="tok-builtin">@typeOf</span>(ptr).alignment</code> must be <code class="zig">&gt;= <span class="tok-builtin">@sizeOf</span>(T).</code></p>
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
<li><a href="#cmpxchgWeak">cmpxchgWeak</a></li>
</ul>

      
      <h2 id="cmpxchgWeak">@cmpxchgWeak</h2>

      <pre><code class="zig"><span class="tok-builtin">@cmpxchgWeak</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T</code></pre>
      <p>
      This function performs a weak atomic compare exchange operation. It's the equivalent of this code,
      except atomic:
      </p>
      <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">cmpxchgWeakButNotAtomic</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, ptr: *T, expected_value: T, new_value: T) ?T {
    <span class="tok-kw">const</span> old_value = ptr.*;
    <span class="tok-kw">if</span> (old_value == expected_value <span class="tok-kw">and</span> usuallyTrueButSometimesFalse()) {
        ptr.* = new_value;
        <span class="tok-kw">return</span> <span class="tok-null">null</span>;
    } <span class="tok-kw">else</span> {
        <span class="tok-kw">return</span> old_value;
    }
}</code></pre>
      <p>
      If you are using cmpxchg in a loop, the sporadic failure will be no problem, and <code class="zig">cmpxchgWeak</code>
      is the better choice, because it can be implemented more efficiently in machine instructions.
      However if you need a stronger guarantee, use <a href="#cmpxchgStrong">@cmpxchgStrong</a>.
      </p>
      <p>
      <code class="zig">AtomicOrder</code> can be found with <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).AtomicOrder</code>.
      </p>
      <p><code class="zig"><span class="tok-builtin">@typeOf</span>(ptr).alignment</code> must be <code class="zig">&gt;= <span class="tok-builtin">@sizeOf</span>(T).</code></p>
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
<li><a href="#cmpxchgStrong">cmpxchgStrong</a></li>
</ul>

      
      <h2 id="compileError">@compileError</h2>

      <pre><code class="zig"><span class="tok-builtin">@compileError</span>(<span class="tok-kw">comptime</span> msg: []<span class="tok-type">u8</span>)</code></pre>
      <p>
      This function, when semantically analyzed, causes a compile error with the
      message <code class="zig">msg</code>.
      </p>
      <p>
      There are several ways that code avoids being semantically checked, such as
      using <code class="zig"><span class="tok-kw">if</span></code> or <code class="zig"><span class="tok-kw">switch</span></code> with compile time constants,
              and <code class="zig"><span class="tok-kw">comptime</span></code> functions.
      </p>
      
      <h2 id="compileLog">@compileLog</h2>

      <pre><code class="zig"><span class="tok-builtin">@compileLog</span>(args: ...)</code></pre>
      <p>
      This function prints the arguments passed to it at compile-time.
      </p>
      <p>
      To prevent accidentally leaving compile log statements in a codebase,
      a compilation error is added to the build, pointing to the compile
      log statement. This error prevents code from being generated, but
      does not otherwise interfere with analysis.
      </p>
      <p>
      This function can be used to do "printf debugging" on
      compile-time executing code.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> warn = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.warn;

<span class="tok-kw">const</span> num1 = blk: {
    <span class="tok-kw">var</span> val1: <span class="tok-type">i32</span> = <span class="tok-number">99</span>;
    <span class="tok-builtin">@compileLog</span>(<span class="tok-str">&quot;comptime val1 = &quot;</span>, val1); 
    val1 = val1 + <span class="tok-number">1</span>;
    <span class="tok-kw">break</span> :blk val1;
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;main&quot;</span> {
    <span class="tok-builtin">@compileLog</span>(<span class="tok-str">&quot;comptime in main&quot;</span>); 

    warn(<span class="tok-str">&quot;Runtime in main, num1 = {}.\n&quot;</span>, num1);
}</code></pre><pre><code class="shell">$ zig test test.zig
| &quot;comptime in main&quot;
| &quot;comptime val1 = &quot;, 99
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:11:5: </span><span class="t31_1">error:</span><span class="t0_1"> found compile log statement</span>
    @compileLog(&quot;comptime in main&quot;); 
    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:5: </span><span class="t31_1">error:</span><span class="t0_1"> found compile log statement</span>
    @compileLog(&quot;comptime val1 = &quot;, val1); 
    <span class="t32_1">^</span>
</code></pre>

      </p>
      <p>
      will ouput:
      </p>
      <p>
      If all <code class="zig"><span class="tok-builtin">@compileLog</span></code> calls are removed or 
      not encountered by analysis, the
      program compiles successfully and the generated executable prints:
      </p>  
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> warn = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.warn;

<span class="tok-kw">const</span> num1 = blk: {
    <span class="tok-kw">var</span> val1: <span class="tok-type">i32</span> = <span class="tok-number">99</span>;
    val1 = val1 + <span class="tok-number">1</span>;
    <span class="tok-kw">break</span> :blk val1;
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;main&quot;</span> {
    warn(<span class="tok-str">&quot;Runtime in main, num1 = {}.\n&quot;</span>, num1);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 main...Runtime in main, num1 = 100.
OK
All tests passed.
</code></pre>

      
      <h2 id="ctz">@ctz</h2>

      <pre><code class="zig"><span class="tok-builtin">@ctz</span>(x: T) U</code></pre>
      <p>
      This function counts the number of trailing zeroes in <code class="zig">x</code> which is an integer
          type <code class="zig">T</code>.
      </p>
      <p>
      The return type <code class="zig">U</code> is an unsigned integer with the minimum number
          of bits that can represent the value <code class="zig">T.bit_count</code>.
      </p>
      <p>
      If <code class="zig">x</code> is zero, <code class="zig"><span class="tok-builtin">@ctz</span></code> returns <code class="zig">T.bit_count</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#clz">@clz</a></li>
<li><a href="#popCount">@popCount</a></li>
</ul>

      
      <h2 id="divExact">@divExact</h2>

      <pre><code class="zig"><span class="tok-builtin">@divExact</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      Exact division. Caller guarantees <code class="zig">denominator != <span class="tok-number">0</span></code> and
          <code class="zig"><span class="tok-builtin">@divTrunc</span>(numerator, denominator) * denominator == numerator</code>.
      </p>
      <ul>
          <li><code class="zig"><span class="tok-builtin">@divExact</span>(<span class="tok-number">6</span>, <span class="tok-number">3</span>) == <span class="tok-number">2</span></code></li>
          <li><code class="zig"><span class="tok-builtin">@divExact</span>(a, b) * b == a</code></li>
      </ul>
      <p>For a function that returns a possible error code, use <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divExact</code>.</p>
      <p>See also:</p><ul>
<li><a href="#divTrunc">@divTrunc</a></li>
<li><a href="#divFloor">@divFloor</a></li>
</ul>

      
      <h2 id="divFloor">@divFloor</h2>

      <pre><code class="zig"><span class="tok-builtin">@divFloor</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      Floored division. Rounds toward negative infinity. For unsigned integers it is
      the same as <code class="zig">numerator / denominator</code>. Caller guarantees <code class="zig">denominator != <span class="tok-number">0</span></code> and
              <code class="zig">!(<span class="tok-builtin">@typeId</span>(T) == builtin.TypeId.Int <span class="tok-kw">and</span> T.is_signed <span class="tok-kw">and</span> numerator == <span class="tok-builtin">@minValue</span>(T) <span class="tok-kw">and</span> denominator == -<span class="tok-number">1</span>)</code>.
      </p>
      <ul>
          <li><code class="zig"><span class="tok-builtin">@divFloor</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == -<span class="tok-number">2</span></code></li>
          <li><code class="zig"><span class="tok-builtin">@divFloor</span>(a, b) + <span class="tok-builtin">@mod</span>(a, b) == a</code></li>
      </ul>
      <p>For a function that returns a possible error code, use <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divFloor</code>.</p>
      <p>See also:</p><ul>
<li><a href="#divTrunc">@divTrunc</a></li>
<li><a href="#divExact">@divExact</a></li>
</ul>

      
      <h2 id="divTrunc">@divTrunc</h2>

      <pre><code class="zig"><span class="tok-builtin">@divTrunc</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      Truncated division. Rounds toward zero. For unsigned integers it is
      the same as <code class="zig">numerator / denominator</code>. Caller guarantees <code class="zig">denominator != <span class="tok-number">0</span></code> and
              <code class="zig">!(<span class="tok-builtin">@typeId</span>(T) == builtin.TypeId.Int <span class="tok-kw">and</span> T.is_signed <span class="tok-kw">and</span> numerator == <span class="tok-builtin">@minValue</span>(T) <span class="tok-kw">and</span> denominator == -<span class="tok-number">1</span>)</code>.
      </p>
      <ul>
          <li><code class="zig"><span class="tok-builtin">@divTrunc</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == -<span class="tok-number">1</span></code></li>
          <li><code class="zig"><span class="tok-builtin">@divTrunc</span>(a, b) + <span class="tok-builtin">@rem</span>(a, b) == a</code></li>
      </ul>
      <p>For a function that returns a possible error code, use <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divTrunc</code>.</p>
      <p>See also:</p><ul>
<li><a href="#divFloor">@divFloor</a></li>
<li><a href="#divExact">@divExact</a></li>
</ul>

      
      <h2 id="embedFile">@embedFile</h2>

      <pre><code class="zig"><span class="tok-builtin">@embedFile</span>(<span class="tok-kw">comptime</span> path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) [X]<span class="tok-type">u8</span></code></pre>
      <p>
      This function returns a compile time constant fixed-size array with length
      equal to the byte count of the file given by <code class="zig">path</code>. The contents of the array
      are the contents of the file.
      </p>
      <p>
      <code class="zig">path</code> is absolute or relative to the current file, just like <code class="zig"><span class="tok-builtin">@import</span></code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#import">@import</a></li>
</ul>

      

      <h2 id="enumToInt">@enumToInt</h2>

      <pre><code class="zig"><span class="tok-builtin">@enumToInt</span>(enum_value: <span class="tok-kw">var</span>) <span class="tok-kw">var</span></code></pre>
      <p>
      Converts an enumeration value into its integer tag type.
      </p>
      <p>
      If the enum has only 1 possible value, the resut is a <code class="zig"><span class="tok-type">comptime_int</span></code>
      known at <a href="#comptime">comptime</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#intToEnum">@intToEnum</a></li>
</ul>

      

      <h2 id="errSetCast">@errSetCast</h2>

      <pre><code class="zig"><span class="tok-builtin">@errSetCast</span>(<span class="tok-kw">comptime</span> T: DestType, value: <span class="tok-kw">var</span>) DestType</code></pre>
      <p>
      Converts an error value from one error set to another error set. Attempting to convert an error
      which is not in the destination error set results in safety-protected <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      

      <h2 id="errorName">@errorName</h2>

      <pre><code class="zig"><span class="tok-builtin">@errorName</span>(err: <span class="tok-kw">error</span>) []<span class="tok-type">u8</span></code></pre>
      <p>
      This function returns the string representation of an error. If an error
      declaration is:
      </p>
      <pre><code class="zig"><span class="tok-kw">error</span> OutOfMem</code></pre>
      <p>
      Then the string representation is <code class="zig"><span class="tok-str">&quot;OutOfMem&quot;</span></code>.
      </p>
      <p>
      If there are no calls to <code class="zig"><span class="tok-builtin">@errorName</span></code> in an entire application,
          or all calls have a compile-time known value for <code class="zig">err</code>, then no
      error name table will be generated.
      </p>
      

      <h2 id="errorReturnTrace">@errorReturnTrace</h2>

      <pre><code class="zig"><span class="tok-builtin">@errorReturnTrace</span>() ?*builtin.StackTrace</code></pre>
      <p>
      If the binary is built with error return tracing, and this function is invoked in a
      function that calls a function with an error or error union return type, returns a
      stack trace object. Otherwise returns `null`.
      </p>
      

      <h2 id="errorToInt">@errorToInt</h2>

      <pre><code class="zig"><span class="tok-builtin">@errorToInt</span>(err: <span class="tok-kw">var</span>) <span class="tok-builtin">@IntType</span>(<span class="tok-null">false</span>, <span class="tok-builtin">@sizeOf</span>(<span class="tok-kw">error</span>) * <span class="tok-number">8</span>)</code></pre>
      <p>
      Supports the following types:
      </p>
      <ul>
          <li>error unions</li>
          <li><code class="zig">E!<span class="tok-type">void</span></code></li>
      </ul>
      <p>
      Converts an error to the integer representation of an error.
      </p>
      <p>
      It is generally recommended to avoid this
      cast, as the integer representation of an error is not stable across source code changes.
      </p>
      <p>See also:</p><ul>
<li><a href="#intToError">@intToError</a></li>
</ul>

      

      <h2 id="export">@export</h2>

      <pre><code class="zig"><span class="tok-builtin">@export</span>(<span class="tok-kw">comptime</span> name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, target: <span class="tok-kw">var</span>, linkage: builtin.GlobalLinkage) []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre>
      <p>
      Creates a symbol in the output object file.
      </p>
      

      <h2 id="fence">@fence</h2>

      <pre><code class="zig"><span class="tok-builtin">@fence</span>(order: AtomicOrder)</code></pre>
      <p>
      The <code class="zig">fence</code> function is used to introduce happens-before edges between operations.
      </p>
      <p>
      <code class="zig">AtomicOrder</code> can be found with <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).AtomicOrder</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
</ul>

      

      <h2 id="field">@field</h2>

      <pre><code class="zig"><span class="tok-builtin">@field</span>(lhs: <span class="tok-kw">var</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) (field)</code></pre>
      <p>Preforms field access equivalent to <code class="zig">lhs.field_name</code>, except instead
      of the field <code class="zig"><span class="tok-str">&quot;field_name&quot;</span></code>, it accesses the field named by the string
      value of <code class="zig">field_name</code>.
      </p>
      

      <h2 id="fieldParentPtr">@fieldParentPtr</h2>

      <pre><code class="zig"><span class="tok-builtin">@fieldParentPtr</span>(<span class="tok-kw">comptime</span> ParentType: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> field_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    field_ptr: *T) *ParentType</code></pre>
      <p>
      Given a pointer to a field, returns the base pointer of a struct.
      </p>
      

      <h2 id="floatCast">@floatCast</h2>

      <pre><code class="zig"><span class="tok-builtin">@floatCast</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, value: <span class="tok-kw">var</span>) DestType</code></pre>
      <p>
      Convert from one float type to another. This cast is safe, but may cause the
      numeric value to lose precision.
      </p>
      

      <h2 id="floatToInt">@floatToInt</h2>

      <pre><code class="zig"><span class="tok-builtin">@floatToInt</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, float: <span class="tok-kw">var</span>) DestType</code></pre>
      <p>
      Converts the integer part of a floating point number to the destination type.
      </p>
      <p>
      If the integer part of the floating point number cannot fit in the destination type,
      it invokes safety-checked <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#intToFloat">@intToFloat</a></li>
</ul>

      

      <h2 id="frameAddress">@frameAddress</h2>

      <pre><code class="zig"><span class="tok-builtin">@frameAddress</span>()</code></pre>
      <p>
      This function returns the base pointer of the current stack frame.
      </p>
      <p>
      The implications of this are target specific and not consistent across all
      platforms. The frame address may not be available in release mode due to
      aggressive optimizations.
      </p>
      <p>
      This function is only valid within function scope.
      </p>
      
      <h2 id="handle">@handle</h2>

      <pre><code class="zig"><span class="tok-builtin">@handle</span>()</code></pre>
      <p>
      This function returns a <code class="zig"><span class="tok-kw">promise</span>-&gt;T</code> type, where <code class="zig">T</code>
      is the return type of the async function in scope.
      </p>
      <p>
      This function is only valid within an async function scope.
      </p>
      
      <h2 id="import">@import</h2>

      <pre><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-kw">comptime</span> path: []<span class="tok-type">u8</span>) (namespace)</code></pre>
      <p>
      This function finds a zig file corresponding to <code class="zig">path</code> and imports all the
      public top level declarations into the resulting namespace.
      </p>
      <p>
      <code class="zig">path</code> can be a relative or absolute path, or it can be the name of a package.
          If it is a relative path, it is relative to the file that contains the <code class="zig"><span class="tok-builtin">@import</span></code>
      function call.
      </p>
      <p>
      The following packages are always available:
      </p>
      <ul>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>)</code> - Zig Standard Library</li>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>)</code> - Compiler-provided types and variables</li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
<li><a href="#embedFile">@embedFile</a></li>
</ul>

      
      <h2 id="inlineCall">@inlineCall</h2>

      <pre><code class="zig"><span class="tok-builtin">@inlineCall</span>(function: X, args: ...) Y</code></pre>
      <p>
      This calls a function, in the same way that invoking an expression with parentheses does:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;inline function call&quot;</span> {
    assert(<span class="tok-builtin">@inlineCall</span>(add, <span class="tok-number">3</span>, <span class="tok-number">9</span>) == <span class="tok-number">12</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> { <span class="tok-kw">return</span> a + b; }</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 inline function call...OK
All tests passed.
</code></pre>

      <p>
      Unlike a normal function call, however, <code class="zig"><span class="tok-builtin">@inlineCall</span></code> guarantees that the call
      will be inlined. If the call cannot be inlined, a compile error is emitted.
      </p>
      <p>See also:</p><ul>
<li><a href="#noInlineCall">@noInlineCall</a></li>
</ul>

      

      <h2 id="intCast">@intCast</h2>

      <pre><code class="zig"><span class="tok-builtin">@intCast</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, int: <span class="tok-kw">var</span>) DestType</code></pre>
      <p>
      Converts an integer to another integer while keeping the same numerical value.
      Attempting to convert a number which is out of range of the destination type results in
      safety-protected <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      

      <h2 id="intToEnum">@intToEnum</h2>

      <pre><code class="zig"><span class="tok-builtin">@intToEnum</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, int_value: <span class="tok-builtin">@TagType</span>(DestType)) DestType</code></pre>
      <p>
      Converts an integer into an <a href="#enum">enum</a> value.
      </p>
      <p>
      Attempting to convert an integer which represents no value in the chosen enum type invokes
      safety-checked <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#enumToInt">@enumToInt</a></li>
</ul>

      

      <h2 id="intToError">@intToError</h2>

      <pre><code class="zig"><span class="tok-builtin">@intToError</span>(value: <span class="tok-builtin">@IntType</span>(<span class="tok-null">false</span>, <span class="tok-builtin">@sizeOf</span>(<span class="tok-kw">error</span>) * <span class="tok-number">8</span>)) <span class="tok-kw">error</span></code></pre>
      <p>
      Converts from the integer representation of an error into the global error set type.
      </p>
      <p>
      It is generally recommended to avoid this
      cast, as the integer representation of an error is not stable across source code changes.
      </p>
      <p>
      Attempting to convert an integer that does not correspond to any error results in
      safety-protected <a href="#Undefined-Behavior">Undefined Behavior</a>.
      </p>
      <p>See also:</p><ul>
<li><a href="#errorToInt">@errorToInt</a></li>
</ul>

      

      <h2 id="intToFloat">@intToFloat</h2>

      <pre><code class="zig"><span class="tok-builtin">@intToFloat</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, int: <span class="tok-kw">var</span>) DestType</code></pre>
      <p>
      Converts an integer to the closest floating point representation. To convert the other way, use <a href="#floatToInt">@floatToInt</a>. This cast is always safe.
      </p>
      

      <h2 id="intToPtr">@intToPtr</h2>

      <pre><code class="zig"><span class="tok-builtin">@intToPtr</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, int: <span class="tok-type">usize</span>) DestType</code></pre>
      <p>
      Converts an integer to a pointer. To convert the other way, use <a href="#ptrToInt">@ptrToInt</a>.
      </p>
      

      <h2 id="IntType">@IntType</h2>

      <pre><code class="zig"><span class="tok-builtin">@IntType</span>(<span class="tok-kw">comptime</span> is_signed: <span class="tok-type">bool</span>, <span class="tok-kw">comptime</span> bit_count: <span class="tok-type">u32</span>) <span class="tok-type">type</span></code></pre>
      <p>
      This function returns an integer type with the given signness and bit count.
      </p>
      
      <h2 id="maxValue">@maxValue</h2>

      <pre><code class="zig"><span class="tok-builtin">@maxValue</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      This function returns the maximum value of the integer type <code class="zig">T</code>.
      </p>
      <p>
      The result is a compile time constant.
      </p>
      
      <h2 id="memberCount">@memberCount</h2>

      <pre><code class="zig"><span class="tok-builtin">@memberCount</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      This function returns the number of members in a struct, enum, or union type.
      </p>
      <p>
      The result is a compile time constant.
      </p>
      <p>
      It does not include functions, variables, or constants.
      </p>
      
      <h2 id="memberName">@memberName</h2>

      <pre><code class="zig"><span class="tok-builtin">@memberName</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> index: <span class="tok-type">usize</span>) [N]<span class="tok-type">u8</span></code></pre>
      <p>Returns the field name of a struct, union, or enum.</p>
      <p>
      The result is a compile time constant.
      </p>
      <p>
      It does not include functions, variables, or constants.
      </p>
      
      <h2 id="memberType">@memberType</h2>

      <pre><code class="zig"><span class="tok-builtin">@memberType</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> index: <span class="tok-type">usize</span>) <span class="tok-type">type</span></code></pre>
      <p>Returns the field type of a struct or union.</p>
      
      <h2 id="memcpy">@memcpy</h2>

      <pre><code class="zig"><span class="tok-builtin">@memcpy</span>(<span class="tok-kw">noalias</span> dest: [*]<span class="tok-type">u8</span>, <span class="tok-kw">noalias</span> source: [*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, byte_count: <span class="tok-type">usize</span>)</code></pre>
      <p>
      This function copies bytes from one region of memory to another. <code class="zig">dest</code> and
          <code class="zig">source</code> are both pointers and must not overlap.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms. Most code
      should not use this function, instead using something like this:
      </p>
      <pre><code class="zig"><span class="tok-kw">for</span> (source[<span class="tok-number">0</span>...byte_count]) |b, i| dest[i] = b;</code></pre>
      <p>
      The optimizer is intelligent enough to turn the above snippet into a memcpy.
      </p>
      <p>There is also a standard library function for this:</p>
      <pre><code class="zig"><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;
mem.copy(<span class="tok-type">u8</span>, dest[<span class="tok-number">0</span>...byte_count], source[<span class="tok-number">0</span>...byte_count]);</code></pre>
      
      <h2 id="memset">@memset</h2>

      <pre><code class="zig"><span class="tok-builtin">@memset</span>(dest: [*]<span class="tok-type">u8</span>, c: <span class="tok-type">u8</span>, byte_count: <span class="tok-type">usize</span>)</code></pre>
      <p>
      This function sets a region of memory to <code class="zig">c</code>. <code class="zig">dest</code> is a pointer.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms. Most
      code should not use this function, instead using something like this:
      </p>
      <pre><code class="zig"><span class="tok-kw">for</span> (dest[<span class="tok-number">0</span>...byte_count]) |*b| b.* = c;</code></pre>
      <p>
      The optimizer is intelligent enough to turn the above snippet into a memset.
      </p>
      <p>There is also a standard library function for this:</p>
      <pre><code class="zig"><span class="tok-kw">const</span> mem = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).mem;
mem.set(<span class="tok-type">u8</span>, dest, c);</code></pre>
      
      <h2 id="minValue">@minValue</h2>

      <pre><code class="zig"><span class="tok-builtin">@minValue</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      This function returns the minimum value of the integer type T.
      </p>
      <p>
      The result is a compile time constant.
      </p>
      
      <h2 id="mod">@mod</h2>

      <pre><code class="zig"><span class="tok-builtin">@mod</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      Modulus division. For unsigned integers this is the same as
      <code class="zig">numerator % denominator</code>. Caller guarantees <code class="zig">denominator &amp;gt; <span class="tok-number">0</span></code>.
      </p>
      <ul>
          <li><code class="zig"><span class="tok-builtin">@mod</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == <span class="tok-number">1</span></code></li>
          <li><code class="zig"><span class="tok-builtin">@divFloor</span>(a, b) + <span class="tok-builtin">@mod</span>(a, b) == a</code></li>
      </ul>
      <p>For a function that returns an error code, see <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.mod</code>.</p>
      <p>See also:</p><ul>
<li><a href="#rem">@rem</a></li>
</ul>

      
      <h2 id="mulWithOverflow">@mulWithOverflow</h2>

      <pre><code class="zig"><span class="tok-builtin">@mulWithOverflow</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T, result: *T) <span class="tok-type">bool</span></code></pre>
      <p>
      Performs <code class="zig">result.* = a * b</code>. If overflow or underflow occurs,
          stores the overflowed bits in <code class="zig">result</code> and returns <code class="zig"><span class="tok-null">true</span></code>.
                  If no overflow or underflow occurs, returns <code class="zig"><span class="tok-null">false</span></code>.
      </p>
      
      <h2 id="newStackCall">@newStackCall</h2>

      <pre><code class="zig"><span class="tok-builtin">@newStackCall</span>(new_stack: []<span class="tok-type">u8</span>, function: <span class="tok-kw">var</span>, args: ...) <span class="tok-kw">var</span></code></pre>
      <p>
      This calls a function, in the same way that invoking an expression with parentheses does. However,
      instead of using the same stack as the caller, the function uses the stack provided in the <code class="zig">new_stack</code>
      parameter.
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">var</span> new_stack_bytes: [<span class="tok-number">1024</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;

<span class="tok-kw">test</span> <span class="tok-str">&quot;calling a function with a new stack&quot;</span> {
    <span class="tok-kw">const</span> arg = <span class="tok-number">1234</span>;

    <span class="tok-kw">const</span> a = <span class="tok-builtin">@newStackCall</span>(new_stack_bytes[<span class="tok-number">0</span>..<span class="tok-number">512</span>], targetFunction, arg);
    <span class="tok-kw">const</span> b = <span class="tok-builtin">@newStackCall</span>(new_stack_bytes[<span class="tok-number">512</span>..], targetFunction, arg);
    _ = targetFunction(arg);

    assert(arg == <span class="tok-number">1234</span>);
    assert(a &lt; b);
}

<span class="tok-kw">fn</span> <span class="tok-fn">targetFunction</span>(x: <span class="tok-type">i32</span>) <span class="tok-type">usize</span> {
    assert(x == <span class="tok-number">1234</span>);

    <span class="tok-kw">var</span> local_variable: <span class="tok-type">i32</span> = <span class="tok-number">42</span>;
    <span class="tok-kw">const</span> ptr = &amp;local_variable;
    ptr.* += <span class="tok-number">1</span>;

    assert(local_variable == <span class="tok-number">43</span>);
    <span class="tok-kw">return</span> <span class="tok-builtin">@ptrToInt</span>(ptr);
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 calling a function with a new stack...OK
All tests passed.
</code></pre>

      
      <h2 id="noInlineCall">@noInlineCall</h2>

      <pre><code class="zig"><span class="tok-builtin">@noInlineCall</span>(function: <span class="tok-kw">var</span>, args: ...) <span class="tok-kw">var</span></code></pre>
      <p>
      This calls a function, in the same way that invoking an expression with parentheses does:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;noinline function call&quot;</span> {
    assert(<span class="tok-builtin">@noInlineCall</span>(add, <span class="tok-number">3</span>, <span class="tok-number">9</span>) == <span class="tok-number">12</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a + b;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 noinline function call...OK
All tests passed.
</code></pre>

      <p>
      Unlike a normal function call, however, <code class="zig"><span class="tok-builtin">@noInlineCall</span></code> guarantees that the call
      will not be inlined. If the call must be inlined, a compile error is emitted.
      </p>
      <p>See also:</p><ul>
<li><a href="#inlineCall">@inlineCall</a></li>
</ul>

      
      <h2 id="OpaqueType">@OpaqueType</h2>

      <pre><code class="zig"><span class="tok-builtin">@OpaqueType</span>() <span class="tok-type">type</span></code></pre>
      <p>
      Creates a new type with an unknown (but non-zero) size and alignment.
      </p>
      <p>
      This is typically used for type safety when interacting with C code that does not expose struct details.
      Example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Derp = <span class="tok-builtin">@OpaqueType</span>();
<span class="tok-kw">const</span> Wat = <span class="tok-builtin">@OpaqueType</span>();

<span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(d: *Derp) <span class="tok-type">void</span>;
<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(w: *Wat) <span class="tok-type">void</span> {
    bar(w);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;call foo&quot;</span> {
    foo(<span class="tok-null">undefined</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:6:9: </span><span class="t31_1">error:</span><span class="t0_1"> expected type '*Derp', found '*Wat'</span>
    bar(w);
        <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:6:9: </span><span class="t36_1">note:</span><span class="t0_1"> pointer type child 'Wat' cannot cast into pointer type child 'Derp'</span>
    bar(w);
        <span class="t32_1">^</span>
</code></pre>

      
      <h2 id="panic">@panic</h2>

      <pre><code class="zig"><span class="tok-builtin">@panic</span>(message: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">noreturn</span></code></pre>
      <p>
      Invokes the panic handler function. By default the panic handler function
      calls the public <code class="zig">panic</code> function exposed in the root source file, or
          if there is not one specified, invokes the one provided in <code class="zig">std/special/panic.zig</code>.
      </p>
      <p>Generally it is better to use <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.panic</code>.
          However, <code class="zig"><span class="tok-builtin">@panic</span></code> can be useful for 2 scenarios:
      </p>
      <ul>
        <li>From library code, calling the programmer's panic function if they exposed one in the root source file.</li>
        <li>When mixing C and Zig code, calling the canonical panic implementation across multiple .o files.</li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Root-Source-File">Root Source File</a></li>
</ul>

      
      <h2 id="popCount">@popCount</h2>

      <pre><code class="zig"><span class="tok-builtin">@popCount</span>(integer: <span class="tok-kw">var</span>) <span class="tok-kw">var</span></code></pre>
      <p>Counts the number of bits set in an integer.</p>
      <p>
      If <code class="zig">integer</code> is known at <a href="#comptime">comptime</a>, the return type is <code class="zig"><span class="tok-type">comptime_int</span></code>.
      Otherwise, the return type is an unsigned integer with the minimum number
      of bits that can represent the bit count of the integer type.
      </p>
      <p>See also:</p><ul>
<li><a href="#ctz">@ctz</a></li>
<li><a href="#clz">@clz</a></li>
</ul>

      
      <h2 id="ptrCast">@ptrCast</h2>

      <pre><code class="zig"><span class="tok-builtin">@ptrCast</span>(<span class="tok-kw">comptime</span> DestType: <span class="tok-type">type</span>, value: <span class="tok-kw">var</span>) DestType</code></pre>
      <p>
      Converts a pointer of one type to a pointer of another type.
      </p>
      
      <h2 id="ptrToInt">@ptrToInt</h2>

      <pre><code class="zig"><span class="tok-builtin">@ptrToInt</span>(value: <span class="tok-kw">var</span>) <span class="tok-type">usize</span></code></pre>
      <p>
      Converts <code class="zig">value</code> to a <code class="zig"><span class="tok-type">usize</span></code> which is the address of the pointer. <code class="zig">value</code> can be one of these types:
      </p>
      <ul>
          <li><code class="zig">*T</code></li>
          <li><code class="zig">?*T</code></li>
          <li><code class="zig"><span class="tok-kw">fn</span>()</code></li>
          <li><code class="zig">?<span class="tok-kw">fn</span>()</code></li>
      </ul>
      <p>To convert the other way, use <a href="#intToPtr">@intToPtr</a></p>

      
      <h2 id="rem">@rem</h2>

      <pre><code class="zig"><span class="tok-builtin">@rem</span>(numerator: T, denominator: T) T</code></pre>
      <p>
      Remainder division. For unsigned integers this is the same as
      <code class="zig">numerator % denominator</code>. Caller guarantees <code class="zig">denominator &gt; <span class="tok-number">0</span></code>.
      </p>
      <ul>
          <li><code class="zig"><span class="tok-builtin">@rem</span>(-<span class="tok-number">5</span>, <span class="tok-number">3</span>) == -<span class="tok-number">2</span></code></li>
          <li><code class="zig"><span class="tok-builtin">@divTrunc</span>(a, b) + <span class="tok-builtin">@rem</span>(a, b) == a</code></li>
      </ul>
      <p>For a function that returns an error code, see <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.rem</code>.</p>
      <p>See also:</p><ul>
<li><a href="#mod">@mod</a></li>
</ul>

      
      <h2 id="returnAddress">@returnAddress</h2>

      <pre><code class="zig"><span class="tok-builtin">@returnAddress</span>()</code></pre>
      <p>
      This function returns a pointer to the return address of the current stack
      frame.
      </p>
      <p>
      The implications of this are target specific and not consistent across
      all platforms.
      </p>
      <p>
      This function is only valid within function scope.
      </p>
      
      <h2 id="setAlignStack">@setAlignStack</h2>

      <pre><code class="zig"><span class="tok-builtin">@setAlignStack</span>(<span class="tok-kw">comptime</span> alignment: <span class="tok-type">u29</span>)</code></pre>
      <p>
      Ensures that a function will have a stack alignment of at least <code class="zig">alignment</code> bytes.
      </p>
      
      <h2 id="setCold">@setCold</h2>

      <pre><code class="zig"><span class="tok-builtin">@setCold</span>(is_cold: <span class="tok-type">bool</span>)</code></pre>
      <p>
      Tells the optimizer that a function is rarely called.
      </p>
      
      <h2 id="setRuntimeSafety">@setRuntimeSafety</h2>

      <pre><code class="zig"><span class="tok-builtin">@setRuntimeSafety</span>(safety_on: <span class="tok-type">bool</span>)</code></pre>
      <p>
      Sets whether runtime safety checks are on for the scope that contains the function call.
      </p>

      
      <h2 id="setEvalBranchQuota">@setEvalBranchQuota</h2>

      <pre><code class="zig"><span class="tok-builtin">@setEvalBranchQuota</span>(new_quota: <span class="tok-type">usize</span>)</code></pre>
      <p>
      Changes the maximum number of backwards branches that compile-time code
      execution can use before giving up and making a compile error.
      </p>
      <p>
      If the <code class="zig">new_quota</code> is smaller than the default quota (<code class="zig"><span class="tok-number">1000</span></code>) or
      a previously explicitly set quota, it is ignored.
      </p>
      <p>
      Example:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;foo&quot;</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; <span class="tok-number">1001</span>) : (i += <span class="tok-number">1</span>) {}
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:9: </span><span class="t31_1">error:</span><span class="t0_1"> evaluation exceeded 1000 backwards branches</span>
        while (i &lt; 1001) : (i += 1) {}
        <span class="t32_1">^</span>
</code></pre>

      <p>Now we use <code class="zig"><span class="tok-builtin">@setEvalBranchQuota</span></code>:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;foo&quot;</span> {
    <span class="tok-kw">comptime</span> {
        <span class="tok-builtin">@setEvalBranchQuota</span>(<span class="tok-number">1001</span>);
        <span class="tok-kw">var</span> i = <span class="tok-number">0</span>;
        <span class="tok-kw">while</span> (i &lt; <span class="tok-number">1001</span>) : (i += <span class="tok-number">1</span>) {}
    }
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 foo...OK
All tests passed.
</code></pre>


      <p>See also:</p><ul>
<li><a href="#comptime">comptime</a></li>
</ul>

      
      <h2 id="setFloatMode">@setFloatMode</h2>

      <pre><code class="zig"><span class="tok-builtin">@setFloatMode</span>(mode: <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).FloatMode)</code></pre>
      <p>
      Sets the floating point mode of the current scope. Possible values are:
      </p>
      <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> FloatMode = <span class="tok-kw">enum</span> {
    Strict,
    Optimized,
};</code></pre>
      <ul>
        <li>
            <code class="zig">Strict</code> (default) - Floating point operations follow strict IEEE compliance.
        </li>
        <li>
            <code class="zig">Optimized</code> - Floating point operations may do all of the following:
          <ul>
            <li>Assume the arguments and result are not NaN. Optimizations are required to retain defined behavior over NaNs, but the value of the result is undefined.</li>
            <li>Assume the arguments and result are not +/-Inf. Optimizations are required to retain defined behavior over +/-Inf, but the value of the result is undefined.</li>
            <li>Treat the sign of a zero argument or result as insignificant.</li>
            <li>Use the reciprocal of an argument rather than perform division.</li>
            <li>Perform floating-point contraction (e.g. fusing a multiply followed by an addition into a fused multiply-and-add).</li>
            <li>Perform algebraically equivalent transformations that may change results in floating point (e.g. reassociate).</li>
          </ul>
          This is equivalent to <code>-ffast-math</code> in GCC.
        </li>
      </ul>
      <p>
      The floating point mode is inherited by child scopes, and can be overridden in any scope.
      You can set the floating point mode in a struct or module scope by using a comptime block.
      </p>
      <p>See also:</p><ul>
<li><a href="#Floating-Point-Operations">Floating Point Operations</a></li>
</ul>

      
      <h2 id="setGlobalLinkage">@setGlobalLinkage</h2>

      <pre><code class="zig"><span class="tok-builtin">@setGlobalLinkage</span>(global_variable_name, <span class="tok-kw">comptime</span> linkage: GlobalLinkage)</code></pre>
      <p>
      <code class="zig">GlobalLinkage</code> can be found with <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).GlobalLinkage</code>.
      </p>
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
</ul>

      
      <h2 id="shlExact">@shlExact</h2>

      <pre><code class="zig"><span class="tok-builtin">@shlExact</span>(value: T, shift_amt: Log2T) T</code></pre>
      <p>
      Performs the left shift operation (<code class="zig">&lt;&lt;</code>). Caller guarantees
      that the shift will not shift any 1 bits out.
      </p>
      <p>
      The type of <code class="zig">shift_amt</code> is an unsigned integer with <code class="zig">log2(T.bit_count)</code> bits.
              This is because <code class="zig">shift_amt &gt;= T.bit_count</code> is undefined behavior.
      </p>
      <p>See also:</p><ul>
<li><a href="#shrExact">@shrExact</a></li>
<li><a href="#shlWithOverflow">@shlWithOverflow</a></li>
</ul>

      
      <h2 id="shlWithOverflow">@shlWithOverflow</h2>

      <pre><code class="zig"><span class="tok-builtin">@shlWithOverflow</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, shift_amt: Log2T, result: *T) <span class="tok-type">bool</span></code></pre>
      <p>
      Performs <code class="zig">result.* = a &lt;&lt; b</code>. If overflow or underflow occurs,
                 stores the overflowed bits in <code class="zig">result</code> and returns <code class="zig"><span class="tok-null">true</span></code>.
                         If no overflow or underflow occurs, returns <code class="zig"><span class="tok-null">false</span></code>.
      </p>
      <p>
      The type of <code class="zig">shift_amt</code> is an unsigned integer with <code class="zig">log2(T.bit_count)</code> bits.
              This is because <code class="zig">shift_amt &gt;= T.bit_count</code> is undefined behavior.
      </p>
      <p>See also:</p><ul>
<li><a href="#shlExact">@shlExact</a></li>
<li><a href="#shrExact">@shrExact</a></li>
</ul>

      
      <h2 id="shrExact">@shrExact</h2>

      <pre><code class="zig"><span class="tok-builtin">@shrExact</span>(value: T, shift_amt: Log2T) T</code></pre>
      <p>
      Performs the right shift operation (<code class="zig">&gt;&gt;</code>). Caller guarantees
      that the shift will not shift any 1 bits out.
      </p>
      <p>
      The type of <code class="zig">shift_amt</code> is an unsigned integer with <code class="zig">log2(T.bit_count)</code> bits.
              This is because <code class="zig">shift_amt &gt;= T.bit_count</code> is undefined behavior.
      </p>
      <p>See also:</p><ul>
<li><a href="#shlExact">@shlExact</a></li>
<li><a href="#shlWithOverflow">@shlWithOverflow</a></li>
</ul>

      

      <h2 id="sizeOf">@sizeOf</h2>

      <pre><code class="zig"><span class="tok-builtin">@sizeOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
      <p>
      This function returns the number of bytes it takes to store <code class="zig">T</code> in memory.
      </p>
      <p>
      The result is a target-specific compile time constant.
      </p>
      

      <h2 id="sliceToBytes">@sliceToBytes</h2>

      <pre><code class="zig"><span class="tok-builtin">@sliceToBytes</span>(value: <span class="tok-kw">var</span>) []<span class="tok-type">u8</span></code></pre>
      <p>
      Converts a slice or array to a slice of <code class="zig"><span class="tok-type">u8</span></code>. The resulting slice has the same
      <a href="#Pointers">pointer</a> properties as the parameter.
      </p>
      

      <h2 id="sqrt">@sqrt</h2>

      <pre><code class="zig"><span class="tok-builtin">@sqrt</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, value: T) T</code></pre>
      <p>
      Performs the square root of a floating point number. Uses a dedicated hardware instruction
      when available. Currently only supports f32 and f64 at runtime. f128 at runtime is TODO.
      </p>
      <p>
      This is a low-level intrinsic. Most code can use <code class="zig">std.math.sqrt</code> instead.
      </p>
      
      <h2 id="subWithOverflow">@subWithOverflow</h2>

      <pre><code class="zig"><span class="tok-builtin">@subWithOverflow</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, a: T, b: T, result: *T) <span class="tok-type">bool</span></code></pre>
      <p>
      Performs <code class="zig">result.* = a - b</code>. If overflow or underflow occurs,
          stores the overflowed bits in <code class="zig">result</code> and returns <code class="zig"><span class="tok-null">true</span></code>.
                  If no overflow or underflow occurs, returns <code class="zig"><span class="tok-null">false</span></code>.
      </p>
      
      <h2 id="tagName">@tagName</h2>

      <pre><code class="zig"><span class="tok-builtin">@tagName</span>(value: <span class="tok-kw">var</span>) []<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></pre>
      <p>
      Converts an enum value or union value to a slice of bytes representing the name.
      </p>
      
      <h2 id="TagType">@TagType</h2>

      <pre><code class="zig"><span class="tok-builtin">@TagType</span>(T: <span class="tok-type">type</span>) <span class="tok-type">type</span></code></pre>
      <p>
      For an enum, returns the integer type that is used to store the enumeration value.
      </p>
      <p>
      For a union, returns the enum type that is used to store the tag value.
      </p>
      
      <h2 id="This">@This</h2>

      <pre><code class="zig"><span class="tok-builtin">@This</span>() <span class="tok-type">type</span></code></pre>
      <p>
      Returns the innermost struct or union that this function call is inside.
      This can be useful for an anonymous struct that needs to refer to itself:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;@This()&quot;</span> {
    <span class="tok-kw">var</span> items = []<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> list = List(<span class="tok-type">i32</span>){ .items = items[<span class="tok-number">0</span>..] };
    assert(list.length() == <span class="tok-number">4</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">List</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();

        items: []T,

        <span class="tok-kw">fn</span> <span class="tok-fn">length</span>(self: Self) <span class="tok-type">usize</span> {
            <span class="tok-kw">return</span> self.items.len;
        }
    };
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 @This()...OK
All tests passed.
</code></pre>

      <p>
      When <code class="zig"><span class="tok-builtin">@This</span>()</code> is used at global scope, it returns a reference to the
      current import. There is a proposal to remove the import type and use an empty struct
      type instead. See 
      <a href="https://github.com/ziglang/zig/issues/1047">#1047</a> for details.
      </p>
      
      <h2 id="truncate">@truncate</h2>

      <pre><code class="zig"><span class="tok-builtin">@truncate</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, integer) T</code></pre>
      <p>
      This function truncates bits from an integer type, resulting in a smaller
      integer type.
      </p>
      <p>
      The following produces a crash in debug mode and undefined behavior in
      release mode:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> a: <span class="tok-type">u16</span> = <span class="tok-number">0xabcd</span>;
<span class="tok-kw">const</span> b: <span class="tok-type">u8</span> = <span class="tok-type">u8</span>(a);</code></pre>
      <p>
      However this is well defined and working code:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> a: <span class="tok-type">u16</span> = <span class="tok-number">0xabcd</span>;
<span class="tok-kw">const</span> b: <span class="tok-type">u8</span> = <span class="tok-builtin">@truncate</span>(<span class="tok-type">u8</span>, a);
<span class="tok-comment">// b is now 0xcd</span></code></pre>
      <p>
      This function always truncates the significant bits of the integer, regardless
      of endianness on the target platform.
      </p>

      
      <h2 id="typeId">@typeId</h2>

      <pre><code class="zig"><span class="tok-builtin">@typeId</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).TypeId</code></pre>
      <p>
      Returns which kind of type something is. Possible values:
      </p>
      <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TypeId = <span class="tok-kw">enum</span> {
    Type,
    Void,
    Bool,
    NoReturn,
    Int,
    Float,
    Pointer,
    Array,
    Struct,
    ComptimeFloat,
    ComptimeInt,
    Undefined,
    Null,
    Optional,
    ErrorUnion,
    Error,
    Enum,
    Union,
    Fn,
    Namespace,
    Block,
    BoundFn,
    ArgTuple,
    Opaque,
};</code></pre>
      
      <h2 id="typeInfo">@typeInfo</h2>

      <pre><code class="zig"><span class="tok-builtin">@typeInfo</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>).TypeInfo</code></pre>
      <p>
      Returns information on the type. Returns a value of the following union:
      </p>
      <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TypeInfo = <span class="tok-kw">union</span>(TypeId) {
    Type: <span class="tok-type">void</span>,
    Void: <span class="tok-type">void</span>,
    Bool: <span class="tok-type">void</span>,
    NoReturn: <span class="tok-type">void</span>,
    Int: Int,
    Float: Float,
    Pointer: Pointer,
    Array: Array,
    Struct: Struct,
    ComptimeFloat: <span class="tok-type">void</span>,
    ComptimeInt: <span class="tok-type">void</span>,
    Undefined: <span class="tok-type">void</span>,
    Null: <span class="tok-type">void</span>,
    Optional: Optional,
    ErrorUnion: ErrorUnion,
    ErrorSet: ErrorSet,
    Enum: Enum,
    Union: Union,
    Fn: Fn,
    Namespace: <span class="tok-type">void</span>,
    BoundFn: Fn,
    ArgTuple: <span class="tok-type">void</span>,
    Opaque: <span class="tok-type">void</span>,
    Promise: Promise,


    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Int = <span class="tok-kw">struct</span> {
        is_signed: <span class="tok-type">bool</span>,
        bits: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Float = <span class="tok-kw">struct</span> {
        bits: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Pointer = <span class="tok-kw">struct</span> {
        size: Size,
        is_const: <span class="tok-type">bool</span>,
        is_volatile: <span class="tok-type">bool</span>,
        alignment: <span class="tok-type">u32</span>,
        child: <span class="tok-type">type</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <span class="tok-kw">enum</span> {
            One,
            Many,
            Slice,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Array = <span class="tok-kw">struct</span> {
        len: <span class="tok-type">usize</span>,
        child: <span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ContainerLayout = <span class="tok-kw">enum</span> {
        Auto,
        Extern,
        Packed,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> StructField = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        offset: ?<span class="tok-type">usize</span>,
        field_type: <span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Struct = <span class="tok-kw">struct</span> {
        layout: ContainerLayout,
        fields: []StructField,
        defs: []Definition,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Optional = <span class="tok-kw">struct</span> {
        child: <span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorUnion = <span class="tok-kw">struct</span> {
        error_set: <span class="tok-type">type</span>,
        payload: <span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        value: <span class="tok-type">usize</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorSet = <span class="tok-kw">struct</span> {
        errors: []Error,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> EnumField = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        value: <span class="tok-type">usize</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Enum = <span class="tok-kw">struct</span> {
        layout: ContainerLayout,
        tag_type: <span class="tok-type">type</span>,
        fields: []EnumField,
        defs: []Definition,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnionField = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        enum_field: ?EnumField,
        field_type: <span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Union = <span class="tok-kw">struct</span> {
        layout: ContainerLayout,
        tag_type: ?<span class="tok-type">type</span>,
        fields: []UnionField,
        defs: []Definition,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> CallingConvention = <span class="tok-kw">enum</span> {
        Unspecified,
        C,
        Cold,
        Naked,
        Stdcall,
        Async,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FnArg = <span class="tok-kw">struct</span> {
        is_generic: <span class="tok-type">bool</span>,
        is_noalias: <span class="tok-type">bool</span>,
        arg_type: ?<span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Fn = <span class="tok-kw">struct</span> {
        calling_convention: CallingConvention,
        is_generic: <span class="tok-type">bool</span>,
        is_var_args: <span class="tok-type">bool</span>,
        return_type: ?<span class="tok-type">type</span>,
        async_allocator_type: ?<span class="tok-type">type</span>,
        args: []FnArg,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Promise = <span class="tok-kw">struct</span> {
        child: ?<span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Definition = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        is_pub: <span class="tok-type">bool</span>,
        data: Data,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            Type: <span class="tok-type">type</span>,
            Var: <span class="tok-type">type</span>,
            Fn: FnDef,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FnDef = <span class="tok-kw">struct</span> {
                fn_type: <span class="tok-type">type</span>,
                inline_type: Inline,
                calling_convention: CallingConvention,
                is_var_args: <span class="tok-type">bool</span>,
                is_extern: <span class="tok-type">bool</span>,
                is_export: <span class="tok-type">bool</span>,
                lib_name: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
                return_type: <span class="tok-type">type</span>,
                arg_names: [][] <span class="tok-kw">const</span> <span class="tok-type">u8</span>,

                <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Inline = <span class="tok-kw">enum</span> {
                    Auto,
                    Always,
                    Never,
                };
            };
        };
    };
};</code></pre>
      
      <h2 id="typeName">@typeName</h2>

      <pre><code class="zig"><span class="tok-builtin">@typeName</span>(T: <span class="tok-type">type</span>) []<span class="tok-type">u8</span></code></pre>
      <p>
      This function returns the string representation of a type.
      </p>

      
      <h2 id="typeOf">@typeOf</h2>

      <pre><code class="zig"><span class="tok-builtin">@typeOf</span>(expression) <span class="tok-type">type</span></code></pre>
      <p>
      This function returns a compile-time constant, which is the type of the
      expression passed as an argument. The expression is evaluated.
      </p>

      
      
      <h1 id="Build-Mode">Build Mode</h1>

      <p>
      Zig has four build modes:
      </p>
      <ul>
        <li><a href="#Debug">Debug</a> (default)</li>
        <li><a href="#ReleaseFast">ReleaseFast</a></li>
        <li><a href="#ReleaseSafe">ReleaseSafe</a></li>
        <li><a href="#ReleaseSmall">ReleaseSmall</a></li>
      </ul>
      <p>
      To add standard build options to a <code>build.zig</code> file:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> Builder = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).build.Builder;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *Builder) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> exe = b.addExecutable(<span class="tok-str">&quot;example&quot;</span>, <span class="tok-str">&quot;example.zig&quot;</span>);
    exe.setBuildMode(b.standardReleaseOptions());
    b.default_step.dependOn(&amp;exe.step);
}</code></pre>
      <p>
      This causes these options to be available:
      </p>
      <pre><code class="shell">  -Drelease-safe=[bool] optimizations on and safety on
  -Drelease-fast=[bool] optimizations on and safety off
  -Drelease-small=[bool] size optimizations on and safety off</code></pre>
      <h2 id="Debug">Debug</h2>

      <pre><code class="shell">$ zig build-exe example.zig</code></pre>
      <ul>
        <li>Fast compilation speed</li>
        <li>Safety checks enabled</li>
        <li>Slow runtime performance</li>
        <li>Large binary size</li>
        <li>No reproducible build requirement</li>
      </ul>
      
      <h2 id="ReleaseFast">ReleaseFast</h2>

      <pre><code class="shell">$ zig build-exe example.zig --release-fast</code></pre>
      <ul>
        <li>Fast runtime performance</li>
        <li>Safety checks disabled</li>
        <li>Slow compilation speed</li>
        <li>Large binary size</li>
        <li>Reproducible build</li>
      </ul>
      
      <h2 id="ReleaseSafe">ReleaseSafe</h2>

      <pre><code class="shell">$ zig build-exe example.zig --release-safe</code></pre>
      <ul>
        <li>Medium runtime performance</li>
        <li>Safety checks enabled</li>
        <li>Slow compilation speed</li>
        <li>Large binary size</li>
        <li>Reproducible build</li>
      </ul>
      
      <h2 id="ReleaseSmall">ReleaseSmall</h2>

      <pre><code class="shell">$ zig build-exe example.zig --release-small</code></pre>
      <ul>
        <li>Medium runtime performance</li>
        <li>Safety checks disabled</li>
        <li>Slow compilation speed</li>
        <li>Small binary size</li>
        <li>Reproducible build</li>
      </ul>
      
      <p>See also:</p><ul>
<li><a href="#Compile-Variables">Compile Variables</a></li>
<li><a href="#Zig-Build-System">Zig Build System</a></li>
<li><a href="#Undefined-Behavior">Undefined Behavior</a></li>
</ul>

      
      <h1 id="Undefined-Behavior">Undefined Behavior</h1>

      <p>
      Zig has many instances of undefined behavior. If undefined behavior is
      detected at compile-time, Zig emits a compile error and refuses to continue.
      Most undefined behavior that cannot be detected at compile-time can be detected
      at runtime. In these cases, Zig has safety checks. Safety checks can be disabled
      on a per-block basis with <a href="#setRuntimeSafety">setRuntimeSafety</a>. The <a href="#ReleaseFast">ReleaseFast</a>
      build mode disables all safety checks in order to facilitate optimizations.
      </p>
      <p>
      When a safety check fails, Zig crashes with a stack trace, like this:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;safety check&quot;</span> {
    <span class="tok-kw">unreachable</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 safety check...reached unreachable code
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:5</span>: <span class="t2_0">0x205054 in ??? (test)</span>
    unreachable;
    <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/test_runner.zig:13:25</span>: <span class="t2_0">0x22294a in ??? (test)</span>
        if (test_fn.func()) |_| {
                        <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:96:22</span>: <span class="t2_0">0x2226fb in ??? (test)</span>
            root.main() catch |err| {
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222675 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224d8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222390 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>

Tests failed. Use the following command to reproduce the failure:
/home/andy/dev/zig/docgen_tmp/test
</code></pre>

      <h2 id="Reaching-Unreachable-Code">Reaching Unreachable Code</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    assert(<span class="tok-null">false</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">assert</span>(ok: <span class="tok-type">bool</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">if</span> (!ok) <span class="tok-kw">unreachable</span>; <span class="tok-comment">// assertion failure</span>
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:14: </span><span class="t31_1">error:</span><span class="t0_1"> unable to evaluate constant expression</span>
    if (!ok) unreachable; // assertion failure
             <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:11: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
    assert(false);
          <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:1:10: </span><span class="t36_1">note:</span><span class="t0_1"> called from here</span>
comptime {
         <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    std.debug.assert(<span class="tok-null">false</span>);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
reached unreachable code
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/debug/index.zig:120:13</span>: <span class="t2_0">0x205029 in ??? (test)</span>
            unreachable; // assertion failure
            <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:21</span>: <span class="t2_0">0x2226cb in ??? (test)</span>
    std.debug.assert(false);
                    <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      
      <h2 id="Index-out-of-Bounds">Index out of Bounds</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> array = <span class="tok-str">&quot;hello&quot;</span>;
    <span class="tok-kw">const</span> garbage = array[<span class="tok-number">5</span>];
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:3:26: </span><span class="t31_1">error:</span><span class="t0_1"> index 5 outside array of size 5</span>
    const garbage = array[5];
                         <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x = foo(<span class="tok-str">&quot;hello&quot;</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> x[<span class="tok-number">5</span>];
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
index out of bounds
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:6:13</span>: <span class="t2_0">0x222709 in ??? (test)</span>
    return x[5];
            <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:16</span>: <span class="t2_0">0x2226d4 in ??? (test)</span>
    var x = foo(&quot;hello&quot;);
               <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      
      <h2 id="Cast-Negative-Number-to-Unsigned-Integer">Cast Negative Number to Unsigned Integer</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> value: <span class="tok-type">i32</span> = -<span class="tok-number">1</span>;
    <span class="tok-kw">const</span> unsigned = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u32</span>, value);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:3:22: </span><span class="t31_1">error:</span><span class="t0_1"> attempt to cast negative value to unsigned integer</span>
    const unsigned = @intCast(u32, value);
                     <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> value: <span class="tok-type">i32</span> = -<span class="tok-number">1</span>;
    <span class="tok-kw">var</span> unsigned = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u32</span>, value);
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, unsigned);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
attempt to cast negative value to unsigned integer
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:20</span>: <span class="t2_0">0x2226fe in ??? (test)</span>
    var unsigned = @intCast(u32, value);
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      <p>
      To obtain the maximum value of an unsigned integer, use <a href="#maxValue">@maxValue</a>.
      </p>
      
      <h2 id="Cast-Truncates-Data">Cast Truncates Data</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> spartan_count: <span class="tok-type">u16</span> = <span class="tok-number">300</span>;
    <span class="tok-kw">const</span> byte = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u8</span>, spartan_count);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:3:18: </span><span class="t31_1">error:</span><span class="t0_1"> cast from 'u16' to 'u8' truncates bits</span>
    const byte = @intCast(u8, spartan_count);
                 <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> spartan_count: <span class="tok-type">u16</span> = <span class="tok-number">300</span>;
    <span class="tok-kw">const</span> byte = <span class="tok-builtin">@intCast</span>(<span class="tok-type">u8</span>, spartan_count);
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, byte);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
integer cast truncated bits
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:18</span>: <span class="t2_0">0x222707 in ??? (test)</span>
    const byte = @intCast(u8, spartan_count);
                 <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      <p>
      To truncate bits, use <a href="#truncate">@truncate</a>.
      </p>
      
      <h2 id="Integer-Overflow">Integer Overflow</h2>

      <h3 id="Default-Operations">Default Operations</h3>

      <p>The following operators can cause integer overflow:</p>
      <ul>
          <li><code class="zig">+</code> (addition)</li>
          <li><code class="zig">-</code> (subtraction)</li>
          <li><code class="zig">-</code> (negation)</li>
          <li><code class="zig">*</code> (multiplication)</li>
          <li><code class="zig">/</code> (division)</li>
        <li><a href="#divTrunc">@divTrunc</a> (division)</li>
        <li><a href="#divFloor">@divFloor</a> (division)</li>
        <li><a href="#divExact">@divExact</a> (division)</li>
      </ul>
      <p>Example with addition at compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
    byte += <span class="tok-number">1</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:3:10: </span><span class="t31_1">error:</span><span class="t0_1"> operation caused overflow</span>
    byte += 1;
         <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;
    byte += <span class="tok-number">1</span>;
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, byte);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
integer overflow
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:10</span>: <span class="t2_0">0x2226ee in ??? (test)</span>
    byte += 1;
         <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      
      <h3 id="Standard-Library-Math-Functions">Standard Library Math Functions</h3>

      <p>These functions provided by the standard library return possible errors.</p>
      <ul>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.add</code></li>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.sub</code></li>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.mul</code></li>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divTrunc</code></li>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divFloor</code></li>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.divExact</code></li>
          <li><code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math.shl</code></li>
      </ul>
      <p>Example of catching an overflow for addition:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> math = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).math;
<span class="tok-kw">const</span> warn = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.warn;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;

    byte = <span class="tok-kw">if</span> (math.add(<span class="tok-type">u8</span>, byte, <span class="tok-number">1</span>)) |result| result <span class="tok-kw">else</span> |err| {
        warn(<span class="tok-str">&quot;unable to add one: {}\n&quot;</span>, <span class="tok-builtin">@errorName</span>(err));
        <span class="tok-kw">return</span> err;
    };

    warn(<span class="tok-str">&quot;result: {}\n&quot;</span>, byte);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
unable to add one: Overflow
error: Overflow
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/math/index.zig:252:5</span>: <span class="t2_0">0x2229fa in ??? (test)</span>
    return if (@addWithOverflow(T, a, b, &amp;answer)) error.Overflow else answer;
    <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:8:9</span>: <span class="t2_0">0x222858 in ??? (test)</span>
        return err;
        <span class="t32_1">^</span>
</code></pre>

      
      <h3 id="Builtin-Overflow-Functions">Builtin Overflow Functions</h3>

      <p>
      These builtins return a <code class="zig"><span class="tok-type">bool</span></code> of whether or not overflow
      occurred, as well as returning the overflowed bits:
      </p>
      <ul>
          <li><a href="#addWithOverflow">@addWithOverflow</a></li>
          <li><a href="#subWithOverflow">@subWithOverflow</a></li>
          <li><a href="#mulWithOverflow">@mulWithOverflow</a></li>
          <li><a href="#shlWithOverflow">@shlWithOverflow</a></li>
      </ul>
      <p>
      Example of <a href="#addWithOverflow">@addWithOverflow</a>:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> warn = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.warn;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> byte: <span class="tok-type">u8</span> = <span class="tok-number">255</span>;

    <span class="tok-kw">var</span> result: <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;
    <span class="tok-kw">if</span> (<span class="tok-builtin">@addWithOverflow</span>(<span class="tok-type">u8</span>, byte, <span class="tok-number">10</span>, &amp;result)) {
        warn(<span class="tok-str">&quot;overflowed result: {}\n&quot;</span>, result);
    } <span class="tok-kw">else</span> {
        warn(<span class="tok-str">&quot;result: {}\n&quot;</span>, result);
    }
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
overflowed result: 9
</code></pre>

      
      <h3 id="Wrapping-Operations">Wrapping Operations</h3>

      <p>
      These operations have guaranteed wraparound semantics.
      </p>
      <ul>
          <li><code class="zig">+%</code> (wraparound addition)</li>
          <li><code class="zig">-%</code> (wraparound subtraction)</li>
          <li><code class="zig">-%</code> (wraparound negation)</li>
          <li><code class="zig">*%</code> (wraparound multiplication)</li>
      </ul>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;wraparound addition and subtraction&quot;</span> {
    <span class="tok-kw">const</span> x: <span class="tok-type">i32</span> = <span class="tok-builtin">@maxValue</span>(<span class="tok-type">i32</span>);
    <span class="tok-kw">const</span> min_val = x +% <span class="tok-number">1</span>;
    assert(min_val == <span class="tok-builtin">@minValue</span>(<span class="tok-type">i32</span>));
    <span class="tok-kw">const</span> max_val = min_val -% <span class="tok-number">1</span>;
    assert(max_val == <span class="tok-builtin">@maxValue</span>(<span class="tok-type">i32</span>));
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 wraparound addition and subtraction...OK
All tests passed.
</code></pre>

      
      
      <h2 id="Exact-Left-Shift-Overflow">Exact Left Shift Overflow</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> x = <span class="tok-builtin">@shlExact</span>(<span class="tok-type">u8</span>(<span class="tok-number">0b01010101</span>), <span class="tok-number">2</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:15: </span><span class="t31_1">error:</span><span class="t0_1"> operation caused overflow</span>
    const x = @shlExact(u8(0b01010101), 2);
              <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">0b01010101</span>;
    <span class="tok-kw">var</span> y = <span class="tok-builtin">@shlExact</span>(x, <span class="tok-number">2</span>);
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, y);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
left shift overflowed bits
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:13</span>: <span class="t2_0">0x222705 in ??? (test)</span>
    var y = @shlExact(x, 2);
            <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      
      <h2 id="Exact-Right-Shift-Overflow">Exact Right Shift Overflow</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> x = <span class="tok-builtin">@shrExact</span>(<span class="tok-type">u8</span>(<span class="tok-number">0b10101010</span>), <span class="tok-number">2</span>);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:15: </span><span class="t31_1">error:</span><span class="t0_1"> exact shift shifted out 1 bits</span>
    const x = @shrExact(u8(0b10101010), 2);
              <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u8</span> = <span class="tok-number">0b10101010</span>;
    <span class="tok-kw">var</span> y = <span class="tok-builtin">@shrExact</span>(x, <span class="tok-number">2</span>);
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, y);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
right shift overflowed bits
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:13</span>: <span class="t2_0">0x222705 in ??? (test)</span>
    var y = @shrExact(x, 2);
            <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      
      <h2 id="Division-by-Zero">Division by Zero</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> c = a / b;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:17: </span><span class="t31_1">error:</span><span class="t0_1"> division by zero</span>
    const c = a / b;
                <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> c = a / b;
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, c);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
division by zero
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:6:15</span>: <span class="t2_0">0x222712 in ??? (test)</span>
    var c = a / b;
              <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      
      <h2 id="Remainder-Division-by-Zero">Remainder Division by Zero</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">i32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">const</span> c = a % b;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:17: </span><span class="t31_1">error:</span><span class="t0_1"> division by zero</span>
    const c = a % b;
                <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> c = a % b;
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, c);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
remainder division by zero or negative value
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:6:15</span>: <span class="t2_0">0x222712 in ??? (test)</span>
    var c = a % b;
              <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      
      <h2 id="Exact-Division-Remainder">Exact Division Remainder</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> b: <span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">const</span> c = <span class="tok-builtin">@divExact</span>(a, b);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:15: </span><span class="t31_1">error:</span><span class="t0_1"> exact division had a remainder</span>
    const c = @divExact(a, b);
              <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u32</span> = <span class="tok-number">10</span>;
    <span class="tok-kw">var</span> b: <span class="tok-type">u32</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">var</span> c = <span class="tok-builtin">@divExact</span>(a, b);
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, c);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
exact division produced remainder
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:6:13</span>: <span class="t2_0">0x222733 in ??? (test)</span>
    var c = @divExact(a, b);
            <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      
      <h2 id="Slice-Widen-Remainder">Slice Widen Remainder</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">var</span> bytes = [<span class="tok-number">5</span>]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> };
    <span class="tok-kw">var</span> slice = <span class="tok-builtin">@bytesToSlice</span>(<span class="tok-type">u32</span>, bytes);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:3:17: </span><span class="t31_1">error:</span><span class="t0_1"> unable to convert [5]u8 to []align(1) const u32: size mismatch</span>
    var slice = @bytesToSlice(u32, bytes);
                <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:3:31: </span><span class="t36_1">note:</span><span class="t0_1"> u32 has size 4; remaining bytes: 1</span>
    var slice = @bytesToSlice(u32, bytes);
                              <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> bytes = [<span class="tok-number">5</span>]<span class="tok-type">u8</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span> };
    <span class="tok-kw">var</span> slice = <span class="tok-builtin">@bytesToSlice</span>(<span class="tok-type">u32</span>, bytes[<span class="tok-number">0</span>..]);
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, slice[<span class="tok-number">0</span>]);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
slice widening size mismatch
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:17</span>: <span class="t2_0">0x222756 in ??? (test)</span>
    var slice = @bytesToSlice(u32, bytes[0..]);
                <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      
      <h2 id="Attempt-to-Unwrap-Null">Attempt to Unwrap Null</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">const</span> number = optional_number.?;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:3:35: </span><span class="t31_1">error:</span><span class="t0_1"> unable to unwrap null</span>
    const number = optional_number.?;
                                  <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;
    <span class="tok-kw">var</span> number = optional_number.?;
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, number);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
attempt to unwrap null
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:5:33</span>: <span class="t2_0">0x2226ff in ??? (test)</span>
    var number = optional_number.?;
                                <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      <p>One way to avoid this crash is to test for null instead of assuming non-null, with
      the <code class="zig"><span class="tok-kw">if</span></code> expression:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> warn = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.warn;
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> optional_number: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>;

    <span class="tok-kw">if</span> (optional_number) |number| {
        warn(<span class="tok-str">&quot;got number: {}\n&quot;</span>, number);
    } <span class="tok-kw">else</span> {
        warn(<span class="tok-str">&quot;it's null\n&quot;</span>);
    }
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
it's null
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Optionals">Optionals</a></li>
</ul>

      
      <h2 id="Attempt-to-Unwrap-Error">Attempt to Unwrap Error</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> number = getNumberOrFail() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:2:38: </span><span class="t31_1">error:</span><span class="t0_1"> caught unexpected error 'UnableToReturnNumber'</span>
    const number = getNumberOrFail() catch unreachable;
                                     <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> number = getNumberOrFail() <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, number);
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
attempt to unwrap error: UnableToReturnNumber
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:9:5</span>: <span class="t2_0">0x22276b in ??? (test)</span>
    return error.UnableToReturnNumber;
    <span class="t32_1">^</span>
???:?:?: <span class="t2_0">0x21fa3e in ??? (???)</span>


<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:38</span>: <span class="t2_0">0x22272c in ??? (test)</span>
    const number = getNumberOrFail() catch unreachable;
                                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      <p>One way to avoid this crash is to test for an error instead of assuming a successful result, with
      the <code class="zig"><span class="tok-kw">if</span></code> expression:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> warn = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.warn;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> result = getNumberOrFail();

    <span class="tok-kw">if</span> (result) |number| {
        warn(<span class="tok-str">&quot;got number: {}\n&quot;</span>, number);
    } <span class="tok-kw">else</span> |err| {
        warn(<span class="tok-str">&quot;got error: {}\n&quot;</span>, <span class="tok-builtin">@errorName</span>(err));
    }
}

<span class="tok-kw">fn</span> <span class="tok-fn">getNumberOrFail</span>() !<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.UnableToReturnNumber;
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
got error: UnableToReturnNumber
</code></pre>

      <p>See also:</p><ul>
<li><a href="#Errors">Errors</a></li>
</ul>

      
      <h2 id="Invalid-Error-Code">Invalid Error Code</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> err = <span class="tok-kw">error</span>.AnError;
    <span class="tok-kw">const</span> number = <span class="tok-builtin">@errorToInt</span>(err) + <span class="tok-number">10</span>;
    <span class="tok-kw">const</span> invalid_err = <span class="tok-builtin">@intToError</span>(number);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:25: </span><span class="t31_1">error:</span><span class="t0_1"> integer value 11 represents no error</span>
    const invalid_err = @intToError(number);
                        <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> err = <span class="tok-kw">error</span>.AnError;
    <span class="tok-kw">var</span> number = <span class="tok-builtin">@errorToInt</span>(err) + <span class="tok-number">500</span>;
    <span class="tok-kw">var</span> invalid_err = <span class="tok-builtin">@intToError</span>(number);
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, number);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
invalid error code
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:6:23</span>: <span class="t2_0">0x22271a in ??? (test)</span>
    var invalid_err = @intToError(number);
                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      
      <h2 id="Invalid-Enum-Cast">Invalid Enum Cast</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    A,
    B,
    C,
};
<span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u2</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">const</span> b = <span class="tok-builtin">@intToEnum</span>(Foo, a);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:8:15: </span><span class="t31_1">error:</span><span class="t0_1"> enum 'Foo' has no tag matching integer value 3</span>
    const b = @intToEnum(Foo, a);
              <span class="t32_1">^</span>
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:1:13: </span><span class="t36_1">note:</span><span class="t0_1"> 'Foo' declared here</span>
const Foo = enum {
            <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">enum</span> {
    A,
    B,
    C,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">u2</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">var</span> b = <span class="tok-builtin">@intToEnum</span>(Foo, a);
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, <span class="tok-builtin">@tagName</span>(b));
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
invalid enum value
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:11:13</span>: <span class="t2_0">0x2226fd in ??? (test)</span>
    var b = @intToEnum(Foo, a);
            <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      

      <h2 id="Invalid-Error-Set-Cast">Invalid Error Set Cast</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> Set1 = <span class="tok-kw">error</span>{
    A,
    B,
};
<span class="tok-kw">const</span> Set2 = <span class="tok-kw">error</span>{
    A,
    C,
};
<span class="tok-kw">comptime</span> {
    _ = <span class="tok-builtin">@errSetCast</span>(Set2, Set1.B);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:10:9: </span><span class="t31_1">error:</span><span class="t0_1"> error.B not a member of error set 'Set2'</span>
    _ = @errSetCast(Set2, Set1.B);
        <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Set1 = <span class="tok-kw">error</span>{
    A,
    B,
};
<span class="tok-kw">const</span> Set2 = <span class="tok-kw">error</span>{
    A,
    C,
};
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    foo(Set1.B);
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(set1: Set1) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> x = <span class="tok-builtin">@errSetCast</span>(Set2, set1);
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, x);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
invalid error code
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:15:15</span>: <span class="t2_0">0x222724 in ??? (test)</span>
    const x = @errSetCast(Set2, set1);
              <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:12:8</span>: <span class="t2_0">0x2226ce in ??? (test)</span>
    foo(Set1.B);
       <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x2226a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      

      <h2 id="Incorrect-Pointer-Alignment">Incorrect Pointer Alignment</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">const</span> ptr = <span class="tok-builtin">@intToPtr</span>(*<span class="tok-type">i32</span>, <span class="tok-number">0x1</span>);
    <span class="tok-kw">const</span> aligned = <span class="tok-builtin">@alignCast</span>(<span class="tok-number">4</span>, ptr);
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:3:35: </span><span class="t31_1">error:</span><span class="t0_1"> pointer address 0x1 is not aligned to 4 bytes</span>
    const aligned = @alignCast(4, ptr);
                                  <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> array <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = []<span class="tok-type">u32</span>{ <span class="tok-number">0x11111111</span>, <span class="tok-number">0x11111111</span> };
    <span class="tok-kw">const</span> bytes = <span class="tok-builtin">@sliceToBytes</span>(array[<span class="tok-number">0</span>..]);
    <span class="tok-kw">if</span> (foo(bytes) != <span class="tok-number">0x11111111</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Wrong;
}
<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(bytes: []<span class="tok-type">u8</span>) <span class="tok-type">u32</span> {
    <span class="tok-kw">const</span> slice4 = bytes[<span class="tok-number">1</span>..<span class="tok-number">5</span>];
    <span class="tok-kw">const</span> int_slice = <span class="tok-builtin">@bytesToSlice</span>(<span class="tok-type">u32</span>, <span class="tok-builtin">@alignCast</span>(<span class="tok-number">4</span>, slice4));
    <span class="tok-kw">return</span> int_slice[<span class="tok-number">0</span>];
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
incorrect alignment
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:8:56</span>: <span class="t2_0">0x2229ff in ??? (test)</span>
    const int_slice = @bytesToSlice(u32, @alignCast(4, slice4));
                                                       <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:4:12</span>: <span class="t2_0">0x22283e in ??? (test)</span>
    if (foo(bytes) != 0x11111111) return error.Wrong;
           <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:96:22</span>: <span class="t2_0">0x2226db in ??? (test)</span>
            root.main() catch |err| {
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x222655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x2224b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x222370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      
      <h2 id="Wrong-Union-Field-Access">Wrong Union Field Access</h2>

      <p>At compile-time:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">comptime</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    f.float = <span class="tok-number">12.34</span>;
}

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">/home/andy/dev/zig/docgen_tmp/test.zig:3:6: </span><span class="t31_1">error:</span><span class="t0_1"> accessing union field 'float' while field 'int' is set</span>
    f.float = 12.34;
     <span class="t32_1">^</span>
</code></pre>

      <p>At runtime:</p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    bar(&amp;f);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(f: *Foo) <span class="tok-type">void</span> {
    f.float = <span class="tok-number">12.34</span>;
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, f.float);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
access of inactive union field
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:14:6</span>: <span class="t2_0">0x22a738 in ??? (test)</span>
    f.float = 12.34;
     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/docgen_tmp/test.zig:10:8</span>: <span class="t2_0">0x22a6dc in ??? (test)</span>
    bar(&amp;f);
       <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:86:22</span>: <span class="t2_0">0x22a6a9 in ??? (test)</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:70:20</span>: <span class="t2_0">0x22a655 in ??? (test)</span>
    return callMain();
                   <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:64:39</span>: <span class="t2_0">0x22a4b8 in ??? (test)</span>
    std.os.posix.exit(callMainWithArgs(argc, argv, envp));
                                      <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:5</span>: <span class="t2_0">0x22a370 in ??? (test)</span>
    @noInlineCall(posixCallMainAndExit);
    <span class="t32_1">^</span>
</code></pre>

      <p>
      This safety is not available for <code class="zig"><span class="tok-kw">extern</span></code> or <code class="zig"><span class="tok-kw">packed</span></code> unions.
      </p>
      <p>
      To change the active field of a union, assign the entire union, like this:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    bar(&amp;f);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(f: *Foo) <span class="tok-type">void</span> {
    f.* = Foo{ .float = <span class="tok-number">12.34</span> };
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, f.float);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
value: 1.23400001e+01
</code></pre>

      <p>
      To change the active field of a union when a meaningful value for the field is not known,
      use <a href="#undefined">undefined</a>, like this:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">union</span> {
    float: <span class="tok-type">f32</span>,
    int: <span class="tok-type">u32</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> f = Foo{ .int = <span class="tok-number">42</span> };
    f = Foo{ .float = <span class="tok-null">undefined</span> };
    bar(&amp;f);
    std.debug.warn(<span class="tok-str">&quot;value: {}\n&quot;</span>, f.float);
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>(f: *Foo) <span class="tok-type">void</span> {
    f.float = <span class="tok-number">12.34</span>;
}</code></pre><pre><code class="shell">$ zig build-exe test.zig
$ ./test
value: 1.23400001e+01
</code></pre>

      

      <h2 id="Out-of-Bounds-Float-To-Integer-Cast">Out of Bounds Float To Integer Cast</h2>

      <p>TODO</p>
      

      
      <h1 id="Memory">Memory</h1>

      <p>TODO: explain no default allocator in zig</p>
      <p>TODO: show how to use the allocator interface</p>
      <p>TODO: mention debug allocator</p>
      <p>TODO: importance of checking for allocation failure</p>
      <p>TODO: mention overcommit and the OOM Killer</p>
      <p>TODO: mention recursion</p>
      <p>See also:</p><ul>
<li><a href="#Pointers">Pointers</a></li>
</ul>


      
      <h1 id="Compile-Variables">Compile Variables</h1>

      <p>
      Compile variables are accessible by importing the <code class="zig"><span class="tok-str">&quot;builtin&quot;</span></code> package,
      which the compiler makes available to every Zig source file. It contains
      compile-time constants such as the current target, endianness, and release mode.
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> separator = <span class="tok-kw">if</span> (builtin.os == builtin.Os.windows) <span class="tok-str">'\\'</span> <span class="tok-kw">else</span> <span class="tok-str">'/'</span>;</code></pre>
      <p>
      Example of what is imported with <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>)</code>:
      </p>
      <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StackTrace = <span class="tok-kw">struct</span> {
    index: <span class="tok-type">usize</span>,
    instruction_addresses: []<span class="tok-type">usize</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Os = <span class="tok-kw">enum</span> {
    freestanding,
    ananas,
    cloudabi,
    dragonfly,
    freebsd,
    fuchsia,
    ios,
    kfreebsd,
    linux,
    lv2,
    macosx,
    netbsd,
    openbsd,
    solaris,
    windows,
    haiku,
    minix,
    rtems,
    nacl,
    cnk,
    aix,
    cuda,
    nvcl,
    amdhsa,
    ps4,
    elfiamcu,
    tvos,
    watchos,
    mesa3d,
    contiki,
    amdpal,
    zen,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Arch = <span class="tok-kw">enum</span> {
    armv8_3a,
    armv8_2a,
    armv8_1a,
    armv8,
    armv8r,
    armv8m_baseline,
    armv8m_mainline,
    armv7,
    armv7em,
    armv7m,
    armv7s,
    armv7k,
    armv7ve,
    armv6,
    armv6m,
    armv6k,
    armv6t2,
    armv5,
    armv5te,
    armv4t,
    armebv8_3a,
    armebv8_2a,
    armebv8_1a,
    armebv8,
    armebv8r,
    armebv8m_baseline,
    armebv8m_mainline,
    armebv7,
    armebv7em,
    armebv7m,
    armebv7s,
    armebv7k,
    armebv7ve,
    armebv6,
    armebv6m,
    armebv6k,
    armebv6t2,
    armebv5,
    armebv5te,
    armebv4t,
    aarch64,
    aarch64_be,
    arc,
    avr,
    bpfel,
    bpfeb,
    hexagon,
    mips,
    mipsel,
    mips64,
    mips64el,
    msp430,
    nios2,
    powerpc,
    powerpc64,
    powerpc64le,
    r600,
    amdgcn,
    riscv32,
    riscv64,
    sparc,
    sparcv9,
    sparcel,
    s390x,
    tce,
    tcele,
    thumb,
    thumbeb,
    <span class="tok-type">i386</span>,
    x86_64,
    xcore,
    nvptx,
    nvptx64,
    le32,
    le64,
    amdil,
    amdil64,
    hsail,
    hsail64,
    spir,
    spir64,
    kalimbav3,
    kalimbav4,
    kalimbav5,
    shave,
    lanai,
    wasm32,
    wasm64,
    renderscript32,
    renderscript64,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Environ = <span class="tok-kw">enum</span> {
    unknown,
    gnu,
    gnuabin32,
    gnuabi64,
    gnueabi,
    gnueabihf,
    gnux32,
    code16,
    eabi,
    eabihf,
    android,
    musl,
    musleabi,
    musleabihf,
    msvc,
    itanium,
    cygnus,
    coreclr,
    simulator,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> ObjectFormat = <span class="tok-kw">enum</span> {
    unknown,
    coff,
    elf,
    macho,
    wasm,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> GlobalLinkage = <span class="tok-kw">enum</span> {
    Internal,
    Strong,
    Weak,
    LinkOnce,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicOrder = <span class="tok-kw">enum</span> {
    Unordered,
    Monotonic,
    Acquire,
    Release,
    AcqRel,
    SeqCst,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> AtomicRmwOp = <span class="tok-kw">enum</span> {
    Xchg,
    Add,
    Sub,
    And,
    Nand,
    Or,
    Xor,
    Max,
    Min,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Mode = <span class="tok-kw">enum</span> {
    Debug,
    ReleaseSafe,
    ReleaseFast,
    ReleaseSmall,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TypeId = <span class="tok-kw">enum</span> {
    Type,
    Void,
    Bool,
    NoReturn,
    Int,
    Float,
    Pointer,
    Array,
    Struct,
    ComptimeFloat,
    ComptimeInt,
    Undefined,
    Null,
    Optional,
    ErrorUnion,
    ErrorSet,
    Enum,
    Union,
    Fn,
    Namespace,
    BoundFn,
    ArgTuple,
    Opaque,
    Promise,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> TypeInfo = <span class="tok-kw">union</span>(TypeId) {
    Type: <span class="tok-type">void</span>,
    Void: <span class="tok-type">void</span>,
    Bool: <span class="tok-type">void</span>,
    NoReturn: <span class="tok-type">void</span>,
    Int: Int,
    Float: Float,
    Pointer: Pointer,
    Array: Array,
    Struct: Struct,
    ComptimeFloat: <span class="tok-type">void</span>,
    ComptimeInt: <span class="tok-type">void</span>,
    Undefined: <span class="tok-type">void</span>,
    Null: <span class="tok-type">void</span>,
    Optional: Optional,
    ErrorUnion: ErrorUnion,
    ErrorSet: ErrorSet,
    Enum: Enum,
    Union: Union,
    Fn: Fn,
    Namespace: <span class="tok-type">void</span>,
    BoundFn: Fn,
    ArgTuple: <span class="tok-type">void</span>,
    Opaque: <span class="tok-type">void</span>,
    Promise: Promise,


    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Int = <span class="tok-kw">struct</span> {
        is_signed: <span class="tok-type">bool</span>,
        bits: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Float = <span class="tok-kw">struct</span> {
        bits: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Pointer = <span class="tok-kw">struct</span> {
        size: Size,
        is_const: <span class="tok-type">bool</span>,
        is_volatile: <span class="tok-type">bool</span>,
        alignment: <span class="tok-type">u32</span>,
        child: <span class="tok-type">type</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <span class="tok-kw">enum</span> {
            One,
            Many,
            Slice,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Array = <span class="tok-kw">struct</span> {
        len: <span class="tok-type">usize</span>,
        child: <span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ContainerLayout = <span class="tok-kw">enum</span> {
        Auto,
        Extern,
        Packed,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> StructField = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        offset: ?<span class="tok-type">usize</span>,
        field_type: <span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Struct = <span class="tok-kw">struct</span> {
        layout: ContainerLayout,
        fields: []StructField,
        defs: []Definition,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Optional = <span class="tok-kw">struct</span> {
        child: <span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorUnion = <span class="tok-kw">struct</span> {
        error_set: <span class="tok-type">type</span>,
        payload: <span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        value: <span class="tok-type">usize</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorSet = <span class="tok-kw">struct</span> {
        errors: []Error,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> EnumField = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        value: <span class="tok-type">usize</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Enum = <span class="tok-kw">struct</span> {
        layout: ContainerLayout,
        tag_type: <span class="tok-type">type</span>,
        fields: []EnumField,
        defs: []Definition,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnionField = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        enum_field: ?EnumField,
        field_type: <span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Union = <span class="tok-kw">struct</span> {
        layout: ContainerLayout,
        tag_type: ?<span class="tok-type">type</span>,
        fields: []UnionField,
        defs: []Definition,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> CallingConvention = <span class="tok-kw">enum</span> {
        Unspecified,
        C,
        Cold,
        Naked,
        Stdcall,
        Async,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FnArg = <span class="tok-kw">struct</span> {
        is_generic: <span class="tok-type">bool</span>,
        is_noalias: <span class="tok-type">bool</span>,
        arg_type: ?<span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Fn = <span class="tok-kw">struct</span> {
        calling_convention: CallingConvention,
        is_generic: <span class="tok-type">bool</span>,
        is_var_args: <span class="tok-type">bool</span>,
        return_type: ?<span class="tok-type">type</span>,
        async_allocator_type: ?<span class="tok-type">type</span>,
        args: []FnArg,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Promise = <span class="tok-kw">struct</span> {
        child: ?<span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Definition = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        is_pub: <span class="tok-type">bool</span>,
        data: Data,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            Type: <span class="tok-type">type</span>,
            Var: <span class="tok-type">type</span>,
            Fn: FnDef,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FnDef = <span class="tok-kw">struct</span> {
                fn_type: <span class="tok-type">type</span>,
                inline_type: Inline,
                calling_convention: CallingConvention,
                is_var_args: <span class="tok-type">bool</span>,
                is_extern: <span class="tok-type">bool</span>,
                is_export: <span class="tok-type">bool</span>,
                lib_name: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
                return_type: <span class="tok-type">type</span>,
                arg_names: [][] <span class="tok-kw">const</span> <span class="tok-type">u8</span>,

                <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Inline = <span class="tok-kw">enum</span> {
                    Auto,
                    Always,
                    Never,
                };
            };
        };
    };
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> FloatMode = <span class="tok-kw">enum</span> {
    Strict,
    Optimized,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> Endian = <span class="tok-kw">enum</span> {
    Big,
    Little,
};

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> endian = Endian.Little;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> is_test = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> os = Os.linux;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> arch = Arch.x86_64;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> environ = Environ.gnu;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> object_format = ObjectFormat.elf;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> mode = Mode.Debug;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> link_libc = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> have_error_return_tracing = <span class="tok-null">false</span>;
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> __zig_test_fn_slice = {}; <span class="tok-comment">// overwritten later</span></code></pre>
      <p>See also:</p><ul>
<li><a href="#Build-Mode">Build Mode</a></li>
</ul>

      
      <h1 id="Root-Source-File">Root Source File</h1>

      <p>TODO: explain how root source file finds other files</p>
      <p>TODO: pub fn main</p>
      <p>TODO: pub fn panic</p>
      <p>TODO: if linking with libc you can use export fn main</p>
      <p>TODO: order independent top level declarations</p>
      <p>TODO: lazy analysis</p>
      <p>TODO: using comptime { _ = @import() }</p>
      
      <h1 id="Zig-Test">Zig Test</h1>

      <p>TODO: basic usage</p>
      <p>TODO: lazy analysis</p>
      <p>TODO: --test-filter</p>
      <p>TODO: --test-name-prefix</p>
      <p>TODO: testing in releasefast and releasesafe mode. assert still works</p>
      
      <h1 id="Zig-Build-System">Zig Build System</h1>

      <p>TODO: explain purpose, it's supposed to replace make/cmake</p>
      <p>TODO: example of building a zig executable</p>
      <p>TODO: example of building a C library</p>
      
      <h1 id="C">C</h1>

      <p>
      Although Zig is independent of C, and, unlike most other languages, does not depend on libc,
      Zig acknowledges the importance of interacting with existing C code.
      </p>
      <p>
      There are a few ways that Zig facilitates C interop.
      </p>
      <h2 id="C-Type-Primitives">C Type Primitives</h2>

      <p>
      These have guaranteed C ABI compatibility and can be used like any other type.
      </p>
      <ul>
          <li><code class="zig"><span class="tok-type">c_short</span></code></li>
          <li><code class="zig"><span class="tok-type">c_ushort</span></code></li>
          <li><code class="zig"><span class="tok-type">c_int</span></code></li>
          <li><code class="zig"><span class="tok-type">c_uint</span></code></li>
          <li><code class="zig"><span class="tok-type">c_long</span></code></li>
          <li><code class="zig"><span class="tok-type">c_ulong</span></code></li>
          <li><code class="zig"><span class="tok-type">c_longlong</span></code></li>
          <li><code class="zig"><span class="tok-type">c_ulonglong</span></code></li>
          <li><code class="zig"><span class="tok-type">c_longdouble</span></code></li>
          <li><code class="zig"><span class="tok-type">c_void</span></code></li>
      </ul>
      <p>See also:</p><ul>
<li><a href="#Primitive-Types">Primitive Types</a></li>
</ul>

      
      <h2 id="C-String-Literals">C String Literals</h2>

      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">puts</span>([*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    puts(<span class="tok-str">c&quot;this has a null terminator&quot;</span>);
    puts(
        <span class="tok-str">c\\and so
</span>        <span class="tok-str">c\\does this
</span>        <span class="tok-str">c\\multiline C string literal
</span>    );
}</code></pre><pre><code class="shell">$ zig build-exe test.zig --library c
$ ./test
this has a null terminator
and so
does this
multiline C string literal
</code></pre>

      <p>See also:</p><ul>
<li><a href="#String-Literals">String Literals</a></li>
</ul>

      
      <h2 id="Import-from-C-Header-File">Import from C Header File</h2>

      <p>
      The <code class="zig"><span class="tok-builtin">@cImport</span></code> builtin function can be used
      to directly import symbols from .h files:
      </p>
      <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> c = <span class="tok-builtin">@cImport</span>({
    <span class="tok-comment">// See https://github.com/ziglang/zig/issues/515</span>
    <span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;_NO_CRT_STDIO_INLINE&quot;</span>, <span class="tok-str">&quot;1&quot;</span>);
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;stdio.h&quot;</span>);
});
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    _ = c.printf(<span class="tok-str">c&quot;hello\n&quot;</span>);
}</code></pre><pre><code class="shell">$ zig build-exe test.zig --library c
$ ./test
hello
</code></pre>

      <p>
      The <code class="zig"><span class="tok-builtin">@cImport</span></code> function takes an expression as a parameter.
      This expression is evaluated at compile-time and is used to control
      preprocessor directives and include multiple .h files:
      </p>
      <pre><code class="zig"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);

<span class="tok-kw">const</span> c = <span class="tok-builtin">@cImport</span>({
    <span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;NDEBUG&quot;</span>, builtin.mode == builtin.Mode.ReleaseFast);
    <span class="tok-kw">if</span> (something) {
        <span class="tok-builtin">@cDefine</span>(<span class="tok-str">&quot;_GNU_SOURCE&quot;</span>, {});
    }
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;stdlib.h&quot;</span>);
    <span class="tok-kw">if</span> (something) {
        <span class="tok-builtin">@cUndef</span>(<span class="tok-str">&quot;_GNU_SOURCE&quot;</span>);
    }
    <span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;soundio.h&quot;</span>);
});</code></pre>
      <p>See also:</p><ul>
<li><a href="#cImport">@cImport</a></li>
<li><a href="#cInclude">@cInclude</a></li>
<li><a href="#cDefine">@cDefine</a></li>
<li><a href="#cUndef">@cUndef</a></li>
<li><a href="#import">@import</a></li>
</ul>

      
      <h2 id="Exporting-a-C-Library">Exporting a C Library</h2>

      <p>
      One of the primary use cases for Zig is exporting a library with the C ABI for other programming languages
      to call into. The <code class="zig"><span class="tok-kw">export</span></code> keyword in front of functions, variables, and types causes them to
      be part of the library API:
      </p>
      <p class="file">mathtest.zig</p>
      <pre><code class="zig"><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a + b;
}</code></pre>
      <p>To make a shared library:</p>
      <pre><code class="shell">$ zig build-lib mathtest.zig
</code></pre>
      <p>To make a static library:</p>
      <pre><code class="shell">$ zig build-lib mathtest.zig --static
</code></pre>
      <p>Here is an example with the <a href="#Zig-Build-System">Zig Build System</a>:</p>
      <p class="file">test.c</p>
      <pre><code class="cpp">// This header is generated by zig from mathtest.zig
#include "mathtest.h"
#include &lt;assert.h&gt;

int main(int argc, char **argv) {
    assert(add(42, 1337) == 1379);
    return 0;
}</code></pre>
      <p class="file">build.zig</p>
      <pre><code class="zig"><span class="tok-kw">const</span> Builder = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).build.Builder;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *Builder) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> lib = b.addSharedLibrary(<span class="tok-str">&quot;mathtest&quot;</span>, <span class="tok-str">&quot;mathtest.zig&quot;</span>, b.version(<span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>));

    <span class="tok-kw">const</span> exe = b.addCExecutable(<span class="tok-str">&quot;test&quot;</span>);
    exe.addCompileFlags([][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{<span class="tok-str">&quot;-std=c99&quot;</span>});
    exe.addSourceFile(<span class="tok-str">&quot;test.c&quot;</span>);
    exe.linkLibrary(lib);

    b.default_step.dependOn(&amp;exe.step);

    <span class="tok-kw">const</span> run_cmd = b.addCommand(<span class="tok-str">&quot;.&quot;</span>, b.env_map, [][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{exe.getOutputPath()});
    run_cmd.step.dependOn(&amp;exe.step);

    <span class="tok-kw">const</span> test_step = b.step(<span class="tok-str">&quot;test&quot;</span>, <span class="tok-str">&quot;Test the program&quot;</span>);
    test_step.dependOn(&amp;run_cmd.step);
}</code></pre>
      <p class="file">terminal</p>
      <pre><code class="shell">$ zig build
$ ./test
$ echo $?
0</code></pre>
      
      <h2 id="Mixing-Object-Files">Mixing Object Files</h2>

      <p>
      You can mix Zig object files with any other object files that respect the C ABI. Example:
      </p>
      <p class="file">base64.zig</p>
      <pre><code class="zig"><span class="tok-kw">const</span> base64 = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).base64;

<span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">decode_base_64</span>(
    dest_ptr: [*]<span class="tok-type">u8</span>,
    dest_len: <span class="tok-type">usize</span>,
    source_ptr: [*]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    source_len: <span class="tok-type">usize</span>,
) <span class="tok-type">usize</span> {
    <span class="tok-kw">const</span> src = source_ptr[<span class="tok-number">0</span>..source_len];
    <span class="tok-kw">const</span> dest = dest_ptr[<span class="tok-number">0</span>..dest_len];
    <span class="tok-kw">const</span> base64_decoder = base64.standard_decoder_unsafe;
    <span class="tok-kw">const</span> decoded_size = base64_decoder.calcSize(src);
    base64_decoder.decode(dest[<span class="tok-number">0</span>..decoded_size], src);
    <span class="tok-kw">return</span> decoded_size;
}</code></pre>
      <p class="file">test.c</p>
      <pre><code class="cpp">// This header is generated by zig from base64.zig
#include "base64.h"

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    const char *encoded = "YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz";
    char buf[200];

    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));
    buf[len] = 0;
    puts(buf);

    return 0;
}</code></pre>
      <p class="file">build.zig</p>
      <pre><code class="zig"><span class="tok-kw">const</span> Builder = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).build.Builder;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">build</span>(b: *Builder) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> obj = b.addObject(<span class="tok-str">&quot;base64&quot;</span>, <span class="tok-str">&quot;base64.zig&quot;</span>);

    <span class="tok-kw">const</span> exe = b.addCExecutable(<span class="tok-str">&quot;test&quot;</span>);
    exe.addCompileFlags([][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {
        <span class="tok-str">&quot;-std=c99&quot;</span>,
    });
    exe.addSourceFile(<span class="tok-str">&quot;test.c&quot;</span>);
    exe.addObject(obj);
    exe.setOutputPath(<span class="tok-str">&quot;.&quot;</span>);

    b.default_step.dependOn(&amp;exe.step);
}</code></pre>
      <p class="file">terminal</p>
      <pre><code class="shell">$ zig build
$ ./test
all your base are belong to us</code></pre>
      <p>See also:</p><ul>
<li><a href="#Targets">Targets</a></li>
<li><a href="#Zig-Build-System">Zig Build System</a></li>
</ul>

      
      
      <h1 id="Targets">Targets</h1>

      <p>
      Zig supports generating code for all targets that LLVM supports. Here is
      what it looks like to execute <code>zig targets</code> on a Linux x86_64
      computer:
      </p>
      <pre><code class="shell">$ zig targets
Architectures:
  armv8_2a
  armv8_1a
  armv8
  armv8r
  armv8m_baseline
  armv8m_mainline
  armv7
  armv7em
  armv7m
  armv7s
  armv7k
  armv7ve
  armv6
  armv6m
  armv6k
  armv6t2
  armv5
  armv5te
  armv4t
  armeb
  aarch64
  aarch64_be
  avr
  bpfel
  bpfeb
  hexagon
  mips
  mipsel
  mips64
  mips64el
  msp430
  nios2
  powerpc
  powerpc64
  powerpc64le
  r600
  amdgcn
  riscv32
  riscv64
  sparc
  sparcv9
  sparcel
  s390x
  tce
  tcele
  thumb
  thumbeb
  i386
  x86_64 (native)
  xcore
  nvptx
  nvptx64
  le32
  le64
  amdil
  amdil64
  hsail
  hsail64
  spir
  spir64
  kalimbav3
  kalimbav4
  kalimbav5
  shave
  lanai
  wasm32
  wasm64
  renderscript32
  renderscript64

Operating Systems:
  freestanding
  ananas
  cloudabi
  dragonfly
  freebsd
  fuchsia
  ios
  kfreebsd
  linux (native)
  lv2
  macosx
  netbsd
  openbsd
  solaris
  windows
  haiku
  minix
  rtems
  nacl
  cnk
  bitrig
  aix
  cuda
  nvcl
  amdhsa
  ps4
  elfiamcu
  tvos
  watchos
  mesa3d
  contiki
  zen

Environments:
  unknown
  gnu (native)
  gnuabi64
  gnueabi
  gnueabihf
  gnux32
  code16
  eabi
  eabihf
  android
  musl
  musleabi
  musleabihf
  msvc
  itanium
  cygnus
  amdopencl
  coreclr
  opencl</code></pre>
      <p>
      The Zig Standard Library (<code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>)</code>) has architecture, environment, and operating sytsem
      abstractions, and thus takes additional work to support more platforms.
      Not all standard library code requires operating system abstractions, however,
      so things such as generic data structures work an all above platforms.
      </p>
      <p>The current list of targets supported by the Zig Standard Library is:</p>
      <ul>
      <li>Linux x86_64</li>
      <li>Windows x86_64</li>
      <li>MacOS x86_64</li>
      </ul>
      
      <h1 id="Style-Guide">Style Guide</h1>

      <p>
These coding conventions are not enforced by the compiler, but they are shipped in
this documentation along with the compiler in order to provide a point of
reference, should anyone wish to point to an authority on agreed upon Zig
coding style.
      </p>
      <h2 id="Whitespace">Whitespace</h2>

      <ul>
        <li>
          4 space indentation
        </li>
        <li>
          Open braces on same line, unless you need to wrap.
        </li>
        <li>If a list of things is longer than 2, put each item on its own line and
          exercise the abilty to put an extra comma at the end.
        </li>
        <li>
          Line length: aim for 100; use common sense.
        </li>
      </ul>
      
      <h2 id="Names">Names</h2>

      <p>
      Roughly speaking: <code class="zig">camelCaseFunctionName</code>, <code class="zig">TitleCaseTypeName</code>,
              <code class="zig">snake_case_variable_name</code>. More precisely:
      </p>
      <ul>
        <li>
            If <code class="zig">x</code> is a <code class="zig"><span class="tok-kw">struct</span></code> (or an alias of a <code class="zig"><span class="tok-kw">struct</span></code>),
                        then <code class="zig">x</code> should be <code class="zig">TitleCase</code>.
        </li>
        <li>
            If <code class="zig">x</code> otherwise identifies a type, <code class="zig">x</code> should have <code class="zig">snake_case</code>.
        </li>
        <li>
            If <code class="zig">x</code> is callable, and <code class="zig">x</code>'s return type is <code class="zig"><span class="tok-type">type</span></code>, then <code class="zig">x</code> should be <code class="zig">TitleCase</code>.
        </li>
        <li>
            If <code class="zig">x</code> is otherwise callable, then <code class="zig">x</code> should be <code class="zig">camelCase</code>.
        </li>
        <li>
            Otherwise, <code class="zig">x</code> should be <code class="zig">snake_case</code>.
        </li>
      </ul>
      <p>
      Acronyms, initialisms, proper nouns, or any other word that has capitalization
      rules in written English are subject to naming conventions just like any other
      word. Even acronyms that are only 2 letters long are subject to these
      conventions.
      </p>
      <p>
      These are general rules of thumb; if it makes sense to do something different,
      do what makes sense. For example, if there is an established convention such as
      <code class="zig">ENOENT</code>, follow the established convention.
      </p>
      
      <h2 id="Examples">Examples</h2>

      <pre><code class="zig"><span class="tok-kw">const</span> namespace_name = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;dir_name/file_name.zig&quot;</span>);
<span class="tok-kw">var</span> global_var: <span class="tok-type">i32</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">const</span> const_name = <span class="tok-number">42</span>;
<span class="tok-kw">const</span> primitive_type_alias = <span class="tok-type">f32</span>;
<span class="tok-kw">const</span> string_alias = []<span class="tok-type">u8</span>;

<span class="tok-kw">const</span> StructName = <span class="tok-kw">struct</span> {};
<span class="tok-kw">const</span> StructAlias = StructName;

<span class="tok-kw">fn</span> <span class="tok-fn">functionName</span>(param_name: TypeName) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> functionPointer = functionName;
    functionPointer();
    functionPointer = otherFunction;
    functionPointer();
}
<span class="tok-kw">const</span> functionAlias = functionName;

<span class="tok-kw">fn</span> <span class="tok-fn">ListTemplateFunction</span>(<span class="tok-kw">comptime</span> ChildType: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> fixed_size: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> List(ChildType, fixed_size);
}

<span class="tok-kw">fn</span> <span class="tok-fn">ShortList</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, <span class="tok-kw">comptime</span> n: <span class="tok-type">usize</span>) <span class="tok-type">type</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {
        field_name: [n]T,
        <span class="tok-kw">fn</span> <span class="tok-fn">methodName</span>() <span class="tok-type">void</span> {}
    };
}

<span class="tok-comment">// The word XML loses its casing when used in Zig identifiers.</span>
<span class="tok-kw">const</span> xml_document =
    <span class="tok-str">\\&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</span>    <span class="tok-str">\\&lt;document&gt;
</span>    <span class="tok-str">\\&lt;/document&gt;
</span>;
<span class="tok-kw">const</span> XmlParser = <span class="tok-kw">struct</span> {};

<span class="tok-comment">// The initials BE (Big Endian) are just another word in Zig identifier names.</span>
<span class="tok-kw">fn</span> <span class="tok-fn">readU32Be</span>() <span class="tok-type">u32</span> {}</code></pre>
      <p>
      See the Zig Standard Library for more examples.
      </p>
      
      
      <h1 id="Source-Encoding">Source Encoding</h1>

      <p>Zig source code is encoded in UTF-8. An invalid UTF-8 byte sequence results in a compile error.</p>
      <p>Throughout all zig source code (including in comments), some codepoints are never allowed:</p>
      <ul>
        <li>Ascii control characters, except for U+000a (LF): U+0000 - U+0009, U+000b - U+0001f, U+007f. (Note that Windows line endings (CRLF) are not allowed, and hard tabs are not allowed.)</li>
        <li>Non-Ascii Unicode line endings: U+0085 (NEL), U+2028 (LS), U+2029 (PS).</li>
      </ul>
      <p>The codepoint U+000a (LF) (which is encoded as the single-byte value 0x0a) is the line terminator character. This character always terminates a line of zig source code (except possbly the last line of the file).</p>
      <p>For some discussion on the rationale behind these design decisions, see <a href="https://github.com/ziglang/zig/issues/663">issue #663</a></p>
      
      <h1 id="Grammar">Grammar</h1>

      <pre><code class="nohighlight">Root = many(TopLevelItem) EOF

TopLevelItem = CompTimeExpression(Block) | TopLevelDecl | TestDecl

TestDecl = "test" String Block

TopLevelDecl = option("pub") (FnDef | ExternDecl | GlobalVarDecl | UseDecl)

GlobalVarDecl = option("export") VariableDeclaration ";"

LocalVarDecl = option("comptime") VariableDeclaration

VariableDeclaration = ("var" | "const") Symbol option(":" TypeExpr) option("align" "(" Expression ")") option("section" "(" Expression ")") "=" Expression

ContainerMember = (ContainerField | FnDef | GlobalVarDecl)

ContainerField = Symbol option(":" PrefixOpExpression) option("=" PrefixOpExpression) ","

UseDecl = "use" Expression ";"

ExternDecl = "extern" option(String) (FnProto | VariableDeclaration) ";"

FnProto = option("nakedcc" | "stdcallcc" | "extern" | ("async" option("&lt;" Expression "&gt;"))) "fn" option(Symbol) ParamDeclList option("align" "(" Expression ")") option("section" "(" Expression ")") option("!") (TypeExpr | "var")

FnDef = option("inline" | "export") FnProto Block

ParamDeclList = "(" list(ParamDecl, ",") ")"

ParamDecl = option("noalias" | "comptime") option(Symbol ":") (TypeExpr | "var" | "...")

Block = option(Symbol ":") "{" many(Statement) "}"

Statement = LocalVarDecl ";" | Defer(Block) | Defer(Expression) ";" | BlockExpression(Block) | Expression ";" | ";"

TypeExpr = (PrefixOpExpression "!" PrefixOpExpression) | PrefixOpExpression

BlockOrExpression = Block | Expression

Expression = TryExpression | ReturnExpression | BreakExpression | AssignmentExpression | CancelExpression | ResumeExpression

AsmExpression = "asm" option("volatile") "(" String option(AsmOutput) ")"

AsmOutput = ":" list(AsmOutputItem, ",") option(AsmInput)

AsmInput = ":" list(AsmInputItem, ",") option(AsmClobbers)

AsmOutputItem = "[" Symbol "]" String "(" (Symbol | "-&gt;" TypeExpr) ")"

AsmInputItem = "[" Symbol "]" String "(" Expression ")"

AsmClobbers= ":" list(String, ",")

UnwrapExpression = BoolOrExpression (UnwrapOptional | UnwrapError) | BoolOrExpression

UnwrapOptional = "orelse" Expression

UnwrapError = "catch" option("|" Symbol "|") Expression

AssignmentExpression = UnwrapExpression AssignmentOperator UnwrapExpression | UnwrapExpression

AssignmentOperator = "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "&lt;&lt;=" | "&gt;&gt;=" | "&amp;=" | "^=" | "|=" | "*%=" | "+%=" | "-%="

BlockExpression(body) = Block | IfExpression(body) | IfErrorExpression(body) | TestExpression(body) | WhileExpression(body) | ForExpression(body) | SwitchExpression | CompTimeExpression(body) | SuspendExpression(body)

CompTimeExpression(body) = "comptime" body

SwitchExpression = "switch" "(" Expression ")" "{" many(SwitchProng) "}"

SwitchProng = (list(SwitchItem, ",") | "else") "=&gt;" option("|" option("*") Symbol "|") Expression ","

SwitchItem = Expression | (Expression "..." Expression)

ForExpression(body) = option(Symbol ":") option("inline") "for" "(" Expression ")" option("|" option("*") Symbol option("," Symbol) "|") body option("else" BlockExpression(body))

BoolOrExpression = BoolAndExpression "or" BoolOrExpression | BoolAndExpression

ReturnExpression = "return" option(Expression)

TryExpression = "try" Expression

AwaitExpression = "await" Expression

BreakExpression = "break" option(":" Symbol) option(Expression)

CancelExpression = "cancel" Expression;

ResumeExpression = "resume" Expression;

Defer(body) = ("defer" | "deferror") body

IfExpression(body) = "if" "(" Expression ")" body option("else" BlockExpression(body))

SuspendExpression(body) = "suspend" option( body )

IfErrorExpression(body) = "if" "(" Expression ")" option("|" option("*") Symbol "|") body "else" "|" Symbol "|" BlockExpression(body)

TestExpression(body) = "if" "(" Expression ")" option("|" option("*") Symbol "|") body option("else" BlockExpression(body))

WhileExpression(body) = option(Symbol ":") option("inline") "while" "(" Expression ")" option("|" option("*") Symbol "|") option(":" "(" Expression ")") body option("else" option("|" Symbol "|") BlockExpression(body))

BoolAndExpression = ComparisonExpression "and" BoolAndExpression | ComparisonExpression

ComparisonExpression = BinaryOrExpression ComparisonOperator BinaryOrExpression | BinaryOrExpression

ComparisonOperator = "==" | "!=" | "&lt;" | "&gt;" | "&lt;=" | "&gt;="

BinaryOrExpression = BinaryXorExpression "|" BinaryOrExpression | BinaryXorExpression

BinaryXorExpression = BinaryAndExpression "^" BinaryXorExpression | BinaryAndExpression

BinaryAndExpression = BitShiftExpression "&amp;" BinaryAndExpression | BitShiftExpression

BitShiftExpression = AdditionExpression BitShiftOperator BitShiftExpression | AdditionExpression

BitShiftOperator = "&lt;&lt;" | "&gt;&gt;"

AdditionExpression = MultiplyExpression AdditionOperator AdditionExpression | MultiplyExpression

AdditionOperator = "+" | "-" | "++" | "+%" | "-%"

MultiplyExpression = CurlySuffixExpression MultiplyOperator MultiplyExpression | CurlySuffixExpression

CurlySuffixExpression = TypeExpr option(ContainerInitExpression)

MultiplyOperator = "||" | "*" | "/" | "%" | "**" | "*%"

PrefixOpExpression = PrefixOp TypeExpr | SuffixOpExpression

SuffixOpExpression = ("async" option("&lt;" SuffixOpExpression "&gt;") SuffixOpExpression FnCallExpression) | PrimaryExpression option(FnCallExpression | ArrayAccessExpression | FieldAccessExpression | SliceExpression | ".*" | ".?")

FieldAccessExpression = "." Symbol

FnCallExpression = "(" list(Expression, ",") ")"

ArrayAccessExpression = "[" Expression "]"

SliceExpression = "[" Expression ".." option(Expression) "]"

ContainerInitExpression = "{" ContainerInitBody "}"

ContainerInitBody = list(StructLiteralField, ",") | list(Expression, ",")

StructLiteralField = "." Symbol "=" Expression

PrefixOp = "!" | "-" | "~" | (("*" | "[*]") option("align" "(" Expression option(":" Integer ":" Integer) ")" ) option("const") option("volatile")) | "?" | "-%" | "try" | "await"

PrimaryExpression = Integer | Float | String | CharLiteral | KeywordLiteral | GroupedExpression | BlockExpression(BlockOrExpression) | Symbol | ("@" Symbol FnCallExpression) | ArrayType | FnProto | AsmExpression | ContainerDecl | ("continue" option(":" Symbol)) | ErrorSetDecl | PromiseType

PromiseType = "promise" option("-&gt;" TypeExpr)

ArrayType : "[" option(Expression) "]" option("align" "(" Expression option(":" Integer ":" Integer) ")")) option("const") option("volatile") TypeExpr

GroupedExpression = "(" Expression ")"

KeywordLiteral = "true" | "false" | "null" | "undefined" | "error" | "unreachable" | "suspend"

ErrorSetDecl = "error" "{" list(Symbol, ",") "}"

ContainerDecl = option("extern" | "packed")
  ("struct" option(GroupedExpression) | "union" option("enum" option(GroupedExpression) | GroupedExpression) | ("enum" option(GroupedExpression)))
  "{" many(ContainerMember) "}"</code></pre>
      
      <h1 id="Zen">Zen</h1>

      <ul>
        <li>Communicate intent precisely.</li>
        <li>Edge cases matter.</li>
        <li>Favor reading code over writing code.</li>
        <li>Only one obvious way to do things.</li>
        <li>Runtime crashes are better than bugs.</li>
        <li>Compile errors are better than runtime crashes.</li>
        <li>Incremental improvements.</li>
        <li>Avoid local maximums.</li>
        <li>Reduce the amount one must remember.</li>
        <li>Minimize energy spent on coding style.</li>
        <li>Together we serve end users.</li>
      </ul>
      
    </div>
  </body>
</html>
