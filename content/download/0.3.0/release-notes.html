<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>0.3.0 Release Notes &middot; The Zig Programming Language</title>
    <link rel="icon" href="/favicon.png">
    <link rel="icon" href="/favicon.svg">
    <style>
      #contents {
        max-width: 50em;
        margin: auto;
        font-size: 18px;
      }
      table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
      }
      th, td {
        padding: 0.1em;
      }
      .t0_1, .t37, .t37_1 {
        font-weight: bold;
      }
      .t2_0 {
        color: grey;
      }
      .t31_1 {
        color: red;
      }
      .t32_1 {
        color: green;
      }
      .t36_1 {
        color: #0086b3;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #998;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      pre > code {
        display: block;
        overflow: auto;

        padding: 0.5em;
        color: #333;
        background: #f8f8f8;
      }
      pre, code {
        font-size: 18px;
      }
    </style>
  </head>
  <!--
░░░░░░░░▀▀▀██████▄▄▄
░░░░░░▄▄▄▄▄░░█████████▄ 
░░░░░▀▀▀▀█████▌░▀▐▄░▀▐█ 
░░░▀▀█████▄▄░▀██████▄██ 
░░░▀▄▄▄▄▄░░▀▀█▄▀█════█▀
░░░░░░░░▀▀▀▄░░▀▀███░▀░░░░░░▄▄
░░░░░▄███▀▀██▄████████▄░▄▀▀▀██▌
░░░██▀▄▄▄██▀▄███▀░▀▀████░░░░░▀█▄
▄▀▀▀▄██▄▀▀▌████▒▒▒▒▒▒███░░░░▌▄▄▀
▌░░░░▐▀████▐███▒▒▒▒▒▐██▌
▀▄░░▄▀░░░▀▀████▒▒▒▒▄██▀
░░▀▀░░░░░░▀▀█████████▀
░░░░░░░░▄▄██▀██████▀█
░░░░░░▄██▀░░░░░▀▀▀░░█
░░░░░▄█░░░░░░░░░░░░░▐▌
░▄▄▄▄█▌░░░░░░░░░░░░░░▀█▄▄▄▄▀▀▄
▌░░░░░▐░░░░░░░░░░░░░░░░▀▀▄▄▄▀
gotta go fast
  -->
  <body>
    <div id="contents">
    <a href="/"><img alt="zig" src="../../zig-logo.svg" style="width: 28em"></a>
    <h1>0.3.0 Release Notes</h1>
    <p>
    <a href="/download">Download &amp; Documentation</a>
    </p>
    <p>
    Zig is an open-source programming language designed for <strong>robustness</strong>,
    <strong>optimality</strong>, and <strong>clarity</strong>. Zig is aggressively pursuing
    its goal of overthrowing C as the de facto language for system programming. Zig intends
    to be so practical that people find themselves using it even if they dislike it.
    </p>
    <p>
    This is a <em>massive</em> release, featuring 6 months of work and
    changes from <strong>36 different contributors</strong>.
    </p>
    <p>I tried to give credit
    where credit is due, but it's inevitable I missed some contributions as I had
    to go through 1,345 commits to type up these release notes. I apologize in
    advance for any mistakes.
    </p>
    <p>
    Special thanks to my <a href="https://github.com/users/andrewrk/sponsorship">sponsors who provide financial support</a>. You're making Zig sustainable.
    </p>

   <h2 id="stack-traces">Stack Traces on All Targets</h2>
   <p>Zig uses LLVM's debug info API to emit native debugging information on all targets.
   This means that you can use native debugging tools on Zig code, for example:
   </p>
   <ul>
     <li>MSVC on Windows</li>
     <li>lldb on MacOS</li>
     <li>gdb and valgrind on Linux</li>
   </ul>
   <p>
   In addition, Zig's standard library can read its own native debug information. This
   means that crashes produce stack traces, and errors produce
   <a href="https://ziglang.org/documentation/0.3.0/#Error-Return-Traces">Error Return Traces</a>.
   </p>
   <h3 id="stack-traces-macos">MacOS</h3>
   <img src="stack-traces-macos.png">
   <p>This implementation is able to look at the executable's own memory to find out where the .o
   files are, which have the DWARF info.</p>
   <h3 id="stack-traces-windows">Windows</h3>
   <img src="stack-traces-windows.png">
   <p>Thanks to <a href="https://github.com/Sahnvour">Sahnvour</a> for implementing the PE parsing
   and starting the effort to PDB parsing. I picked up where he left off and finished Windows stack traces.
   </p>
   <p>
   Thanks to Zachary Turner from the LLVM project for helping me understand the PDB format. I still owe
   LLVM some PDB documentation patches in return.
   </p>
   <p>Similar to MacOS, a Windows executable in memory has location information pointing to a .pdb file which
   contains debug information.</p>
   <h3 id="stack-traces-linux">Linux</h3>
   <img src="stack-traces-linux.png">
   <p>Linux stack traces worked in 0.2.0. However now <code class="zig">std.debug.dumpStackTrace</code> &amp; friends use <code class="zig">ArenaAllocator</code> backed by
   <code class="zig">DirectAllocator</code>. This has the downside of failing to print a stack trace
        when the system is out of memory, but for the more common use case when the system is not
        out of memory, but the debug info cannot fit in <code class="zig">std.debug.global_allocator</code>,
        now stack traces will work. This is the case for the self hosted compiler.
   There is <a href="https://github.com/ziglang/zig/issues/907#issuecomment-415946565">a proposal</a> to
   <code>mmap()</code> debug info rather than using <code>read()</code>.
   </p>
   <p>See also <a href="#rosegment">Compatibility with Valgrind</a>.

   <h2 id="zig-fmt">zig fmt</h2>
   <p>
   Thanks to Jimmi Holst Christensen's diligent work, the Zig standard library now supports parsing Zig code.
   This API is used to implement <code>zig fmt</code>, a tool that reformats code to fit the
   canonical style.
   </p>
   <p>
   As an example, <code>zig fmt</code> will change this code:
   </p>
   <pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;fmt&quot;</span> {
<span class="tok-kw">const</span> a = []<span class="tok-type">u8</span>{
    <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-comment">//</span>
    <span class="tok-number">3</span>,
    <span class="tok-number">4</span>, <span class="tok-comment">// foo</span>
    <span class="tok-number">5</span>,
    <span class="tok-number">6</span>,
    <span class="tok-number">7</span> };
         <span class="tok-kw">switch</span> (<span class="tok-number">0</span>) { <span class="tok-number">0</span> =&gt; {}, <span class="tok-number">1</span> =&gt; <span class="tok-kw">unreachable</span>, <span class="tok-number">2</span>,
            <span class="tok-number">3</span> =&gt; {}, <span class="tok-number">4</span>...<span class="tok-number">7</span> =&gt; {}, <span class="tok-number">1</span> + <span class="tok-number">4</span> * <span class="tok-number">3</span> + <span class="tok-number">22</span> =&gt; {}, <span class="tok-kw">else</span> =&gt; { <span class="tok-kw">const</span> a = <span class="tok-number">1</span>; <span class="tok-kw">const</span> b = a; }, }

    foo(a, b, c, d, e, f, g,);
}</code></pre>
   <p>
   ...into this code:
   </p>
<pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;fmt&quot;</span> {
    <span class="tok-kw">const</span> a = []<span class="tok-type">u8</span>{
        <span class="tok-number">1</span>, <span class="tok-number">2</span>,
        <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-comment">// foo</span>
        <span class="tok-number">5</span>, <span class="tok-number">6</span>,
        <span class="tok-number">7</span>,
    };
    <span class="tok-kw">switch</span> (<span class="tok-number">0</span>) {
        <span class="tok-number">0</span> =&gt; {},
        <span class="tok-number">1</span> =&gt; <span class="tok-kw">unreachable</span>,
        <span class="tok-number">2</span>, <span class="tok-number">3</span> =&gt; {},
        <span class="tok-number">4</span>...<span class="tok-number">7</span> =&gt; {},
        <span class="tok-number">1</span> + <span class="tok-number">4</span> * <span class="tok-number">3</span> + <span class="tok-number">22</span> =&gt; {},
        <span class="tok-kw">else</span> =&gt; {
            <span class="tok-kw">const</span> a = <span class="tok-number">1</span>;
            <span class="tok-kw">const</span> b = a;
        },
    }

    foo(
        a,
        b,
        c,
        d,
        e,
        f,
        g,
    );
}</code></pre>
  <p>It does not make any decisions about line widths. That is left up to the user.
     However, it follows certain cues about when to line break. For example, it will put the
     same number of array items in a line as there are in the first one. And it will
     put a function call all on one line if there is no trailing comma, but break every
     parameter into its own line if there is a trailing comma.
    </p>
    <p>Thanks to Marc Tiehuis, there are currently two editor plugins that integrate with <code>zig fmt</code>:
    <ul>
      <li><a href="https://github.com/ziglang/zig.vim">Vim</a></li>
      <li><a href="https://github.com/ziglang/vscode-zig">VSCode</a></li>
    </ul>
    <p>
    <code>zig fmt</code> is only implemented in the self-hosted compiler,
    which is <a href="#stage2-progress">not finished yet</a>. To use it, one
    must follow the README instructions to build the self-hosted compiler from source.
    </p>
    <p>
    The
    <a href="https://github.com/ziglang/zig/blob/0.3.0/std/zig/parse.zig#L12">implementation of the self-hosted parser</a>
    is an interesting case study of avoiding recursion by using an explicit stack. It is essentially a
    hand-written recursive descent parser, but with heap allocations instead of recursion. When Jimmi
    originally implemented the code, we thought that we could not solve the unbounded stack growth problem
    of recursion. However, since then, I prototyped several solutions that provide the ability to have
    recursive function calls without giving up statically known upper bound stack growth. See
    <a href="#recursion">Recursion Status</a> for more details.
    </p>
    <p>Automatic formatting can be disabled in source files with a comment like this:</p>
    <pre><code class="zig"><span class="tok-comment">// zig fmt: off</span>
<span class="tok-kw">test</span>     <span class="tok-str">&quot;this is left alone&quot;</span>  {   }
<span class="tok-comment">// zig fmt: on</span></code></pre>
    <p>
    <code>zig fmt</code> is written using the standard library's event-based I/O abstractions and
    <code class="zig"><span class="tok-kw">async</span></code>/<code class="zig"><span class="tok-kw">await</span></code> syntax, which means that it is
    multi-threaded with non-blocking I/O. A debug build of <code>zig fmt</code> on my laptop
    formats the entire Zig standard library in 2.1 seconds, which is 75,516 lines per second.
    See <a href="#concurrency">Concurrency Status</a> for more details.
    </p>

   <h2 id="zig-run">zig run</h2>
   <p>
   <code>zig run file.zig</code> can now be used to execute a file directly.
   </p>
   <p>Thanks to Marc Tiehuis for the initial implementation of this feature. Marc writes:</p>
   <p>
    On a POSIX system, a shebang can be used to run a zig file directly. An
    example shebang would be <code>#!/usr/bin/zig run</code>. You may not be able pass
    extra compile arguments currently as part of the shebang. Linux for example
    treats all arguments after the first as a single argument which will result
    in an 'invalid command'.
   </p>
   <p>Note: there is <a href="https://github.com/ziglang/zig/issues/1505">a proposal</a>
   to change this to <code>zig file.zig</code> to match the interface of other languages,
   as well as enable the common pattern <code>#!/usr/bin/env zig</code>.</p>
   <p>
   Zig caches the binary generated by <code>zig run</code> so that subsequent invocations have low
   startup cost. See <a href="#caching">Build Artifact Caching</a> for more details.
   </p>

   <h2 id="static-builds">Automated Static Linux x86_64 Builds of Master Branch</h2>
   <p>Zig now supports building statically against <a href="https://www.musl-libc.org/">musl libc</a>.</p>
   <p>On every master branch push, the continuous integration server creates a static Linux build of zig
   and updates the URL <code>https://ziglang.org/builds/zig-linux-x86_64-master.tar.xz</code> to redirect to it.
   </p>
   <p>
   In addition, Zig now looks for libc and the Zig standard library at runtime. This makes static
   builds the easiest and most reliable way to start using the latest version of Zig immediately.
   </p>
   <p>
   Windows has automated static builds of master branch
   <a href="https://ci.appveyor.com/project/andrewrk/zig-d3l86/history">via AppVeyor</a>.
   </p>
   <p>
   MacOS static CI builds are
   <a href="https://github.com/ziglang/zig/issues/1089">in progress</a>
   and should be available soon.
   </p>

   <h2 id="pointer-reform">Pointer Reform</h2>
   <p>During this release cycle, two design flaws were fixed, which led to a chain reaction
   of changes that I called Pointer Reform, resulting in a more consistent syntax with
   simpler semantics.</p>
   <p>The first design flaw was that the syntax for pointers was ambiguous if the pointed
   to type was a <code class="zig"><span class="tok-type">type</span></code>. Consider this 0.2.0 code:</p>
   <pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">comptime</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> b = &amp;a;
    <span class="tok-builtin">@compileLog</span>(<span class="tok-builtin">@typeOf</span>(b));
    *b = <span class="tok-number">2</span>;
    assert(a == <span class="tok-number">2</span>);
}</code></pre>
   <p>This works fine. The value printed from the
   <code class="zig"><span class="tok-builtin">@compileLog</span></code> statement is <code class="zig">&amp;<span class="tok-type">i32</span></code>.
   This makes sense because <code class="zig">b</code> is a pointer to <code class="zig">a</code>.</p>
   <p>Now let's do it with a <code class="zig"><span class="tok-type">type</span></code>:</p>
   <pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">comptime</span> {
    <span class="tok-kw">var</span> a: <span class="tok-type">type</span> = <span class="tok-type">i32</span>;
    <span class="tok-kw">const</span> b = &amp;a;
    <span class="tok-builtin">@compileLog</span>(b);
    *b = <span class="tok-type">f32</span>;
    assert(a == <span class="tok-type">f32</span>);
}</code></pre>
<pre><code class="shell">$ zig build-obj test.zig 
| &amp;i32
<span class="t0_1">test.zig:6:5:</span> <span class="t31_1">error:</span> <span class="t0_1">found compile log statement</span>
    @compileLog(b);
    <span class="t32_1">^</span>
<span class="t0_1">test.zig:7:5:</span> <span class="t31_1">error:</span> <span class="t0_1">attempt to dereference non-pointer type 'type'</span>
    *b = f32;
    <span class="t32_1">^</span></code></pre>
<p>It doesn't work in 0.2.0, because the <code class="zig">&amp;</code> operator worked differently for
<code class="zig"><span class="tok-type">type</span></code> than other types. Here, <code class="zig">b</code> is the type <code class="zig">&amp;<span class="tok-type">i32</span></code> instead of a pointer to a type which is how we wanted to use it.</p>
<p>This prevented other things from working too; for example if you had a
<code class="zig">[]<span class="tok-type">type</span>{<span class="tok-type">i32</span>, <span class="tok-type">u8</span>, <span class="tok-type">f64</span>}</code> and you tried to use a for loop,
it crashed the compiler because internally a for loop uses the <code class="zig">&amp;</code>
operator on the array element.</p>
   <p>The only reasonable solution to this is to have different syntax for the address-of operator and
   the pointer operator, rather than them both being <code class="zig">&amp;</code>.</p>
   <p>So pointer syntax becomes <code class="zig">*T</code>, matching syntax from most other languages such as C.
   Address-of syntax remains <code class="zig">&amp;foo</code>, again matching common address-of syntax such as in C.
   This leaves one problem though.</p>
   <p>With this modification, the syntax <code class="zig">*foo</code> becomes ambiguous with the syntax for
   dereferencing. And so dereferencing syntax is changed to a postfix operator: <code class="zig">foo.*</code>.
   This matches post-fix indexing syntax: <code class="zig">foo[<span class="tok-number">0</span>]</code>, and in practice ends up harmonizing
   nicely with other postfix operators.</p>
   <p>The other design flaw is a problem that has plagued C since its creation: the pointer type doesn't tell you how many items
   there are at the address. This is now fixed by having two kinds of pointers in Zig:</p>
   <ul>
     <li><code class="zig">*T</code> - pointer to exactly one item.
       <ul>
         <li>Supports deref syntax: <code class="zig">ptr.*</code></li>
       </ul>
     </li>
     <li><code class="zig">[*]T</code> - pointer to unknown number of items.
       <ul>
         <li>Supports index syntax: <code class="zig">ptr[i]</code></li>
         <li>Supports slice syntax: <code class="zig">ptr[start..end]</code></li>
         <li><code class="zig">T</code> must have a known size, which means that it cannot be
           <code class="zig"><span class="tok-type">c_void</span></code> or any other <code class="zig"><span class="tok-builtin">@OpaqueType</span>()</code>.</li>
        </ul>
     </li>
   </ul>
   <p>Note that this causes pointers to arrays to fall into place, as a single-item pointer
   to an array acts as a pointer to a compile-time known number of items:</p>
   <ul>
     <li><code class="zig">*[N]T</code> - pointer to N items, same as single-item pointer to array.
       <ul>
         <li>Supports index syntax: <code class="zig">array_ptr[i]</code></li>
         <li>Supports slice syntax: <code class="zig">array_ptr[start..end]</code></li>
         <li>Supports len property: <code class="zig">array_ptr.len</code></li>
       </ul>
     </li>
   </ul>
   <p>Consider how slices fit into this picture:</p>
   <ul>
     <li><code class="zig">[]T</code> - pointer to runtime-known number of items.
       <ul>
         <li>Supports index syntax: <code class="zig">slice[i]</code></li>
         <li>Supports slice syntax: <code class="zig">slice[start..end]</code></li>
         <li>Supports len property: <code class="zig">slice.len</code></li>
       </ul>
     </li>
   </ul>
   <p>This makes Zig pointers significantly less error prone. For example, it fixed issue <a href="https://github.com/ziglang/zig/issues/386">#386</a>,
   which demonstrates how a pointer to an array in Zig 0.2.0 is a footgun when passed as a parameter.
   Meanwhile in 0.3.0, equivalent code is nearly impossible to get wrong.</p>
   <p>For consistency with the postfix pointer dereference operator, optional unwrapping syntax is
   now postfix as well:</p>
   <p>0.2.0: <code>??x</code></p>
   <p>0.3.0: <code class="zig">x.?</code></p>
   <p>And finally, to remove the last inconsistency of optional syntax, the <code>??</code> operator
   is now the keyword <code class="zig"><span class="tok-kw">orelse</span></code>. This means that Zig now has the property that
   <strong>all control flow occurs exclusively via keywords</strong>.
   <p>
   There is <a href="https://github.com/ziglang/zig/issues/265">a plan for one more pointer type</a>,
   which is a pointer that has a null-terminated
   number of items. This would be the type of the parameter to <code>strlen</code> for example.
   Although this will make the language bigger by adding a new type, it allows Zig to delete a feature
   in exchange, since it will make
   <a href="https://ziglang.org/documentation/0.3.0/#C-String-Literals">C string literals</a> unnecessary.
   String literals will both have a compile-time known length and be null-terminated; therefore they
   will <a href="https://ziglang.org/documentation/0.3.0/#Implicit-Casts">implicitly cast</a> to 
   slices as well as null-terminated pointers.
   </p>
   <p>
   There is one new issue caused by Pointer Reform. Because C does not have the concept of
   single-item pointers or unknown-length pointers (or non-null pointers),
   Zig must translate all C pointers as <code class="zig">?[*]T</code>. That is, a pointer to
   an unknown number of items that might be null. This can cause some friction when using C APIs,
   which is unfortunate because Zig's types are perfectly compatible with C's types, but
   .h files are unable to adequately describe pointers. Although it would be much safer to
   translate .h files offline and fix their prototypes, there is
   <a href="https://github.com/ziglang/zig/issues/1059">a proposal to add a C pointer type</a>.
   This new pointer type should never be used on purpose, but would be used when auto-translating C code.
   It would simply have C pointer semantics, which means it would be just as much of a footgun as C pointers are.
   The upside is that it would make interaction with C APIs go back to being perfectly seamless.
   </p>

   <h2 id="default-float-mode">Default Float Mode is now Strict</h2>
   <p>In response to an overwhelming consensus, floating point operations use Strict mode by default.
   Code can use <a href="https://ziglang.org/documentation/0.3.0/#setFloatMode">@setFloatMode</a> to
   override the mode on a per-scope basis.</p>
   <p>Thanks to Marc Tiehuis for implementing the change.</p>

   <h2 id="remove-this">Remove this</h2>
   <p><code>this</code> was always a weird language feature. An identifier which referred to the thing in the
   most immediate scope, which could be a module, a type, a function, or even a block of code.</p>
   <p>The main use case for it was for anonymous structs to refer to themselves. This use case is solved
   with a new builtin function, <a href="https://ziglang.org/documentation/0.3.0/#This">@This()</a>,
   which always returns the innermost struct or union that the builtin call is inside.</p>
   <p>The "block of code" type is removed from Zig, and the first argument of
   <a href="https://ziglang.org/documentation/0.3.0/#setFloatMode">@setFloatMode</a> is removed.
   <code class="zig"><span class="tok-builtin">@setFloatMode</span></code> now always refers to the current scope.
   </p>

   <h2 id="casting-syntax">Remove Explicit Casting Syntax</h2>
   <p>Previously, these two lines would have different meanings:</p>
   <pre><code class="zig"><span class="tok-kw">export</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: <span class="tok-type">u32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> a: <span class="tok-type">u8</span> = x;
    <span class="tok-kw">const</span> b = <span class="tok-type">u8</span>(x);
}</code></pre>
   <p>The assignment to <code class="zig">a</code> would give <code>error: expected type 'u8', found 'u32'</code>,
   because not all values of <code class="zig"><span class="tok-type">u32</span></code> can fit in a <code class="zig"><span class="tok-type">u8</span></code>. But the
   assignment to <code class="zig">b</code> was "cast harder" syntax, and Zig would truncate bits,
   with a safety check to ensure that the mathematical meaning of the integer was preserved.
   </p><p>
   Now, both lines are identical in semantics. There is no more "cast harder" syntax.
   Both cause the compile error because implicit casts are only allowed when it is
   completely unambiguous how to get from one type to another, and the transformation is
   guaranteed to be safe. For other casts, Zig has builtin functions:
   </p>
   <ul>
     <li><a href="https://ziglang.org/documentation/0.3.0/#bitCast">@bitCast</a> - change type but maintain bit representation</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#alignCast">@alignCast</a> - make a pointer have more alignment</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#boolToInt">@boolToInt</a> - convert true to 1 and false to 0</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#bytesToSlice">@bytesToSlice</a> - convert a slice of bytes to a slice of another type</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#enumToInt">@enumToInt</a> - obtain the integer tag value of an enum or tagged union</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#errSetCast">@errSetCast</a> - convert to a smaller error set</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#errorToInt">@errorToInt</a> - obtain the integer value of an error code</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#floatCast">@floatCast</a> - convert a larger float to a smaller float</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#floatToInt">@floatToInt</a> - obtain the integer part of a float value</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#intCast">@intCast</a> - convert between integer types</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#intToEnum">@intToEnum</a> - obtain an enum value based on its integer tag value</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#intToError">@intToError</a> - obtain an error code based on its integer value</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#intToFloat">@intToFloat</a> - convert an integer to a float value</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#intToPtr">@intToPtr</a> - convert an address to a pointer</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#ptrCast">@ptrCast</a> - convert between pointer types</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#ptrToInt">@ptrToInt</a> - obtain the address of a pointer</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#sliceToBytes">@sliceToBytes</a> - convert a slice of anything to a slice of bytes</li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#truncate">@truncate</a> - convert between integer types, chopping off bits</li>
   </ul>
   <p>
  Some are safe; some are not. Some perform language-level assertions; some do not.
  Some are no-ops at runtime; some are not. Each casting function is documented independently.
   </p>
   <p>
   Having explicit and fine-grained casting like this is a form of intentional redundancy.
   Casts are often the source of bugs, and therefore it is worth double-checking a cast to verify that
   it is still correct when the type of the operand changes. For example, imagine that we have the following
   code:
   </p>
   <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(x: <span class="tok-type">i32</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> i = <span class="tok-builtin">@intCast</span>(<span class="tok-type">usize</span>, x);
}</code></pre>
   <p>
   Now consider what happens when the type of <code class="zig">x</code> changes to a pointer:
   <pre><code class="shell"><span class="t0_1">test.zig:2:29:</span> <span class="t31_1">error:</span> <span class="t0_1">expected integer type, found '*i32'</span>
    var i = @intCast(usize, x);
                            <span class="t32_1">^</span></code></pre>
   Although we technically know how to convert a pointer to an integer,
   because we used <code class="zig"><span class="tok-builtin">@intCast</span></code>, we are forced to inspect the cast and change
   it appropriately. Perhaps that means changing it to <code class="zig"><span class="tok-builtin">@ptrToInt</span></code>, or perhaps
   the entire function needs to be reworked in response to the type change.
   </p>

   <h2 id="parameter-passing">Direct Parameter Passing</h2>
   <p>
   Previously, it was illegal to pass structs and unions by value in non-<code class="zig"><span class="tok-kw">extern</span></code>
   functions. Instead, one would have to have the function accept a <code class="zig"><span class="tok-kw">const</span></code> pointer
   parameter. This was to avoid the ambiguity that C programs face - having to make the decision about
   whether by-value or by-reference was better. However, there were some problems with this. For example,
   when the parameter type is inferred, Zig would automatically convert to a <code class="zig"><span class="tok-kw">const</span></code>
   pointer. This caused problems in generic code, which could not distinguish between a type which is
   a pointer, and a type which has been automatically converted to a pointer.
   </p>
   <p>
   Now, parameters can be passed directly:
   </p>
   <pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
    x: <span class="tok-type">i32</span>,
    y: <span class="tok-type">i32</span>,
};

<span class="tok-kw">fn</span> <span class="tok-fn">callee</span>(foo: Foo) <span class="tok-type">void</span> {
    assert(foo.y == <span class="tok-number">2</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;pass directly&quot;</span> {
    callee(Foo{ .x = <span class="tok-number">1</span>, .y = <span class="tok-number">2</span> });
}</code></pre>
   <p>
   I have avoided using the term "by-value" because the semantics of this kind of parameter passing
   are different:
   </p>
   <ul>
     <li>Zig is free to pass the parameter by value - perhaps if it is smaller than some number of bytes -
       or pass it by reference.</li>
     <li>To the callee, the value appears to be a value and is immutable.</li>
     <li>The caller guarantees that the bytes of the parameter will not change for the duration of the
       call. This means that it is unsound to pass a global variable in this way if that global variable
      is mutated by the callee. There is an
      <a href="https://github.com/ziglang/zig/issues/476">open issue</a>
      which explores adding runtime safety checks for this.</li>
   </ul>
   <p>
   Because of these semantics, there's a clear flow chart for whether to accept a parameter as
   <code class="zig">T</code> or <code class="zig">*<span class="tok-kw">const</span> T</code>:
   </p>
   <ul>
     <li>Use <code class="zig">T</code>, unless one of the following is true:
       <ul>
         <li>The function depends on the address of the parameter.</li>
         <li>The parameter <a href="https://github.com/ziglang/zig/issues/1108">may alias</a>
           another parameter or global variable.</li>
       </ul>
     </li>
   </ul>
   <p>Now that we have this kind of parameter passing, Zig's implicit cast
   from <code class="zig">T</code> to <code class="zig">*<span class="tok-kw">const</span> T</code> is less important.
   One might even make the case that such a cast is dangerous. Therefore we have
   <a href="https://github.com/ziglang/zig/issues/1465">a proposal to remove it</a>.
   </p>
   <p>
   There is one more area that needs consideration with regards to direct parameter passing,
   and that is with coroutines. The problem is that if a reference to a stack variable is
   passed to a coroutine, it may become invalid after the coroutine suspends.
   This is a <a href="https://github.com/ziglang/zig/issues/1592">design flaw</a> in Zig that will
   be addressed in a future version. See <a href="#concurrency">Concurrency Status</a> for more details.
   </p>
   <p>Note that <code class="zig"><span class="tok-kw">extern</span></code> functions are bound by the C ABI,
   and therefore none of this applies to them.</p>

   <h2 id="rand-funcs">Rewrite Rand Functions</h2>
   <p>Marc Tiehuis writes:</p>
   <p>
    We now use a generic Rand structure which abstracts the core functions
    from the backing engine.
   </p>
   <p>
    The old Mersenne Twister engine is removed and replaced instead with
    three alternatives:
   </p>
   <ul>
     <li>Pcg32</li>
     <li>Xoroshiro128+</li>
     <li>Isaac64</li>
   </ul>
   <p>
    These should provide sufficient coverage for most purposes, including a
    CSPRNG using Isaac64. Consumers of the library that do not care about
    the actual engine implementation should use <code>DefaultPrng</code> and <code>DefaultCsprng</code>.
   </p>

   <h2 id="async-err-ret-traces">Error Return Traces across async/await</h2>
   <p>One of the problems with non-blocking programming is that stack traces
   and exceptions are less useful, because the actual stack trace points back
   to the event loop code.
   </p>
   <p>
   In Zig 0.3.0, <a href="https://ziglang.org/documentation/0.3.0/#Error-Return-Traces">Error Return Traces</a>
   work across suspend points. This means you can use <code class="zig"><span class="tok-kw">try</span></code> as the main
   error handling strategy, and when an error bubbles up all the way, you'll still be able to find out
   where it came from:
   </p>
   <pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> event = std.event;
<span class="tok-kw">const</span> fs = event.fs;

<span class="tok-kw">test</span> <span class="tok-str">&quot;unwrap error in async fn&quot;</span> {
    <span class="tok-kw">var</span> da = std.heap.DirectAllocator.init();
    <span class="tok-kw">defer</span> da.deinit();
    <span class="tok-kw">const</span> allocator = &amp;da.allocator;

    <span class="tok-kw">var</span> loop: event.Loop = <span class="tok-null">undefined</span>;
    <span class="tok-kw">try</span> loop.initMultiThreaded(allocator);
    <span class="tok-kw">defer</span> loop.deinit();

    <span class="tok-kw">const</span> handle = <span class="tok-kw">try</span> <span class="tok-kw">async</span>&lt;allocator&gt; openTheFile(&amp;loop);
    <span class="tok-kw">defer</span> <span class="tok-kw">cancel</span> handle;

    loop.run();
}

<span class="tok-kw">async</span> <span class="tok-kw">fn</span> <span class="tok-fn">openTheFile</span>(loop: *event.Loop) <span class="tok-type">void</span> {
    <span class="tok-kw">const</span> future = (<span class="tok-kw">async</span> fs.openRead(loop, <span class="tok-str">&quot;does_not_exist.txt&quot;</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>);
    <span class="tok-kw">const</span> fd = (<span class="tok-kw">await</span> future) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;
}</code></pre><pre><code class="shell">$ zig test test.zig
Test 1/1 unwrap error in async fn...attempt to unwrap error: FileNotFound
<span class="t37_1">std/event/fs.zig:367:5</span>: <span class="t2_0">0x22cb15 in ??? (test)</span>
    return req_node.data.msg.Open.result;
    <span class="t32_1">^</span>
<span class="t37_1">std/event/fs.zig:374:13</span>: <span class="t2_0">0x22e5fc in ??? (test)</span>
            return await (async openPosix(loop, path, flags, os.File.default_mode) catch unreachable);
            <span class="t32_1">^</span>
<span class="t37_1">test.zig:22:31</span>: <span class="t2_0">0x22f34b in ??? (test)</span>
    const fd = (await future) catch unreachable;
                              <span class="t32_1">^</span>
<span class="t37_1">std/event/loop.zig:664:25</span>: <span class="t2_0">0x20c147 in ??? (test)</span>
                        resume handle;
                        <span class="t32_1">^</span>
<span class="t37_1">std/event/loop.zig:543:23</span>: <span class="t2_0">0x206dee in ??? (test)</span>
        self.workerRun();
                      <span class="t32_1">^</span>
<span class="t37_1">test.zig:17:13</span>: <span class="t2_0">0x206178 in ??? (test)</span>
    loop.run();
            <span class="t32_1">^</span>

Tests failed. Use the following command to reproduce the failure:
zig-cache/test
</code></pre>
<p>Note that this output contains 3 components:</p>
    <ul>
      <li>An error message: <code>attempt to unwrap error: FileNotFound</code></li>
      <li>An error return trace. The error was first returned at <code>fs.zig:367:5</code>
        and then returned at <code>fs.zig:374:13</code>. You could go look at those source locations
        for more information.</li>
      <li>A stack trace. Once the error came back from <code>openRead</code>, the code tried to
        <code class="zig"><span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span></code> which caused the panic. You can see that the stack
        trace does, in fact, go into the event loop as described above.
      </li>
    </ul>
    <p>It is important to note in this example, that the error return trace survived despite
    the fact that the event loop is multi-threaded, and any one of those threads could be the worker
    thread that resumes an async function at the <code class="zig"><span class="tok-kw">await</span></code> point.
    </p>
    <p>
    This feature is enabled by default for Debug and ReleaseSafe builds, and disabled for ReleaseFast
    and ReleaseSmall builds.
    </p>
    <p>
    This is just the beginning of an exploration of what debugging non-blocking behavior
    could look like in the future of Zig. See <a href="#concurrency">Concurrency Status</a> for more details.
    </p>

   <h2 id="async-call-syntax">New Async Call Syntax</h2>
   <p>Instead of <code>async(allocator) call()</code>, now it is
   <code>async&lt;allocator&gt; call()</code>.
   </p>
   <p>This fixes syntax ambiguity when leaving off the allocator,
   and fixes parse failure when call is a field access.</p>
   <p>This sets a precedent for using <code>&lt;</code> <code>&gt;</code> to pass arguments
   to a keyword. This will affect <code>enum</code>, <code>union</code>, <code>fn</code>, and
   <code>align</code> (see <a href="https://github.com/ziglang/zig/issues/661">#661</a>).
   </p>

   <h2 id="release-small">ReleaseSmall Mode</h2>
   <p>Alexandros Naskos contributed a <a href="https://ziglang.org/documentation/0.3.0/#ReleaseSmall">new build mode.</a></p>
    <pre><code>$ zig build-exe example.zig --release-small</code></pre>
    <ul>
      <li>Medium runtime performance</li>
      <li>Safety checks disabled</li>
      <li>Slow compilation speed</li>
      <li>Small binary size</li>
    </ul>

   <h2 id="builtin-typeInfo-and-field">New builtins: @typeInfo and @field</h2>
   <p>Alexandros Naskos bravely dove head-first into the deepest, darkest parts of the Zig
   compiler and implemented an incredibly useful builtin function:
   <a href="https://ziglang.org/documentation/0.3.0/#typeInfo">@typeInfo</a>.
   </p>
   <p>
   This function accepts a <code class="zig"><span class="tok-type">type</span></code> as a parameter, and returns a compile-time known
   value of this type:
   </p>
   <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> TypeInfo = <span class="tok-kw">union</span>(TypeId) {
    Type: <span class="tok-type">void</span>,
    Void: <span class="tok-type">void</span>,
    Bool: <span class="tok-type">void</span>,
    NoReturn: <span class="tok-type">void</span>,
    Int: Int,
    Float: Float,
    Pointer: Pointer,
    Array: Array,
    Struct: Struct,
    ComptimeFloat: <span class="tok-type">void</span>,
    ComptimeInt: <span class="tok-type">void</span>,
    Undefined: <span class="tok-type">void</span>,
    Null: <span class="tok-type">void</span>,
    Optional: Optional,
    ErrorUnion: ErrorUnion,
    ErrorSet: ErrorSet,
    Enum: Enum,
    Union: Union,
    Fn: Fn,
    Namespace: <span class="tok-type">void</span>,
    BoundFn: Fn,
    ArgTuple: <span class="tok-type">void</span>,
    Opaque: <span class="tok-type">void</span>,
    Promise: Promise,


    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Int = <span class="tok-kw">struct</span> {
        is_signed: <span class="tok-type">bool</span>,
        bits: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Float = <span class="tok-kw">struct</span> {
        bits: <span class="tok-type">u8</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Pointer = <span class="tok-kw">struct</span> {
        size: Size,
        is_const: <span class="tok-type">bool</span>,
        is_volatile: <span class="tok-type">bool</span>,
        alignment: <span class="tok-type">u32</span>,
        child: <span class="tok-type">type</span>,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Size = <span class="tok-kw">enum</span> {
            One,
            Many,
            Slice,
        };
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Array = <span class="tok-kw">struct</span> {
        len: <span class="tok-type">usize</span>,
        child: <span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ContainerLayout = <span class="tok-kw">enum</span> {
        Auto,
        Extern,
        Packed,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> StructField = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        offset: ?<span class="tok-type">usize</span>,
        field_type: <span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Struct = <span class="tok-kw">struct</span> {
        layout: ContainerLayout,
        fields: []StructField,
        defs: []Definition,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Optional = <span class="tok-kw">struct</span> {
        child: <span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorUnion = <span class="tok-kw">struct</span> {
        error_set: <span class="tok-type">type</span>,
        payload: <span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Error = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        value: <span class="tok-type">usize</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ErrorSet = <span class="tok-kw">struct</span> {
        errors: []Error,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> EnumField = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        value: <span class="tok-type">usize</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Enum = <span class="tok-kw">struct</span> {
        layout: ContainerLayout,
        tag_type: <span class="tok-type">type</span>,
        fields: []EnumField,
        defs: []Definition,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> UnionField = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        enum_field: ?EnumField,
        field_type: <span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Union = <span class="tok-kw">struct</span> {
        layout: ContainerLayout,
        tag_type: ?<span class="tok-type">type</span>,
        fields: []UnionField,
        defs: []Definition,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> CallingConvention = <span class="tok-kw">enum</span> {
        Unspecified,
        C,
        Cold,
        Naked,
        Stdcall,
        Async,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FnArg = <span class="tok-kw">struct</span> {
        is_generic: <span class="tok-type">bool</span>,
        is_noalias: <span class="tok-type">bool</span>,
        arg_type: ?<span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Fn = <span class="tok-kw">struct</span> {
        calling_convention: CallingConvention,
        is_generic: <span class="tok-type">bool</span>,
        is_var_args: <span class="tok-type">bool</span>,
        return_type: ?<span class="tok-type">type</span>,
        async_allocator_type: ?<span class="tok-type">type</span>,
        args: []FnArg,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Promise = <span class="tok-kw">struct</span> {
        child: ?<span class="tok-type">type</span>,
    };

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Definition = <span class="tok-kw">struct</span> {
        name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
        is_pub: <span class="tok-type">bool</span>,
        data: Data,

        <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Data = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {
            Type: <span class="tok-type">type</span>,
            Var: <span class="tok-type">type</span>,
            Fn: FnDef,

            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> FnDef = <span class="tok-kw">struct</span> {
                fn_type: <span class="tok-type">type</span>,
                inline_type: Inline,
                calling_convention: CallingConvention,
                is_var_args: <span class="tok-type">bool</span>,
                is_extern: <span class="tok-type">bool</span>,
                is_export: <span class="tok-type">bool</span>,
                lib_name: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
                return_type: <span class="tok-type">type</span>,
                arg_names: [][] <span class="tok-kw">const</span> <span class="tok-type">u8</span>,

                <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Inline = <span class="tok-kw">enum</span> {
                    Auto,
                    Always,
                    Never,
                };
            };
        };
    };
};</code></pre>
   <p>
   This kicks open the door for compile-time reflection, especially when combined with the fact that
   Jimmi Holst Christensen implemented <a href="https://ziglang.org/documentation/0.3.0/#field">@field</a>,
   which performs field access with a compile-time known name:
   <pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;@field&quot;</span> {
    <span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
        one: <span class="tok-type">i32</span>,
        two: <span class="tok-type">bool</span>,
    };
    <span class="tok-kw">var</span> f = Foo{
        .one = <span class="tok-number">42</span>,
        .two = <span class="tok-null">true</span>,
    };

    <span class="tok-kw">const</span> names = [][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;two&quot;</span>, <span class="tok-str">&quot;one&quot;</span> };

    assert(<span class="tok-builtin">@field</span>(f, names[<span class="tok-number">0</span>]) == <span class="tok-null">true</span>);
    assert(<span class="tok-builtin">@field</span>(f, names[<span class="tok-number">1</span>]) == <span class="tok-number">42</span>);

    <span class="tok-builtin">@field</span>(f, <span class="tok-str">&quot;one&quot;</span>) += <span class="tok-number">1</span>;
    assert(<span class="tok-builtin">@field</span>(f, <span class="tok-str">&quot;on&quot;</span> ++ <span class="tok-str">&quot;e&quot;</span>) == <span class="tok-number">43</span>);
}</code></pre>
   <p>This has the potential to be abused, and so the feature should be used carefully.</p>
   <p>After Jimmi implemented <code class="zig"><span class="tok-builtin">@field</span></code>, he improved the implementation of 
   <code class="zig"><span class="tok-builtin">@typeInfo</span></code> and fixed several bugs. And now, the combination of
   these builtins is used to implement struct printing in userland:</p>
   <pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
    one: <span class="tok-type">i32</span>,
    two: *<span class="tok-type">u64</span>,
    three: <span class="tok-type">bool</span>,
};

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u64</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">var</span> f = Foo{
        .one = <span class="tok-number">42</span>,
        .two = &amp;x,
        .three = <span class="tok-null">false</span>,
    };

    std.debug.warn(<span class="tok-str">&quot;here it is: {}\n&quot;</span>, f);
}</code></pre>
   <p>Output:</p>
   <pre><code>here it is: Foo{ .one = 42, .two = u64@7ffdda208cf0, .three = false }</code></pre>
   <p>See <a href="https://github.com/ziglang/zig/blob/0.3.0/std/fmt/index.zig#L15">std/fmt/index.zig:15</a>
   for the implementation.</p>
   <p>
   Now that we have <code class="zig"><span class="tok-builtin">@typeInfo</span></code>, there is one more question to answer:
   should there be a function which accepts a <code class="zig">TypeInfo</code> value, and makes
   a type out of it?
   </p>
   <p>
   This hypothetical feature is called <code>@reify</code>, and it's a
   <a href="https://github.com/ziglang/zig/issues/383">hot topic</a>. Although undeniably powerful and
   useful, there is concern that it would be <em>too</em> powerful, leading to complex meta-programming
   that goes against the spirit of simplicity that Zig stands for.</p>

   <h2 id="cmpxchg">Improve cmpxchg</h2>
   <p><code>@cmpxchg</code> is removed. <a href="https://ziglang.org/documentation/0.3.0/#cmpxchgStrong">@cmpxchgStrong</a> and <a href="https://ziglang.org/documentation/0.3.0/#cmpxchgWeak">@cmpxchgWeak</a> are added.
   <p>The functions have operand type as the first parameter.</p>
   <p>The return type is <code>?T</code> where <code>T</code> is the operand type.</p>

   <h2 id="f16">New Type: f16</h2>
   <p>Ben Noordhuis implemented <code class="zig"><span class="tok-type">f16</span></code>. This is guaranteed to be
    IEEE-754-2008 binary16 format, even on systems that have no hardware support,
    thanks to the additions to compiler_rt that Ben contributed. He also added support
    for <code class="zig"><span class="tok-type">f16</span></code> to <code>std.math</code> functions such as <code>isnormal</code>
    and <code>fabs</code>.
   </p>

   <h2 id="int-sizes">All Integer Sizes are Primitives</h2>
   <p>Zig 0.2.0 had primitive types for integer bit widths of 2-8, 16, 29, 32, 64, 128.
   Any number other than that, and you had to use <a href="https://ziglang.org/documentation/0.3.0/#IntType">@IntType</a> to create the type.
   But you would get a compile error if you shadowed one of the above bit widths that already existed, for example with
   <pre><code class="zig"><span class="tok-kw">const</span> <span class="tok-type">u29</span> = <span class="tok-builtin">@IntType</span>(<span class="tok-null">false</span>, <span class="tok-number">29</span>); <span class="tok-comment">// error: u29 shadows primitive type</span></code></pre>
   </p>
   <p>Needless to say, this situation was unnecessarily troublesome (<a href="https://github.com/ziglang/zig/issues/745">#745</a>). And so now
    arbitrary bit-width integers can be referenced by using an identifier of
    <code>i</code> or <code>u</code> followed by digits. For example, the identifier
    <code class="zig"><span class="tok-type">i7</span></code> refers to a signed 7-bit integer. 
   </p>
   <p>
   <code class="zig"><span class="tok-type">u0</span></code> is a 0-bit type, which means:</p>
   <ul>
     <li><code class="zig"><span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u0</span>) == <span class="tok-number">0</span></code></li>
     <li>No actual code is generated for loads and stores of this type of value.</li>
     <li>The value of a <code class="zig"><span class="tok-type">u0</span></code> as always the compile-time known value of <code class="zig"><span class="tok-number">0</span></code>.</li>
   </ul>
   <p>
   <code class="zig"><span class="tok-type">i0</span></code> <a href="https://github.com/ziglang/zig/issues/1593">doesn't make sense</a>
   and will probably crash the compiler.
   </p>
   <p>
   Although Zig defines arbitrary integer sizes to support all primitive operations, if you try to use,
   for example, multiplication on 256-bit integers:
   </p>
   <pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;large multiplication&quot;</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">u256</span> = <span class="tok-number">0xabcd</span>;
    <span class="tok-kw">var</span> y: <span class="tok-type">u256</span> = <span class="tok-number">0xefef</span>;
    <span class="tok-kw">var</span> z = x * y;
}</code></pre>
   <p>Then you'll get an error like this:</p>
   <pre>LLVM ERROR: Unsupported library call operation!</pre>
   <p>
   Zig isn't supposed to be letting LLVM leak through here, but that's a separate issue.
   What's happening is that normally if a primitive operation such as multiplication of
   integers cannot be lowered to a machine instruction, LLVM will emit a library call to
   compiler_rt to perform the operation. This works for up to 128-bit multiplication,
   for example. However compiler_rt does not define an arbitrary precision multiplication
   library function, and so LLVM is not able to generate code.
   </p>
   <p>It <a href="https://github.com/ziglang/zig/issues/1534">is planned</a> to submit a patch
   to LLVM which adds the ability to emit a lib call for situations like this, and then
   Zig will include the arbitrary precision multiplication function in Zig's compiler_rt.</p>
   <p>In addition to this, Zig 0.3.0 fixes
   <a href="https://github.com/ziglang/zig/issues/1242">a bug</a> where
   <code class="zig"><span class="tok-builtin">@IntType</span></code> was silently wrapping the bit count parameter if it was greater
   than pow(2, 32).
   </p>

   <h2 id="f128">Improved f128 Support</h2>
   <p>Marc Tiehuis &amp; Ben Noordhuis solved the various issues that prevented <code>f128</code> from being generally useful.</p>
   <ul>
      <li>Fix hex-float parsing. -Marc Tiehuis (<a href="https://github.com/ziglang/zig/issues/495">#495</a>)</li>
      <li>Add compiler-rt functions to support <code>f128</code>. -Marc Tiehuis
        <ul>
          <li><code>__floatunditf</code></li>
          <li><code>__floatunsitf</code></li>
          <li><code>__floatunsitf</code></li>
          <li><code>__floatuntitf</code></li>
          <li><code>__floatuntisf</code></li>
          <li><code>__trunctfdf2</code></li>
          <li><code>__trunctfsf2</code></li>
          <li><code>__floattitf</code></li>
          <li><code>__floattidf</code></li>
          <li><code>__floattisf</code></li>
        </ul>
      </li>
      <li>Alignment fix and allow rudimentary f128 float printing. -Marc Tiehuis</li>
      <li>Fix f128 remainder division bug. The modulo operation computed rem(b+rem(a,b), b) which produces -1
        for a=1 and b=2. Switch to a - b * trunc(a/b) which produces the expected result, 1. -Ben Noordhuis (<a href="https://github.com/ziglang/zig/issues/1137">#1137</a>) </li>
    </ul>

   <h2 id="caching">Build Artifact Caching</h2>
   <p>Zig now supports global build artifact caching. This feature is one of those things that
   you can generally ignore, because it "just works" without any babysitting.</p>
   <p>By default, compilations are not cached. You can enable the global cache for a compilation
   by using <code>--cache on</code>:</p>
   <pre><code>andy@xps:~/tmp$ time zig build-exe hello.zig 

real	0m0.414s
user	0m0.369s
sys	0m0.049s
andy@xps:~/tmp$ time zig build-exe hello.zig --cache on
/home/andy/.local/share/zig/stage1/artifact/hkGO0PyaOKDrdg2wyhV1vRy0ATyTaT0s0ECa2BiHFJfsb9RDVKK_r3qwHI5gaEfv/hello

real	0m0.412s
user	0m0.377s
sys	0m0.038s
andy@xps:~/tmp$ time zig build-exe hello.zig --cache on
/home/andy/.local/share/zig/stage1/artifact/hkGO0PyaOKDrdg2wyhV1vRy0ATyTaT0s0ECa2BiHFJfsb9RDVKK_r3qwHI5gaEfv/hello

real	0m0.012s
user	0m0.009s
sys	0m0.003s</code></pre>
   <p>When the cache is on, the output is not written to the current directory. Instead, the output
   is kept in the cache directory, and the path to it is printed to stdout.</p>
   <p>This is off by default, because this is an uncommon use case. The real benefit of build artifact
   caching comes in 3 places:</p>
   <ul>
     <li><a href="#zig-run">zig run</a>, where it is enabled by default:
     <pre><code>andy@xps:~/tmp$ time zig run hello.zig 
Hello, world!

real	0m0.553s
user	0m0.500s
sys	0m0.055s
andy@xps:~/tmp$ time zig run hello.zig 
Hello, world!

real	0m0.013s
user	0m0.007s
sys	0m0.006s</code></pre>
     </li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#Zig-Build-System">zig build</a>, so that your build
       script only has to build once.</li>
     <li>
       When building an executable or shared library, Zig must build <code>compiler_rt.o</code> and
       <code>builtin.o</code> from source, for the given target. This usually only has to be done
       once ever, which is why other compilers such as gcc ship with these components already built.
       The problem with that strategy is that you have to build a special version of the compiler for
       cross-compiling. With Zig, you can always build for any target, on any target.
       <br><br>
       So caching these artifacts provides a happy solution.
     </li>
   </ul>
   <p>
   The cache is perfect; there are no false positives. You could even fix a bug in <code>memcpy</code>
   in the system's libc, and Zig will detect that its own code has (indirectly) been updated,
   and invalidate the cache entry.
   </p>
   <p>
   If you use <code>zig build-exe</code>, Zig will still create a <code>zig-cache</code> directory
   in the current working directory in order to store an intermediate <code>.o</code> file.
   This is because on MacOS, the intermediate .o file stores the debug information, and therefore
   it needs to stick around somewhere sensible for <a href="#stack-traces">Stack Traces</a> to work.
   </p>
   <p>
   Likewise, if you use <code>zig test</code>, Zig will put the test binary in the <code>zig-cache</code>
   directory in the current working directory. It's useful to leave the test binary here so that the
   programmer can use a debugger on it or otherwise inspect it.
   </p>
   <p>The <code>zig-cache</code> directory <em>is</em> cleaner than before, however. For example, the
   <code>builtin.zig</code> file is no longer created there. It participates in the global caching system,
   just like <code>compiler_rt.o</code>. You can use <code>zig builtin</code> to see the contents of
   <code class="zig"><span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>)</code>.</p>

   <h2 id="rosegment">Compatibility with Valgrind</h2>
   <p>I noticed that valgrind does not see Zig's debug symbols (<a href="https://github.com/ziglang/zig/issues/896">#896</a>):</p>
   <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    foo().* += <span class="tok-number">1</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() *<span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> <span class="tok-builtin">@intToPtr</span>(*<span class="tok-type">i32</span>, <span class="tok-number">10000000</span>);
}</code></pre><pre><code>==24133== Invalid read of size 4
==24133==    at 0x2226D5: ??? (in /home/andy/downloads/zig/build/test)
==24133==    by 0x2226A8: ??? (in /home/andy/downloads/zig/build/test)
==24133==    by 0x222654: ??? (in /home/andy/downloads/zig/build/test)
==24133==    by 0x2224B7: ??? (in /home/andy/downloads/zig/build/test)
==24133==    by 0x22236F: ??? (in /home/andy/downloads/zig/build/test)</code></pre>
   <p>After digging around, I was able to reproduce the problem using only Clang and LLD:</p>
   <pre><code>static int *foo(void) {
    return (int *)10000000;
}

int main(void) {
    int *x = foo();
    *x += 1;
}</code></pre>
   <p>If this C code is built with Clang and linked with LLD, Valgrind has the same issue
   as with the Zig code.</p>
   <p>I sent <a href="https://sourceforge.net/p/valgrind/mailman/message/36286103/">a message</a>
   to the Valgrind mailing list, and they
   <a href="https://sourceforge.net/p/valgrind/mailman/message/36286122/">suggested</a>
   submitting a bug fix to Valgrind.
   That's a good idea. I'm a little busy with Zig development though - anybody else want to take
   a crack at it?
   </p>
   <p>
   In the meantime, Zig now has a <code>--no-rosegment</code> flag, which works around the bug.
   It should only be used for this purpose; the flag will likely be removed once Valgrind fixes
   the issue upstream and enough time passes that the new version becomes generally available.
   </p>
   <pre><code>$ zig build-exe test.zig --no-rosegment
$ valgrind ./test
==24241== Invalid read of size 4
==24241==    at 0x221FE5: main (test.zig:2)</code></pre>

   <h2 id="godbolt">Zig is now on Godbolt Compiler Explorer</h2>
   <p>Marc Tiehuis added Zig support, and then worked with the
   <a href="https://github.com/mattgodbolt/compiler-explorer/">Compiler Explorer</a> team to get it
   merged upstream and deployed.</p>
   <ul>
     <li><a href="https://godbolt.org/z/MORFut">square function example</a></li>
     <li><a href="https://godbolt.org/z/VpJXuT">sum over array example --release-small</a></li>
     <li><a href="https://godbolt.org/z/yx6Yu5">sum over array example --release-fast</a></li>
   </ul>
   <p>The command line API that Compiler Explorer uses is covered by Zig's main test suite
   to ensure that it continues working as the language evolves.</p>

   <h2 id="zig-init">zig init-lib and init-exe</h2>
   <p><code>zig init-lib</code> can be used to initialize a
   <a href="https://ziglang.org/documentation/0.3.0/#Zig-Build-System">zig build</a>
   project in the current directory which will create a simple library:</p>
   <pre>$ zig init-lib
Created build.zig
Created src/main.zig

Next, try `zig build --help` or `zig build test`
$ zig build test
Test 1/1 basic add functionality...OK
All tests passed.</pre>
   <p>Likewise, <code>zig init-exe</code> initializes a simple application:</p>
   <pre>$ zig init-exe
Created build.zig
Created src/main.zig

Next, try `zig build --help` or `zig build run`
$ zig build run
All your base are belong to us.</pre>
   <p>The main Zig test suite tests this functionality so that it will not regress as Zig continues to evolve.</p>

   <h2 id="concurrency">Concurrency Status</h2>
   <p>
   Concurrency is now solved. That is, there is a concrete plan for how concurrency will work in Zig,
   and now it's a matter of implementing all the pieces.
   </p>
   <p>
   First and foremost, Zig supports low-level control over hardware.
   That means that it has atomic primitives:
   </p>
   <ul>
     <li><a href="https://ziglang.org/documentation/0.3.0/#atomicLoad">@atomicLoad</a></li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#atomicRmw">@atomicRmw</a></li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#cmpxchgStrong">@cmpxchgStrong</a></li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#cmpxchgWeak">@cmpxchgWeak</a></li>
     <li><a href="https://ziglang.org/documentation/0.3.0/#fence">@fence</a></li>
   </ul>
   <p>...and it means that you can directly spawn kernel threads using standard library functions:</p>
   <pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;
<span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);
<span class="tok-kw">const</span> AtomicRmwOp = builtin.AtomicRmwOp;
<span class="tok-kw">const</span> AtomicOrder = builtin.AtomicOrder;

<span class="tok-kw">test</span> <span class="tok-str">&quot;spawn threads&quot;</span> {
    <span class="tok-kw">var</span> shared_ctx: <span class="tok-type">i32</span> = <span class="tok-number">1</span>;

    <span class="tok-kw">const</span> thread1 = <span class="tok-kw">try</span> std.os.spawnThread({}, start1);
    <span class="tok-kw">const</span> thread2 = <span class="tok-kw">try</span> std.os.spawnThread(&amp;shared_ctx, start2);
    <span class="tok-kw">const</span> thread3 = <span class="tok-kw">try</span> std.os.spawnThread(&amp;shared_ctx, start2);
    <span class="tok-kw">const</span> thread4 = <span class="tok-kw">try</span> std.os.spawnThread(&amp;shared_ctx, start2);

    thread1.wait();
    thread2.wait();
    thread3.wait();
    thread4.wait();

    assert(shared_ctx == <span class="tok-number">4</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">start1</span>(ctx: <span class="tok-type">void</span>) <span class="tok-type">u8</span> {
    <span class="tok-kw">return</span> <span class="tok-number">0</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">start2</span>(ctx: *<span class="tok-type">i32</span>) <span class="tok-type">u8</span> {
    _ = <span class="tok-builtin">@atomicRmw</span>(<span class="tok-type">i32</span>, ctx, AtomicRmwOp.Add, <span class="tok-number">1</span>, AtomicOrder.SeqCst);
    <span class="tok-kw">return</span> <span class="tok-number">0</span>;
}</code></pre>
   <p>
   On POSIX targets, when you link against libc, the standard library uses
   pthreads; otherwise it uses its own lightweight kernel thread implementation.
   </p>
   <p>You can use mutexes, signals, condition variables, and all those things.
   Anything you can accomplish in C, you can accomplish in Zig.</p>
   <p>
   However, the standard library provides a higher level concurrency abstraction,
   designed for optimal performance, debuggability, and structuring code to closely
   model the problems that concurrency presents.
   </p>
   <p>
   The abstraction is built on two language features: stackless coroutines and
   <code class="zig"><span class="tok-kw">async</span></code>/<code class="zig"><span class="tok-kw">await</span></code>
   syntax. Everything else is implemented in userland.
   </p>
   <p>
   <code class="zig">std.event.Loop</code> creates a kernel thread pool matching the number
   of logical CPUs. It can then be used for non-blocking I/O that will be dispatched across
   the thread pool, using the platform-native API:
   </p>
   <ul>
     <li>Windows - <a href="https://docs.microsoft.com/en-us/windows/desktop/FileIO/i-o-completion-ports">I/O Completion Ports</a></li>
     <li>MacOS - <a href="https://man.openbsd.org/kqueue.2">kqueue</a></li>
     <li>Linux - <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a></li>
   </ul>
   <p>This is a competitor to <a href="http://libuv.org/">libuv</a>, except multi-threaded.</p>
   <p>
   Once you have an event loop, all of the <code class="zig">std.event</code> API becomes available to use:
   </p>
   <ul>
     <li><code class="zig">std.event.Channel</code> - Many producer, many consumer, thread-safe, runtime configurable buffer size.
When buffer is empty, consumers suspend and are resumed by producers. When buffer is full, producers suspend and are resumed by consumers.</li>
     <li><code class="zig">std.event.Future</code> - A value that many consumers can <code class="zig"><span class="tok-kw">await</span></code>.</li>
     <li><code class="zig">std.event.Group</code> - A way to <code class="zig"><span class="tok-kw">await</span></code> multiple <code class="zig"><span class="tok-kw">async</span></code> operations.</li>
     <li><code class="zig">std.event.Lock</code> - Ensures only one thread gets access to a resource, without blocking a kernel thread.</li>
     <li><code class="zig">std.event.RwLock</code> - Same as Lock except allows multiple readers to access data simultaneously.</li>
     <li><code class="zig">std.event.fs</code> - File system operations based on
       <code class="zig"><span class="tok-kw">async</span></code>/<code class="zig"><span class="tok-kw">await</span></code> syntax.
     </li>
     <li><code class="zig">std.event.tcp</code> - Network operations based on
       <code class="zig"><span class="tok-kw">async</span></code>/<code class="zig"><span class="tok-kw">await</span></code> syntax.
     </li>
   </ul>
   <p>
   All of these abstractions provide convenient APIs based on 
   <code class="zig"><span class="tok-kw">async</span></code>/<code class="zig"><span class="tok-kw">await</span></code>
   syntax, making it practical for API users to model their code with maximally efficient concurrency.
   None of these abstractions block or use mutexes; when an API user must suspend, control flow
   goes to the next coroutine waiting to run, if any. If no coroutines are waiting to run,
   the application will sit idly, waiting for an event from the respective platform-native API
   (e.g. epoll on Linux).
   </p>
   <p>
   As an example, here is a snippet from a test in the standard library:
   </p>
   <pre><code class="zig"><span class="tok-kw">async</span> <span class="tok-kw">fn</span> <span class="tok-fn">testFsWatch</span>(loop: *Loop) !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> file_path = <span class="tok-kw">try</span> os.path.join(loop.allocator, test_tmp_dir, <span class="tok-str">&quot;file.txt&quot;</span>);
    <span class="tok-kw">defer</span> loop.allocator.free(file_path);

    <span class="tok-kw">const</span> contents =
        <span class="tok-str">\\line 1
</span>        <span class="tok-str">\\line 2
</span>    ;
    <span class="tok-kw">const</span> line2_offset = <span class="tok-number">7</span>;

    <span class="tok-comment">// first just write then read the file</span>
    <span class="tok-kw">try</span> <span class="tok-kw">await</span> <span class="tok-kw">try</span> <span class="tok-kw">async</span> fs.writeFile(loop, file_path, contents);

    <span class="tok-kw">const</span> read_contents = <span class="tok-kw">try</span> <span class="tok-kw">await</span> <span class="tok-kw">try</span> <span class="tok-kw">async</span> fs.readFile(loop, file_path, <span class="tok-number">1024</span> * <span class="tok-number">1024</span>);
    assert(mem.eql(<span class="tok-type">u8</span>, read_contents, contents));

    <span class="tok-comment">// now watch the file</span>
    <span class="tok-kw">var</span> watch = <span class="tok-kw">try</span> fs.Watch(<span class="tok-type">void</span>).create(loop, <span class="tok-number">0</span>);
    <span class="tok-kw">defer</span> watch.destroy();

    assert((<span class="tok-kw">try</span> <span class="tok-kw">await</span> <span class="tok-kw">try</span> <span class="tok-kw">async</span> watch.addFile(file_path, {})) == <span class="tok-null">null</span>);

    <span class="tok-kw">const</span> ev = <span class="tok-kw">try</span> <span class="tok-kw">async</span> watch.channel.get();
    <span class="tok-kw">var</span> ev_consumed = <span class="tok-null">false</span>;
    <span class="tok-kw">defer</span> <span class="tok-kw">if</span> (!ev_consumed) <span class="tok-kw">cancel</span> ev;

    <span class="tok-comment">// overwrite line 2</span>
    <span class="tok-kw">const</span> fd = <span class="tok-kw">try</span> <span class="tok-kw">await</span> <span class="tok-kw">try</span> <span class="tok-kw">async</span> fs.openReadWrite(loop, file_path, os.File.default_mode);
    {
        <span class="tok-kw">defer</span> os.close(fd);

        <span class="tok-kw">try</span> <span class="tok-kw">await</span> <span class="tok-kw">try</span> <span class="tok-kw">async</span> fs.pwritev(loop, fd, [][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{<span class="tok-str">&quot;lorem ipsum&quot;</span>}, line2_offset);
    }

    ev_consumed = <span class="tok-null">true</span>;
    <span class="tok-kw">switch</span> ((<span class="tok-kw">try</span> <span class="tok-kw">await</span> ev).id) {
        WatchEventId.CloseWrite =&gt; {},
        WatchEventId.Delete =&gt; <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;wrong event&quot;</span>),
    }
    <span class="tok-kw">const</span> contents_updated = <span class="tok-kw">try</span> <span class="tok-kw">await</span> <span class="tok-kw">try</span> <span class="tok-kw">async</span> fs.readFile(loop, file_path, <span class="tok-number">1024</span> * <span class="tok-number">1024</span>);
    assert(mem.eql(<span class="tok-type">u8</span>, contents_updated,
        <span class="tok-str">\\line 1
</span>        <span class="tok-str">\\lorem ipsum
</span>    ));
}</code></pre>
   <p>
   You can see that even though Zig is a language with manual memory management that insists on handling
   every possible error, it manages to be quite high level using these event-based APIs.
   </p>
   <p>
   Now, there are some problems to solve:
   </p>
   <ul>
     <li><a href="https://github.com/ziglang/zig/issues/1363">The way that canceling a coroutine works is currently unsound.</a> - I know how to fix this, but it'll have to be in 0.4.0. Unfortunately it's causing occasional
     test failures.
     </li>
     <li>
       <a href="https://github.com/ziglang/zig/issues/1260">Lack of a guarantee about whether an async function call allocates memory or not.</a> - In theory, there are many cases where Zig should be able to guarantee that
       an async function call will not allocate memory for the coroutine frame. However in practice, using
       LLVM's coroutines API, it will always result in an allocation.
     </li>
     <li><a href="https://github.com/ziglang/zig/issues/802">LLVM's coroutines implementation is buggy</a> -
       Right now Zig sadly is forced to disable optimizations for <code class="zig"><span class="tok-kw">async</span></code> functions because 
       LLVM has <a href="https://bugs.llvm.org/show_bug.cgi?id=36578">a bug</a>
       where Mem2Reg turns correct coroutine frame spills back into incorrect
       parameter references.
     </li>
     <li><strong>LLVM's coroutines implementation is slow</strong> - When I analyzed the compilation
     speed of Zig, even with optimizations off, LLVM takes up over 80% of the time. And for the zig behavioral
     tests, even though coroutines are a tiny percent of the code, LLVM's coroutine splitting pass takes
     up 30% of that time.</li>
   </ul>
   <p>
   And so, the plan is to rework coroutines, without using any of LLVM's coroutines API. Zig will implement
   coroutines in the frontend, and LLVM will see only functions and structs. This is
   <a href="https://github.com/rust-lang/rfcs/blob/master/text/2394-async_await.md">how Rust does it</a>,
   and I think it was a strong choice.
   </p>
   <p>
   The coroutine frame will be in a struct, and so Zig will know the size of it at compile-time, and
   it will solve the problem of guaranteeing allocation elision - the <code class="zig"><span class="tok-kw">async</span></code> callsite
   will simply have to provide the coroutine frame pointer in order to create the promise.
   </p>
   <p>
   This will also be relevant for recursion; stackless function calls do not count against the
   static stack size upper bound calculation. See <a href="#recursion">Recursion Status</a> for
   more details.
   </p>

   <h2 id="stage2-progress">Self-Hosted Compiler Status</h2>
   <p>The self-hosted compiler is well underway.
   <a href="https://www.youtube.com/watch?v=b_Pm29crq6Q">Here's a 1 minute demo of the self-hosted compiler watching source files and rebuilding.</a>
   </p>
   <p>
   The self-hosted compiler cannot do much more than Hello World at the moment, but
   it's being constructed from the ground up to fully take advantage of multiple cores
   and in-memory caching. In addition, Zig's error system and other safety features
   are making it easy to write reliable, robust code. Between stack traces, error return
   traces, and runtime safety checks, I barely even need a debugger.
   </p>
   <p>
   Marc Tiehuis contributed a <a href="https://tiehuis.github.io/blog/zig2.html">Big Integer library</a>,
   which the self-hosted compiler is using for integer literals and compile-time math operations.
   </p>
   <p>
   Writing the self-hosted compiler code revealed to me how coroutines should work in Zig.
   All the little details and ergonomics are clear to me now. And so before I continue any further on the
   self-hosted compiler, I will use this knowledge to rework coroutines and solve the problems with them.
   See <a href="#concurrency">Concurrency Status</a> for more details.
   </p>
   <p>As a reminder, even when the self-hosted compiler is complete, Zig will forever be stuck
   with the stage1 C++ compiler code. See <a href="https://github.com/ziglang/zig/issues/853">The Grand Bootstrapping Plan</a> for more details.</p>
   <p>
   The self-hosted compiler is successfully sharing some C++ code with the stage1 compiler.
   For example the libLLVM C++ API wrapper is built into a static library, which then exports a C API wrapper.
   The self-hosted compiler links against this static library in order to make libLLVM C++ API calls via the 
   C API wrapper. In addition, the Microsoft Visual Studio detection code requires the Windows COM API,
   which is also C++, and so a similar strategy is used. I think it's pretty neat that the build system
   builds a static library once and then ends up linking against it twice - one for each of the two compiler stages!
   </p>

   <h2 id="recursion">Recursion Status</h2>
   <p>
   I've <a href="https://www.recurse.com/events/localhost-andrew-kelley">said before</a> that
   recursion is one of the enemies of perfect software, because it represents a way that a
   program can fail with no foolproof way of preventing it. With recursion, pick any stack size
   and I'll give you an input that will crash your program. Embedded developers are all too
   familiar with this problem.
   </p>
   <p>
   It's always possible to rewrite code using an explicit stack using heap allocations,
   and <a href="#zig-fmt">that's exactly what Jimmi did</a> in the self-hosted parser.
   </p>
   <p>
   On the other hand, when recursion fits the problem, it's significantly more clear and
   maintainable. It would be a real shame to have to give it up.
   </p>
   <p>
   I researched different ways that Zig could keep recursion, even when we
   introduce <a href="https://github.com/ziglang/zig/issues/157">statically known stack upper bound size</a>. 
   I came up with a proof of concept for
   <a href="https://ziglang.org/documentation/0.3.0/#newStackCall">@newStackCall</a>,
   a builtin function that calls a function using an explicitly provided new stack.
   You can find a usage example in the documentation by following that link.
   </p>
   <p>
   This works, and it does break call graph cycles, but it would be a little bit awkward to use.
   Because if you allocate an entire new stack, it has to be big enough for the rest of the
   stack upper bound size, but in a recursive call, which should be only one stack frame,
   it would overallocate every time.
   </p>
   <p>
   So that's why I think that the actual solution to this problem is Zig's stackless coroutines.
   Because Zig's coroutines are stackless, they are the perfect solution for recursion (direct
   or indirect). With the reworking of coroutines, it will be possible to put the coroutine
   frame of an async function anywhere - in a struct, in the stack, in a global variable -
   as long as it outlives the duration of the coroutine. See <a href="#concurrency">Concurrency</a>
   for more details.
   </p>
   <p>
   Although recursion is not yet solved, we know enough to know that recursion is OK to use in Zig.
   It does suffer from the stack overflow issue today, but in the future we will have a compile error
   to prevent call graph cycles. And then this hypothetical compile error will be solved by using
   <code class="zig"><span class="tok-builtin">@newStackCall</span></code> or stackless functions (but probably stackless functions).
   Once recursion is solved, if stackless functions turn out to be the better solution,
   Zig will remove <code class="zig"><span class="tok-builtin">@newStackCall</span></code> from the language, unless someone demonstrates
   a compelling use case for it.
   </p>
   <p>For now, use recursion whenever you want; you'll know when it's time to update your code.</p>

   <h2 id="wasm">WebAssembly Status</h2>
   <p>The pieces for web assembly are starting to come together.</p>
   <p>Ben Noordhuis fixed support for <code>--target-arch wasm32</code> (<a href="https://github.com/ziglang/zig/issues/1094">#1094</a>).</p>
   <p>LLVM <a href="https://reviews.llvm.org/D43211">merged my patch</a> to make WebAssembly
   a normal (non-experimental) target. But they didn't do it before the LLVM 7 release. So
   Zig 0.3.0 will not have WebAssembly support by default, but 0.4.0 will.</p>
   <p>
   That being said, the static builds of Zig provided by ziglang.org have the WebAssembly
   target enabled.
   </p>
   <p>
   Apart from this, there appears to be
   <a href="https://github.com/ziglang/zig/issues/1570">an issue with Zig's WebAssembly linker</a>.
   Once this is solved, all that is left is to use WebAssembly in real life use cases, to work
   out the ergonomics, and solve the inevitable issues that arise.
   </p>

   <h2 id="documentation">Documentation</h2>
   <p>
   The language reference documentation now contains no JavaScript. The code blocks
   are pre-formatted with <code>std.zig.Tokenizer</code>. The same is true for these
   release notes.
   </p>
   <p>
   The <code>builtin.zig</code> example code in the documentation is now automatically updated from
   the output of Zig, so the docs can't get out of date for this.
   </p>
    <p>In addition to the above, the following improvements were made to the documentation:</p>
    <ul>
      <li>Added docs for <a href="https://ziglang.org/documentation/0.3.0/#packed-enum">packed enum</a>.</li>
      <li>Added docs for <a href="https://ziglang.org/documentation/0.3.0/#union">union</a> methods.</li>
      <li>Added alignment documentation to <code>std.mem.Allocator</code> functions.</li>
      <li>Added docs for <a href="https://ziglang.org/documentation/0.3.0/#Coroutines">Coroutines</a>.</li>
      <li>Added docs for <a href="https://ziglang.org/documentation/0.3.0/#Error-Return-Traces">Error Return Traces</a>.</li>
      <li>Clarify that float types are guaranteed to be represented as IEEE 754 in memory.</li>
      <li>Added docs for <a href="https://ziglang.org/documentation/0.3.0/#void">void</a>.</li>
      <li>Added docs for <a href="https://ziglang.org/documentation/0.3.0/#Casting">Casting</a>.</li>
      <li>Improved docs for <a href="https://ziglang.org/documentation/0.3.0/#while">while</a>
        and <a href="https://ziglang.org/documentation/0.3.0/#undefined">undefined</a> .</li>
      <li>Added docs for <a href="https://ziglang.org/documentation/0.3.0/#Wrong-Union-Field-Access">Wrong Union Field Access</a>.</li>
      <li>Corrected <a href="https://ziglang.org/documentation/0.3.0/#memcpy">@memcpy</a> and
          <a href="https://ziglang.org/documentation/0.3.0/#memset">@memset</a> function signatures. -Marc Tiehuis
      </li>
      <li>Added docs for <a href="https://ziglang.org/documentation/0.3.0/#Peer-Type-Resolution">Peer Type Resolution</a>.</li>
      <li>Added docs for <a href="https://ziglang.org/documentation/0.3.0/#Exporting-a-C-Library">Exporting a C Library</a>.</li>
      <li>Added docs for <a href="https://ziglang.org/documentation/0.3.0/#Labeled-while">labeled while</a>,
        <a href="https://ziglang.org/documentation/0.3.0/#blocks">labeled blocks</a>, and
        <a href="https://ziglang.org/documentation/0.3.0/#Labeled-for">labeled for</a>.</li>
    </ul>

   <h2 id="std-lib">Standard Library API Changes</h2>
   <ul>
     <li><code>std.mem.SplitIterator</code> is now public</li>
     <li><code>std.math.atan2</code> is now public</li>
     <li><code>std.os.linux</code> now makes public all the syscall numbers and syscall functions</li>
     <li><code>std.math.cast</code> handles signed integers</li>
     <li>added <code>std.zig.parse</code></li>
     <li>added <code>std.zig.parseStringLiteral</code></li>
     <li>added <code>std.zig.render</code></li>
     <li>added <code>std.zig.ast</code></li>
     <li>added <code>std.zig.Token</code></li>
     <li>added <code>std.zig.Tokenizer</code></li>
     <li>added <code>std.io.readLine</code></li>
     <li>replace <code>File.exists</code> with <code>File.access</code>. -Marc Tiehuis</li>
     <li>rename <code>std.rand.Rand</code> to <code>std.rand.Random</code></li>
     <li>added common hash/checksum functions. -Marc Tiehuis
       <ul>
         <li>SipHash64, SipHash128</li>
         <li>Crc32 (fast + small variants)</li>
         <li>Adler32</li>
         <li>Fnv1a (32, 64 and 128 bit variants)</li>
       </ul>
     </li>
     <li>Add Hmac function -Marc Tiehuis</li>
     <li>Added timestamp, high-perf. timer functions -tgschultz
       <ul>
         <li><code>std.os.time.sleep</code></li>
         <li><code>std.os.time.posixSleep</code></li>
         <li><code>std.os.time.timestamp</code></li>
         <li><code>std.os.time.miliTimestamp</code></li>
         <li><code>std.os.time.Timer</code></li>
       </ul>
     </li>
     <li>Added complex number support. -Marc Tiehuis
       <ul>
         <li><code>std.math.complex.Complex</code></li>
         <li><code>std.math.complex.abs</code></li>
         <li><code>std.math.complex.acos</code></li>
         <li><code>std.math.complex.acosh</code></li>
         <li><code>std.math.complex.arg</code></li>
         <li><code>std.math.complex.asin</code></li>
         <li><code>std.math.complex.asinh</code></li>
         <li><code>std.math.complex.atan</code></li>
         <li><code>std.math.complex.atanh</code></li>
         <li><code>std.math.complex.conj</code></li>
         <li><code>std.math.complex.cos</code></li>
         <li><code>std.math.complex.cosh</code></li>
         <li><code>std.math.complex.exp</code></li>
         <li><code>std.math.complex.log</code></li>
         <li><code>std.math.complex.pow</code></li>
         <li><code>std.math.complex.proj</code></li>
         <li><code>std.math.complex.sinh</code></li>
         <li><code>std.math.complex.sin</code></li>
         <li><code>std.math.complex.sqrt</code></li>
         <li><code>std.math.complex.tanh</code></li>
         <li><code>std.math.complex.tan</code></li>
         <li><code>std.math.complex.ldexp_cexp</code></li>
       </ul>
     </li>
     <li>Added more slice manipulation functions. Thanks Braedon Wooding for the original PR. (<a href="https://github.com/ziglang/zig/issues/944">#944</a>)
       <ul>
         <li><code>std.mem.trimLeft</code></li>
         <li><code>std.mem.trimRight</code></li>
         <li><code>std.mem.trimRight</code></li>
         <li><code>std.mem.lastIndexOfScalar</code></li>
         <li><code>std.mem.lastIndexOfAny</code></li>
         <li><code>std.mem.lastIndexOf</code></li>
         <li><code>std.mem.endsWith</code></li>
       </ul>
     </li>
     <li>Added <code>std.atomic.Stack</code></li>
     <li>Added <code>std.atomic.Queue</code></li>
     <li>Added <code>std.os.spawnThread</code>. It works on all targets. On Linux, when linking libc, it uses pthreads, and when not linking libc, it makes syscalls directly.</li>
     <li>Add JSON decoder. -Marc Tiehuis
       <ul>
       <li><code>std.json.Token</code></li>
       <li><code>std.json.StreamingParser</code></li>
       <li><code>std.json.TokenStream</code></li>
       <li><code>std.json.validate</code></li>
       <li><code>std.json.ValueTree</code></li>
       <li><code>std.json.ObjectMap</code></li>
       <li><code>std.json.Value</code></li>
       <li><code>std.json.Parser</code> - A non-stream JSON parser which constructs a tree of Value's.</li>
       </ul>
     </li>
      <li>Added <code>std.SegmentedList</code></li>
      <li>Removed functions from <code>std.Buffer</code>. Instead users should use <code>std.io.BufferOutStream</code>.
        <ul>
          <li>Removed <code>std.Buffer.appendFormat</code></li>
          <li>Removed <code>std.Buffer.appendByte</code></li>
          <li>Removed <code>std.Buffer.appendByteNTimes</code></li>
        </ul>
      </li>
     <li>Add arbitrary-precision integer to std. -Marc Tiehuis
       <ul>
         <li><code>std.math.big.Int</code></li>
         <li><code>std.math.big.Limb</code></li>
         <li><code>std.math.big.DoubleLimb</code></li>
         <li><code>std.math.big.Log2Limb</code></li>
       </ul>
     </li>
     <li><code>std.os.Dir</code> gains Windows support.</li>
     <li><code>std.os.File.access</code> no longer depends on shlwapi.dll on Windows.</li>
     <li><code>std.os.path.dirname</code> returns null instead of empty slice when there
       is no directory component. This makes it harder to write bugs. (<a href="https://github.com/ziglang/zig/issues/1017">#1017</a>)
      </li>
      <li>Reading from a file can return <code>error.IsDir</code>.</li>
      <li>Added <code>std.math.floatMantissaBits</code> and <code>std.math.floatExponentBits</code> -Marc Tiehuis</li>
      <li><code>std.mem.Allocator</code> allows allocation of any 0 sized type, not just <code>void</code>. -Jimmi Holst Christensen.</li>
      <li>Added <code>std.os.cpuCount</code></li>
      <li>Added <code>std.sort.asc</code> and <code>std.sort.desc</code> -Marc Tiehuis</li>
      <li><code>std.fmt.format</code> add <code>*</code> for formatting things as pointers. (<a href="https://github.com/ziglang/zig/issues/1285">#1285</a>)</li>
      <li><code>std.fmt.format</code> add integer binary output format. -Marc Tiehuis (<a href="https://github.com/ziglang/zig/issues/1313">#1313</a>)</li>
      <li>Added <code>std.mem.secureZero</code>. -Marc Tiehuis
        <br><br>
        This is identical to <code>mem.set(u8, slice, 0)</code> except that it will never
    be optimized out by the compiler. Intended usage is for clearing
    secret data.
        <br><br>
    The resulting assembly has been manually verified in --release-* modes.
        <br><br>
    It would be valuable to test the 'never be optimized out' claim in tests
    but this is harder than initially expected due to how much Zig appears
    to know locally. May be doable with <code>@intToPtr</code>, <code>@ptrToInt</code> to get around
    known data dependencies but I could not work it out right now.
      </li>
      <li><code>std.fmt.format</code> handles non-pointer struct/union/enums. Adds support for printing structs
        via reflection. (<a href="https://github.com/ziglang/zig/issues/1380">#1380</a>)</li>
      <li>Many <code>std.os</code> file functions no longer require an allocator. They rely on
        <code>PATH_MAX</code>, because even Windows, Linux, and MacOS syscalls will fail for paths longer
        than <code>PATH_MAX</code>.</li>
      <li>Add <code>std.crypto.chaCha20IETF</code> and <code>std.crypto.chaCha20With64BitNonce</code>. -Shawn Landden &amp; Marc Tiehuis</li>
      <li>Add poly1305 and x25519 crypto primitives. -Marc Tiehuis
        <br><br>
        These are translated from <a href="https://monocypher.org/">monocypher</a> which
        has fairly competitive performance while remaining quite simple.
        <br><br>
        Initial performance comparision:
        <br>
        <pre>Zig:
  Poly1305: 1423 MiB/s
  X25519:   8671 exchanges per second

Monocypher:
  Poly1305: 1567 MiB/s
  X25519:   10539 exchanges per second</pre>
        There is room for improvement and no real effort has been made at all in
        optimization beyond a direct translation.
      </li>
      <li>Removed deprecated, unused Windows functions
        <ul>
          <li><code>std.os.windows.CryptAcquireContextA</code></li>
          <li><code>std.os.windows.CryptReleaseContext</code></li>
          <li><code>std.os.windows.CryptGenRandom</code></li>
        </ul>
      </li>
  </ul>

   <h2 id="thanks-contributors">Thank you contributors!</h2>
   <ul>
     <li><strong>Tesla Ice Zhang</strong> fixed typos in the Zig grammar documentation and created <a href="https://github.com/ice1000/zig-intellij">The IntelliJ IDEA plugin for the Zig programming language</a></li>
     <li><strong>Jay Weisskopf</strong> cleaned up the Zig documentation</li>
     <li><strong>hellerve</strong> finished the Mac OS dir entry iterator code</li>
     <li><strong>Raul Leal</strong> fixed an undeclared identifier error in readUntilDelimiterBuffer and incorrect number of parameters in readUntilDelimiterAlloc (<a href="https://github.com/ziglang/zig/issues/877">#877</a>)</li>
     <li><strong>Wander Lairson Costa</strong> fixed the build process to find libxml2 and zlib correctly. (<a href="https://github.com/ziglang/zig/issues/847">#847</a>)</li>
     <li><strong>tgschultz</strong> added more linux syscalls and constants to the std lib.</li>
     <li><strong>tgschultz</strong> fixed compiler errors around Darwin code.</li>
     <li><strong>Harry Eakins</strong> added readability improvements and a bug-fix to the standard library
       crypto throughput test.</li>
     <li><strong>tgschultz</strong> Added DirectAllocator support for alignments bigger than os.page_size on posix systems. (<a href="https://github.com/ziglang/zig/issues/939">#939</a>)</li>
     <li><strong>Braedon Wooding</strong> &amp; <strong>Josh Wolfe</strong> Added UTF-8 encoding and decoding support. (<a href="https://github.com/ziglang/zig/issues/954">#954</a>)</li>
     <li><strong>Alexandros Naskos</strong> Fixed a bug where comptime was being incorrectly applied across function definition boundaries. (<a href="https://github.com/ziglang/zig/issues/972">#972</a>)</li>
     <li><strong>Braedon Wooding</strong> worked towards unifying the <code>std.ArrayList</code> and <code>std.HashMap</code> APIs regarding iteration. (<a href="https://github.com/ziglang/zig/issues/981">#981</a>)</li>
     <li><strong>Braedon Wooding</strong> added documentation for arg types and error inference.</li>
     <li><strong>tgschultz</strong> added custom formatter support to <code>std.fmt.format</code>.
     <li><strong>isaachier</strong> Fixed const-ness of buffer in <code>std.Buffer.replaceContents</code> method (<a href="https://github.com/ziglang/zig/issues/1065">#1065</a>)</li>
     <li><strong>isaachier</strong> Fixed error handling in <code>std.Buffer.fromOwnedSlice</code>. (<a href="https://github.com/ziglang/zig/issues/1082">#1082</a>)</li>
     <li><strong>Arthur Elliott</strong> Added <code>std.ArrayList.setOrError</code> so you can set a value without growing the underlying buffer, with range safety checks.</li>
     <li><strong>marleck55</strong> std/fmt: Use lowercase k for kilo in base 1000 (<a href="https://github.com/ziglang/zig/issues/1090">#1090</a>)</li>
     <li><strong>tgschultz</strong> added C string to fmt by using <code>{s}</code>. (<a href="https://github.com/ziglang/zig/issues/1092">#1092</a>)</li>
     <li><strong>Alexandros Naskos</strong> Fixed optional types of zero bit types. (<a href="https://github.com/ziglang/zig/issues/1110">#1110</a>)</li>
     <li><strong>Jay Weisskopf</strong> Made <code>zig version</code> compliant with SemVer with regards
         to the git revision metadata.</li>
     <li><strong>Sahnvour</strong> fixed a compilation error on windows introduced by pointer reform.</li>
     <li><strong>Bodie Solomon</strong> Fixed zig not finding std lib files on Darwin when the executable is a symlink. (<a href="https://github.com/ziglang/zig/issues/1117">#1117</a>)</li>
     <li><strong>Isaac Hier</strong> Fixed the increment operation for the comptime value <code>-1</code>.</li>
     <li><strong>Isaac Hier</strong> Fixed the compiler's internal path joining function when the dirname is empty.</li>
     <li><strong>tgschultz</strong> Fixed standard library regressions from updated syntax. (<a href="https://github.com/ziglang/zig/issues/1162">#1162</a>)</li>
     <li><strong>Isaac Hier</strong> Improved the compile error for when the RHS of a shift is too large for the LHS. (<a href="https://github.com/ziglang/zig/issues/1168">#1168</a>)</li>
     <li><strong>Jay Weisskopf</strong> Fixed version detection for out-of-source builds.</li>
     <li><strong>Isaac Hier</strong> Fixed an assertion crash on enum switch values</li>
     <li><strong>wilsonk</strong> Fixed a build error in the crypto throughput test (<a href="https://github.com/ziglang/zig/issues/1211">#1211</a>)</li>
     <li><strong>Bas van den Berg</strong> Fixed <code>std.ArrayList.insert</code> and added tests. (<a href="https://github.com/ziglang/zig/issues/1232">#1232</a>)</li>
     <li><strong>tgschultz</strong> Added <code>std.ArrayList.swapRemove</code>. (<a href="https://github.com/ziglang/zig/issues/1230">#1230</a>)</li>
     <li><strong>Eduardo Sánchez Muñoz</strong> fixed bad code generated when an extern function returns a small struct. (<a href="https://github.com/ziglang/zig/issues/1234">#1234</a>)</li>
     <li><strong>Bas van den Berg</strong> fixed aligned reallocation. (<a href="https://github.com/ziglang/zig/issues/1237">#1237</a>)</li>
     <li><strong>Bas van den Berg</strong> improved realloc on fixed buffer allocator. (<a href="https://github.com/ziglang/zig/issues/1238">#1238</a>)</li>
     <li><strong>Wink Saville</strong> gave ArrayList tests consistent names. (<a href="https://github.com/ziglang/zig/issues/1253">#1253</a>)</li>
     <li><strong>Wink Saville</strong> added <code>std.ArrayList.swapRemoveOrError</code>. (<a href="https://github.com/ziglang/zig/issues/1254">#1254</a>)</li>
     <li><strong>Jay Weisskopf</strong> Fixed minor documentation errors (<a href="https://github.com/ziglang/zig/issues/1256">#1256</a>)</li>
     <li><strong>kristopher tate</strong> Added more <code>std.os.posix</code> constants.</li>
     <li><strong>kristopher tate</strong> Made tests skippable by returning <code>error.SkipZigTest</code></li>
     <li><strong>Nathan Sharp</strong> Added <code>std.io.PeekStream</code> and <code>std.io.Slicestream</code>.
       <br><br>
    SliceStream is a read-only stream wrapper around a slice of bytes. It
    allows adapting algorithms which work on InStreams to in-memory data.
       <br><br>
    PeekStream is a stream wrapper which allows "putting back" bytes into
    the stream so that they can be read again. This will help make
    look-ahead parsers easier to write.
      </li>
      <li><strong>dbandstra</strong> added int writing functions to OutStream, and skipBytes function to InStream (<a href="https://github.com/ziglang/zig/issues/1300">#1300</a>)</li>
      <li><strong>dbandstra</strong> add SliceOutStream, rename SliceStream to SliceInStream (<a href="https://github.com/ziglang/zig/issues/1301">#1301</a>)</li>
      <li><strong>Matthew D. Steele</strong> added "Comments" section to language reference (<a href="https://github.com/ziglang/zig/issues/1309">#1309</a>)</li>
      <li><strong>kristopher tate</strong> Windows: Call RtlGenRandom() instead of CryptGetRandom() (<a href="https://github.com/ziglang/zig/issues/1319">#1319</a>)</li>
      <li><strong>kristopher tate</strong> Add builtin function @handle() (<a href="https://github.com/ziglang/zig/issues/1297">#1297</a>)</li>
      <li><strong>kristopher tate</strong> better support for `_` identifier (<a href="https://github.com/ziglang/zig/issues/1204">#1204</a>, <a href="https://github.com/ziglang/zig/issues/1320">#1320</a>)</li>
      <li><strong>Matthew D. Steele</strong> Fix the start-less-than-end assertion in std.rand.Random.range (<a href="https://github.com/ziglang/zig/issues/1325">#1325</a>)</li>
      <li><strong>Matthew D. Steele</strong> Fix a type error in std.os.linux.getpid() (<a href="https://github.com/ziglang/zig/issues/1326">#1326</a>)</li>
      <li><strong>Matthew D. Steele</strong> Add thread ID support to std.os.Thread (<a href="https://github.com/ziglang/zig/issues/1316">#1316</a>)</li>
      <li><strong>Shawn Landden</strong>doc: @addWithOverflow also returns if overflow occured</li>
      <li><strong>Shawn Landden</strong>added a red-black tree implementation to std</li>
      <li><strong>Wink Saville</strong> fixed @atomicRmw not type checking correctly.</li>
      <li><strong>prazzb</strong> Fixed LLVM detection at build time for some linux distros. (<a href="https://github.com/ziglang/zig/issues/1378">#1378</a>)</li>
      <li><strong>tgschultz</strong> fixed handling of [*]u8 when no format specifier is set. (<a href="https://github.com/ziglang/zig/issues/1379">#1379</a>)</li>
      <li><strong>Shawn Landden</strong> do not use an allocator when we don't need to because of the existance of PATH_MAX</li>
      <li><strong>Raul Leal</strong> Allow implicit cast from <code>*[N]T</code> to <code>?[*]T</code> (<a href="https://github.com/ziglang/zig/issues/1398">#1398</a>)</li>
      <li><strong>kristopher tate</strong> Added a test for writing u64 integers (<a href="https://github.com/ziglang/zig/issues/1401">#1401</a>)</li>
      <li><strong>tgschultz</strong> Fixed compile error when passing enum to fmt</li>
      <li><strong>tgschultz</strong> Implemented tagged union support in <code>std.fmt.format</code> (<a href="https://github.com/ziglang/zig/issues/1432">#1432</a>)</li>
      <li><strong>Raul Leal</strong> Allow implicit cast from <code>*T</code> and <code>[*]T</code> to <code>?*c_void</code></li>
     <li><strong>kristopher tate</strong> correct version comparison for detecting msvc (fixes <a href="https://github.com/ziglang/zig/issues/1438">#1438</a>)</li>
     <li><strong>kristopher tate</strong> allow bytes to be printed-out as hex (<a href="https://github.com/ziglang/zig/issues/1358">#1358</a>)</li>
     <li><strong>Shawn Landden</strong> updated incorrect documentation comments (<a href="https://github.com/ziglang/zig/issues/1456">#1456</a>)</li>
     <li><strong>hfcc</strong> Added compilation error when a non-float is given to <code>@floatToInt</code></li>
     <li><strong>kristopher tate</strong> X25519: Fix createPublicKey signature and add test (<a href="https://github.com/ziglang/zig/issues/1480">#1480</a>)</li>
     <li><strong>Sahnvour</strong> Fixes a path corruption when compiling on windows. (<a href="https://github.com/ziglang/zig/issues/1488">#1488</a>)</li>
     <li><strong>Bas van den Berg</strong> Add capacity and appendAssumeCapacity to ArrayList</li>
     <li><strong>emekoi</strong>fixed WriteFile segfault</li>
     <li><strong>kristopher tate</strong> fixed handling of file paths with spaces in the cache</li>
     <li><strong>Wink Saville</strong> fixed build failures of FileOutStream/FileInStream from syntax changes</li>
     <li><strong>emekoi</strong>fixed compiling on mingw (<a href="https://github.com/ziglang/zig/issues/1542">#1542</a>)</li>
     <li><strong>Raul Leal</strong> added builtin functions: <code>@byteOffsetOf</code> and <code>@bitOffsetOf</code>.</li>
     <li><strong>Christian Wesselhoeft</strong> fixed BufferOutStream import - it is defined in io.zig.</li>
     <li><strong>Wink Saville</strong> fixed a typo in a doc comment</li>
     <li><strong>Wink Saville</strong> fixed a build issue with GCC 8</li>
     <li><strong>Wink Saville</strong> refactored some parsing code in the self-hosted compiler</li>
     <li><strong>Jay Weisskopf</strong> improved the help output of the command line interface</li>
   </ul>

    <h2 id="misc">Miscellaneous Improvements</h2>
    <ul>
      <li>LLVM, Clang, and LLD dependencies are <a href="http://releases.llvm.org/7.0.0/docs/ReleaseNotes.html">updated to 7.0.0</a>.
      </li>
      <li>Greatly increased test coverage.</li>
      <li>std.os - getting dir entries works on Mac OS.</li>
      <li>allow integer and float literals to be passed to var params. See <a href="https://github.com/ziglang/zig/issues/623">#623</a></li>
      <li>add <a href="https://ziglang.org/documentation/0.3.0/#sqrt">@sqrt</a> built-in function. <a href="https://github.com/ziglang/zig/issues/767">#767</a></li>
      <li>The compiler exits with error code instead of abort() for file not found.</li>
      <li>Add <a href="https://ziglang.org/documentation/0.3.0/#atomicLoad">@atomicLoad</a> builtin.</li>
      <li>stage1 compiler defaults to installing in the build directory</li>
      <li>ability to use async function pointers</li>
      <li>Revise self-hosted command line interface</li>
      <li>Add exp/norm distributed random float generation. -Marc Tiehuis</li>
      <li>On linux, <code>clock_gettime</code> uses the VDSO optimization, even
      for static builds.</li>
      <li>Better error reporting for missing libc on Windows. (<a href="https://github.com/ziglang/zig/issues/931">#931</a>)</li>
      <li>Improved fmt float-printing. -Marc Tiehuis
        <ul>
          <li>Fix errors printing very small numbers</li>
          <li>Add explicit scientific output mode</li>
          <li>Add rounding based on a specific precision for both decimal/exp modes.</li>
          <li>Test and confirm exp/decimal against libc for all <code>f32</code> values. Various
            changes to better match libc.</li>
        </ul>
      </li>
      <li>The crypto throughput test now uses the new <code>std.os.time</code> module. -Marc Tiehuis</li>
      <li>Added better support for unpure enums in tranlate C. -Jimmi Holst Christensen (<a href="https://github.com/ziglang/zig/issues/975">#975</a>)</li>
      <li>Made container methods that can be <code>const</code>, <code>const</code>. -Jimmi Holst Christensen</li>
      <li>Tagged union field access prioritizes members over enum tags. (<a href="https://github.com/ziglang/zig/issues/959">#959</a>)</li>
      <li><code>std.fmt.format</code> supports <code>{B}</code> for human readable bytes using SI prefixes.</li>
      <li>Zig now knows the C integer sizes for OpenBSD. Thanks to Jan Schreib for this information. (<a href="https://github.com/ziglang/zig/issues/1016">#1016</a>)</li>
      <li>Renamed integer literal type and float literal type to <code>comptime_int</code> and <code>comptime_float</code>. -Jimmi Holst Christensen</li>
      <li><a href="https://ziglang.org/documentation/0.2.0/#canImplicitCast">@canImplicitCast</a> is removed. Nobody will miss it.</li>
      <li>Allow access of <code>array.len</code> through a pointer. -Jimmi Holst Christensen</li>
      <li>Optional pointers follow const-casting rules. Any <code>*T -&gt; ?*T</code> cast
        is allowed implicitly, even when it occurs deep inside the type, and the cast
        is a no-op at runtime.
      </li>
      <li>Add i128 compiler-rt div/mul support. -Marc Tiehuis</li>
      <li>Add target C int type information for msp430 target. <a href="https://github.com/ziglang/zig/issues/1125">#1125</a></li>
      <li>Add <code>__extenddftf2</code> and <code>__extendsftf2</code> to zig's compiler-rt.</li>
      <li>Add support for zig to compare comptime array values. -Jimmi Holst Christensen (<a href="https://github.com/ziglang/zig/issues/1167">#1167</a>)</li>
      <li>Support <code>--emit</code> in <code>test</code> command. -Ben Noordhuis (<a href="https://github.com/ziglang/zig/issues/1175">#1175</a>)</li>
      <li>Operators now throw a compiler error when operating on undefined values. -Jimmi Holst Christensen (<a href="https://github.com/ziglang/zig/issues/1185">#1185</a>)</li>
      <li>Always link against compiler_rt even when linking libc. Sometimes libgcc is missing things we need,
        so we always link compiler_rt and rely on weak linkage to allow libgcc to override.</li>
      <li>Add compile error notes for where struct definitions are. (<a href="https://github.com/ziglang/zig/issues/1202">#1202</a>)</li>
      <li>Add <a href="https://ziglang.org/documentation/0.3.0/#popCount">@popCount</a>.</li>
      <li>Cleaner output from zig build when there are compile errors.</li>
      <li>new <code>builder.addBuildOption</code> API. -Josh Wolfe</li>
      <li>Add compile error for disallowed types in extern structs. (<a href="https://github.com/ziglang/zig/issues/1218">#1218</a>)</li>
      <li>build system: add <code>-Dskip-release</code> option to test faster. -Andrew Kelley &amp; Jimmi Holst Christensen</li>
      <li>allow <code>==</code> for comparing optional pointers. <a href="https://github.com/ziglang/zig/issues/658">#658</a></li>
      <li>allow implicit cast of undefined to optional</li>
      <li>switch most windows calls to use W versions instead of A. (<a href="https://github.com/ziglang/zig/issues/534">#534</a>)</li>
      <li>Better anonymous struct naming. This makes anonymous structs inherit the name of the
        function they are in only when they are the return expression. Also document the behavior
        and provide examples. (<a href="https://github.com/ziglang/zig/issues/1243">#1243</a>)</li>
      <li>compile error for @noInlineCall on an inline fn (<a href="https://github.com/ziglang/zig/issues/1133">#1133</a>)</li>
      <li>stage1: use os_path_resolve instead of os_path_real to canonicalize imports.
    This means that softlinks can represent different files,
    but referencing the same absolute path different ways
    still references the same import.</li>
      <li>rename <code>--enable-timing-info</code> to <code>-ftime-report</code> to match clang, and
         have it print llvm's internal timing info.</li>
      <li>Binary releases now include the LICENSE file.</li>
      <li>Overhaul standard library api for getting random integers. -Josh Wolfe (<a href="https://github.com/ziglang/zig/issues/1578">#1578</a>)</li>
    </ul>

    <h2 id="bug-fixes">Bug Fixes</h2>
    <ul>
      <li>fix incorrect compile error on inferred error set from async function <a href="https://github.com/ziglang/zig/issues/856">#856</a></li>
      <li>fix <code>promise-&gt;T</code> syntax not parsed <a href="https://github.com/ziglang/zig/issues/857">#857</a></li>
      <li>fix crash when compile error in analyzing @panic call</li>
      <li>fix compile time array concatenation for slices <a href="https://github.com/ziglang/zig/issues/866">#866</a></li>
      <li>fix off-by-one error in all standard library crypto functions. -Marc Tiehuis</li>
      <li>fix use-after-free in BufMap.set() - Ben Noordhuis <a href="https://github.com/ziglang/zig/issues/879">#879</a></li>
      <li>fix llvm assert on version string with git sha -Ben Noordhuis <a href="https://github.com/ziglang/zig/issues/898">#898</a></li>
      <li>codegen: fix not putting llvm allocas together</li>
      <li>fix calling convention at callsite of zig-generated fns</li>
      <li>inline functions now must be stored in const or comptime var. <a href="https://github.com/ziglang/zig/issues/913">#913</a></li>
      <li>fix linux implementation of self exe path <a href="https://github.com/ziglang/zig/issues/894">#894</a></li>
      <li>Fixed looking for windows sdk when targeting linux. -Jimmi Holst Christensen</li>
      <li>Fixed incorrect exit code when build.zig cannot be created. -Ben Noordhuis</li>
      <li>Fix os.File.mode function. -Marc Tiehuis</li>
      <li>Fix OpqaueType usage in exported c functions. -Marc Tiehuis</li>
      <li>Added <code>memmove</code> to builtin.o. LLVM occasionally generates a dependency on this function.</li>
      <li>Fix <code>std.BufMap</code> logic. -Ben Noordhuis</li>
      <li>Fix undefined behavior triggered by fn inline test</li>
      <li>Build system supports LLVM_LIBDIRS and CLANG_LIBDIRS. -Ben Noordhuis</li>
      <li>The Zig compiler does exit(1) instead of abort() for file not found.</li>
      <li>Add compile error for invalid deref on switch target. (<a href="https://github.com/ziglang/zig/issues/945">#945</a>)</li>
      <li>Fix printing floats in release mode. -Marc Tiehuis (<a href="https://github.com/ziglang/zig/issues/564">#564</a>, <a href="https://github.com/ziglang/zig/issues/669">#669</a>, <a href="https://github.com/ziglang/zig/issues/928">#928</a>)</li>
      <li>Fix <a href="https://ziglang.org/documentation/0.3.0/#shlWithOverflow">@shlWithOverflow</a> producing incorrect results when used at comptime (<a href="https://github.com/ziglang/zig/issues/948">#948</a>)</li>
      <li>Fix labeled break causing defer in same block to fail compiling (<a href="https://github.com/ziglang/zig/issues/830">#830</a>)</li>
      <li>Fix compiler crash with functions with empty error sets. -Jimmi Holst Christensen (<a href="https://github.com/ziglang/zig/issues/762">#762</a>, <a href="https://github.com/ziglang/zig/issues/818">#818</a>)</li>
      <li>Fix returning literals from functions with inferred error sets. -Jimmi Holst Christensen (<a href="https://github.com/ziglang/zig/issues/852">#852</a>)</li>
      <li>Fix compiler crash for <code>.ReturnType</code> and <a href="https://ziglang.org/documentation/0.3.0/#ArgType">@ArgType</a> on unresolved types. -Jimmi Holst Christensen (<a href="https://github.com/ziglang/zig/issues/846">#846</a>)</li>
      <li>Fix compiler-rt ABI for x86_64 windows</li>
      <li>Fix extern enums having the wrong size. -Jimmi Holst Christensen (<a href="https://github.com/ziglang/zig/issues/970">#970</a>)</li>
      <li>Fix bigint multi-limb shift and masks. -Marc Tiehuis</li>
      <li>Fix bigint shift-right partial shift. -Marc Tiehuis</li>
      <li>translate-c: fix typedef duplicate definition of variable. (<a href="https://github.com/ziglang/zig/issues/998">#998</a>)</li>
      <li>fix comptime code modification of global const. (<a href="https://github.com/ziglang/zig/issues/1008">#1008</a>)</li>
      <li>build: add flag to LLD to fix gcc 8 build. (<a href="https://github.com/ziglang/zig/issues/1013">#1013</a>)</li>
      <li>fix AtomicFile for relative paths. (<a href="https://github.com/ziglang/zig/issues/1017">#1017</a>)</li>
      <li>fix compiler assert when trying to unwrap return type <code>type</code>. -Jimmi Holst Christensen</li>
      <li>fix crash when evaluating return type has compile error. (<a href="https://github.com/ziglang/zig/issues/1058">#1058</a>)</li>
      <li>Fix Log2Int type construction. -Marc Tiehuis</li>
      <li>fix std.os.windows.PathFileExists specified in the wrong DLL (<a href="https://github.com/ziglang/zig/issues/1066">#1066</a>)</li>
      <li>Fix structs that contain types which require comptime. (<a href="https://github.com/ziglang/zig/issues/586">#586</a>)
        <br> <br>
    Now, if a struct has any fields which require comptime,
    such as <code>type</code>, then the struct is marked as requiring
    comptime as well. Same goes for unions.
    <br> <br>
    This means that a function will implicitly be called
    at comptime if the return type is a struct which contains
    a field of type <code>type</code>.
    <br> <br>
      </li>
      <li>fix assertion failure when debug printing comptime values</li>
      <li>fix <a href="https://ziglang.org/documentation/0.3.0/#tagName">@tagName</a> handling specified enum values incorrectly. (<a href="https://github.com/ziglang/zig/issues/976">#976</a>, <a href="https://github.com/ziglang/zig/issues/1080">#1080</a>)</li>
      <li>fix ability to call mutating methods on zero size structs. (<a href="https://github.com/ziglang/zig/issues/838">#838</a>)</li>
      <li>disallow implicit casts that break rules for optionals. (<a href="https://github.com/ziglang/zig/issues/1102">#1102</a>)</li>
      <li>Fix windows x86_64 i128 ABI issue. -Marc Tiehuis</li>
      <li>Disallow opaque as a return type of function type syntax. (<a href="https://github.com/ziglang/zig/issues/1115">#1115</a>)</li>
      <li>Fix compiler crash for invalid enums. (<a href="https://github.com/ziglang/zig/issues/1079">#1079</a>, <a href="https://github.com/ziglang/zig/issues/1147">#1147</a>)</li>
      <li>Fix crash for optional pointer to empty struct. (<a href="https://github.com/ziglang/zig/issues/1153">#1153</a>)</li>
      <li>Fix comptime <code>@tagName</code> crashing sometimes. (<a href="https://github.com/ziglang/zig/issues/1118">#1118</a>)</li>
      <li>Fix coroutine accessing freed memory. (<a href="https://github.com/ziglang/zig/issues/1164">#1164</a>)</li>
      <li>Fix runtime libc detection on linux depending on locale. (<a href="https://github.com/ziglang/zig/issues/1165">#1165</a>)</li>
      <li>Fix await on early return when return type is struct.</li>
      <li>Fix iterating over a void slice. (<a href="https://github.com/ziglang/zig/issues/1203">#1203</a>)</li>
      <li>Fix crash on <code>@ptrToInt</code> of a <code>*void</code> (<a href="https://github.com/ziglang/zig/issues/1192">#1192</a>)</li>
      <li>fix crash when calling comptime-known undefined function ptr. <a href="https://github.com/ziglang/zig/issues/880">#880</a>, <a href="https://github.com/ziglang/zig/issues/1212">#1212</a></li>
      <li>fix <code>@setEvalBranchQuota</code> not respected in generic fn calls. <a href="https://github.com/ziglang/zig/issues/1257">#1257</a></li>
      <li>Allow pointers to anything in extern/exported declarations (<a href="https://github.com/ziglang/zig/issues/1258">#1258</a>) -Jimmi Holst Christensen</li>
      <li>Prevent non-export symbols from clobbering builtins. (<a href="https://github.com/ziglang/zig/issues/1263">#1263</a>)</li>
      <li>fix generation of error defers for fns inside fns. (<a href="https://github.com/ziglang/zig/issues/878">#878</a>)</li>
      <li>Fixed windows getPos. -Jimmi Holst Christensen</li>
      <li>fix logic for determining whether param requires comptime (<a href="https://github.com/ziglang/zig/issues/778">#778</a>, <a href="https://github.com/ziglang/zig/issues/1213">#1213</a>)</li>
      <li>Fixed bug in LLD crashing when linking twice in the same process. (<a href="https://github.com/ziglang/zig/issues/1289">#1289</a>)</li>
      <li>fix assertion failure when some compile errors happen</li>
      <li>add compile error for non-inline for loop on comptime type</li>
      <li>add compile error for missing parameter name of generic function</li>
      <li>add compile error for ignoring return value of while loop bodies (<a href="https://github.com/ziglang/zig/issues/1049">#1049</a>)</li>
      <li>fix tagged union initialization with a runtime void (<a href="https://github.com/ziglang/zig/issues/1328">#1328</a>)</li>
      <li>translate-c: fix for loops and do while loops with empty body</li>
      <li>fix incorrectly generating an unused const fn global (<a href="https://github.com/ziglang/zig/issues/1277">#1277</a>)</li>
      <li>Fix builtin alignment type. -Marc Tiehuis (<a href="https://github.com/ziglang/zig/issues/1235">#1235</a>)</li>
      <li>fix handling multiple extern vars with the same name</li>
      <li>fix llvm assertion failure when building std lib tests for macos (<a href="https://github.com/ziglang/zig/issues/1417">#1417</a>)</li>
      <li>fix false negative determining if function is generic</li>
      <li>fix <code>@typeInfo</code> unable to distinguish compile error vs no-payload (<a href="https://github.com/ziglang/zig/issues/1421">#1421</a>, <a href="https://github.com/ziglang/zig/issues/1426">#1426</a>)</li>
      <li>fix crash when var in inline loop has different types (<a href="https://github.com/ziglang/zig/issues/917">#917</a>, <a href="https://github.com/ziglang/zig/issues/845">#845</a>, <a href="https://github.com/ziglang/zig/issues/741">#741</a>, <a href="https://github.com/ziglang/zig/issues/740">#740</a>)</li>
      <li>add compile error for function prototype with no body (<a href="https://github.com/ziglang/zig/issues/1231">#1231</a>)</li>
      <li>fix invalid switch expression parameter. (<a href="https://github.com/ziglang/zig/issues/604">#604</a>)</li>
      <li>Translate-c: Check for error before working on while loop body. -Jimmi Holst Christensen (<a href="https://github.com/ziglang/zig/issues/1445">#1445</a>)</li>
      <li>use the sret attribute at the callsite when appropriate. Thanks to Shawn Landden for the
        original pull request. (<a href="https://github.com/ziglang/zig/issues/1450">#1450</a>)</li>
      <li>ability to <code>@ptrCast</code> to <code>*void</code>. (<a href="https://github.com/ziglang/zig/issues/960">#960</a>)</li>
      <li>compile error instead of segfault for unimplemented feature. (<a href="https://github.com/ziglang/zig/issues/1103">#1103</a>)</li>
      <li>fix incorrect value for inline loop. (<a href="https://github.com/ziglang/zig/issues/1436">#1436</a>)</li>
      <li>compile errors instead of crashing for unimplemented minValue/maxValue builtins</li>
      <li>add compile error for comptime control flow inside runtime block (<a href="https://github.com/ziglang/zig/issues/834">#834</a>)</li>
      <li>update throughput test to new File API (<a href="https://github.com/ziglang/zig/issues/1468">#1468</a>)</li>
      <li>fix compile error on gcc 7.3.0. Only set -Werror for debug builds, and only for zig itself, not for
        embedded LLD. (<a href="https://github.com/ziglang/zig/issues/1474">#1474</a>)</li>
      <li>stage1: fix emit asm with explicit output file (<a href="https://github.com/ziglang/zig/issues/1473">#1473</a>)</li>
      <li>stage1: fix crash when invalid type used in array type (<a href="https://github.com/ziglang/zig/issues/1186">#1186</a>)</li>
      <li>stage1 compile error instead of crashing for unsupported comptime ptr cast (<a href="https://github.com/ziglang/zig/issues/955">#955</a>)</li>
      <li>stage1: fix tagged union with no payloads (<a href="https://github.com/ziglang/zig/issues/1478">#1478</a>)</li>
      <li>Add compile error for using outer scoped runtime variables from a fn defined inside it. (<a href="https://github.com/ziglang/zig/issues/876">#876</a>)</li>
      <li>stage1: improve handling of generic fn proto type expr. (<a href="https://github.com/ziglang/zig/issues/902">#902</a>)</li>
      <li>stage1: compile error instead of incorrect code for unimplemented C ABI. (<a href="https://github.com/ziglang/zig/issues/1411">#1411</a>, <a href="https://github.com/ziglang/zig/issues/1481">#1481</a>)</li>
      <li>add support for partial C ABI compatibility on x86_64. (<a href="https://github.com/ziglang/zig/issues/1411">#1411</a>, <a href="https://github.com/ziglang/zig/issues/1264">#1264</a>)</li>
      <li>fix crash when var init has compile error and then the var is referenced (<a href="https://github.com/ziglang/zig/issues/1483">#1483</a>)</li>
      <li>fix incorrect union const value generation (<a href="https://github.com/ziglang/zig/issues/1381">#1381</a>)</li>
      <li>fix incorrect error union const value generation (<a href="https://github.com/ziglang/zig/issues/1442">#1442</a>)</li>
      <li>fix tagged union with only 1 field tripping assertion (<a href="https://github.com/ziglang/zig/issues/1495">#1495</a>)</li>
      <li>add compile error for merging non- error sets (<a href="https://github.com/ziglang/zig/issues/1509">#1509</a>)</li>
      <li>fix assertion failure on compile-time <code>@intToPtr</code> of function</li>
      <li>fix tagged union with all void payloads but meaningful tag (<a href="https://github.com/ziglang/zig/issues/1322">#1322</a>)</li>
      <li>fix alignment of structs. (<a href="https://github.com/ziglang/zig/issues/1248">#1248</a>, <a href="https://github.com/ziglang/zig/issues/1052">#1052</a>, <a href="https://github.com/ziglang/zig/issues/1154">#1154</a>)</li>
      <li>fix crash when pointer casting a runtime extern function</li>
      <li>allow extern structs to have stdcallcc function pointers (<a href="https://github.com/ziglang/zig/issues/1536">#1536</a>)</li>
      <li>add compile error for non-optional types compared against null (<a href="https://github.com/ziglang/zig/issues/1539">#1539</a>)</li>
      <li>add compile error for <code>@ptrCast</code> 0 bit type to non-0 bit type</li>
      <li>fix codegen for <code>@intCast</code> to <code>u0</code></li>
      <li>fix @bytesToSlice on a packed struct (<a href="https://github.com/ziglang/zig/issues/1551">#1551</a>)</li>
      <li>fix implicit cast of packed struct field to const ptr (<a href="https://github.com/ziglang/zig/issues/966">#966</a>)</li>
      <li>implementation for bitcasting extern enum type to c_int (<a href="https://github.com/ziglang/zig/issues/1036">#1036</a>)</li>
      <li>add compile error for slice.*.len (<a href="https://github.com/ziglang/zig/issues/1372">#1372</a>)</li>
      <li>fix optional pointer to empty struct incorrectly being non-null (<a href="https://github.com/ziglang/zig/issues/1178">#1178</a>)</li>
      <li>better string literal caching implementation
        <br><br>
    We were caching the ConstExprValue of string literals,
    which works if you can never modify ConstExprValues.
    This premise is broken with `comptime var ...`.
        <br><br>
    So I implemented an optimization in ConstExprValue
    arrays, where it stores a <code>Buf *</code> directly rather
    than an array of ConstExprValues for the elements,
    and then similar to array of undefined, it is
    expanded into the canonical form when necessary.
    However many operations can happen directly on the
    <code>Buf *</code>, which is faster.
        <br><br>
    Furthermore, before a ConstExprValue array is expanded
    into canonical form, it removes itself from the string
    literal cache. This fixes the issue, because before an
    array element is modified it would have to be expanded.
        <br><br>
        See <a href="https://github.com/ziglang/zig/issues/1076">#1076</a></li>
      <li>add compile error for casting const array to mutable slice (<a href="https://github.com/ziglang/zig/issues/1565">#1565</a>)</li>
      <li>fix <code>std.fmt.formatInt</code> to handle upcasting to base int size</li>
      <li>fix comptime slice of pointer to array (<a href="https://github.com/ziglang/zig/issues/1565">#1565</a>)</li>
      <li>fix comptime string concatenation ignoring slice bounds (<a href="https://github.com/ziglang/zig/issues/1362">#1362</a>)</li>
      <li>stage1: unify 2 implementations of pointer deref. I found out there were accidentally
        two code paths in zig ir for pointer dereference. So this should fix a few bugs. (<a href="https://github.com/ziglang/zig/issues/1486">#1486</a>)</li>
      <li>add compile error for slice of undefined slice (<a href="https://github.com/ziglang/zig/issues/1293">#1293</a>)</li>
      <li>fix @compileLog having unintended side effects. (<a href="https://github.com/ziglang/zig/issues/1459">#1459</a>)</li>
      <li>fix translate-c incorrectly translating negative enum init values (<a href="https://github.com/ziglang/zig/issues/1360">#1360</a>)</li>
      <li>fix comptime bitwise operations with negative values (<a href="https://github.com/ziglang/zig/issues/1387">#1387</a>, <a href="https://github.com/ziglang/zig/issues/1529">#1529</a>)</li>
      <li>fix self reference through fn ptr field crash (<a href="https://github.com/ziglang/zig/issues/1208">#1208</a>)</li>
      <li>fix crash on runtime index into slice of comptime type (<a href="https://github.com/ziglang/zig/issues/1435">#1435</a>)</li>
      <li>fix implicit casting to <code class="zig">*<span class="tok-type">c_void</span></code> (<a href="https://github.com/ziglang/zig/issues/1588">#1588</a>)</li>
      <li>fix variables which are pointers to packed struct fields (<a href="https://github.com/ziglang/zig/issues/1121">#1121</a>)</li>
      <li>fix crash when compile error evaluating return type of inferred error set. (<a href="https://github.com/ziglang/zig/issues/1591">#1591</a>)</li>
      <li>fix zig-generated DLLs not properly exporting functions. (<a href="https://github.com/ziglang/zig/issues/1443">#1443</a>)</li>
    </ul>

   <h2 id="there-are-bugs">This Release Contains Bugs</h2>
   <p>
   Zig has <a href="https://github.com/zig-lang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Abug">known bugs</a>.
   </p>
   <p>The first release that will ship with no known bugs will be 1.0.0.</p>


   <h2 id="roadmap">Roadmap</h2>
   <ul>
     <li>Redo coroutines without using LLVM Coroutines and rework the semantics. See <a href="https://github.com/ziglang/zig/issues/1363">#1363</a> and <a href="https://github.com/ziglang/zig/issues/1194">#1194</a>.</li>
     <li>Tuples instead of var args. <a href="https://github.com/ziglang/zig/issues/208">#208</a></li>
     <li>Well-defined copy-eliding semantics. <a href="https://github.com/ziglang/zig/issues/287">#287</a></li>
     <li>Self-hosted compiler. <a href="https://github.com/ziglang/zig/issues/89">#89</a></li>
     <li>Get to 100% documentation coverage of the language</li>
     <li>Auto generated documentation. <a href="https://github.com/ziglang/zig/issues/21">#21</a></li>
     <li>Package manager. <a href="https://github.com/ziglang/zig/issues/943">#943</a></li>
   </ul>

   <h2 id="projects">Active External Projects Using Zig</h2>
   <ul>
     <li><a href="https://github.com/Hejsil/pokemon-randomizer">pokemon-randomizer</a> - Pokémon Rom randomizer tool</li>
     <li><a href="https://gitlab.com/dbandstra/oxid">oxid</a> - arcade-style game where you fight waves of monsters in a fixed-screen maze</li>
     <li><a href="https://github.com/tiehuis/zig-rosetta">zig-rosetta</a> - Rosettacode examples in zig</a></li>
     <li><a href="https://github.com/andrewrk/zig-vulkan-triangle/">zig-vulkan-triangle</a> - simple triangle displayed using vulkan, glfw, and zig</a></li>
   </ul>

   <h2 id="thanks-patreon">Thank you financial supporters!</h2>

<p>
Special thanks to those who <a href="https://github.com/users/andrewrk/sponsorship">donate monthly</a>. We're now at $1,349 of the $3,000 goal. I hope this release helps to show how much time I've been able to dedicate to the project thanks to your support.
</p>

<ul>
  <li>Lauren Chavis</li>
  <li>Raph Levien</li>
  <li>connectFree Corporation</li>
  <li>Stevie Hryciw</li>
  <li>Andrea Orru</li>
  <li>Harry Eakins</li>
  <li>Filippo Valsorda</li>
  <li>jeff kelley</li>
  <li>Martin Schwaighofer</li>
  <li>Brendon Scheinman</li>
  <li>Ali Anwar</li>
  <li>Adrian Sinclair</li>
  <li>David Joseph</li>
  <li>Ryan Worl</li>
  <li>Tanner Schultz</li>
  <li>Don Poor</li>
  <li>Jimmy Zelinskie</li>
  <li>Thomas Ballinger</li>
  <li>David Hayden</li>
  <li>Audun Wilhelmsen</li>
  <li>Tyler Bender</li>
  <li>Matthew </li>
  <li>Mirek Rusin</li>
  <li>Peter Ronnquist</li>
  <li>Josh Gentry</li>
  <li>Trenton Cronholm</li>
  <li>Champ Yen</li>
  <li>Robert Paul Herman</li>
  <li>Caius </li>
  <li>Kelly Wilson</li>
  <li>Steve Perkins</li>
  <li>Clement Rey</li>
  <li>Eduard Nicodei</li>
  <li>Christopher A. Butler</li>
  <li>Colleen Silva-Hayden</li>
  <li>Wesley Kelley</li>
  <li>Jordan Torbiak</li>
  <li>Mitch Small</li>
  <li>Josh McDonald</li>
  <li>Jeff </li>
  <li>Paul Merrill</li>
  <li>Rudi Angela</li>
  <li>Justin B Alexander</li>
  <li>Ville Tuulos</li>
  <li>shen xizhi</li>
  <li>Ross Cousens</li>
  <li>Lorenz Vandevelde</li>
  <li>Ivan </li>
  <li>Jay Weisskopf</li>
  <li>William L Sommers</li>
  <li>Gerdus van Zyl</li>
  <li>Anthony J. Benik</li>
  <li>Brian Glusman</li>
  <li>Furkan Mustafa</li>
  <li>Le Bach</li>
  <li>Jordan Guggenheim</li>
  <li>Tyler Philbrick</li>
  <li>Marko Mikulicic</li>
  <li>Brian Lewis</li>
  <li>Matt Whiteside</li>
  <li>Elizabeth Ryan</li>
  <li>Thomas Lopatic</li>
  <li>Patricio Villalobos</li>
  <li>joe ardent</li>
  <li>John Goen</li>
  <li>Luis Alfonso Higuera Gamboa</li>
  <li>Jason Merrill</li>
  <li>Andriy Tyurnikov</li>
  <li>Sanghyeon Seo</li>
  <li>Neil Henning</li>
  <li>aaronstgeorge@gmail.com </li>
  <li>Raymond Imber</li>
  <li>Artyom Kazak</li>
  <li>Brian Orr</li>
  <li>Frans van den Heuvel</li>
  <li>Jantzen Owens</li>
  <li>David Bremner</li>
  <li>Veit Heller</li>
  <li>Benoit Jauvin-Girard</li>
  <li>Chris Rabuse</li>
  <li>Jeremy Larkin</li>
  <li>Rasmus Rønn Nielsen</li>
  <li>Aharon sharim</li>
  <li>Stephen Oates</li>
  <li>Quetzal Bradley</li>
  <li>Wink Saville</li>
  <li>S.D. </li>
  <li>George K</li>
  <li>Jonathan Raphaelson</li>
  <li>Chad Russell</li>
  <li>Alexandra Gillis</li>
  <li>Pradeep Gowda</li>
  <li>david karapetyan</li>
  <li>Lewis </li>
  <li>stdev </li>
  <li>Wojciech Miłkowski</li>
  <li>Jonathan Wright</li>
  <li>Ernst Rohlicek</li>
  <li>Alexander Ellis</li>
  <li>bb010g </li>
  <li>Pau Fernández</li>
  <li>Krishna Aradhi</li>
  <li>occivink </li>
  <li>Adrian Hatch</li>
  <li>Deniz Kusefoglu</li>
  <li>Dan Boykis</li>
  <li>Hans Wennborg</li>
  <li>Matus Hamorsky</li>
  <li>Ben Morris</li>
  <li>Tim Hutt</li>
  <li>Gudmund Vatn</li>
  <li>Tobias Haegermarck</li>
  <li>Martin Angers</li>
  <li>Christoph Müller</li>
  <li>Johann Muszynski</li>
  <li>Fabio Utzig</li>
  <li>Eigil Skjæveland</li>
  <li>Harry </li>
  <li>moomeme </li>
  <li>xash </li>
  <li>bowman han</li>
  <li>Romain Beaumont</li>
  <li>Nate Dobbins</li>
  <li>Paul Anderson</li>
  <li>Jon Renner</li>
  <li>Karl Syvert Løland</li>
  <li>Stanley Zheng</li>
  <li>myfreeweb </li>
  <li>Dennis Furey</li>
  <li>Dana Davis</li>
  <li>Ansis Malins</li>
  <li>Drew Carmichael</li>
  <li>Doug Thayer</li>
  <li>Henryk Gerlach</li>
  <li>Dylan La Com</li>
  <li>David Pippenger</li>
  <li>Matthew Steele</li>
  <li>tumdum </li>
  <li>Alex Alex</li>
  <li>Andrew London</li>
  <li>Jirka Grunt</li>
  <li>Dillon A</li>
  <li>Yannik </li>
  <li>VilliHaukka </li>
  <li>Chris Castle</li>
  <li>Antonio D'souza</li>
  <li>Silicon </li>
  <li>Damien Dubé</li>
  <li>Dbzruler72 </li>
  <li>McSpiros </li>
  <li>Francisco Vallarino</li>
  <li>Shawn Park</li>
  <li>Simon Kreienbaum</li>
  <li>Gregoire Picquot</li>
  <li>Silicas </li>
  <li>James Haggerty</li>
  <li>Falk Hüffner</li>
  <li>allan </li>
  <li>Ahmad Tolba</li>
  <li>jose maria gonzalez ondina</li>
  <li>Adrian Boyko</li>
  <li>Benedikt Mandelkow</li>
  <li>Will Cassella</li>
  <li>Michael Weber</li>
</ul>

   <h2 id="thanks-for-the-turkish-delight">Thank you Andrea Orru for sending me a giant box of Turkish Delight</h2>
   <img src="turkish-delight.jpg">
    </div>
  </body>
</html>
