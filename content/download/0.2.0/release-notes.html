<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>0.2.0 Release Notes &middot; The Zig Programming Language</title>
    <link rel="icon" href="/favicon.png">
    <link rel="icon" href="/favicon.svg">
    <style>
.hljs{display:block;overflow-x:auto;padding:0.5em;color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:bold}.hljs-number,.hljs-literal,.hljs-variable,.hljs-template-variable,.hljs-tag .hljs-attr{color:#008080}.hljs-string,.hljs-doctag{color:#d14}.hljs-title,.hljs-section,.hljs-selector-id{color:#900;font-weight:bold}.hljs-subst{font-weight:normal}.hljs-type,.hljs-class .hljs-title{color:#458;font-weight:bold}.hljs-tag,.hljs-name,.hljs-attribute{color:#000080;font-weight:normal}.hljs-regexp,.hljs-link{color:#009926}.hljs-symbol,.hljs-bullet{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:bold}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:bold}
    </style>
    <style type="text/css">
      #contents {
        max-width: 50em;
        margin: auto;
        font-size: 18px;
      }
      table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
      }
      th, td {
        padding: 0.1em;
      }
      pre, code {
        font-size: 18px;
      }
    </style>
  </head>
  <!--
___________________6666666___________________ 
____________66666__________66666_____________ 
_________6666___________________666__________ 
_______666__6____________________6_666_______ 
_____666_____66_______________666____66______ 
____66_______66666_________66666______666____ 
___66_________6___66_____66___66_______666___ 
__66__________66____6666_____66_________666__ 
_666___________66__666_66___66___________66__ 
_66____________6666_______6666___________666_ 
_66___________6666_________6666__________666_ 
_66________666_________________666_______666_ 
_66_____666______66_______66______666____666_ 
_666__666666666666666666666666666666666__66__ 
__66_______________6____66______________666__ 
___66______________66___66_____________666___ 
____66______________6__66_____________666____ 
_______666___________666___________666_______ 
_________6666_________6_________666__________ 
____________66666_____6____66666_____________ 
___________________6666666___________________

See https://github.com/zig-lang/zig/issues/666
  -->
  <body>
    <div id="contents">
    <a href="/"><img alt="zig" src="../../zig-logo.svg" style="width: 28em"></a>
    <h1>0.2.0 Release Notes</h1>
    <p>
    <a href="/download">Download &amp; Documentation</a>
    </p>
    <p>
    This is a <em>huge</em> release, containing several high-impact features such as unions, inferred error sets, and coroutines, and features changes from <strong>16 different contributors</strong>.
    </p>
    <p>
    Special thanks to my <a href="https://github.com/users/andrewrk/sponsorship">sponsors who provide financial support</a>. You're making Zig sustainable.
    </p>

    <h2 id="unions-enums">Unions &amp; Enums</h2>
    <p>
    Zig now supports unions. They come in a few flavors:
    </p>
    <ul>
      <li><code>union</code> - this one provides no guarantees about size, and in debug builds has a secret field to provide runtime safety if the wrong field is accessed.</li>
      <li><code>extern union</code> for when you need C ABI compatibility. No runtime safety.</li>
      <li><code>packed union</code> for when you need guaranteed size. No runtime safety.</li>
      <li><code>union(EnumType)</code> to use <code>EnumType</code> as the tag type of the union. This lets you <code>switch</code> on the union and access the tag value.</li>
      <li><code>union(enum)</code> to auto-generate the tag type.</li>
    </ul>
    <p>
    Enums are no longer tagged unions; they are simple enumerations. They also allow you to specify the integer tag type
    with <code>enum(IntType)</code>. And finally, enum fields can specify the integer tag value, so enums no longer have to
    start at <code>0</code> and count upwards. Enum types which have explicit integer tag types are allowed inside packed structs.
    </p>
    <p>
    C translation now understands C unions and translates them to <code>extern union</code>.
    It also understands the GNU extension to specify the integer tag type of enums and translates it accordingly.
    </p>

<pre><code class="zig">const TheTag = enum {A, B, C};
const TheUnion = union(TheTag) { A: i32, B: i32, C: i32 };
test "union field access gives the enum values" {
    assert(TheUnion.A == TheTag.A);
    assert(TheUnion.B == TheTag.B);
    assert(TheUnion.C == TheTag.C);
}</code></pre>

<p>
If you want to auto-create an enum for a union, you can use the <code>enum</code>
keyword like this:
</p>

<pre><code class="zig">const TheUnion2 = union(enum) {
    Item1,
    Item2: i32,
};</code></pre>

<p>
You can switch on a union-enum just like you could previously with an
enum:
</p>

<pre><code class="zig">const SwitchProngWithVarEnum = union(enum) {
    One: i32,
    Two: f32,
    Meh: void,
};
fn switchProngWithVarFn(a: &amp;const SwitchProngWithVarEnum) {
    switch(*a) {
        SwitchProngWithVarEnum.One =&gt; |x| {
            assert(x == 13);
        },
        SwitchProngWithVarEnum.Two =&gt; |x| {
            assert(x == 13.0);
        },
        SwitchProngWithVarEnum.Meh =&gt; |x| {
            const v: void = x;
        },
    }
}</code></pre>

<p>
However, if you do not give an enum to a union, the tag value is not
visible to the programmer:
</p>

<pre><code class="zig">const Payload = union {
    A: i32,
    B: f64,
    C: bool,
};
export fn entry() {
    const a = Payload { .A = 1234 };
    foo(a);
}
fn foo(a: &amp;const Payload) {
    switch (*a) {
        Payload.A =&gt; {},
        else =&gt; unreachable,
    }
}</code></pre>

<pre><code>test.zig:11:13: error: switch on union which has no attached enum
    switch (*a) {
            ^
test.zig:1:17: note: consider 'union(enum)' here
const Payload = union {
                ^
test.zig:12:16: error: container 'Payload' has no member called 'A'
        Payload.A =&gt; {},
               ^</code></pre>

<p>
There is still debug safety though!
</p>

<pre><code class="zig">const Foo = union {
    float: f32,
    int: u32,
};

pub fn main() -&gt; void {
    var f = Foo { .int = 42 };
    bar(&amp;f);
}

fn bar(f: &amp;Foo) {
    f.float = 12.34;
}
</code></pre>

<pre><code>access of inactive union field
lib/zig/std/special/panic.zig:12:35: 0x0000000000203674 in ??? (test)
        @import("std").debug.panic("{}", msg);
                                  ^
test.zig:12:6: 0x0000000000217bd7 in ??? (test)
    f.float = 12.34;
     ^
test.zig:8:8: 0x0000000000217b7c in ??? (test)
    bar(&amp;f);
       ^
Aborted</code></pre>

<p>
However, if you make an <code>extern union</code> to be compatible with C code,
there is no debug safety, just like a C union.
</p>

<p>
Other tidbits:
</p>

<ul>
  <li> <code>@enumTagName</code> is renamed to <a href="/documentation/0.2.0/#builtin-tagName">@tagName</a></li>
 <li> <code>@EnumTagType</code> is renamed to <a href="/documentation/0.2.0/#builtin-TagType">@TagType</a>, and it works on both enums and
   union-enums.</li>
 <li>There is no longer an <code>EnumTag</code> type</li>
 <li>It is now an error for enums and unions to have 0 fields. However
   you can still have a struct with 0 fields.</li>
 <li> union values can implicitly cast to enum values when the enum type is
   the tag type of the union and the union value tag is comptime known to
   have a void field type. likewise, enum values can implicitly cast to
   union values. See <a href="https://github.com/zig-lang/zig/issues/642">#642</a>.</li>
</ul>

<pre><code class="zig">test "cast tag type of union to union" {
    var x: Value2 = Letter2.B;
    assert(Letter2(x) == Letter2.B);
}
const Letter2 = enum { A, B, C };
const Value2 = union(Letter2) { A: i32, B, C, };

test "implicit cast union to its tag type" {
    var x: Value2 = Letter2.B;
    assert(x == Letter2.B);
    giveMeLetterB(x);
}
fn giveMeLetterB(x: Letter2) {
    assert(x == Value2.B);
}</code></pre>

<h2 id="rip-goto">Labeled loops, blocks, break, and continue, and R.I.P. goto</h2>

<p>
We used to have labels and goto like this:
</p>

<pre><code class="zig">export fn entry() {
    label:
    goto label;
}</code></pre>

<p>
Now this does not work, because goto is gone.
</p>

<pre><code>test.zig:2:10: error: expected token ';', found ':'
    label:
         ^</code></pre>

<p>
There are a few reasons to use goto, but all of the use cases are better served
with other zig control flow features:
</p>

<ul>
  <li>cleanup pattern. Use <code>defer</code> and <code>errdefer</code> instead.</li>
  <li>goto backward</li>
  <li>goto forward</li>
</ul>

<h3>goto backward</h3>

<pre><code class="zig">export fn entry() {
    start_over:

    while (some_condition) {
        // do something...
        goto start_over;
    }
}</code></pre>

<p>
Instead, use a loop!
</p>

<pre><code class="zig">export fn entry() {
    outer: while (true) {

        while (some_condition) {
            // do something...
            continue :outer;
        }

        break;
    }
}</code></pre>

<h3>goto forward</h3>

<pre><code class="zig">pub fn findSection(elf: &amp;Elf, name: []const u8) !?&amp;SectionHeader {
    var file_stream = io.FileInStream.init(elf.in_file);
    const in = &amp;file_stream.stream;

    section_loop: for (elf.section_headers) |*elf_section| {
        if (elf_section.sh_type == SHT_NULL) continue;

        const name_offset = elf.string_section.offset + elf_section.name;
        try elf.in_file.seekTo(name_offset);

        for (name) |expected_c| {
            const target_c = try in.readByte();
            if (target_c == 0 or expected_c != target_c) goto next_section;
        }

        {
            const null_byte = try in.readByte();
            if (null_byte == 0) return elf_section;
        }
next_section:
    }

    return null;
}</code></pre>

<p>
Looks like the use case is breaking out of an outer loop:
</p>

<pre><code class="zig">pub fn findSection(elf: &amp;Elf, name: []const u8) !?&amp;SectionHeader {
    var file_stream = io.FileInStream.init(elf.in_file);
    const in = &amp;file_stream.stream;

    section_loop: for (elf.section_headers) |*elf_section| {
        if (elf_section.sh_type == SHT_NULL) continue;

        const name_offset = elf.string_section.offset + elf_section.name;
        try elf.in_file.seekTo(name_offset);

        for (name) |expected_c| {
            const target_c = try in.readByte();
            if (target_c == 0 or expected_c != target_c) continue :section_loop;
        }

        {
            const null_byte = try in.readByte();
            if (null_byte == 0) return elf_section;
        }
    }

    return null;
}</code></pre>

<p>
You can also break out of arbitrary blocks:
</p>

<pre><code class="zig">export fn entry() {
    outer: {

        while (some_condition) {
            // do something...
            break :outer;
        }
    }
}</code></pre>

<p>
This can be used to return a value from a block in the same way you
can return a value from a function:
</p>

<pre><code class="zig">export fn entry() {
    const value = init: {
        for (slice) |item| {
            if (item &gt; 100)
                break :init item;
        }
        break :init 0;
    };
}</code></pre>

<p>
Omitting a semicolon no longer causes the value to be returned by the block.
Instead you must use explicit block labels to return a value from a block.
I'm considering a keyword such as <code>result</code> which defaults to the
current block.
</p>

<p>
See <a href="https://github.com/zig-lang/zig/issues/346">#346</a>, <a href="https://github.com/zig-lang-zig/issues/630">#630</a>, and <a href="https://github.com/zig-lang-zig/issues/629">#629</a>.
</p>

    <h2 id="error-syntax">Error Syntax Cleanup</h2>
<p>
One of the biggest complaints newcomers to Zig had was about its sigils regarding error handling.
Given this, I made an effort to choose friendlier syntax.
</p>
<ul>
  <li><code>%return</code> is replaced with <code>try</code></li>
  <li><code>%defer</code> is replaced with <code>errdefer</code></li>
  <li><code>a %% b</code> is replaced with <code>a catch b</code></li>
  <li><code>%%x</code> is removed entirely to discourage its use.
    You can get an equivalent effect with <code>x catch unreachable</code>,
    which has been updated to understand that it was attempting to unwrap an error union.
    See <a href="https://github.com/zig-lang/zig/issues/545">#545</a>  and <a href="https://github.com/zig-lang/zig/issues/510">#510</a></li>
</ul>
<p>
After these changes, there is a strong pattern that only keywords can modify control flow.
For example we have <code>and</code> and <code>or</code> instead of <code>&amp;&amp;</code> and <code>||</code>. There is one last exception, which is <code>a ?? b</code>. Maybe it's okay, since <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operator">C# set a precedent</a>.
</p>

<h2 id="errorreturntraces">Error Return Traces</h2>
<p>
I'm really excited about this one. I invented a new kind of debugging tool and integrated it into Debug and ReleaseSafe builds.
</p>
<p>
One of the concerns with removing the <code>%%</code> prefix operator was that it was
just so gosh darn convenient to get a stack trace right at the moment where you
asserted that a value did not have an error. I wanted to make it so that programmers
could use <code>try</code> everywhere and still get the debuggability benefit when
an error occurred.
</p>
<p>
Watch this:
</p>
<pre><code class="zig">const std = @import("std");

pub fn main() !void {
    const allocator = std.debug.global_allocator;

    const args = try std.os.argsAlloc(allocator);
    defer std.os.argsFree(allocator, args);

    const count = try parseFile(allocator, args[1]);

    if (count &lt; 10) return error.NotEnoughItems;
}

fn parseFile(allocator: &amp;std.mem.Allocator, file_path: []const u8) !usize {
    const contents = std.io.readFileAlloc(allocator, file_path) catch return error.UnableToReadFile;
    defer allocator.free(contents);

    return contents.len;
}</code></pre>
<p>
Here's a simple program with a bunch of different ways that errors could get returned
from <code>main</code>. In our test example, we're going to open a bogus file that
does not exist.
</p>
<pre><code class="zig">$ zig build-exe test2.zig
$ ./test2 bogus-does-not-exist.txt
error: UnableToReadFile
/home/andy/dev/zig/build/lib/zig/std/os/index.zig:301:33: 0x000000000021acd0 in ??? (test2)
                posix.ENOENT =&gt; return PosixOpenError.PathNotFound,
                                ^
/home/andy/dev/zig/build/lib/zig/std/os/file.zig:25:24: 0x00000000002096f6 in ??? (test2)
            const fd = try os.posixOpen(allocator, path, flags, 0);
                       ^
/home/andy/dev/zig/build/lib/zig/std/io.zig:267:16: 0x000000000021ebec in ??? (test2)
    var file = try File.openRead(allocator, path);
               ^
/home/andy/dev/zig/build/test2.zig:15:71: 0x000000000021ce72 in ??? (test2)
    const contents = std.io.readFileAlloc(allocator, file_path) catch return error.UnableToReadFile;
                                                                      ^
/home/andy/dev/zig/build/test2.zig:9:19: 0x000000000021c1f9 in ??? (test2)
    const count = try parseFile(allocator, args[1]);
                  ^</code></pre>
<p>
This is not a stack trace snapshot from when an error was "created". This is a <strong>return trace</strong> of all the points in the code where an error was returned from a function.
</p>
<p>
Note that, if it only told you the origin of the error that we ultimately received - <code>UnableToReadFile</code> - we would only see the bottom 2 items in the trace.
Not only do we have this information, we have all the information about the origin of
the error, right up to the fact that we received <code>ENOENT</code> from <code>open</code>.
</p>
<p>
With this in place, programmers can comfortably use <code>try</code> everywhere, safe
in the knowledge that it will be straightforward to troubleshoot the origin of any error
bubbling up through the system.
</p>
<p>
I hope you're skeptically wondering, OK, what's the tradeoff in terms of binary size, performance, and memory?
</p>
<p>
First of all, this feature is disabled in ReleaseFast mode. So the answer is,
literally no cost, in this case. But what about Debug and ReleaseSafe builds?
</p>
<p>
To analyze performance cost, there are two cases:
</p>
<ul>
  <li>when no errors are returned</li>
  <li>when returning errors</li>
</ul>
<p>
For the case when no errors are returned, the cost is a single memory write operation, only in the first non-failable function in the call graph that calls a failable function, i.e. when a function returning <code>void</code> calls a function returning <code>error</code>.
This is to initialize this struct in the stack memory:
</p>
<pre><code class="zig">pub const StackTrace = struct {
    index: usize,
    instruction_addresses: [N]usize,
};</code></pre>
<p>
Here, N is the maximum function call depth as determined by call graph analysis. Recursion is ignored and counts for 2.
</p>
<p>
A pointer to <code>StackTrace</code> is passed as a secret parameter to every function that can return an error, but it's always the first parameter, so it can likely sit in a register and stay there.
</p>
<p>
That's it for the path when no errors occur. It's practically free in terms of performance.
</p>
<p>
When generating the code for a function that returns an error, just before the <code>return</code> statement (only for the <code>return</code> statements that return errors), Zig generates a call to this function:
</p>
<pre><code class="zig">noinline fn __zig_return_error(stack_trace: &amp;StackTrace) void {
    stack_trace.instruction_addresses[stack_trace.index] = @returnAddress();
    stack_trace.index = (stack_trace.index + 1) % N;
}</code></pre>
<p>
The cost is 2 math operations plus some memory reads and writes. The memory accessed is constrained and should remain cached for the duration of the error return bubbling.
</p>
<p>
As for code size cost, 1 function call before a return statement is no big deal. Even so,
I have <a href="https://github.com/zig-lang/zig/issues/690">a plan</a> to make the call to
<code>__zig_return_error</code> a tail call, which brings the code size cost down to actually zero. What is a return statement in code without error return tracing can become a jump instruction in code with error return tracing.
</p>
<p>
There are a few ways to activate this error return tracing feature:
</p>
<ul>
  <li>Return an error from main</li>
  <li>An error makes its way to <code>catch unreachable</code> and you have not overridden the default panic handler</li>
  <li>Use <a href="/documentation/0.2.0/#errorReturnTrace">@errorReturnTrace</a> to access the current return trace. You can use <code>std.debug.dumpStackTrace</code> to print it. This function returns comptime-known <code>null</code> when building without error return tracing support.</li>
</ul>

<p>Related issues: <a href="https://github.com/zig-lang/zig/issues/651">#651</a>  <a href="https://github.com/zig-lang/zig/issues/684">#684</a>
</p>

    <h2 id="error-sets">Error Sets</h2>
    <p>Code that could be any error in the entire program can use <code>error!T</code> to get the previous behavior.
    But the new best practice is to use <strong>error sets</strong>.</p>
<pre><code class="zig">// error union looks like this
// this could be any error in the entire program
const x: error!i32 = 1234;

// declare an error set
const MyErrSet = error {OutOfMemory, FileNotFound};

// error union with an error set
const y: MyErrSet!i32 = 5678;
const z1: MyErrSet!i32 = MyErrSet.OutOfMemory;

// there is a shortcut for this:
const z2: MyErrSet!i32 = error{OutOfMemory}.OutOfMemory;
// this is the same as
const z2: MyErrSet!i32 = error.OutOFMemory;

// leave off the error set in a function return type to
// have it infer the error set
fn foo() !i32 {
    // this declares the ItFailed error
    return error{ItFailed};
}

// merge error sets
const ErrSetA = error{
    /// ErrSetA doc comment
    BadValue,
    Accident,
};
const ErrSetB = error{
    //// ErrSetB doc comment
    BadValue,
    Broken,
};
// doc comment of MergedErrSet.BadValue is "ErrSetA doc comment"
// MergedErrSet contains {BadValue, Accident, Broken}
const MergedErrSet = ErrSetA || ErrSetB;
</code></pre>
    <p>
    Most functions in zig can use error set inference:
    </p>
    <pre><code class="zig">fn foo(x: i32) !void {
    return std.math.add(x, 1);
}</code></pre>
    <p>Switching on the possible error from this function gives:</p>
    <pre><code class="zig">const std = @import("std");

test "inferred error set" {
    foo(1234) catch |e| switch (e) {

    };
}

fn foo(x: i32) !bool {
    const y = try std.math.add(i32, x, 1);
    return y == 10;
}</code></pre>
    <p>Compile errors:</p>
    <pre><code class="zig">test.zig:4:25: error: error.Overflow not handled in switch
    foo(1234) catch |e| switch (e) {
                        ^</code></pre>

    <h2 id="coroutines">Coroutines</h2>
    <p>In this release, Zig gains the keywords:</p>
    <ul>
      <li><code>async</code></li>
      <li><code>await</code></li>
      <li><code>suspend</code></li>
      <li><code>resume</code></li>
      <li><code>promise</code></li>
    </ul>
    <p>Zig now has support for coroutines. However, the feature is so brand-spanking new that there is not yet
    any documentation or non-trivial usage examples. I plan to make a blog post about this soon.</p>

    <h2 id="documentation">Documentation</h2>
    <p>
    All the outdated docs are fixed, and we have automatic
    <a href="https://github.com/zig-lang/zig/blob/46aa416c48c283849059292267ac25a6d0db76d6/doc/docgen.zig">docgen tool</a>
    which:
    </p>
    <ul>
      <li>Automatically generates the table of contents</li>
      <li>Validates all internal links</li>
      <li>Validates all code examples</li>
      <li>Turns terminal coloring of stack traces and compile errors into HTML</li>
    </ul>
    <p>The tool is, of course, written in Zig. <a href="https://github.com/zig-lang/zig/issues/465">#465</a></p>
    <p>In addition to the above, the following improvements were made to the documentation:</p>
    <ul>
      <li>Added documentation for <a href="/documentation/0.2.0/#noInlineCall">@noInlineCall</a></li>
      <li>Added documentation for <a href="/documentation/0.2.0/#extern-enum">extern enum</a></a>
      <li>Improved the documentation styling</li>
      <li>Made the documentation a single file that has no external dependencies</li>
      <li>Add the documentation to appveyor build artifacts as <code>langref.html</code>. In other words we ship with the docs now.</li>
      <li>improved styling for mobile devices<ul>
        <li> No overscrolling on small screens</li>
        <li> Font-size is reduced for more content per screen</li>
        <li> Tables + Code blocks scroll within a block to avoid page-widenening</li>
      </ul></li>
    </ul>
    <p>
    There is still much more to document, before we have achieved <a href="https://github.com/zig-lang/zig/issues/367">basic documentation for everything</a>.
    </p>

    <h2 id="translate-c">Translating C Code</h2>
    <p>
    <code>parse-c</code> has been renamed to <code>translate-c</code>.
    </p>
    <p>
    Performance is improved. Previously we did linear search to find existing global
    declarations; now we index using a hash map.
    </p>
    <p>
    Building <a href="https://github.com/andrewrk/tetris">tetris</a> went from taking 5.3 sec to 0.76 sec.
    </p>
    <p>
    In addition the following changes were made:
    </p>
    <ul>
      <li>Better output when <a href="/documentation/0.2.0/#cImport">@cImport</a> generates invalid Zig code</li>
      <li>Support C NULL to pointer implicit cast</li>
      <li>Support C comma operator</li>
      <li>Support bitshift operators</li>
      <li>Support compound assign operators</li>
      <li>Support pre/post increment/decrement</li>
      <li>Support do loop</li>
      <li>Support unary dereference operator</li>
      <li>Support address-of operator</li>
      <li>Support string literals</li>
      <li>Support returning void</li>
      <li>Support for loops, while loops, break, and continue</li>
      <li>Support switch statements</li>
      <li>Support pointer casting</li>
      <li>Support NOT operator</li>
      <li>Translate macros referencing field lookup as function calls which assert the fn pointer is non-null</li>
      <li>Support const ptr initializer</li>
      <li>Support static incomplete array inside function</li>
      <li>Macro translation can understand some kinds of pointer casting</li>
      <li>Support uninitialized variables</li>
      <li>Support if and while statements on integers and floats</li>
      <li>Support ignored return values</li>
    </ul>

    <h2 id="self-hosted-compiler">Self-Hosted Compiler Progress</h2>
    <p>
    The self-hosted compiler effort has begun.
    </p>
    <p>
    So far we have a tokenizer, and an incomplete parser and formatter.
    The code uses no recursion and therefore has compile-time
    known stack space usage. See <a href="https://github.com/zig-lang/zig/issues/157">#157</a>
    </p>

    <p>
    The self-hosted compiler works on every supported platform, is built using
    the zig build system, tested with <code>zig test</code>, links against LLVM,
    and can import <strong>100%</strong> of the LLVM symbols from the LLVM
    C-API .h files - <em>even the inline functions</em>.
    </p>

    <p>
    There is one C++ file in Zig which uses the more powerful LLVM C++ API
    (for example to create debug information) and exposes a C API. This file
    is now shared between the C++ self-hosted compiler and the self-hosted compiler.
    In stage1, we create a static library with this one file in it, and then use
    that library in both the C++ compiler and the self-hosted compiler.
    </p>

    <p>
    The self hosted tokenizer and parser have no external dependencies, and are therefore included
    as part of the standard library.
    </p>

    <h2 id="zig-build">Zig Build System</h2>
    <ul>
      <li>zig build prints failed commands</li>
      <li>zig build with no args no longer confusingly creates a build.zig file. Use <code>zig build --init</code> for that.</li>
    </ul>

    <p>Many improvements are planned but were not the focus of 0.2.0.</p>

    <h2 id="std-lib">Standard Library API Changes</h2>

    <ul>
      <li>Merge io.InStream and io.OutStream into io.File</li>
      <li>Introduce io.OutStream and io.InStream interfaces <ul>
          <li>io.File implements both of these</li>
        </ul>
      </li>
      <li>Move mem.IncrementingAllocator to heap.IncrementingAllocator</li>
      <li>Rename <code>std.ArrayList.resizeDown</code> to <code>std.ArrayList.shrink</code>.</li>
      <li>Introduce <code>std.debug.warn</code> and remove <code>std.io.stderr</code></li>
      <li>Introduce buffered I/O<ul>
          <li>Add <code>std.io.FileInStream</code></li>
          <li>Add <code>std.io.FileOutStream</code></li>
          <li>Add <code>std.io.BufferedOutStream</code></li>
          <li>Add <code>std.io.BufferedInStream</code></li>
          <li>Remove <code>std.io.File.in_stream</code></li>
          <li>Remove <code>std.io.File.out_stream</code></li>
        </ul></li>
        <li>Rework std.base64 API. <a href="https://github.com/zig-lang/zig/issues/611">#611</a><ul>
          <li>Rename <code>std.base64.decode</code> to <code>std.base64.decodeExactUnsafe</code></li>
          <li>Add <code>std.base64.decodeExact</code></li>
          <li>Add <code>std.base64.decodeWithIgnore</code></li>
        </ul></li>
      <li>Add <code>std.mem.readIntLE</code> and <code>std.mem.readIntBE</code>.</li>
      <li>Add <code>std.os.argsAlloc</code> and <code>std.os.argsFree</code></li>
      <li>Add <code>std.os.ChildProcess.exec</code></li>
      <li>Implemented <code>std.os.selfExePath</code> and <code>std.os.selfExeDirPath</code> for windows.</li>
      <li>std.io.OutStream and std.io.InStream take error set parameters</li>
      <li> move std.io.File to std.os.File</li>
      <li> add <code>zig fmt</code> to self hosted compiler</li>
      <li> introduce std.io.BufferedAtomicFile API</li>
      <li> introduce std.os.AtomicFile API</li>
      <li> add <code>std.os.default_file_mode</code></li>
      <li> change FileMode on posix from being a usize to a u32</li>
      <li> add std.os.File.mode to return mode of an open file</li>
      <li> std.os.copyFile copies the mode from the source file instead of
        using the default file mode for the dest file</li>
      <li> move <code>std.os.line_sep</code> to <code>std.cstr.line_sep</code></li>
      <li>Add utf8 string view API</li>
      <li><code>std.os.ChildProcess</code> no longer does any signal handling</li>
    </ul>

    <h3 id="arg-parsing">Higher level arg-parsing API</h3>

    <p>
    It's really a shame that Windows command line parsing requires you to
    allocate memory. This means that to have a cross-platform API for command
    line arguments, even though in POSIX it can never fail, we have to handle
    the possibility because of Windows. This lead to a command line args
    API like this:
    </p>

    <pre><code class="zig">pub fn main() -&gt; !void {
    var arg_it = os.args();
    // skip my own exe name
    _ = arg_it.skip();
    while (arg_it.next(allocator)) |err_or_arg| {
        const arg = try err_or_arg;
        defer allocator.free(arg);
        // use the arg...
    }
}</code></pre>

    <p>
    Yikes, a bit cumbersome. I added a higher level API. Now you can call
    <code>std.os.argsAlloc</code> and get a <code>error{OutOfMem}![]const []u8</code>, and you just have to call
    <code>std.os.argsFree</code> when you're done with it.
    </p>

    <pre><code class="zig">pub fn main() -&gt; !void {
        const allocator = std.heap.c_allocator;

        const args = try os.argsAlloc(allocator);
        defer os.argsFree(allocator, args);

        var arg_i: usize = 1;
        while (arg_i &lt; args.len) : (arg_i += 1) {
            const arg = args[arg_i];
            // do something with arg...
        }
    }</code></pre>

    <p>Better! Single point of failure.</p>

    <p>
    For now this uses the other API under the hood, but it could be
    reimplemented with the same API to do a single allocation.
    </p>

    <p>
    I added a new kind of test to make sure command line argument parsing works.
    </p>

<h3 id="std-sort">std.sort</h3>

<p>
<a href="https://github.com/Hejsil">Hejsil</a> <a href="https://github.com/zig-lang/zig/issues/657">pointed out</a>
that the quicksort implementation in the standard library failed a simple test case.
</p>

<p>
There was another problem with the implementation of sort in the standard library, 
which is that it used <code>O(n)</code> stack space via recursion. This is fundamentally
insecure, especially if you consider that the length of an array you might want to sort could be
user input. It prevents <a href="https://github.com/zig-lang/zig/issues/157">#157</a>
from working as well.
</p>

<p>
I had a look at
<a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms">Wikipedia's Comparison of Sorting Algorithms</a> and only 1 sorting algorithm checked all the boxes:
</p>

<ul>
  <li>Best case <code>O(n)</code> complexity (adaptive sort)</a>
  <li>Average case <code>O(n * log(n))</code> complexity</a>
  <li>Worst case <code>O(n * log(n))</code> complexity</a>
  <li><code>O(1)</code> memory</a>
  <li>Stable sort</a>
</ul>

<p>
And that algorithm is <a href="https://en.wikipedia.org/wiki/Block_sort">Block sort</a>.
</p>

<p>
I found a
<a href="https://github.com/BonzaiThePenguin/WikiSort/blob/master/WikiSort.c">high quality implementation of block sort in C</a>,
which is licensed under the public domain.
</p>

<p>
I ported the code from C to Zig, integrated it into the standard library, and it passed all tests first try. Amazing.
</p>

<p>
Surely, I thought, there must be some edge case. So I created a simple fuzz tester:
</p>

<pre><code class="zig">test "sort fuzz testing" {
    var rng = std.rand.Rand.init(0x12345678);
    const test_case_count = 10;
    var i: usize = 0;
    while (i &lt; test_case_count) : (i += 1) {
        try fuzzTest(&amp;rng);
    }
}

var fixed_buffer_mem: [100 * 1024]u8 = undefined;

fn fuzzTest(rng: &amp;std.rand.Rand) !void {
    const array_size = rng.range(usize, 0, 1000);
    var fixed_allocator = mem.FixedBufferAllocator.init(fixed_buffer_mem[0..]);
    var array = try fixed_allocator.allocator.alloc(IdAndValue, array_size);
    // populate with random data
    for (array) |*item, index| {
        item.id = index;
        item.value = rng.range(i32, 0, 100);
    }
    sort(IdAndValue, array, cmpByValue);

    var index: usize = 1;
    while (index &lt; array.len) : (index += 1) {
        if (array[index].value == array[index - 1].value) {
            assert(array[index].id &gt; array[index - 1].id);
        } else {
            assert(array[index].value &gt; array[index - 1].value);
        }
    }
}</code></pre>

<p>
This test passed as well. And so I think this problem is solved.
</p>

<h3 id="crypto">Crypto Additions</h3>
<h4>Integer Rotation Functions</h4>
<pre><code class="language-zig">/// Rotates right. Only unsigned values can be rotated.
/// Negative shift values results in shift modulo the bit count.
pub fn rotr(comptime T: type, x: T, r: var) -&gt; T {
test "math.rotr" {
    assert(rotr(u8, 0b00000001, usize(0))  == 0b00000001);
    assert(rotr(u8, 0b00000001, usize(9))  == 0b10000000);
    assert(rotr(u8, 0b00000001, usize(8))  == 0b00000001);
    assert(rotr(u8, 0b00000001, usize(4))  == 0b00010000);
    assert(rotr(u8, 0b00000001, isize(-1)) == 0b00000010);
}
/// Rotates left. Only unsigned values can be rotated.
/// Negative shift values results in shift modulo the bit count.
pub fn rotl(comptime T: type, x: T, r: var) -&gt; T {
test "math.rotl" {
    assert(rotl(u8, 0b00000001, usize(0))  == 0b00000001);
    assert(rotl(u8, 0b00000001, usize(9))  == 0b00000010);
    assert(rotl(u8, 0b00000001, usize(8))  == 0b00000001);
    assert(rotl(u8, 0b00000001, usize(4))  == 0b00010000);
    assert(rotl(u8, 0b00000001, isize(-1)) == 0b10000000);
}</code></pre>
<h4>MD5 and SHA1 Hash Functions</h4>
<p><a href="https://github.com/zig-lang/zig/pull/686">Marc writes</a>:</p>
<p>Some performance comparisons to C.</p>

<p>We take the fastest time measurement taken across multiple runs.</p>

<p>The block hashing functions use the same md5/sha1 methods.</p>

<pre><code>Cpu: Intel(R) Core(TM) i5-6500 CPU @ 3.20GHz
Gcc: 7.2.1 20171224
Clang: 5.0.1
Zig: 0.1.1.304f6f1d
</code></pre>

<p>See <a href="https://www.nayuki.io/page/fast-md5-hash-implementation-in-x86-assembly">https://www.nayuki.io/page/fast-md5-hash-implementation-in-x86-assembly</a>:</p>

<pre><code>gcc -O2
    661 Mb/s
clang -O2
    490 Mb/s
zig --release-fast and zig --release-safe
    570 Mb/s
zig
    50 Mb/s
</code></pre>

<p>See <a href="https://www.nayuki.io/page/fast-sha1-hash-implementation-in-x86-assembly">https://www.nayuki.io/page/fast-sha1-hash-implementation-in-x86-assembly</a>
:</p>

<pre><code>gcc -O2
    588 Mb/s
clang -O2
    563 Mb/s
zig --release-fast and zig --release-safe
    610 Mb/s
zig
    21 Mb/s
</code></pre>

<p>In short, zig provides pretty useful tools for writing this sort of
code. We are in the lead against clang (which uses the same LLVM
backend) with us being slower only against md5 with GCC.</p>

<h4>SHA-2 Functions</h4>
<p><a href="https://github.com/zig-lang/zig/pull/687">Marc writes</a>:</p>
<p>We take the fastest time measurement taken across multiple runs. Tested
across multiple compiler flags and the best chosen.</p>

<pre><code>Cpu: Intel(R) Core(TM) i5-6500 CPU @ 3.20GHz
Gcc: 7.2.1 20171224
Clang: 5.0.1
Zig: 0.1.1.304f6f1d
</code></pre>

<p>See <a href="https://www.nayuki.io/page/fast-sha2-hashes-in-x86-assembly">https://www.nayuki.io/page/fast-sha2-hashes-in-x86-assembly</a>.</p>

<pre><code>Gcc -O2
    219 Mb/s
Clang -O2
    213 Mb/s
Zig --release-fast
    284 Mb/s
Zig --release-safe
    211 Mb/s
Zig
    6 Mb/s
</code></pre>

<pre><code>Gcc -O2
    350 Mb/s
Clang -O2
    354 Mb/s
Zig --release-fast
    426 Mb/s
Zig --release-safe
    300 Mb/s
Zig
    11 Mb/s
</code></pre>

<h4>Blake2 Hash Functions</h4>
<p><a href="https://github.com/zig-lang/zig/pull/689">Marc writes</a>:</p>

<p>Blake performance numbers for reference:</p>

<pre><code>Cpu: Intel(R) Core(TM) i5-6500 CPU @ 3.20GHz
</code></pre>

<p>-- Blake2s</p>

<pre><code>Zig --release-fast
    485 Mb/s
Zig --release-safe
    377 Mb/s
Zig
    11 Mb/s
</code></pre>

<p>-- Blake2b</p>

<pre><code>Zig --release-fast
    616 Mb/s
Zig --release-safe
    573 Mb/s
Zig
    18 Mb/s
</code></pre>

<h4>Sha3 Hashing Functions</h4>
<p><a href="https://github.com/zig-lang/zig/pull/696">Marc writes:</a></p>

<p>Initially we had a comptime bug which did not allow us to unroll the inner Sha3
functions.
Once this was <a href="https://github.com/zig-lang/zig/commit/7a893691c0aedf4d7ae68a9eb06800e4094381cc">fixed</a>
we saw a large, near 3x speed boost.</p>

<pre><code>Cpu: Intel(R) Core(TM) i5-6500 CPU @ 3.20GHz
</code></pre>

<p>-- Sha3-256</p>

<pre><code>Zig --release-fast
    265 Mb/s
Zig --release-safe
    249 Mb/s
Zig
    10 Mb/s
</code></pre>

<p>-- Sha3-512</p>

<pre><code>Zig --release-fast
    144 Mb/s
Zig --release-safe
    143 Mb/s
Zig
    5 Mb/s
</code></pre>

<h3>introduce std.heap.ArenaAllocator and std.heap.DirectAllocator</h3>

<ul>
  <li> DirectAllocator does the underlying syscall for every allocation.</li>
  <li> ArenaAllocator takes another allocator as an argument and
       allocates bytes up front, falling back to DirectAllocator with
       increasingly large allocation sizes, to avoid calling it too often.
       Then the entire arena can be freed at once.</li>
</ul>
<p>
    The self hosted parser is updated to take advantage of ArenaAllocator
    for the AST that it returns. This significantly reduces the complexity
    of cleanup code.
</p>
<p>
    docgen and build runner are updated to use the combination of
    ArenaAllocator and DirectAllocator instead of IncrementingAllocator,
    which is now deprecated in favor of FixedBufferAllocator combined
    with DirectAllocator.
</p>
<p>
    Added asserts in Allocator to ensure that implementors of the
    interface return slices of the correct size.
</p>
<p>
    Fixed a bug in Allocator when you call realloc to grow the allocation.
</p>
<p>
Removed <code>std.heap.IncrementingAllocator</code>. 
Use <code>std.heap.FixedBufferAllocator</code> combined with
<code>std.heap.DirectAllocator</code> instead.
</p>

<h2 id="export">@export</h2>

<p>
There is now an <a href="/documentation/0.2.0/#export">@export</a> builtin function which can be used in a comptime block
to conditionally export a function:
</p>

<pre><code class="zig">const builtin = @import("builtin");

comptime {
    const strong_linkage = builtin.GlobalLinkage.Strong;
    if (builtin.link_libc) {
        @export("main", main, strong_linkage);
    } else if (builtin.os == builtin.Os.windows) {
        @export("WinMainCRTStartup", WinMainCRTStartup, strong_linkage);
    } else {
        @export("_start", _start, strong_linkage);
    }
}</code></pre>

<p>
It can also be used to create aliases:
</p>


<pre><code class="zig">const builtin = @import("builtin");
const is_test = builtin.is_test;

comptime {
    const linkage = if (is_test) builtin.GlobalLinkage.Internal else builtin.GlobalLinkage.Weak;
    const strong_linkage = if (is_test) builtin.GlobalLinkage.Internal else builtin.GlobalLinkage.Strong;

    @export("__letf2", @import("comparetf2.zig").__letf2, linkage);
    @export("__getf2", @import("comparetf2.zig").__getf2, linkage);

    if (!is_test) {
        // only create these aliases when not testing
        @export("__cmptf2", @import("comparetf2.zig").__letf2, linkage);
        @export("__eqtf2", @import("comparetf2.zig").__letf2, linkage);
        @export("__lttf2", @import("comparetf2.zig").__letf2, linkage);
        @export("__netf2", @import("comparetf2.zig").__letf2, linkage);
        @export("__gttf2", @import("comparetf2.zig").__getf2, linkage);
    }
}</code></pre>

<p>
Previous export syntax is still allowed. See <a href="https://github.com/zig-lang/zig/issues/462">#462</a> and <a href="https://github.com/zig-lang/zig/issues/420">#420 blaze it</a>.
</p>

<h2 id="atomicrmw">@atomicRmw</h2>
<p>The <a href="/documentation/0.2.0/#atomicRmw">@atomicRmw</a> function can be used to do an atomic read-modify-write.</p>

<h2 id="ir-pass">New IR pass iteration strategy</h2>

<p>
Before:
</p>

<ul>
  <li> IR basic blocks are in arbitrary order</li>
    <li> when doing an IR pass, when a block is encountered, code
    must look at all the instructions in the old basic block,
    determine what blocks are referenced, and queue up those
    old basic blocks first.
    </li>
    <li> This had a bug</li>
</ul>

<pre><code class="zig">while (cond) {
    if (false) { }
    break;
}</code></pre>

<p>
Pretty crazy right? Something as simple as this would crash the compiler.
</p>
<p>
Now:
</p>

<ul>
  <li> IR basic blocks are required to be in an order that guarantees
    they will be referenced by a branch, before any instructions
    within are referenced.
    ir pass1 is updated to meet this constraint.</li>
    <li>Then doing an IR pass, we iterate over old basic blocks
    in the order they appear. Blocks which have not been
    referenced are discarded.</li>
    <li>After the pass is complete, we must iterate again to look
    for old basic blocks which now point to incomplete new
    basic blocks, due to comptime code generation.</li>
    <li>This last part can probably be optimized - most of the time
      we don't need to iterate over the basic block again.</li>
</ul>

    <p>
This improvement deletes a lot of messy code:
    </p>

<pre> 5 files changed, 288 insertions(+), 1243 deletions(-) </pre>

<p>
And it also fixes comptime branches not being respected sometimes:
</p>

<pre><code class="zig">export fn entry() {
    while (false) {
        @compileError("bad");
    }
}</code></pre>

<p>Before, this would cause a compile error. Now the while loop respects the
implicit compile-time.
</p>

<p>
See <a href="https://github.com/zig-lang/zig/issues/667">#667</a>.
</p>

<h2 id="return-void">Syntax: Mandatory Function Return Type </h2>
<p><code>-&gt;</code> is removed, and all functions require an explicit return type.</p>
<p>The purpose of this is:</p>
<ul>
  <li> Only one way to do things</li>
  <li> Changing a function with void return type to return a possible
       error becomes a 1 character change, subtly encouraging
       people to use errors.</li>
</ul>
    <p>This has been a controversial change, and <a href="https://github.com/zig-lang/zig/issues/760">may be reverted</a>.</p>

<h2 id="gen-h">Generating .h Files</h2>
<ul>
  <li>Now Zig emits compile errors for non-extern, non-packed struct, enum, unions in <code>extern</code> fn signatures.</li>
  <li>Zig generates .h file content for <code>extern</code> struct, enum, unions</li>
  <li>.h file generation is now tested in the main test suite.</li>
</ul>
<p>Marc Tiehuis added array type handling:</p>
<pre><code class="language-zig">const Foo = extern struct {
    A: [2]i32,
    B: [4]&amp;u32,
};
export fn entry(foo: Foo, bar: [3]u8) void { }</code></pre>
<p>This generates:</p>
<pre><code class="language-c">struct Foo {
    int32_t A[2];
    uint32_t * B[4];
};

TEST_EXPORT void entry(struct Foo foo, uint8_t bar[]);</code></pre>


    <h2 id="misc">Miscellaneous Improvements</h2>
    <ul>
      <li>LLVM, Clang, and LLD dependencies are updated to 6.0.0. This fixes several issues - most notably,
        debug information on Windows.
      </li>
      <li>More reliable detection of the CRT on Windows. <a href="https://github.com/zig-lang/zig/issues/517">#517</a></li>
      <li>Added more compile-time type reflection, including function return type and parameter types. <a href="https://github.com/zig-lang/zig/issues/383">#383</a></li>
      <li>Added compile-time reflection for aggregate types:
        <a href="/documentation/0.2.0/#memberType">@memberType</a> and <a href="/documentation/0.2.0/#memberName">@memberName</a>
      </li>
  <li>Rename <code>builtin.is_big_endian</code> to <code>builtin.endian</code>. This is in preparation for
   having endianness be a pointer property, which is related to packed structs.
   See <a href="https://github.com/zig-lang/zig/issues/307">#307</a>.
  </li>
  <li>Tested Zig with LLVM debug mode and fixed some bugs that were causing LLVM
   assertions.
  </li>
  <li>Add
    <a href="/documentation/0.2.0/#builtin-noInlineCall">@noInlineCall</a>.
    See <a href="https://github.com/zig-lang/zig/issues/640">#640</a>.
    This fixes a crash in <code>--release-safe</code> and <code>--release-fast</code> modes
    where the optimizer inlines everything into <code>_start</code> and
   clobbers the command line argument data.
   If we were able to verify that the user's code never reads
   command line args, we could leave off this "no inline"
   attribute. This might call for a patch to LLVM. It seems like inlining
   into a naked function should correctly bump the stack pointer.
  </li>
  <li>add <code>i29</code> and <code>u29</code> primitive types. <code>u29</code> is the type of alignment,
   so it makes sense to be a primitive.
   probably in the future we'll make any <code>i</code> or <code>u</code> followed by
   digits into a primitive.
  </li>
  <li>add implicit cast from enum tag type of union to const ptr to the union. closes <a href="https://github.com/zig-lang/zig/issues/654">#654</a>
  </li>
  <li>ELF stack traces support <code>DW_AT_ranges</code>, so sometimes when you would see "???"
   you now get a useful stack trace instead.
   </li>
   <li>add <code>std.sort.min</code> and <code>std.sort.max</code> functions
 </li>
 <li><code>std.fmt.bufPrint</code> returns a possible <code>error.BufferTooSmall</code> instead of 
   asserting that the buffer is large enough.
   </li>
   <li>Remove unnecessary inline calls in <code>std.math</code>.
 </li>
 <li><code>zig build</code> now has a <code>--search-prefix</code> option. Any number of search prefixes can be
   specified.
   </li>
   <li>add some utf8 parsing utilities to the standard library.
 </li>

  <li>The return type of <code>main</code> can now be <code>void</code>, <code>noreturn</code>, <code>u8</code>, or an error union. <a href="https://github.com/zig-lang/zig/issues/535">#535</a></li>
  <li>Implemented bigint div and rem. <a href="https://github.com/zig-lang/zig/issues/405">#405</a></li>
  <li>Removed coldcc keyword and added <a href="/documentation/0.2.0/#setCold">@setCold</a>. <a href="https://github.com/zig-lang/zig/issues/661">#661</a></li>
  <li>Renamed "debug safety" to "runtime safety". <a href="https://github.com/zig-lang/zig/issues/437">#437</a></li>
  <li>Updated windows build to use llvm 5.0.1.
    <a href="http://lists.llvm.org/pipermail/llvm-dev/2018-January/120153.html">Reported usability issue regarding diaguids.lib to llvm-dev.</a></li>
  <li>Added more test coverage.</li>
  <li>
    The same string literal codegens to the same constant.
    This makes it so that you can send the same string literal
    as a comptime slice and get the same type.
  </li>
  <li>format struct pointers as "&lt;typename&gt;@&lt;address&gt;" <a href="https://github.com/zig-lang/zig/issues/752">#752</a></li>
  <li>implement <code>openSelfExe()</code> on Darwin</li>
  <li>ability to slice an undefined pointer at compile time if the len is 0.</li>
  <li>limited stack trace support on macos</li>
  <li>types inside functions are correctly named after variables instead of the function.</li>
  <li>Allow implicit cast from <code>S</code> to <code>?&amp;const S</code></li>
  <li>Allow implicit cast from <code>&amp;const</code> to <code>?&amp;const &amp;const</code></li>
  <li>@ptrCast gives a compile error when attempting to change const-ness.</li>
  <li>Assume soft floating point unless "hf" is in the target environ</li>
  <li>update to SoftFloat-3e</li>
  <li>prettier stack traces</li>
    </ul>

    <h2 id="bug-fixes">Bug Fixes</h2>
    <ul>
      <li>zig build: fix system libraries not respected for C artifacts <a href="https://github.com/zig-lang/zig/issues/550">#550</a></li>
      <li>std.fmt.format supports ints smaller than u8 <a href="https://github.com/zig-lang/zig/issues/546">#546</a></li>
      <li>fix compiler crash regarding the type name of undefined <a href="https://github.com/zig-lang/zig/issues/547">#547</a></li>
      <li>report compile error instead of crashing for void in var args <a href="https://github.com/zig-lang/zig/issues/557">#557</a></li>
      <li>add missing compile error for <a href="/documentation/0.2.0/#setAlignStack">@setAlignStack</a> alignment too big</li>
      <li>fix missing compiler_rt in release modes. <a href="https://github.com/zig-lang/zig/issues/563">#563</a></li>
      <li>fix crash on field access of opaque type</li>
      <li>add guard to c_headers for duplicate va_list on darwin</li>
      <li>fix generating invalid LLVM types for some mixtures of union and struct</li>
      <li>add missing target environment</li>
      <li>fix incorrect debug info for empty structs. <a href="https://github.com/zig-lang/zig/issues/579">#579</a></li>
      <li>fix enum sizes too large. <a href="https://github.com/zig-lang/zig/issues/598">#598</a></li>
      <li>fix parameter of extern var args not type checked. <a href="https://github.com/zig-lang/zig/issues/601">#601</a></li>
      <li>fix fstat darwin implementation. <a href="https://github.com/zig-lang/zig/issues/605">#605</a></li>
      <li>fix bug with multiple function definitions with the same name</li>
      <li>fix crash when constant inside comptime function has compile error. <a href="https://github.com/zig-lang/zig/issues/625">#625</a></li>
      <li>fix capturing value of switch with all unreachable prongs. <a href="https://github.com/zig-lang/zig/issues/635">#635</a></li>
  <li> fix const and volatile qualifiers being dropped sometimes.
   in the expression <code>&amp;const a.b</code>, the const (and/or volatile)
   qualifiers would be incorrectly dropped. See <a href="https://github.com/zig-lang/zig/issues/655">#655</a>.
  </li>
  <li> fix compiler crash in a nullable if after an if in a switch
 prong of a switch with 2 prongs in an else. See <a href="https://github.com/zig-lang/zig/issues/656">#656</a>.
  </li>
  <li>fix assert when wrapping zero bit type in nullable. See <a href="https://github.com/zig-lang/zig/issues/659">#659</a>.
  </li>
  <li>fix crash when implicitly casting array of len 0 to slice. See <a href="https://github.com/zig-lang/zig/issues/660">#660</a>.
  </li>
  <li>fix endianness of sub-byte integer fields in packed structs. In the future
 packed structs will require specifying endianness. See <a href="https://github.com/zig-lang/zig/issues/307">#307</a>.
  </li>
  <li>fix <code>std.os.path.resolve</code> when the drive is missing.
  </li>
  <li>fix automatically C-translated functions not having debug information.
  </li>
  <li>fix crash when passing union enum with sub-byte field to const slice parameter.
 See <a href="https://github.com/zig-lang/zig/issues/664">#664</a>.
 </li>

  <li>fix exp1m implementation by using <code>@setFloatMode</code> and using modular arithmetic</li>
  <li>fix compiler crash related to <code>@alignOf</code></li>
  <li>fix null debug info for 0-length array type. <a href="https://github.com/zig-lang/zig/issues/702">#702</a></li>
  <li>fix compiler not able to rename files into place on windows if the file already existed</li>
  <li>fix crash when switching on enum with 1 field and no switch prongs. <a href="https://github.com/zig-lang/zig/issues/712">#712</a></li>
  <li>fix crash on union-enums with only 1 field. <a href="https://github.com/zig-lang/zig/issues/713">#713</a></li>
  <li>fix crash when align 1 field before self referential align 8 field as slice return type. <a href="https://github.com/zig-lang/zig/issues/723">#723</a></li>
  <li>fix error message mentioning <code>unreachable</code> instead of <code>noreturn</code></li>
  <li>fix std.io.readFileAllocExtra incorrectly returning <code>error.EndOfStream</code></li>
  <li>workaround for microsoft releasing windows SDK with the wrong version</li>
  <li>Found a bug in NewGVN. Disabled it to match clang and filed an llvm bug.</li>
  <li>emit compile error for @panic called at compile time. <a href="https://github.com/zig-lang/zig/issues/706">#706</a></li>
  <li>emit compile error for shifting by negative comptime integer. <a href="https://github.com/zig-lang/zig/issues/698">#698</a></li>
  <li>emit compile error for calling naked function. @ptrCast a naked function first to call it.</li>
  <li>emit compile error for duplicate struct, enum, union fields. <a href="https://github.com/zig-lang/zig/issues/730">#730</a></li>

  <li>Add fallback to /dev/urandom on Linux for std.os.getRandBytes</li>
  <li>handle linux returning EINVAL for large writes. <a href="https://github.com/zig-lang/zig/issues/743">#743</a></li>
  <li>fix crash with error peer type resolution. <a href="https://github.com/zig-lang/zig/issues/765">#765</a></li>
  <li>fix exported variable not named in the object file. <a href="https://github.com/zig-lang/zig/issues/771">#771</a></li>
  <li>fix crash when doing comptime float rem comptime int. <a href="https://github.com/zig-lang/zig/issues/776">#776</a></li>
  <li>fix compiler crash when struct contains ptr to another struct wich contains original struct</li>
  <li>fix assert on self-referencing function ptr field. <a href="https://github.com/zig-lang/zig/issues/795">#795</a></li>
  <li>fix stack traces not working with DWARF 4</li>
  <li>fix assertion when taking slice of zero-length array. <a href="https://github.com/zig-lang/zig/issues/788">#788</a></li>
  <li>var is no longer a pseudo-type, it is syntax. <a href="https://github.com/zig-lang/zig/issues/779">#779</a></li>
  <li>turn assertion into compile error for using var as return type. <a href="https://github.com/zig-lang/zig/issues/758">#758</a></li>
  <li>add compile error for using @tagName on extern union</li>
  <li>enums with 1 field and explicit tag type still get the tag type. <a href="https://github.com/zig-lang/zig/issues/820">#820</a></li>
  <li>fix partial inlining of binary math operator using the old value. <a href="https://github.com/zig-lang/zig/issues/699">#699</a></li>
  <li>fix incorrect comptime memoization. <a href="https://github.com/zig-lang/zig/issues/639">#639</a> <a href="https://github.com/zig-lang/zig/issues/827">#827</a> <a href="https://github.com/zig-lang/zig/issues/828">#828</a></li>
  <li>AST Render no longer outputs erroneous semicolon</li>
  <li>fix incorrect @setEvalBranchQuota compile error. <a href="https://github.com/zig-lang/zig/issues/688">#688</a></li>
  <li>fix comptime slicing not preserving comptime mutability. <a href="https://github.com/zig-lang/zig/issues/826">#826</a></li>
  <li>fix casting a function to a pointer causing compiler crash. <a href="https://github.com/zig-lang/zig/issues/777">#777</a></li>
  <li>fix crash when taking @offsetOf a void struct member</li>

    </ul>

   <h2 id="there-are-bugs">This Release Contains Bugs</h2>
   <p>
   Zig has <a href="https://github.com/zig-lang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Abug">known bugs</a>.
   </p>
   <p>The first release that will ship with no known bugs will be 1.0.0.</p>

   <h2 id="roadmap">Roadmap</h2>
   <ul>
     <li>Proof-of-concept non-blocking TCP server using the new async/await feature with a kernel thread pool multiplexed onto coroutines. Blog post coming soon hopefully.</li>
     <li>Pointer Reform. <a href="https://github.com/zig-lang/zig/issues/770">#770</a></li>
     <li>Better argument-passing policy. <a href="https://github.com/zig-lang/zig/issues/733">#733</a></li>
     <li>Self-hosted compiler</li>
     <li>Get to 100% documentation coverage </li>
     <li>Automatic documentation generation</li>
     <li>Well-defined copy-eliding semantics. <a href="https://github.com/zig-lang/zig/issues/287">#287</a></li>
     <li>Get to all tests passing and 0 bugs, 0 TODO comments in self-hosted compiler.</li>
     <li>Compiler-as-a-server watching files for changes and performing incremental builds.</li>
   </ul>

   <h2 id="thanks-contributors">Thank you contributors!</h2>
   <ul>
<li>Andrea Orru</li>
<li>Andreas Haferburg</li>
<li>Ben Noordhuis</li>
<li>Brendon Scheinman</li>
<li>David McFarland</li>
<li>Jacob Dufault</li>
<li>Jeff Fowler</li>
<li>Jimmi Holst Christensen</li>
<li>Josh Wolfe</li>
<li>Joshua Olson</li>
<li>MIURA Masahiro</li>
<li>Marc Tiehuis</li>
<li>Mason Remaley</li>
<li>Peter Rönnquist</li>
<li>Ryan Saunderson</li>
<li>scurest</li>
   </ul>
   <h2 id="thanks-patreon">Thank you financial supporters!</h2>

<p>
Special thanks to those who <a href="https://github.com/users/andrewrk/sponsorship">donate monthly</a>. We're now at $224 of the $3,000 goal. You're making Zig sustainable.
</p>

<ul>
  <li>Lauren Chavis</li>
  <li>Andrea Orru</li>
  <li>Adrian Sinclair</li>
  <li>David Joseph</li>
  <li>jeff kelley</li>
  <li>Hasen Judy</li>
  <li>Brendon Scheinman</li>
  <li>Wesley Kelley</li>
  <li>Harry Eakins</li>
  <li>Richard Ohnemus</li>
  <li>Matthew </li>
  <li>Martin Schwaighofer</li>
  <li>Mirek Rusin</li>
  <li>Jordan Torbiak</li>
  <li>Pyry Kontio</li>
  <li>Thomas Ballinger</li>
  <li>Peter Ronnquist</li>
  <li>Luke McCarthy</li>
  <li>Robert Paul Herman</li>
  <li>Audun Wilhelmsen</li>
  <li>Marko Mikulicic</li>
  <li>Jimmi Holst Christensen</li>
  <li>Caius </li>
  <li>Don Poor</li>
  <li>Anthony J. Benik</li>
  <li>David Hayden</li>
  <li>Tyler Philbrick</li>
  <li>Tanner Schultz</li>
  <li>Eduard Nicodei</li>
  <li>Christopher A. Butler</li>
  <li>Colleen Silva-Hayden</li>
  <li>Jeremy Larkin</li>
  <li>Rasmus Rønn Nielsen</li>
  <li>Brian Lewis</li>
  <li>Tom Palmer</li>
  <li>Josh McDonald</li>
  <li>Chad Russell</li>
  <li>Alexandra Gillis</li>
  <li>david karapetyan</li>
  <li>Zi He Goh</li>
</ul>
    </div>
    <script>
/*! highlight.js v9.12.0 | BSD3 License | git.io/hljslicense */
!function(e){var n="object"==typeof window&&window||"object"==typeof self&&self;"undefined"!=typeof exports?e(exports):n&&(n.hljs=e({}),"function"==typeof define&&define.amd&&define([],function(){return n.hljs}))}(function(e){function n(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}function t(e){return e.nodeName.toLowerCase()}function r(e,n){var t=e&&e.exec(n);return t&&0===t.index}function a(e){return k.test(e)}function i(e){var n,t,r,i,o=e.className+" ";if(o+=e.parentNode?e.parentNode.className:"",t=B.exec(o))return w(t[1])?t[1]:"no-highlight";for(o=o.split(/\s+/),n=0,r=o.length;r>n;n++)if(i=o[n],a(i)||w(i))return i}function o(e){var n,t={},r=Array.prototype.slice.call(arguments,1);for(n in e)t[n]=e[n];return r.forEach(function(e){for(n in e)t[n]=e[n]}),t}function u(e){var n=[];return function r(e,a){for(var i=e.firstChild;i;i=i.nextSibling)3===i.nodeType?a+=i.nodeValue.length:1===i.nodeType&&(n.push({event:"start",offset:a,node:i}),a=r(i,a),t(i).match(/br|hr|img|input/)||n.push({event:"stop",offset:a,node:i}));return a}(e,0),n}function c(e,r,a){function i(){return e.length&&r.length?e[0].offset!==r[0].offset?e[0].offset<r[0].offset?e:r:"start"===r[0].event?e:r:e.length?e:r}function o(e){function r(e){return" "+e.nodeName+'="'+n(e.value).replace('"',"&quot;")+'"'}s+="<"+t(e)+E.map.call(e.attributes,r).join("")+">"}function u(e){s+="</"+t(e)+">"}function c(e){("start"===e.event?o:u)(e.node)}for(var l=0,s="",f=[];e.length||r.length;){var g=i();if(s+=n(a.substring(l,g[0].offset)),l=g[0].offset,g===e){f.reverse().forEach(u);do c(g.splice(0,1)[0]),g=i();while(g===e&&g.length&&g[0].offset===l);f.reverse().forEach(o)}else"start"===g[0].event?f.push(g[0].node):f.pop(),c(g.splice(0,1)[0])}return s+n(a.substr(l))}function l(e){return e.v&&!e.cached_variants&&(e.cached_variants=e.v.map(function(n){return o(e,{v:null},n)})),e.cached_variants||e.eW&&[o(e)]||[e]}function s(e){function n(e){return e&&e.source||e}function t(t,r){return new RegExp(n(t),"m"+(e.cI?"i":"")+(r?"g":""))}function r(a,i){if(!a.compiled){if(a.compiled=!0,a.k=a.k||a.bK,a.k){var o={},u=function(n,t){e.cI&&(t=t.toLowerCase()),t.split(" ").forEach(function(e){var t=e.split("|");o[t[0]]=[n,t[1]?Number(t[1]):1]})};"string"==typeof a.k?u("keyword",a.k):x(a.k).forEach(function(e){u(e,a.k[e])}),a.k=o}a.lR=t(a.l||/\w+/,!0),i&&(a.bK&&(a.b="\\b("+a.bK.split(" ").join("|")+")\\b"),a.b||(a.b=/\B|\b/),a.bR=t(a.b),a.e||a.eW||(a.e=/\B|\b/),a.e&&(a.eR=t(a.e)),a.tE=n(a.e)||"",a.eW&&i.tE&&(a.tE+=(a.e?"|":"")+i.tE)),a.i&&(a.iR=t(a.i)),null==a.r&&(a.r=1),a.c||(a.c=[]),a.c=Array.prototype.concat.apply([],a.c.map(function(e){return l("self"===e?a:e)})),a.c.forEach(function(e){r(e,a)}),a.starts&&r(a.starts,i);var c=a.c.map(function(e){return e.bK?"\\.?("+e.b+")\\.?":e.b}).concat([a.tE,a.i]).map(n).filter(Boolean);a.t=c.length?t(c.join("|"),!0):{exec:function(){return null}}}}r(e)}function f(e,t,a,i){function o(e,n){var t,a;for(t=0,a=n.c.length;a>t;t++)if(r(n.c[t].bR,e))return n.c[t]}function u(e,n){if(r(e.eR,n)){for(;e.endsParent&&e.parent;)e=e.parent;return e}return e.eW?u(e.parent,n):void 0}function c(e,n){return!a&&r(n.iR,e)}function l(e,n){var t=N.cI?n[0].toLowerCase():n[0];return e.k.hasOwnProperty(t)&&e.k[t]}function p(e,n,t,r){var a=r?"":I.classPrefix,i='<span class="'+a,o=t?"":C;return i+=e+'">',i+n+o}function h(){var e,t,r,a;if(!E.k)return n(k);for(a="",t=0,E.lR.lastIndex=0,r=E.lR.exec(k);r;)a+=n(k.substring(t,r.index)),e=l(E,r),e?(B+=e[1],a+=p(e[0],n(r[0]))):a+=n(r[0]),t=E.lR.lastIndex,r=E.lR.exec(k);return a+n(k.substr(t))}function d(){var e="string"==typeof E.sL;if(e&&!y[E.sL])return n(k);var t=e?f(E.sL,k,!0,x[E.sL]):g(k,E.sL.length?E.sL:void 0);return E.r>0&&(B+=t.r),e&&(x[E.sL]=t.top),p(t.language,t.value,!1,!0)}function b(){L+=null!=E.sL?d():h(),k=""}function v(e){L+=e.cN?p(e.cN,"",!0):"",E=Object.create(e,{parent:{value:E}})}function m(e,n){if(k+=e,null==n)return b(),0;var t=o(n,E);if(t)return t.skip?k+=n:(t.eB&&(k+=n),b(),t.rB||t.eB||(k=n)),v(t,n),t.rB?0:n.length;var r=u(E,n);if(r){var a=E;a.skip?k+=n:(a.rE||a.eE||(k+=n),b(),a.eE&&(k=n));do E.cN&&(L+=C),E.skip||(B+=E.r),E=E.parent;while(E!==r.parent);return r.starts&&v(r.starts,""),a.rE?0:n.length}if(c(n,E))throw new Error('Illegal lexeme "'+n+'" for mode "'+(E.cN||"<unnamed>")+'"');return k+=n,n.length||1}var N=w(e);if(!N)throw new Error('Unknown language: "'+e+'"');s(N);var R,E=i||N,x={},L="";for(R=E;R!==N;R=R.parent)R.cN&&(L=p(R.cN,"",!0)+L);var k="",B=0;try{for(var M,j,O=0;;){if(E.t.lastIndex=O,M=E.t.exec(t),!M)break;j=m(t.substring(O,M.index),M[0]),O=M.index+j}for(m(t.substr(O)),R=E;R.parent;R=R.parent)R.cN&&(L+=C);return{r:B,value:L,language:e,top:E}}catch(T){if(T.message&&-1!==T.message.indexOf("Illegal"))return{r:0,value:n(t)};throw T}}function g(e,t){t=t||I.languages||x(y);var r={r:0,value:n(e)},a=r;return t.filter(w).forEach(function(n){var t=f(n,e,!1);t.language=n,t.r>a.r&&(a=t),t.r>r.r&&(a=r,r=t)}),a.language&&(r.second_best=a),r}function p(e){return I.tabReplace||I.useBR?e.replace(M,function(e,n){return I.useBR&&"\n"===e?"<br>":I.tabReplace?n.replace(/\t/g,I.tabReplace):""}):e}function h(e,n,t){var r=n?L[n]:t,a=[e.trim()];return e.match(/\bhljs\b/)||a.push("hljs"),-1===e.indexOf(r)&&a.push(r),a.join(" ").trim()}function d(e){var n,t,r,o,l,s=i(e);a(s)||(I.useBR?(n=document.createElementNS("http://www.w3.org/1999/xhtml","div"),n.innerHTML=e.innerHTML.replace(/\n/g,"").replace(/<br[ \/]*>/g,"\n")):n=e,l=n.textContent,r=s?f(s,l,!0):g(l),t=u(n),t.length&&(o=document.createElementNS("http://www.w3.org/1999/xhtml","div"),o.innerHTML=r.value,r.value=c(t,u(o),l)),r.value=p(r.value),e.innerHTML=r.value,e.className=h(e.className,s,r.language),e.result={language:r.language,re:r.r},r.second_best&&(e.second_best={language:r.second_best.language,re:r.second_best.r}))}function b(e){I=o(I,e)}function v(){if(!v.called){v.called=!0;var e=document.querySelectorAll("pre code");E.forEach.call(e,d)}}function m(){addEventListener("DOMContentLoaded",v,!1),addEventListener("load",v,!1)}function N(n,t){var r=y[n]=t(e);r.aliases&&r.aliases.forEach(function(e){L[e]=n})}function R(){return x(y)}function w(e){return e=(e||"").toLowerCase(),y[e]||y[L[e]]}var E=[],x=Object.keys,y={},L={},k=/^(no-?highlight|plain|text)$/i,B=/\blang(?:uage)?-([\w-]+)\b/i,M=/((^(<[^>]+>|\t|)+|(?:\n)))/gm,C="</span>",I={classPrefix:"hljs-",tabReplace:null,useBR:!1,languages:void 0};return e.highlight=f,e.highlightAuto=g,e.fixMarkup=p,e.highlightBlock=d,e.configure=b,e.initHighlighting=v,e.initHighlightingOnLoad=m,e.registerLanguage=N,e.listLanguages=R,e.getLanguage=w,e.inherit=o,e.IR="[a-zA-Z]\\w*",e.UIR="[a-zA-Z_]\\w*",e.NR="\\b\\d+(\\.\\d+)?",e.CNR="(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",e.BNR="\\b(0b[01]+)",e.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",e.BE={b:"\\\\[\\s\\S]",r:0},e.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[e.BE]},e.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[e.BE]},e.PWM={b:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/},e.C=function(n,t,r){var a=e.inherit({cN:"comment",b:n,e:t,c:[]},r||{});return a.c.push(e.PWM),a.c.push({cN:"doctag",b:"(?:TODO|FIXME|NOTE|BUG|XXX):",r:0}),a},e.CLCM=e.C("//","$"),e.CBCM=e.C("/\\*","\\*/"),e.HCM=e.C("#","$"),e.NM={cN:"number",b:e.NR,r:0},e.CNM={cN:"number",b:e.CNR,r:0},e.BNM={cN:"number",b:e.BNR,r:0},e.CSSNM={cN:"number",b:e.NR+"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",r:0},e.RM={cN:"regexp",b:/\//,e:/\/[gimuy]*/,i:/\n/,c:[e.BE,{b:/\[/,e:/\]/,r:0,c:[e.BE]}]},e.TM={cN:"title",b:e.IR,r:0},e.UTM={cN:"title",b:e.UIR,r:0},e.METHOD_GUARD={b:"\\.\\s*"+e.UIR,r:0},e});hljs.registerLanguage("cpp",function(t){var e={cN:"keyword",b:"\\b[a-z\\d_]*_t\\b"},r={cN:"string",v:[{b:'(u8?|U)?L?"',e:'"',i:"\\n",c:[t.BE]},{b:'(u8?|U)?R"',e:'"',c:[t.BE]},{b:"'\\\\?.",e:"'",i:"."}]},s={cN:"number",v:[{b:"\\b(0b[01']+)"},{b:"(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)"},{b:"(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"}],r:0},i={cN:"meta",b:/#\s*[a-z]+\b/,e:/$/,k:{"meta-keyword":"if else elif endif define undef warning error line pragma ifdef ifndef include"},c:[{b:/\\\n/,r:0},t.inherit(r,{cN:"meta-string"}),{cN:"meta-string",b:/<[^\n>]*>/,e:/$/,i:"\\n"},t.CLCM,t.CBCM]},a=t.IR+"\\s*\\(",c={keyword:"int float while private char catch import module export virtual operator sizeof dynamic_cast|10 typedef const_cast|10 const for static_cast|10 union namespace unsigned long volatile static protected bool template mutable if public friend do goto auto void enum else break extern using asm case typeid short reinterpret_cast|10 default double register explicit signed typename try this switch continue inline delete alignof constexpr decltype noexcept static_assert thread_local restrict _Bool complex _Complex _Imaginary atomic_bool atomic_char atomic_schar atomic_uchar atomic_short atomic_ushort atomic_int atomic_uint atomic_long atomic_ulong atomic_llong atomic_ullong new throw return and or not",built_in:"std string cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap array shared_ptr abort abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr",literal:"true false nullptr NULL"},n=[e,t.CLCM,t.CBCM,s,r];return{aliases:["c","cc","h","c++","h++","hpp"],k:c,i:"</",c:n.concat([i,{b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:c,c:["self",e]},{b:t.IR+"::",k:c},{v:[{b:/=/,e:/;/},{b:/\(/,e:/\)/},{bK:"new throw return else",e:/;/}],k:c,c:n.concat([{b:/\(/,e:/\)/,k:c,c:n.concat(["self"]),r:0}]),r:0},{cN:"function",b:"("+t.IR+"[\\*&\\s]+)+"+a,rB:!0,e:/[{;=]/,eE:!0,k:c,i:/[^\w\s\*&]/,c:[{b:a,rB:!0,c:[t.TM],r:0},{cN:"params",b:/\(/,e:/\)/,k:c,r:0,c:[t.CLCM,t.CBCM,r,s,e]},t.CLCM,t.CBCM,i]},{cN:"class",bK:"class struct",e:/[{;:]/,c:[{b:/</,e:/>/,c:["self"]},t.TM]}]),exports:{preprocessor:i,strings:r,k:c}}});hljs.registerLanguage("llvm",function(e){var n="([-a-zA-Z$._][\\w\\-$.]*)";return{k:"begin end true false declare define global constant private linker_private internal available_externally linkonce linkonce_odr weak weak_odr appending dllimport dllexport common default hidden protected extern_weak external thread_local zeroinitializer undef null to tail target triple datalayout volatile nuw nsw nnan ninf nsz arcp fast exact inbounds align addrspace section alias module asm sideeffect gc dbg linker_private_weak attributes blockaddress initialexec localdynamic localexec prefix unnamed_addr ccc fastcc coldcc x86_stdcallcc x86_fastcallcc arm_apcscc arm_aapcscc arm_aapcs_vfpcc ptx_device ptx_kernel intel_ocl_bicc msp430_intrcc spir_func spir_kernel x86_64_sysvcc x86_64_win64cc x86_thiscallcc cc c signext zeroext inreg sret nounwind noreturn noalias nocapture byval nest readnone readonly inlinehint noinline alwaysinline optsize ssp sspreq noredzone noimplicitfloat naked builtin cold nobuiltin noduplicate nonlazybind optnone returns_twice sanitize_address sanitize_memory sanitize_thread sspstrong uwtable returned type opaque eq ne slt sgt sle sge ult ugt ule uge oeq one olt ogt ole oge ord uno ueq une x acq_rel acquire alignstack atomic catch cleanup filter inteldialect max min monotonic nand personality release seq_cst singlethread umax umin unordered xchg add fadd sub fsub mul fmul udiv sdiv fdiv urem srem frem shl lshr ashr and or xor icmp fcmp phi call trunc zext sext fptrunc fpext uitofp sitofp fptoui fptosi inttoptr ptrtoint bitcast addrspacecast select va_arg ret br switch invoke unwind unreachable indirectbr landingpad resume malloc alloca free load store getelementptr extractelement insertelement shufflevector getresult extractvalue insertvalue atomicrmw cmpxchg fence argmemonly double",c:[{cN:"keyword",b:"i\\d+"},e.C(";","\\n",{r:0}),e.QSM,{cN:"string",v:[{b:'"',e:'[^\\\\]"'}],r:0},{cN:"title",v:[{b:"@"+n},{b:"@\\d+"},{b:"!"+n},{b:"!\\d+"+n}]},{cN:"symbol",v:[{b:"%"+n},{b:"%\\d+"},{b:"#\\d+"}]},{cN:"number",v:[{b:"0[xX][a-fA-F0-9]+"},{b:"-?\\d+(?:[.]\\d+)?(?:[eE][-+]?\\d+(?:[.]\\d+)?)?"}],r:0}]}});hljs.registerLanguage("bash",function(e){var t={cN:"variable",v:[{b:/\$[\w\d#@][\w\d_]*/},{b:/\$\{(.*?)}/}]},s={cN:"string",b:/"/,e:/"/,c:[e.BE,t,{cN:"variable",b:/\$\(/,e:/\)/,c:[e.BE]}]},a={cN:"string",b:/'/,e:/'/};return{aliases:["sh","zsh"],l:/\b-?[a-z\._]+\b/,k:{keyword:"if then else elif fi for while in do done case esac function",literal:"true false",built_in:"break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp",_:"-ne -eq -lt -gt -f -d -e -s -l -a"},c:[{cN:"meta",b:/^#![^\n]+sh\s*$/,r:10},{cN:"function",b:/\w[\w\d_]*\s*\(\s*\)\s*\{/,rB:!0,c:[e.inherit(e.TM,{b:/\w[\w\d_]*/})],r:0},e.HCM,s,a,t]}});hljs.registerLanguage("shell",function(s){return{aliases:["console"],c:[{cN:"meta",b:"^\\s{0,3}[\\w\\d\\[\\]()@-]*[>%$#]",starts:{e:"$",sL:"bash"}}]}});
    </script>
    <script>
hljs.registerLanguage("zig", function(t) {
    var e = {
            cN: "keyword",
            b: "\\b[a-z\\d_]*_t\\b"
        },
        r = {
            cN: "string",
            v: [{
                b: '(u8?|U)?L?"',
                e: '"',
                i: "\\n",
                c: [t.BE]
            }, {
                b: '(u8?|U)?R"',
                e: '"',
                c: [t.BE]
            }, {
                b: "'\\\\?.",
                e: "'",
                i: "."
            }]
        },
        s = {
            cN: "number",
            v: [{
                b: "\\b(0b[01']+)"
            }, {
                b: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)"
            }, {
                b: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
            }],
            r: 0
        },
        i = {
            cN: "meta",
            b: /#\s*[a-z]+\b/,
            e: /$/,
            k: {
                "meta-keyword": "zzzzzzdisable"
            },
            c: [{
                b: /\\\n/,
                r: 0
            }, t.inherit(r, {
                cN: "meta-string"
            }), {
                cN: "meta-string",
                b: /<[^\n>]*>/,
                e: /$/,
                i: "\\n"
            }, t.CLCM, t.CBCM]
        },
        a = t.IR + "\\s*\\(",
        c = {
            keyword: "const align var extern stdcallcc nakedcc volatile export pub noalias inline struct packed enum union break return try catch test continue unreachable comptime and or asm defer errdefer if else switch while for fn use bool f32 f64 void type noreturn error i8 u8 i16 u16 i32 u32 i64 u64 isize usize i8w u8w i16w i32w u32w i64w u64w isizew usizew c_short c_ushort c_int c_uint c_long c_ulong c_longlong c_ulonglong",
            built_in: "breakpoint returnAddress frameAddress fieldParentPtr setFloatMode IntType OpaqueType compileError compileLog setCold setRuntimeSafety setEvalBranchQuota offsetOf memcpy inlineCall setGlobalLinkage setGlobalSection divTrunc divFloor enumTagName intToPtr ptrToInt panic canImplicitCast ptrCast bitCast rem mod memset sizeOf alignOf alignCast maxValue minValue memberCount memberName memberType typeOf addWithOverflow subWithOverflow mulWithOverflow shlWithOverflow shlExact shrExact cInclude cDefine cUndef ctz clz import cImport errorName embedFile cmpxchg fence divExact truncate atomicRmw",
            literal: "true false null undefined"
        },
        n = [e, t.CLCM, t.CBCM, s, r];
    return {
        aliases: ["c", "cc", "h", "c++", "h++", "hpp"],
        k: c,
        i: "</",
        c: n.concat([i, {
            b: "\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",
            e: ">",
            k: c,
            c: ["self", e]
        }, {
            b: t.IR + "::",
            k: c
        }, {
            v: [{
                b: /=/,
                e: /;/
            }, {
                b: /\(/,
                e: /\)/
            }, {
                bK: "new throw return else",
                e: /;/
            }],
            k: c,
            c: n.concat([{
                b: /\(/,
                e: /\)/,
                k: c,
                c: n.concat(["self"]),
                r: 0
            }]),
            r: 0
        }, {
            cN: "function",
            b: "(" + t.IR + "[\\*&\\s]+)+" + a,
            rB: !0,
            e: /[{;=]/,
            eE: !0,
            k: c,
            i: /[^\w\s\*&]/,
            c: [{
                b: a,
                rB: !0,
                c: [t.TM],
                r: 0
            }, {
                cN: "params",
                b: /\(/,
                e: /\)/,
                k: c,
                r: 0,
                c: [t.CLCM, t.CBCM, r, s, e]
            }, t.CLCM, t.CBCM, i]
        }, {
            cN: "class",
            bK: "class struct",
            e: /[{;:]/,
            c: [{
                b: /</,
                e: />/,
                c: ["self"]
            }, t.TM]
        }]),
        exports: {
            preprocessor: i,
            strings: r,
            k: c
        }
    }
});
    hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
