---
.title = "Zig Build System",
.author = "",
.date = @date("2024-08-07:00:00:00"),
.layout = "page.shtml",
.custom = {
	"mobile_menu_title": "Zig Build System",
	"toc": true,
},
---
# [Quando introdurre il Zig Build System?]($heading.id('build-system'))

In molti casi sono sufficienti i comandi base `zig build-exe`, `zig build-lib`, `zig build-obj` e
`zig test`. A volte però un progetto necessita di un ulteriore livello di astrazione
per gestire la complessità del compilare da sorgente.

Per esempio, potrebbe verificarsi una di queste situazioni:

- La riga di comando diventa troppo lunga e complessa, e vuoi trascriverla altrove.
- Vuoi compilare molte cose, o il processo di compilazione ha molti passaggi.
- Vuoi sfruttare processi paralleli e caching per ridurre il tempo di compilazione.
- Vuoi esporre delle opzioni di configurazione per il progetto.
- Il processo di compilazione è differente a seconda del sistema di destinazione e altre opzioni.
- Il tuo progetto ha dipendenze da altri progetti.
- Vuoi evitare dipendenze superflue da cmake, make, shell, msvc,
  python e altro, rendendo il progetto accessibile a più contributori.
- Vuoi fornire un pacchetto usufruibile da terzi.
- Vuoi mettere a disposizione a strumenti come gli IDE un modo standardizzato
  per comprendere semanticamente come compilare il progetto.

Se qualunque di queste è applicabile, il progetto trarrà benificio dal Zig Build System.

# [Per iniziare]($heading.id('getting-started'))
## [Eseguibile semplice]($heading.id('simple'))
Questo build script crea un eseguibile a partire da un file Zig contenente una funzione `main` pubblica.

[]($code.language('=html').buildAsset("build-system/1-simple-executable/hello.zig"))
[]($code.language('=html').buildAsset("build-system/1-simple-executable/build.zig"))

## [Installare artefatti di build]($heading.id('installing-artifacts'))

Il build system di Zig, come la maggior parte dei build system, è basato sul modellare il progetto come un grafo aciclico diretto (DAG) di "step", che vengono eseguiti in parallelo.

Di default, lo step principale nel grafo è lo step di **installazione**, il cui scopo
è copiare gli artefatti di build nella loro destinazione finale.
Lo step di installazione parte senza dipendenze, quindi eseguendo `zig build` non accade nulla.
Il build script di un progetto deve aggiungere elementi all'insieme delle cose da installare,
ed è ciò che fa la chiamata alla funzione `installArtifact` qui sopra.

**Output**
```
├── build.zig
├── hello.zig
├── .zig-cache
└── zig-out
    └── bin
        └── hello
```

In questo output sono presenti due cartelle generate: `.zig-cache` and `zig-out`. La prima contiene file che renderanno le compilazioni successive più rapide, ma questi file non sono pensati per essere tracciati in un sistema di controllo versione; questa cartella può essere completamente eliminata in qualunque momento senza conseguenze.

La seconda cartella generata, `zig-out`, è un "prefisso di installazione". Questo è correlato al concetto standard di gerarchia del file system. Questa cartella non è scelta dal progetto, ma dall'utente del comando `zig build` con la flag `--prefix` (`-p` per abbreviare).

Tu, come responsabile del progetto, scegli cosa conterrà questa cartella, ma l'utente sceglie dove installarla nel proprio sistema. Il build script non può definire percorsi di output assoluti perchè questo ostacolerebbe il caching, concorrenza e composibilità, oltre a infastidire l'utente finale.

## [Aggiungere uno step per eseguire l'applicazione]($heading.id('run-step'))

È pratica comune aggiungere uno step `Run`, per permettere di eseguire l'applicazione principale direttamente dalla riga di comando.

[]($code.language('=html').buildAsset("build-system/convenience-run-step/hello.zig"))
[]($code.language('=html').buildAsset("build-system/convenience-run-step/build.zig"))

# [Le basi]($heading.id('basics'))

## [Opzioni fornite dall'utente]($heading.id('user-options'))

Usa `b.option` per rendere il build script configurabile dagli utenti finali e anche
da altri progetti che dipendono dal tuo progetto come pacchetto.

[]($code.language('=html').buildAsset("build-system/2-user-provided-options/build.zig"))
[]($code.language('=html').buildAsset("build-system/2-user-provided-options/example.zig"))

Nota la presenza di queste righe:

```
Project-Specific Options:
  -Dwindows=[bool]             Target Microsoft Windows
```

Questa parte del menù di aiuto è generata automaticamente in base alla logica in `build.zig`.
Gli utenti possono scoprire le opzioni di configurazione del build script in questo modo.

## [Opzioni di configurazione standard]($heading.id('standard-options'))

Nella sezione precedente abbiamo usato una flag booleana per indicare una compilazione per Windows.
Possiamo fare ancora di meglio.

La maggior parte dei progetti vuole rendere possibile modificare la piattaforma di destinazione e le opzioni di ottimizzazione.
Per incoraggiare una convenzione standard nella nomenclatura di queste opzioni,
Zig fornisce le funzioni `standardTargetOptions` e `standardOptimizeOption`.

Le opzioni di destinazione standard permettono a chi esegue `zig build` di scegliere la piattaforma
per cui compilare. Di default è permessa qualunque piattaforma, escluderle tutte significa
compilare per il sistema host (quello usato per la compilazione).
Sono disponibili ulteriori opzioni per restringere l'insieme di piattaforme supportate.

Le opzioni di ottimizzazione standard permettono a chi esegue `zig build` di scegliere
tra `Debug`, `ReleaseSafe`, `ReleaseFast` e `ReleaseSmall`. Di default
il build script non considera nessuna delle opzioni di rilascio come preferibile,
quindi l'utente deve prendere una decisione per poter creare una build di rilascio.

[]($code.language('=html').buildAsset("build-system/3-standard-config-options/hello.zig"))
[]($code.language('=html').buildAsset("build-system/3-standard-config-options/build.zig"))

Ora il nostro menù `--help` contiene più elementi:

```
Project-Specific Options:
  -Dtarget=[string]            The CPU architecture, OS, and ABI to build for
  -Dcpu=[string]               Target CPU features to add or subtract
  -Doptimize=[enum]            Prioritize performance, safety, or binary size (-O flag)
                                 Supported Values:
                                   Debug
                                   ReleaseSafe
                                   ReleaseFast
                                   ReleaseSmall
```

È del tutto possibile creare queste opzioni usando direttamente `b.option`, ma questa API
fornisce una convenzione comune per i nomi di queste opzioni, che sono utilizzate di frequente.

Nell'output del nostro terminale, osserva che abbiamo passato `-Dtarget=x86_64-windows -Doptimize=ReleaseSmall`.
In confronto al primo esempio, ora vediamo file diversi nel prefisso di installazione:

```
zig-out/
└── bin
    └── hello.exe
```

## [Opzioni per la compilazione condizionale]($heading.id('conditional-compilation'))

Per passare delle opzioni dal build script al codice Zig del progetto, usa lo step `Options`.

[]($code.language('=html').buildAsset("build-system/conditional-compilation/app.zig"))
[]($code.language('=html').buildAsset("build-system/conditional-compilation/build.zig"))

In questo esempio, i dati forniti da `@import("config")` sono noti in fase di compilazione,
impedendo l'innesco di `@compileError`. Se avessimo passato `-Dversion=0.2.3`
oppure omesso l'opzione, avremmo visto la compilazione di `app.zig` fallire con l'errore "too old".

## [Libreria statica]($heading.id('static-library'))

Questo build script crea una libreria statica di codice Zig, e inoltre crea
un eseguibile di altro codice Zig che usa la libreria..

[]($code.language('=html').buildAsset("build-system/simple-static-library/fizzbuzz.zig"))
[]($code.language('=html').buildAsset("build-system/simple-static-library/demo.zig"))
[]($code.language('=html').buildAsset("build-system/simple-static-library/build.zig"))

In questo caso, viene installata solo la libreria statica:

```
zig-out/
└── lib
    └── libfizzbuzz.a
```

Però, se guardi attentamente, il build script contiene un'opzione per installare anche la demo.
Se passiamo anche l'opzione `-Denable-demo`, allora dovremmo vedere questo nel prefisso di installazione:

```
zig-out/
├── bin
│   └── demo
└── lib
    └── libfizzbuzz.a
```

Nota che nonostante la chiamata non condizionale a `addExecutable`, il build system
non perde tempo compilando l'eseguibile `demo` a meno che sia richiesto
con `-Denable-demo`, perchè il build system è basato su un grafo aciclico diretto (DAG)
in cui gli archi rappresentano dipendenze.

## [Libreria dinamica]($heading.id('dynamic-library'))

Qui usiamo gli stessi file dell'esempio sulla [libreria statica](#static-library),
eccetto il file `build.zig` che ha delle modifiche.

[]($code.language('=html').buildAsset("build-system/dynamic-library/build.zig"))

**Output**
```
zig-out
└── lib
    ├── libfizzbuzz.so -> libfizzbuzz.so.1
    ├── libfizzbuzz.so.1 -> libfizzbuzz.so.1.2.3
    └── libfizzbuzz.so.1.2.3
```

Come nell'esempio della libreria statica, per ottenere un link dell'eseguibile alla libreria, usa codice come questo:

```zig
exe.linkLibrary(libfizzbuzz);
```

## [Testing]($heading.id('testing'))

Individual files can be tested directly with `zig test foo.zig`, however, more
complex use cases can be solved by orchestrating testing via the build script.

When using the build script, unit tests are broken into two different steps in
the build graph, the **Compile** step and the **Run** step. Without a call to
`addRunArtifact`, which establishes a dependency edge between these two steps,
the unit tests will not be executed.

The Compile step can be configured the same as any executable, library, or
object file, for example by [linking against system libraries](#linking-to-system-libraries),
setting target options, or adding additional compilation units.

The Run step can be configured the same as any Run step, for example by
skipping execution when the host is not capable of executing the binary.

When using the build system to run unit tests, the build runner and the test
runner communicate via stdin and stdout in order to run multiple unit test
suites concurrently, and report test failures in a meaningful way without
having their output jumbled together. This is one reason why
[writing to standard out in unit tests is problematic](https://github.com/ziglang/zig/issues/15091) -
it will interfere with this communication channel. On the flip side, this
mechanism will enable an upcoming feature, which is is the
[ability for a unit test to expect a panic](https://github.com/ziglang/zig/issues/1356).

[]($code.language('=html').buildAsset("build-system/unit-testing/main.zig"))
[]($code.language('=html').buildAsset("build-system/unit-testing/build.zig"))

In this case it might be a nice adjustment to enable `skip_foreign_checks` for
the unit tests:

```diff
@@ -23,6 +23,7 @@
         });
 
         const run_unit_tests = b.addRunArtifact(unit_tests);
+        run_unit_tests.skip_foreign_checks = true;
         test_step.dependOn(&run_unit_tests.step);
     }
 }
```

[]($code.language('=html').buildAsset("build-system/unit-testing-skip-foreign/build.zig"))

## [Linking to System Libraries]($heading.id('linking-system-libraries'))

For satisfying library dependencies, there are two choices:

1. Provide these libraries via the Zig Build System
   (see [Package Management](#package-management) and [Static Library](#static-library)).
2. Use the files provided by the host system.

For the use case of upstream project maintainers, obtaining these libraries via
the Zig Build System provides the least friction and puts the configuration
power in the hands of those maintainers. Everyone who builds this way will have
reproducible, consistent results as each other, and it will work on every
operating system and even support cross-compilation. Furthermore, it allows the
project to decide with perfect precision the exact versions of its entire
dependency tree it wishes to build against. This is expected to be the
generally preferred way to depend on external libraries.

However, for the use case of packaging software into repositories such as
Debian, Homebrew, or Nix, it is mandatory to link against system libraries. So,
build scripts must
[detect the mode](https://github.com/ziglang/zig/issues/14281) and configure accordingly.

[]($code.language('=html').buildAsset("build-system/system-libraries/build.zig"))

Users of `zig build` may use `--search-prefix` to provide additional
directories that are considered "system directories" for the purposes of finding
static and dynamic libraries.

# [Generating Files]($heading.id('generating-files'))

## [Running System Tools]($heading.id('system-tools'))
This version of hello world expects to find a `word.txt` file in the same path,
and we want to use a system tool to generate it starting from a JSON file.

Be aware that system dependencies will make your project harder to build for your
users. This build script depends on `jq`, for example, which is not present by
default in most Linux distributions and which might be an unfamiliar tool for 
Windows users.

The next section will replace `jq` with a Zig tool included in the source tree,
which is the preferred approach.

**`words.json`**
```json
{
  "en": "world",
  "it": "mondo",
  "ja": "世界" 
}
```

[]($code.language('=html').buildAsset("build-system/10.5-system-tool/src/main.zig"))
[]($code.language('=html').buildAsset("build-system/10.5-system-tool/build.zig"))

**Output**

```
zig-out
├── hello
└── word.txt
```

Note how `captureStdOut` creates a temporary file with the output of the `jq` invocation.

## [Running the Project's Tools]($heading.id('project-tools'))

This version of hello world expects to find a `word.txt` file in the same path,
and we want to produce it at build-time by invoking a Zig program on a JSON file.


**`tools/words.json`**
```json
{
  "en": "world",
  "it": "mondo",
  "ja": "世界" 
}
```

[]($code.language('=html').buildAsset("build-system/11-zig-tool/src/main.zig"))

[]($code.language('=html').buildAsset("build-system/11-zig-tool/tools/word_select.zig"))

[]($code.language('=html').buildAsset("build-system/11-zig-tool/build.zig"))

**Output**

```
zig-out
├── hello
└── word.txt
```
## [Producing Assets for `@embedFile`]($heading.id('embed-file'))

This version of hello world wants to `@embedFile` an asset generated at build time,
which we're going to produce using a tool written in Zig.


**`tools/words.json`**
```json
{
  "en": "world",
  "it": "mondo",
  "ja": "世界" 
}
```

[]($code.language('=html').buildAsset("build-system/12-embedfile/src/main.zig"))

[]($code.language('=html').buildAsset("build-system/12-embedfile/tools/word_select.zig"))

[]($code.language('=html').buildAsset("build-system/12-embedfile/build.zig"))

**Output**

```
zig-out/
└── bin
    └── hello
```

## [Generating Zig Source Code]($heading.id('generating-zig'))
This build file uses a Zig program to generate a Zig file and then exposes it
to the main program as a module dependency.

[]($code.language('=html').buildAsset("build-system/13-import/src/main.zig"))
[]($code.language('=html').buildAsset("build-system/13-import/tools/generate_struct.zig"))
[]($code.language('=html').buildAsset("build-system/13-import/build.zig"))

**Output**

```
zig-out/
└── bin
    └── hello
```

## [Dealing With One or More Generated Files]($heading.id('write-files'))

The **WriteFiles** step provides a way to generate one or more files which
share a parent directory. The generated directory lives inside the local .zig-cache,
and each generated file is independently available as a `std.Build.LazyPath`.
The parent directory itself is also available as a LazyPath.

This API supports writing arbitrary strings to the generated directory as well
as copying files into it.

[]($code.language('=html').buildAsset("build-system/write-files/src/main.zig"))
[]($code.language('=html').buildAsset("build-system/write-files/build.zig"))

**Output**

```
zig-out/
└── project.tar.gz
```

## [Mutating Source Files in Place]($heading.id('mutating-source'))

It is uncommon, but sometimes the case that a project commits generated files
into version control. This can be useful when the generated files are seldomly updated
and have burdensome system dependencies for the update process, but *only* during the
update process.

For this, **WriteFiles** provides a way to accomplish this task. This is a feature that
[will be extracted from WriteFiles into its own Build Step](https://github.com/ziglang/zig/issues/14944)
in a future Zig version.

Be careful with this functionality; it should not be used during the normal
build process, but as a utility run by a developer with intention to update
source files, which will then be committed to version control. If it is done
during the normal build process, it will cause caching and concurrency bugs.

[]($code.language('=html').buildAsset("build-system/mutate-source-files/tools/proto_gen.zig"))
[]($code.language('=html').buildAsset("build-system/mutate-source-files/src/main.zig"))
[]($code.language('=html').buildAsset("build-system/mutate-source-files/src/protocol.zig"))
[]($code.language('=html').buildAsset("build-system/mutate-source-files/build.zig"))

```=html
<pre><code class="shell">$ zig build update-protocol --summary all
<span class="sgr-36m">Build Summary:</span> 4/4 steps succeeded
update-protocol<span class="sgr-32m"> success</span>
└─ WriteFile<span class="sgr-32m"> success</span>
   └─ run proto_gen (protocol.zig)<span class="sgr-32m"> success</span><span class="sgr-2m"> 401us</span><span class="sgr-2m"> MaxRSS:1M</span>
      └─ zig build-exe proto_gen Debug native<span class="sgr-32m"> success</span><span class="sgr-2m"> 1s</span><span class="sgr-2m"> MaxRSS:183M</span>
</code></pre>
```

After running this command, `src/protocol.zig` is updated in place.

# [Handy Examples]($heading.id('examples'))

## [Build for multiple targets to make a release]($heading.id('release'))

In this example we're going to change some defaults when creating an `InstallArtifact` step in order to put the build for each target into a separate subdirectory inside the install path. 

[]($code.language('=html').buildAsset("build-system/10-release/build.zig"))
[]($code.language('=html').buildAsset("build-system/10-release/hello.zig"))

**Output**

```
zig-out
├── aarch64-linux
│   └── hello
├── aarch64-macos
│   └── hello
├── x86_64-linux-gnu
│   └── hello
├── x86_64-linux-musl
│   └── hello
└── x86_64-windows
    ├── hello.exe
    └── hello.pdb
```
