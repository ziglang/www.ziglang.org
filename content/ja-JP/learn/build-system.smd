---
.title = "Zigビルドシステム",
.author = "",
.date = @date("2024-08-07:00:00:00"),
.layout = "page.shtml",
.custom = {
	"mobile_menu_title": "Zigビルドシステム",
	"toc": true,
},
---
# [Zigビルドシステムを使うべきときは？]($heading.id('build-system'))

基本的なコマンド `zig build-exe`、`zig build-lib`、`zig build-obj`、および `zig test` が十分な場合が多いです。
しかし、時にはプロジェクトがソースからビルドするための複雑さを管理するために別の抽象化レイヤーが必要な場合もあります。

たとえば、以下のような状況が当てはまるかもしれません:

- コマンドラインが長くて扱いにくくなり、それを書き留める場所が欲しい。
- 多くのものをビルドしたい、またはビルドプロセスに多くのステップが含まれている。
- 並行処理とキャッシングを活用してビルド時間を短縮したい。
- プロジェクトの設定オプションを公開したい。
- ビルドプロセスがターゲットシステムや他のオプションによって異なる。
- 他のプロジェクトへの依存関係がある。
- cmake、make、シェル、msvc、pythonなどへの不必要な依存を避け、より多くの貢献者にプロジェクトをアクセスしやすくしたい。
- サードパーティが利用できるパッケージを提供したい。
- IDEなどのツールがプロジェクトのビルド方法を意味的に理解するための標準化された方法を提供したい。

これらのいずれかに当てはまる場合、プロジェクトはZigビルドシステムを使用することで恩恵を受けるでしょう。

# [はじめに]($heading.id('getting-started'))
## [シンプルな実行ファイル]($heading.id('simple'))
このビルドスクリプトは、パブリックなmain関数定義を含むZigファイルから実行ファイルを作成します。

[]($code.language('=html').buildAsset("build-system/1-simple-executable/hello.zig"))
[]($code.language('=html').buildAsset("build-system/1-simple-executable/build.zig"))

## [ビルド成果物のインストール]($heading.id('installing-artifacts'))

Zigビルドシステムは、ほとんどのビルドシステムと同様に、個別に並行して実行されるステップの有向非巡回グラフ（DAG）としてプロジェクトをモデル化することに基づいています。


デフォルトでは、グラフの主要なステップは**インストール**ステップであり、その目的はビルド成果物を最終的な置き場所にコピーすることです。
インストールステップは最初は依存関係がなく、したがって `zig build` を実行しても何も起こりません。
プロジェクトのビルドスクリプトはインストールするもののセットに追加する必要があり、それが上記の `installArtifact` 関数呼び出しの役割です。

**出力**
```
├── build.zig
├── hello.zig
├── .zig-cache
└── zig-out
    └── bin
        └── hello
```

この出力には2つの生成されたディレクトリがあります: `.zig-cache` と `zig-out`です。
最初のものは後続のビルドを高速化するファイルを含んでいますが、これらのファイルはソース管理することを意図しておらず、このディレクトリはいつでも完全に削除しても問題ありません。

2つ目の `zig-out` は「インストールプレフィックス」です。これは標準的なファイルシステム階層の概念にマッピングされます。
このディレクトリはプロジェクトによって選択されるのではなく、`--prefix`フラグ（短縮形は `-p`）を使用して `zig build` のユーザーによって選択されます。

プロジェクトメンテナとして、あなたはこのディレクトリに何を配置するかを決めますが、ユーザーはそれをシステムのどこにインストールするかを選びます。
ビルドスクリプトは出力パスをハードコーディングすることはできません。なぜなら、これがキャッシング、並行性、組み合わせ可能性を破壊し、最終ユーザーを困らせることになるからです。

## [アプリケーション実行のための便利なステップの追加]($heading.id('run-step'))

ビルドコマンドから直接メインアプリケーションを実行する方法を提供するために、**実行**ステップを追加することが一般的です。

[]($code.language('=html').buildAsset("build-system/convenience-run-step/hello.zig"))
[]($code.language('=html').buildAsset("build-system/convenience-run-step/build.zig"))

# [基本]($heading.id('basics'))

## [ユーザー提供オプション](#user-provided-options)

`b.option`を使用して、エンドユーザーやパッケージとしてプロジェクトに依存する他のプロジェクトに対して、ビルドスクリプトを設定可能にします。

[]($code.language('=html').buildAsset("build-system/2-user-provided-options/build.zig"))
[]($code.language('=html').buildAsset("build-system/2-user-provided-options/example.zig"))

以下の行に注目してください:

```
Project-Specific Options:
  -Dwindows=[bool]             Target Microsoft Windows
```
ヘルプメニューのこの部分は、`build.zig`ロジックの実行に基づいて自動生成されます。

## [標準設定オプション]($heading.id('standard-options'))

以前は、Windowsをビルド対象とすることを示すためにブール値フラグを使用していました。しかし、より良い方法があります。

ほとんどのプロジェクトはターゲットと最適化設定を変更する機能を提供したいと考えています。
これらのオプションの標準的な命名規則を推奨するために、Zigは`standardTargetOptions`と`standardOptimizeOption`というヘルパー関数を提供しています。

標準ターゲットオプションにより、`zig build`を実行する人はビルド対象を選択することが出来ます。
デフォルトでは、どのターゲットも許可され、選択がない場合はホストシステムをターゲットにします。
サポートされるターゲットセットを制限するための他のオプションも利用できます。

標準最適化オプションにより、`zig build`を実行する人は、`Debug`、`ReleaseSafe`、`ReleaseFast`、および `ReleaseSmall`の間で選択することができます。
デフォルトでは、ビルドスクリプトはどのリリースオプションも優先的な選択とみなさず、ユーザーはリリースビルドを作成するためにユーザーが決定を下す必要があります。

[]($code.language('=html').buildAsset("build-system/3-standard-config-options/hello.zig"))
[]($code.language('=html').buildAsset("build-system/3-standard-config-options/build.zig"))

`--help`メニューには、より多くの項目が含まれています:

```
Project-Specific Options:
  -Dtarget=[string]            The CPU architecture, OS, and ABI to build for
  -Dcpu=[string]               Target CPU features to add or subtract
  -Doptimize=[enum]            Prioritize performance, safety, or binary size (-O flag)
                                 Supported Values:
                                   Debug
                                   ReleaseSafe
                                   ReleaseFast
                                   ReleaseSmall
```

`b.option`で直接これらのオプションを作成することも完全に可能ですが、このAPIはこれらの頻繁に使用される設定のために一般的に使用される命名規則を提供します。

ターミナル出力では、`-Dtarget=x86_64-windows -Doptimize=ReleaseSmall`を渡したことがわかります。
最初の例と比較して、インストールプレフィックスに異なるファイルが表示されます:

```
zig-out/
└── bin
    └── hello.exe
```

## [条件付きコンパイルのためのオプション]($heading.id('conditional-compilation'))

ビルドスクリプトからプロジェクトのZigコードにオプションを渡すには、`Options`ステップを使用します。

[]($code.language('=html').buildAsset("build-system/conditional-compilation/app.zig"))
[]($code.language('=html').buildAsset("build-system/conditional-compilation/build.zig"))

この例では、`@import("config")`によって提供されるデータはコンパイル時に既知であり、`@compileError`の発動を防ぎます。
もし`-Dversion=0.2.3`を渡したり、オプションを省略した場合、`app.zig`のコンパイルが「too old」というエラーで失敗します。

## [静的ライブラリ]($heading.id('static-library'))

このビルドスクリプトはZigコードから静的ライブラリを生成し、さらにそれらを利用する他のZigコードから実行ファイルも生成します。

[]($code.language('=html').buildAsset("build-system/simple-static-library/fizzbuzz.zig"))
[]($code.language('=html').buildAsset("build-system/simple-static-library/demo.zig"))
[]($code.language('=html').buildAsset("build-system/simple-static-library/build.zig"))

この場合、静的ライブラリのみがインストールされます:

```
zig-out/
└── lib
    └── libfizzbuzz.a
```

しかしよく見るとビルドスクリプトはデモもインストールするオプションを含んでいます。
さらに `-Denable-demo` を渡すと、インストールプレフィックスに以下のように表示されます:

```
zig-out/
├── bin
│   └── demo
└── lib
    └── libfizzbuzz.a
```

`addExecutable`への無条件の呼び出しにも関わらず、`-Denable-demo` で要求されない限り、ビルドシステムは実際には`demo`実行可能ファイルをビルドするのに時間を無駄にしません。
これはビルドシステムが依存関係エッジをもつ有向非巡回グラフに基づいているからです。

## [動的ライブラリ]($heading.id('dynamic-library'))

ここでは、[静的ライブラリ](#static-library)の例からすべてのファイルを同じままにしておきますが、`build.zig`ファイルを変更します。

[]($code.language('=html').buildAsset("build-system/dynamic-library/build.zig"))

**出力**
```
zig-out
└── lib
    ├── libfizzbuzz.so -> libfizzbuzz.so.1
    ├── libfizzbuzz.so.1 -> libfizzbuzz.so.1.2.3
    └── libfizzbuzz.so.1.2.3
```

静的ライブラリの例と同様に、実行ファイルがそれにリンクするにはこのようなコードを使用します:

```zig
exe.linkLibrary(libfizzbuzz);
```

## [テスト]($heading.id('testing'))

個々のファイルは `zig test foo.zig` で直接テストできますが、より複雑なユースケースはビルドスクリプトを通じてテストを調整することで解決できます。

ビルドスクリプトを使用する場合、ユニットテストはビルドグラフの2つの異なるステップ、**コンパイル**ステップと**実行**ステップに分けられます。
これらの2つのステップ間に依存関係エッジを確立する `addRunArtifact` の呼び出さない限り、ユニットテストは実行されません。

コンパイルステップは、例えば [システムライブラリにリンクする](#linking-to-system-libraries)、ターゲットオプションを設定する、または追加のコンパイルユニットを追加するなど、実行可能ファイル、ライブラリ、またはオブジェクトファイルと同様に構成できます。

実行ステップは、任意の実行ステップと同じように構成できます。例えば、ホストがバイナリを実行できない場合に実行をスキップするなどです。

ビルドシステムを使用してユニットテストを実行する場合、ビルドランナーとテストランナーは複数のユニットテストスイートを並行して実行し、それらの出力が混ざり合うことなく意味のある方法でテスト失敗を報告するために、*stdin*と*stdout*を介して通信します。
これらは [ユニットテストで標準出力に書き込むことが問題となる](https://github.com/ziglang/zig/issues/15091)理由の1つです。- この通信チャネルに干渉するためです。
一方で、このメカニズムは今後の機能、つまり[ユニットテストがパニックを期待する能力](https://github.com/ziglang/zig/issues/1356)を可能にします。


[]($code.language('=html').buildAsset("build-system/unit-testing/main.zig"))
[]($code.language('=html').buildAsset("build-system/unit-testing/build.zig"))

この場合`skip_foreign_checks`をユニットテストに対して有効にするのは良い調整かもしれません:

```diff
@@ -23,6 +23,7 @@
         });

         const run_unit_tests = b.addRunArtifact(unit_tests);
+        run_unit_tests.skip_foreign_checks = true;
         test_step.dependOn(&run_unit_tests.step);
     }
 }
```

[]($code.language('=html').buildAsset("build-system/unit-testing-skip-foreign/build.zig"))

## [システムライブラリへのリンク]($heading.id('linking-to-system-libraries'))

ライブラリ依存関係を満たすには、2つの選択肢があります:

1. Zigビルドシステムを通じてこれらのライブラリを提供する
    (パッケージ管理と[静的ライブラリ](#static-library)を参照)。
2. ホストシステムが提供するファイルを使用する。

上流プロジェクトメンテナのユーズケースでは、Zigビルドシステムを通じてこれらのライブラリを取得することで、摩擦が最小限に抑えられ、設定の力をそれらのメンテナの手に委ねることが出来ます。
この方法でビルドする全ての人は互いに再現可能で一貫した結果を得ることができ、あらゆるオペレーティングシステムで機能し、さらにクロスコンパイルもサポートします。
さらに、プロジェクトが依存関係ツリー全体の正確なバージョンを完璧な精度で決定することも可能です。これが一般的に好まれる外部ライブラリへの依存方法と予想されます。

しかし、Debian, Homebrew, Nixなどのリポジトリにソフトウェアをパッケージするユースケースでは、システムライブラリにリンクすることが必須です。
そのためビルドスクリプトは、[モードを検出](https://github.com/ziglang/zig/issues/14281)してそれに応じて構成する必要があります。

[]($code.language('=html').buildAsset("build-system/system-libraries/build.zig"))

`zig build`のユーザーは、`--search-prefix`を使用して、静的および動的ライブラリを見つけるための「システムディレクトリ」と見なされる追加のディレクトリを提供するために`--search-prefix`を使用できます。

# [ファイルの生成]($heading.id('generating-files'))

## [システムツールの実行]($heading.id('system-tools'))

このバージョンのhello worldは、同じパスに `word.txt` ファイルがあることを期待しており、JSONファイルから生成するためにシステムツールを使用して生成したいと考えています。

システム依存関係はプロジェクトのビルドをユーザーにとって難しくすることに注意してください。
例えば、このビルドスクリプトは `jq` に依存していますが、これはほとんどのLinuxディストリビューションにデフォルトでは存在せず、Windowsユーザーには馴染みのないツールかもしれません。

次のセクションでは、`jq`をソースツリーに含まれるZigツールに置き換えます。これが推奨されるアプローチです。


**`words.json`**
```json
{
  "en": "world",
  "it": "mondo",
  "ja": "世界"
}
```

[]($code.language('=html').buildAsset("build-system/10.5-system-tool/src/main.zig"))
[]($code.language('=html').buildAsset("build-system/10.5-system-tool/build.zig"))

**出力**

```
zig-out
├── hello
└── word.txt
```

`captureStdOut`が`jq`の呼び出しの出力を持つ一時ファイルを作成する方法に注目してください。

## [プロジェクトのツールの実行]($heading.id('project-tools'))

このバージョンのhello worldは、同じパスに `word.txt` ファイルがあることを期待しており、ビルド時にJSONファイルにZigプログラムを呼びだして生成したいと考えています。


**`tools/words.json`**
```json
{
  "en": "world",
  "it": "mondo",
  "ja": "世界"
}
```

[]($code.language('=html').buildAsset("build-system/11-zig-tool/src/main.zig"))

[]($code.language('=html').buildAsset("build-system/11-zig-tool/tools/word_select.zig"))

[]($code.language('=html').buildAsset("build-system/11-zig-tool/build.zig"))

**出力**

```
zig-out
├── hello
└── word.txt
```
## [`@embedFile`のためのアセットの生成]($heading.id('embed-file'))

このバージョンのhello worldはビルド時に生成されたアセットを`@embedFile`したいと考えており、
Zigで書かれたツールを使用して生成します。


**`tools/words.json`**
```json
{
  "en": "world",
  "it": "mondo",
  "ja": "世界"
}
```

[]($code.language('=html').buildAsset("build-system/12-embedfile/src/main.zig"))

[]($code.language('=html').buildAsset("build-system/12-embedfile/tools/word_select.zig"))

[]($code.language('=html').buildAsset("build-system/12-embedfile/build.zig"))

**出力**

```
zig-out/
└── bin
    └── hello
```

## [Zigソースコードの生成]($heading.id('generating-zig'))
このビルドファイルはZigプログラムを使用してZigファイルを生成し、それをモジュール依存関係としてメインプログラムに公開します。

[]($code.language('=html').buildAsset("build-system/13-import/src/main.zig"))
[]($code.language('=html').buildAsset("build-system/13-import/tools/generate_struct.zig"))
[]($code.language('=html').buildAsset("build-system/13-import/build.zig"))

**出力

```
zig-out/
└── bin
    └── hello
```

## [1つまたは複数の生成されたファイルの処理]($heading.id('write-files'))

**WriteFiles**ステップは、親ディレクトリを共有する1つまたは複数のファイルを生成する方法を提供します。
生成されたディレクトリはローカルの`.zig-cache`内にあり、生成された各ファイルは個別に`std.Build.LazyPath`として利用可能です。
親ディレクトリ自体も`LazyPath`として利用可能です。

このAPIは、生成されたディレクトリに任意の文字列を書き込んだり、ファイルをそこにコピーしたりすることをサポートしています。

[]($code.language('=html').buildAsset("build-system/write-files/src/main.zig"))
[]($code.language('=html').buildAsset("build-system/write-files/build.zig"))

**出力**

```
zig-out/
└── project.tar.gz
```

## [ソースファイルのその場での変更]($heading.id('mutating-source'))

一般的ではありませんが、プロジェクトが生成されたファイルをバージョン管理にコミットすることがあります。これは、生成されたファイルが滅多に更新されず、更新プロセスに負担のかかるシステム依存関係がある場合に役立ちますが、更新プロセス中のみです。


このために、**WriteFiles**はこのタスクを達成する方法を提供します。これは将来のZigのバージョンで[WriteFilesから独自のビルドステップに抽出される予定の機能](https://github.com/ziglang/zig/issues/14944)です。

この機能は注意して使用してください。通常のビルドプロセス中ではなく、ソースファイルを更新する意図を持った開発者が実行するユーティリティとして使用すべきで、それらはバージョン管理にコミットされます。通常のビルドプロセス中に行われると、キャッシングと並行性のバグを引き起こします。

[]($code.language('=html').buildAsset("build-system/mutate-source-files/tools/proto_gen.zig"))
[]($code.language('=html').buildAsset("build-system/mutate-source-files/src/main.zig"))
[]($code.language('=html').buildAsset("build-system/mutate-source-files/src/protocol.zig"))
[]($code.language('=html').buildAsset("build-system/mutate-source-files/build.zig"))

```=html
<pre><code class="shell">$ zig build update-protocol --summary all
<span class="sgr-36m">Build Summary:</span> 4/4 steps succeeded
update-protocol<span class="sgr-32m"> success</span>
└─ WriteFile<span class="sgr-32m"> success</span>
   └─ run proto_gen (protocol.zig)<span class="sgr-32m"> success</span><span class="sgr-2m"> 401us</span><span class="sgr-2m"> MaxRSS:1M</span>
      └─ zig build-exe proto_gen Debug native<span class="sgr-32m"> success</span><span class="sgr-2m"> 1s</span><span class="sgr-2m"> MaxRSS:183M</span>
</code></pre>
```

このコマンドを実行すると、`src/protocol.zig`がその場で更新されます。

# [便利な例]($heading.id('examples'))

## [リリース作成のための複数のターゲットビルド]($heading.id('release'))

この例では、`InstallArtifact`ステップを作成する際にいくつかのデフォルトを変更し、各ターゲットのビルドをインストールパス内の別々のサブディレクトリに配置します。

[]($code.language('=html').buildAsset("build-system/10-release/build.zig"))
[]($code.language('=html').buildAsset("build-system/10-release/hello.zig"))

**出力**

```
zig-out
├── aarch64-linux
│   └── hello
├── aarch64-macos
│   └── hello
├── x86_64-linux-gnu
│   └── hello
├── x86_64-linux-musl
│   └── hello
└── x86_64-windows
    ├── hello.exe
    └── hello.pdb
```
