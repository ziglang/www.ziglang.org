---
.title = "Zig ビルドシステム",
.author = "",
.date = @date("2024-08-07:00:00:00"),
.layout = "page.shtml",
.custom = {
	"mobile_menu_title": "Zig ビルドシステム",
	"toc": true,
},
---
# [いつ Zig ビルドシステムを使うべきか？]($heading.id('build-system'))

基本的なコマンドである `zig build-exe`、`zig build-lib`、`zig build-obj`、および `zig test` は多くの場合十分です。しかし、時にはソースからのビルドの複雑さを管理するために、もう一段階の抽象化が必要になることがあります。

例えば、以下のような状況が該当するかもしれません：

- コマンドラインが長くなりすぎて扱いにくくなり、どこかに書き留めておきたい。
- 多くのものをビルドしたい、またはビルドプロセスに多くのステップが含まれている。
- 並行処理やキャッシュを活用してビルド時間を短縮したい。
- プロジェクトの設定オプションを公開したい。
- ターゲットシステムやその他のオプションによってビルドプロセスが異なる。
- 他のプロジェクトに依存している。
- cmake、make、shell、msvc、python などの不要な依存を避け、より多くのコントリビュータがアクセスできるようにしたい。
- IDEなどのツールがビルド方法を意味的に理解できる標準化された方法を提供したい。

これらのいずれかに該当する場合、プロジェクトは Zig ビルドシステムを使うことで恩恵を受けるでしょう。

# [はじめに]($heading.id('getting-started'))
## [シンプルな実行可能ファイル]($heading.id('simple'))
このビルドスクリプトは、public な main 関数定義を含む Zig ファイルから実行可能ファイルを作成します。

[]($code.language('=html').buildAsset("build-system/1-simple-executable/hello.zig"))
[]($code.language('=html').buildAsset("build-system/1-simple-executable/build.zig"))

## [ビルド成果物のインストール]($heading.id('installing-artifacts'))

Zig ビルドシステムは、ほとんどのビルドシステムと同様に、プロジェクトを独立して並行して実行されるステップの有向非巡回グラフ（DAG）としてモデル化しています。

デフォルトでは、グラフのメインステップは **Install** ステップであり、その目的はビルド成果物を最終的な配置場所にコピーすることです。Install ステップは依存関係を持たないため、`zig build` を実行しても何も起こりません。プロジェクトのビルドスクリプトは、`installArtifact` 関数呼び出しでインストール対象を追加する必要があります。

**出力**
```
├── build.zig
├── hello.zig
├── .zig-cache
└── zig-out
    └── bin
        └── hello
```

この出力には2つの生成ディレクトリがあります：`.zig-cache` と `zig-out`。前者は後続のビルドを高速化するファイルを含みますが、ソース管理にチェックインすることは意図されておらず、いつでも削除して問題ありません。

後者の `zig-out` は「インストールプレフィックス」です。これは標準的なファイルシステム階層の概念に対応しています。このディレクトリはプロジェクトによって選ばれるのではなく、`zig build` のユーザーが `--prefix` フラグ（短縮形は `-p`）で指定します。

プロジェクトのメンテナとして、何をこのディレクトリに置くかを決めますが、ユーザーがシステム内のどこにインストールするかを選びます。ビルドスクリプトは出力パスをハードコードできません。なぜなら、これがキャッシュ、並行処理、合成性を壊し、最終ユーザーを困らせるからです。

## [アプリケーション実行のための便利なステップの追加]($heading.id('run-step'))

ビルドコマンドから直接メインアプリケーションを実行する方法を提供するために、**Run** ステップを追加することが一般的です。

[]($code.language('=html').buildAsset("build-system/convenience-run-step/hello.zig"))
[]($code.language('=html').buildAsset("build-system/convenience-run-step/build.zig"))

# [基本]($heading.id('basics'))

## [ユーザー提供オプション]($heading.id('user-options'))

`b.option` を使って、ビルドスクリプトをエンドユーザーやパッケージとして依存する他のプロジェクトに対して設定可能にします。

[]($code.language('=html').buildAsset("build-system/2-user-provided-options/build.zig"))
[]($code.language('=html').buildAsset("build-system/2-user-provided-options/example.zig"))

以下の行に注目してください：

```
Project-Specific Options:
  -Dwindows=[bool]             Target Microsoft Windows
```

このヘルプメニューの部分は、`build.zig` ロジックの実行に基づいて自動生成されます。ユーザーはこの方法でビルドスクリプトの設定オプションを発見できます。

## [標準設定オプション]($heading.id('standard-options'))

以前は Windows 向けビルドを示すためにブールフラグを使っていましたが、より良い方法があります。

ほとんどのプロジェクトはターゲットや最適化設定を変更できるようにしたいです。これらのオプションの標準的な命名規則を促進するために、Zig は `standardTargetOptions` と `standardOptimizeOption` ヘルパー関数を提供しています。

標準ターゲットオプションは、`zig build` を実行する人がビルド対象を選べるようにします。デフォルトでは任意のターゲットが許可され、選択しなければホストシステムがターゲットになります。サポートされるターゲットセットの制限オプションもあります。

標準最適化オプションは、`zig build` を実行する人が `Debug`、`ReleaseSafe`、`ReleaseFast`、`ReleaseSmall` の中から選べるようにします。デフォルトではどのリリースオプションもビルドスクリプトの推奨ではなく、ユーザーがリリースビルドを作成するために決定を下す必要があります。

[]($code.language('=html').buildAsset("build-system/3-standard-config-options/hello.zig"))
[]($code.language('=html').buildAsset("build-system/3-standard-config-options/build.zig"))

これで `--help` メニューに以下の項目が追加されます：

```
Project-Specific Options:
  -Dtarget=[string]            The CPU architecture, OS, and ABI to build for
  -Dcpu=[string]               Target CPU features to add or subtract
  -Doptimize=[enum]            Prioritize performance, safety, or binary size (-O flag)
                                 Supported Values:
                                   Debug
                                   ReleaseSafe
                                   ReleaseFast
                                   ReleaseSmall
```

ターミナル出力では、`-Dtarget=x86_64-windows -Doptimize=ReleaseSmall` を渡したことがわかります。最初の例と比べて、インストールプレフィックス内のファイルが異なります：

```
zig-out/
└── bin
    └── hello.exe
```

## [条件付きコンパイルのためのオプション]($heading.id('conditional-compilation'))

ビルドスクリプトからプロジェクトの Zig コードにオプションを渡すには、`Options` ステップを使います。

[]($code.language('=html').buildAsset("build-system/conditional-compilation/app.zig"))
[]($code.language('=html').buildAsset("build-system/conditional-compilation/build.zig"))

この例では、`@import("config")` で提供されるデータが comptime で既知であるため、`@compileError` は発生しません。`-Dversion=0.2.3` を渡したりオプションを省略した場合、`app.zig` のコンパイルは「too old」エラーで失敗します。

## [静的ライブラリ]($heading.id('static-library'))

このビルドスクリプトは、Zig コードから静的ライブラリを作成し、他の Zig コードからそれを使って実行可能ファイルを作成します。

[]($code.language('=html').buildAsset("build-system/simple-static-library/fizzbuzz.zig"))
[]($code.language('=html').buildAsset("build-system/simple-static-library/demo.zig"))
[]($code.language('=html').buildAsset("build-system/simple-static-library/build.zig"))

この場合、静的ライブラリのみがインストールされます。

```
zig-out/
└── lib
    └── libfizzbuzz.a
```

ただし、`addExecutable` を無条件に呼び出しているにもかかわらず、`-Denable-demo` を渡すとインストールプレフィックスに以下が現れます：

```
zig-out/
├── bin
│   └── demo
└── lib
    └── libfizzbuzz.a
```

Zig ビルドシステムは、有向非巡回グラフに依存関係のエッジを持つため、`-Denable-demo` が要求されない限り、`demo` 実行可能ファイルのビルドに時間を無駄にしません。

## [動的ライブラリ]($heading.id('dynamic-library'))

[静的ライブラリ](#static-library) の例と同じファイルを使いますが、`build.zig` ファイルが変更されています。

[]($code.language('=html').buildAsset("build-system/dynamic-library/build.zig"))

**出力**

```
zig-out
└── lib
    ├── libfizzbuzz.so -> libfizzbuzz.so.1
    ├── libfizzbuzz.so.1 -> libfizzbuzz.so.1.2.3
    └── libfizzbuzz.so.1.2.3
```

静的ライブラリの例と同様に、実行可能ファイルをリンクするには以下のようにします：

```zig
exe.linkLibrary(libfizzbuzz);
```

## [テスト]($heading.id('testing'))

個々のファイルは `zig test foo.zig` で直接テストできますが、より複雑なケースはビルドスクリプトでテストを調整して解決できます。

ビルドスクリプトを使う場合、ユニットテストはビルドグラフの2つの異なるステップ、**Compile** ステップと **Run** ステップに分かれます。`addRunArtifact` の呼び出しがないと、ユニットテストは実行されません。

Compile ステップは、実行可能ファイル、ライブラリ、オブジェクトファイルと同様に設定できます。例えば、[システムライブラリへのリンク](#linking-to-system-libraries)やターゲットオプションの設定、追加のコンパイルユニットの追加などです。

Run ステップは、ホストが実行可能でない場合にスキップするなど、Run ステップと同様に設定できます。

ビルドシステムでユニットテストを実行する場合、ビルドランナーとテストランナーは複数のユニットテストスイートを並行して実行し、テスト失敗を意味のある方法で報告するために *stdin* と *stdout* を介して通信します。これにより、出力が混ざることを防ぎます。これが、ユニットテストで標準出力に書き込むことが問題になる理由の一つです（[issue #15091](https://github.com/ziglang/zig/issues/15091)）。一方で、これはユニットテストがパニックを期待できるようにする機能（[issue #1356](https://github.com/ziglang/zig/issues/1356)）を可能にします。

[]($code.language('=html').buildAsset("build-system/unit-testing/main.zig"))
[]($code.language('=html').buildAsset("build-system/unit-testing/build.zig"))

この場合、ユニットテストに対して `skip_foreign_checks` を有効にするのが良い調整かもしれません。

```diff
@@ -23,6 +23,7 @@
         });

         const run_unit_tests = b.addRunArtifact(unit_tests);
+        run_unit_tests.skip_foreign_checks = true;
         test_step.dependOn(&run_unit_tests.step);
     }
 }
```

[]($code.language('=html').buildAsset("build-system/unit-testing-skip-foreign/build.zig"))

## [システムライブラリへのリンク]($heading.id('linking-to-system-libraries'))

ライブラリ依存関係を満たすには、2つの選択肢があります：

1. Zig ビルドシステムを通じてこれらのライブラリを提供する（パッケージ管理および[静的ライブラリ](#static-library)を参照）。
2. ホストシステムが提供するファイルを使用する。

上流のプロジェクトメンテナにとっては、Zig ビルドシステムを使ってこれらのライブラリを取得することが最も摩擦が少なく、設定の自由度が高いです。これにより、すべての OS で再現可能かつ一貫した結果が得られ、クロスコンパイルもサポートされます。さらに、プロジェクトは依存するライブラリの正確なバージョンを決定できます。

しかし、Debian、Homebrew、Nix などのリポジトリにソフトウェアをパッケージングする場合は、システムライブラリにリンクすることが必須です。そのため、ビルドスクリプトは[モードを検出](https://github.com/ziglang/zig/issues/14281)して適切に設定する必要があります。

[]($code.language('=html').buildAsset("build-system/system-libraries/build.zig"))

`zig build` のユーザーは、`--search-prefix` を使って静的および動的ライブラリを探すための追加ディレクトリを「システムディレクトリ」として指定できます。

# [ファイル生成]($heading.id('generating-files'))

## [システムツールの実行]($heading.id('system-tools'))
この hello world バージョンは同じパスに `word.txt` ファイルを探しますが、JSON ファイルからシステムツールを使って生成したいと考えています。

システム依存はユーザーのビルドを難しくします。例えば、このビルドスクリプトは `jq` に依存していますが、ほとんどの Linux ディストリビューションにはデフォルトで入っておらず、Windows ユーザーには馴染みがないかもしれません。

次のセクションでは、`jq` をソースツリーに含まれる Zig ツールに置き換えます。これが推奨される方法です。

**`words.json`**
```json
{
  "en": "world",
  "it": "mondo",
  "ja": "世界"
}
```

[]($code.language('=html').buildAsset("build-system/10.5-system-tool/src/main.zig"))
[]($code.language('=html').buildAsset("build-system/10.5-system-tool/build.zig"))

**出力**

```
zig-out
├── hello
└── word.txt
```

`captureStdOut` は `jq` の呼び出しで得られた出力を一時ファイルに作成します。

## [プロジェクトのツールの実行]($heading.id('project-tools'))

この hello world バージョンは同じパスに `word.txt` ファイルを探しますが、JSON ファイルに対して Zig プログラムを実行して生成します。

**`tools/words.json`**
```json
{
  "en": "world",
  "it": "mondo",
  "ja": "世界"
}
```

[]($code.language('=html').buildAsset("build-system/11-zig-tool/src/main.zig"))

[]($code.language('=html').buildAsset("build-system/11-zig-tool/tools/word_select.zig"))

[]($code.language('=html').buildAsset("build-system/11-zig-tool/build.zig"))

**出力**

```
zig-out
├── hello
└── word.txt
```

## [`@embedFile` 用のアセット生成]($heading.id('embed-file'))

この hello world バージョンはビルド時に生成されるアセットを `@embedFile` で埋め込みたいと考えています。

**`tools/words.json`**
```json
{
  "en": "world",
  "it": "mondo",
  "ja": "世界"
}
```

[]($code.language('=html').buildAsset("build-system/12-embedfile/src/main.zig"))

[]($code.language('=html').buildAsset("build-system/12-embedfile/tools/word_select.zig"))

[]($code.language('=html').buildAsset("build-system/12-embedfile/build.zig"))

**出力**

```
zig-out/
└── bin
    └── hello
```

## [Zig ソースコード生成]($heading.id('generating-zig'))
このビルドファイルは Zig プログラムを使って Zig ファイルを生成し、メインプログラムにモジュール依存として公開します。

[]($code.language('=html').buildAsset("build-system/13-import/src/main.zig"))
[]($code.language('=html').buildAsset("build-system/13-import/tools/generate_struct.zig"))
[]($code.language('=html').buildAsset("build-system/13-import/build.zig"))

**出力**

```
zig-out/
└── bin
    └── hello
```

## [1つ以上の生成ファイルの処理]($heading.id('write-files'))

**WriteFiles** ステップは、親ディレクトリを共有する1つ以上のファイルを生成する方法を提供します。生成されたディレクトリはローカルの `.zig-cache` 内にあり、各生成ファイルは独立して `std.Build.LazyPath` として利用可能です。親ディレクトリ自体も `LazyPath` として利用可能です。

この API は生成ディレクトリへの任意の文字列書き込みやファイルのコピーをサポートします。

**出力**

```
zig-out/
└── project.tar.gz
```

## [ソースファイルのインプレース変更]($heading.id('mutating-source'))

生成ファイルをバージョン管理にコミットすることは稀ですが、生成ファイルがめったに更新されず、更新プロセスに負担のかかるシステム依存がある場合に便利です。ただし、通常のビルドプロセス中にこれを行うと、キャッシュや並行処理のバグを引き起こします。

**WriteFiles** はこのタスクを達成する方法を提供します。これは将来的に WriteFiles から独立したビルドステップとして抽出される予定です。

[]($code.language('=html').buildAsset("build-system/mutate-source-files/tools/proto_gen.zig"))
[]($code.language('=html').buildAsset("build-system/mutate-source-files/src/main.zig"))
[]($code.language('=html').buildAsset("build-system/mutate-source-files/src/protocol.zig"))
[]($code.language('=html').buildAsset("build-system/mutate-source-files/build.zig"))

```=html
<pre><code class="shell">$ zig build update-protocol --summary all
<span class="sgr-36m">Build Summary:</span> 4/4 steps succeeded
update-protocol<span class="sgr-32m"> success</span>
└─ WriteFile<span class="sgr-32m"> success</span>
   └─ run proto_gen (protocol.zig)<span class="sgr-2m"> 401us</span><span class="sgr-2m"> MaxRSS:1M</span>
      └─ zig build-exe proto_gen Debug native<span class="sgr-32m"> success</span><span class="sgr-2m"> 1s</span><span class="sgr-2m"> MaxRSS:183M</span>
</code></pre>
```

このコマンドを実行すると、`src/protocol.zig` がインプレースで更新されます。

# [便利な例]($heading.id('examples'))

## [複数ターゲット向けのビルドでリリースを作成]($heading.id('release'))

この例では、`InstallArtifact` ステップを作成するときにいくつかのデフォルトを変更し、各ターゲットのビルドをインストールパス内の別々のサブディレクトリに配置します。

[]($code.language('=html').buildAsset("build-system/10-release/build.zig"))
[]($code.language('=html').buildAsset("build-system/10-release/hello.zig"))

**出力**

```
zig-out
├── aarch64-linux
│   └── hello
├── aarch64-macos
│   └── hello
├── x86_64-linux-gnu
│   └── hello
├── x86_64-linux-musl
│   └── hello
└── x86_64-windows
    ├── hello.exe
    └── hello.pdb
