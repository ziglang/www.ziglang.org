---
.title = "なぜ Zig なのか？すでに C++、D、Rust があるのに",
.author = "",
.date = @date("2024-08-07:00:00:00"),
.layout = "page.shtml",
.custom = {
	"mobile_menu_title": "なぜ Zig？",
},
---

# 隠された制御フローはない

Zig のコードが関数を呼び出すために飛び出しているように見えないなら、それは違います。つまり、次のコードは `foo()` と `bar()` のみを呼び出し、何も型を知らなくてもこれが保証されます：

```zig
var a = b + c.d;
foo();
bar();
```

隠された制御フローの例：

* D には `@property` 関数があり、これはフィールドアクセスのように見えるメソッドで、上記の例では `c.d` が関数を呼び出すかもしれません。
* C++、D、Rust には演算子のオーバーロードがあり、`+` 演算子は関数を呼び出すかもしれません。
* C++、D、Go には throw/catch 例外があり、`foo()` は例外をスローして `bar()` が呼ばれないようにするかもしれません。（もちろん、Zig でも `foo()` がデッドロックして `bar()` が呼ばれないことはありますが、それはどのチューリング完全な言語でも起こり得ます。）

この設計の目的は、可読性を向上させることです。

# 隠された割り当てはない

Zig はヒープ割り当てに関しては手を出しません。`new` キーワードやヒープアロケータを使う言語機能（例えば文字列連結演算子[1]）はありません。ヒープの概念はライブラリやアプリケーションコードで管理され、言語自体ではありません。

隠された割り当ての例：

* Go の `defer` は関数ローカルスタックにメモリを割り当てます。これは直感的でない制御フローの方法であり、ループ内で `defer` を使うとメモリ不足になることがあります。
* C++ のコルーチンはコルーチンを呼び出すためにヒープメモリを割り当てます。
* Go では、関数呼び出しがヒープ割り当てを引き起こすことがあります。なぜなら、ゴルーチンは小さなスタックを割り当て、呼び出しスタックが深くなるとサイズ変更されるからです。
* Rust の標準ライブラリの主要な API はメモリ不足時にパニックを起こし、アロケータパラメータを受け入れる代替 API は後付けです（[rust-lang/rust#29802](https://github.com/rust-lang/rust/issues/29802) を参照）。

ほとんどのガベージコレクション言語は隠された割り当てが散在しています。ガベージコレクタはクリーンアップ側でその証拠を隠します。

隠された割り当ての主な問題は、コードの*再利用性*を妨げ、コードが適用される環境の数を不必要に制限することです。制御フローや関数呼び出しがメモリ割り当ての副作用を持たないことを保証できる必要があるユースケースが存在します。プログラミング言語はこの保証を現実的に提供できなければ、そのユースケースに対応できません。

Zig にはヒープアロケータを提供し操作する標準ライブラリ機能がありますが、それらはオプションの標準ライブラリ機能であり、言語自体には組み込まれていません。ヒープアロケータを初期化しなければ、プログラムがヒープ割り当てをしないことを確信できます。

標準ライブラリのヒープメモリを割り当てる必要がある機能はすべて、`Allocator` パラメータを受け取ります。これにより、Zig 標準ライブラリはフリースタンディングターゲットをサポートします。例えば `std.ArrayList` や `std.AutoHashMap` はベアメタルプログラミングに使えます！

カスタムアロケータにより手動メモリ管理が容易になります。Zig には use-after-free や double-free に対してメモリ安全を維持するデバッグアロケータがあります。メモリリークのスタックトレースを自動検出して表示します。アリーナアロケータは複数の割り当てをまとめて一括解放できます。特定のアプリケーションのニーズに応じてパフォーマンスやメモリ使用量を改善するための特殊なアロケータもあります。

[1]: 実際には文字列連結演算子（一般的には配列連結演算子）がありますが、コンパイル時にのみ動作し、実行時のヒープ割り当ては行いません。

# 標準ライブラリなしのファーストクラスサポート

前述の通り、Zig には完全にオプションの標準ライブラリがあります。各 std ライブラリ API は使用した場合にのみプログラムにコンパイルされます。Zig は libc とリンクすることも、リンクしないことも同等にサポートします。Zig はベアメタルや高性能開発に適しています。

これは両方の良いところを兼ね備えています。例えば Zig では、WebAssembly プログラムは標準ライブラリの通常機能を使いながら、他の WebAssembly 対応言語と比べて最小のバイナリサイズを実現できます。

# ライブラリ向けのポータブル言語

プログラミングの聖杯の一つはコードの再利用です。残念ながら、実際には何度も車輪の再発明をしています。多くの場合、それは正当化されます。

 * アプリケーションにリアルタイム要件がある場合、ガベージコレクションやその他の非決定的な動作を使うライブラリは依存関係として不適格です。
 * 言語がエラーを無視しやすく、ライブラリが正しくエラーを処理し伝播することを検証しにくい場合、ライブラリを無視して再実装する誘惑があります。Zig はプログラマがエラーを正しく処理することが最も簡単な設計であり、ライブラリが正しくエラーを伝播することを合理的に期待できます。
 * 現状、C は最も汎用的でポータブルな言語であることが実用的に真実です。C コードと相互作用できない言語は埋もれるリスクがあります。Zig は外部関数の C ABI 準拠を簡単にし、実装内の一般的なバグを防ぐ安全性と言語設計を導入することで、新しいポータブル言語を目指しています。

# 既存プロジェクト向けのパッケージマネージャとビルドシステム

Zig はプログラミング言語に加えツールチェインです。
[ビルドシステムとパッケージマネージャ](/learn/build-system/)が付属しており、従来の C/C++ プロジェクトでも役立ちます。

Zig コードを C や C++ の代わりに書くだけでなく、autotools、cmake、make、scons、ninja などの代替としても使えます。さらに、ネイティブ依存関係のパッケージマネージャも提供します。このビルドシステムは、プロジェクトのコードベースがすべて C や C++ であっても適しています。例えば、[ffmpeg を zig ビルドシステムに移植する](https://github.com/andrewrk/ffmpeg)ことで、[50 MiB の zig ダウンロード](/download/)だけで任意のサポート対象システム向けに ffmpeg をビルドできます。オープンソースプロジェクトにとって、ソースからビルドし、クロスコンパイルできるこの能力は、貴重なコントリビュータを獲得するか失うかの違いになり得ます。

apt-get、pacman、homebrew などのシステムパッケージマネージャはエンドユーザー体験に重要ですが、開発者のニーズには不十分なことがあります。言語固有のパッケージマネージャは、コントリビュータがいないか多いかの違いを生みます。オープンソースプロジェクトにとって、プロジェクトをビルドできるかどうかの難しさは大きな障害です。C/C++ プロジェクトでは依存関係が致命的になることもあります。特に Windows ではパッケージマネージャがありません。Zig は、ユーザーのシステムパッケージマネージャに正しいバージョンがあることに依存せず、どのシステムでも最初の試行でビルドが成功することを実質的に保証する方法で、ネイティブライブラリに依存できます。

**他の言語にはパッケージマネージャがありますが、Zig のように厄介なシステム依存を排除するものはありません。**

Zig は宣言的 API を使ってプロジェクトのビルドシステムを合理的な言語で置き換え、パッケージ管理を提供し、他の C ライブラリに依存できるようにします。依存関係があることで高レベルの抽象化が可能になり、再利用可能な高レベルコードの普及につながります。

# シンプルさ

C++、Rust、D は多くの機能があり、作業中のアプリケーションの意味から気をそらすことがあります。プログラミング言語の知識をデバッグする代わりに、アプリケーション自体をデバッグしていることに気づきます。

Zig はマクロがありませんが、複雑なプログラムを明確で繰り返しのない方法で表現するのに十分強力です。Rust でさえ、`format!` のような特別なケースを持つマクロがありますが、それはコンパイラ自体に実装されています。一方、Zig の同等の関数は標準ライブラリで実装されており、コンパイラに特別なコードはありません。

# ツール

Zig は[ダウンロードセクション](/download/)から入手できます。Zig は Linux、Windows、macOS 向けのバイナリアーカイブを提供しています。これらのアーカイブで得られるものは以下の通りです：

* 単一のアーカイブをダウンロードして展開するだけでインストールされ、システム設定は不要
* 静的にコンパイルされており、実行時依存関係なし
* LLVM を使った最適化リリースビルドと、Zig 独自のバックエンドによる高速コンパイル性能をサポート
* C コード出力用のバックエンドもサポート
* 主要プラットフォームへのクロスコンパイルがすぐに可能
* 必要に応じて動的にコンパイルされる libc のソースコードを同梱
* 並行処理とキャッシュを備えたビルドシステムを含む
* libc サポート付きで C と C++ のコードをコンパイル
* `zig cc` で GCC/Clang のコマンドライン互換性を提供
* Windows リソースコンパイラを含む
