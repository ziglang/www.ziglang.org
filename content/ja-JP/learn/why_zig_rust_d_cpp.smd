---
.title = "すでにC++, D, Rustがあるのに、なぜZigなのか？",
.author = "",
.date = @date("2024-08-07:00:00:00"),
.layout = "page.shtml",
.custom = {
	"mobile_menu_title": "Why Zig?",
},
---

# 隠蔽された制御フローがない

Zigコードが関数を呼び出すためにジャンプしているように見えなければ、実際にジャンプしていません。つまり、以下のコードが`foo()`を呼び出し、その後`bar()`を呼び出すだけであることが確信でき、何の型もシル必要なく保証されます。

```zig
var a = b + c.d;
foo();
bar();
```

隠蔽された制御フローの例:

* D には`@property`関数があり、これはフィールドアクセスのように見える関数を呼び出すメソッドです。上の例では、`c.d`が関数を呼び出す可能性があります。
* C++, D, そしてRustには演算子オーバーロードがあるため、`+`演算子が関数を呼び出す可能性があります。
* C++, D, そしてGoにはthrow/catch例外があるため、`foo()`が例外をスローし、`bar()`の呼び出しを防ぐ可能性があります。(もちろん、Zigでも`foo()`がデッドロックして`bar()`の呼び出しを防ぐ可能性がありますが、それはチューリング完全な言語ではどれでも起こり得ます。)

The purpose of this design decision is to improve readability.
この設計決定の目的は、読みやすさを向上させることです。

# 隠蔽されたメモリ割り当てがない


Zigはヒープ割り当てに関して干渉しないアプローチをとっています。
`new`キーワードやヒープアロケータを使用する他の言語機能（例：文字列連結演算子[1]）はありません。
ヒープの概念全体は言語ではなく、ライブラリとアプリケーションコードによって管理されています。

隠蔽されたメモリ割り当ての例:

* Goの`defer`は関数ローカルスタックにメモリを割り当てます。この制御フローの直感的でない動作に加えて、メモリ不足エラーを引き起こす可能性があります。
* C++のコルーチンは、コルーチンを呼び出すためにヒープメモリを割り当てます。
* Goでは、ゴルーチンが小さなスタックを割り当て、コールスタックが十分に深くなるとサイズが変更されるため、関数呼び出しがヒープ割り当てを引き起こす可能性があります。
* Rustの標準ライブラリAPIは、メモリ不足条件でパニックを起こし、アロケーターパラメータを受け入れる代替APIは後付けです
  (see [rust-lang/rust#29802](https://github.com/rust-lang/rust/issues/29802)).

ほとんど全てのガベレージコレクション言語には隠蔽されたメモリ割り当てが散在しています。
これはガベージコレクタがクリーンアップ側の証拠を隠すからです。

隠蔽されたメモリ割り当ての主な問題は、コードの*再利用性*を妨げ、不必要にそのコードがデプロイされる環境の数を制限することです。
シンプルに、制御フローや関数呼び出しがメモリ割り当ての副作用を持たないと確実に信頼できなければならないユースケースがあり、プログラミング言語はこの保証を実際に提供できる場合にのみ、これらのユースケースにサービスを提供できます。

Zigでは、標準ライブラリの機能がヒープアロケータを提供し、それを使用しますが、オプションの標準ライブラリ機能であり、言語自体に組み込まれていません。
もしヒープアロケータを初期化しなければ、プログラムがヒープ割り当てを行わないことを確信できます。


ヒープメモリを割り当てる必要がある標準ライブラリのすべての機能は、`Allocator`パラメータを受け入れます。
これにより、Zig標準ライブラリはフリースタンディングターゲットをサポートします。
例えば、`std.ArrayList`や`std.AutoHashMap`はベアメタルプログラミングに使用できます！


カスタムアロケータにより、手動メモリ管理が簡単になります。
Zigには、use-after-freeやdouble-freeに対してメモリ安全性を維持するデバッグアロケータがあります。
メモリリークを自動的に検出し、スタックトレースを出力します。任意の数の割り当てを一つにまとめて、各割り当てを個別に管理するのではなく一度に全てを解放できるアリーナアロケータもあります。
特殊目的のアロケータを使用して、特定のアプリケーションのニーズに合わせてパフォーマンスやメモリ使用量を改善できます。

[1]: 実際には文字列連結演算子（一般的には配列連結演算子）がありますが、コンプタイムにのみ機能するため、ランタイムのヒープ割り当ては行いません。

# 標準ライブラリを使用しない First-class サポート

上記で示唆したように、Zigには完全にオプションの標準ライブラリがあります。
各標準ライブラリAPIは、使用する場合にのみプログラムにコンパイルされます。
Zigは、libcにリンクするかしないかにかかわらず、同等のサポートを提供します。
Zigはベアメタルや高性能開発に適しています。

これは両方の世界の良いところを持っています。
例えば、ZigではWebAssemblyプログラムが標準ライブラリの通常の機能を使用できると同時に、WebAssemblyへのコンパイルをサポートする他のプログラミング言語と比較して、最小のバイナリを生成することができます。

# ライブラリのためのポータブルな言語

プログラミングの聖杯の一つはコードの再利用です。残念ながら、実際には、私たちは何度も車輪を再発明しています。それには正当な理由があることが多いです。

 * アプリケーションにリアルタイム要件がある場合、ガベージコレクションやその他の非決定的な動作を使用するライブラリは依存関係から除外されます。
 * 言語がエラーを無視することを容易にし、ライブラリが正しくエラーを処理して伝播させることを確認しにくい場合、そのライブラリを無視して再実装することが魅力的になります。自分自身がすべての関連エラーを正しく処理したことを知っているからです。Zigは、プログラマーが最も怠惰にできることがエラーを正しく処理することであるように設計されており、したがってライブラリが適切にエラーを伝播させることを合理的に確信できます。
 * 現在、実用的にはCが最も汎用的でポータブルな言語であることは事実です。Cコードと対話する能力を持たない言語は、知名度の低さをリスクとします。Zigは、外部関数のためにC ABIに準拠することを簡単にすると同時に、実装内の一般的なバグを防ぐ安全性と言語設計を導入することにより、新しいポータブルなライブラリ言語になることを目指しています。

# 既存プロジェクトのためのパッケージマネージャとビルドシステム

Zigはプログラミング言語に加えてツールチェーンでもあります。
従来のC/C++プロジェクトのコンテキストでも便利な[ビルドシステムとパッケージマネージャ](/learn/build-system/)が付属しています。


CまたはC++コードの代わりにZigコードを書くことができるだけでなく、Zigをautotools、cmake、make、scons、ninjaなどの代替としてZigを使用することもできます。
さらに、ネイティブ依存関係のためのパッケージマネージャも提供しています。このビルドシステムは、プロジェクトのコードベース全体がCまたはC++である場合でも適切です。
このビルドシステムは、プロジェクトのコードベース全体がCまたはC++で書かれている場合でも適切です。例えば、[ffmpegをzigビルドシステムに移植する](https://github.com/andrewrk/ffmpeg)ことで、[わずか50MiBのzig](/download/)をダウンロードするだけで、ffmpegを任意のサポートされたシステムでコンパイルすることができます。オープンソースプロジェクトにとって、このソースからビルドするための簡素化された能力は、貴重なコントリビューターを獲得するか失うかの違いになる可能性があります。

apt-get, pacman, homebrew などのシステムパッケージマネージャはエンドユーザー体験に不可欠ですが、開発者のニーズには不十分な場合があります。
言語固有のパッケージマネージャは、コントリビューターがいないか多くいるかの違いになる可能性があります。
オープンソースプロジェクトにとって、プロジェクトをビルドすること自体の難しさは、潜在的なコントリビューターにとって大きな障害です。
C/C++プロジェクトでは、依存関係が致命的になる可能性があります。特にWindowsでは、パッケージマネージャが存在しません。
Zig自体をビルドする場合でも、ほとんどの潜在的なコントリビューターはLLVM依存関係に困難を感じています。
Zigはプロジェクトがネイティブライブラリに直接依存する方法を提供します - ユーザーのシステムパッケージマネージャが正しいバージョンを利用可能にすることに依存せず、使用されているシステムや対象となるプラットフォームに関係なく、プロジェクトを最初の試みで確実にビルドする方法を提供します。

**他の言語にもパッケージマネージャはありますが、Zigのようにやっかいなシステム依存関係を排除するものはありません。**

Zigはプロジェクトのビルドシステムを、プロジェクトをビルドするための宣言的APIを持つ合理的な言語に置き換え、パッケージ管理も提供し、他のCライブラリに依存する能力を提供します。依存関係を持つ能力により、より高いレベルの抽象化が可能になり、再利用可能な高レベルコードの増殖が促進されます。

# シンプル

C++、Rust、Dには非常に多くの機能があり、実際に取り組んでいるアプリケーションの意味から気を散らすことがあります。アプリケーション自体をデバッグするのではなく、プログラミング言語に関する知識をデバッグしていることに気づくことがあります。

Zigにはマクロはありませんが、複雑なプログラムを明確で反復のない方法で表現するのに十分な強力さを持っています。
Rust でさえ、コンパイラ自体に実装されている`format!`のような特別なケースを持つマクロがあります。
一方、Zigでは、同等の機能はコンパイラに特殊なケースコードなしで標準ライブラリに実装されています。

# ツール

Zigは[ダウンロードセクション](/download/)からダウンロードできます。ZigはLinux、Windows、macOS用のバイナリアーカイブを提供しています。
以下はこれらのアーカイブの一つで得られるものについて説明しています。

* 単一のアーカイブをダウンロードして展開するだけでインストールでき、システム設定は必要ありません
* 静的にコンパイルされているため、ランタイム依存関係はありません
* 最適化されたリリースビルドにはLLVMを使用し、より高速なコンパイルパフォーマンスにはZigのカスタムバックエンドを使用することをサポートしています
* さらにCコードを出力するためのバックエンドをサポートしています
* ほとんどの主要なプラットフォームへのクロスコンパイルをすぐにサポートしています
* 必要に応じて任意のサポートされているプラットフォーム用に動的にコンパイルされるlibcのソースコードが付属しています
* 並列処理とキャッシングを備えたビルドシステムが含まれています
* libcサポート付きでCおよびC++コードをコンパイルします
* `zig cc`でGCC/Clangコマンドラインと互換性のあるドロップイン置き換えが可能です
* Windowsリソースコンパイラが含まれています
