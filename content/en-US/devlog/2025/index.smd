---
.title = "Devlog",
.author = "",
.date = @date("2025-01-24T00:00:00"),
.layout = "devlog.shtml",
// When archiving this devlog, remember to disable
// RSS feed generation, as only the current year page
// should be generating a feed.
.alternatives = [{
    .name = "rss",
	.layout = "devlog.xml",
	.output = "/devlog/index.xml",
}],
.custom = {
	"mobile_menu_title": "Devlog",
},
// Every entry is a block of markdown content that
// starts with a $section heading.
// The $section.id is the date of the new micro-post.
// It will also be used as the unique identifier for your
// new entry both in HTML (as the fragment value) and in
// the RSS feed.
// If you want to publish more than one entry in the same
// day, add hours, minutes and seconds to the id value.
// If you get a date parsing error on build, you messed up
// the date syntax.
// You can look at this page's '.date' frontmatter field for
// an example of a correct date string.
---

# [Intro to the Zig Build System Video]($section.id('2025-06-06'))
Author: Loris Cro

I've released a few days ago a new video on YouTube where I show how to get
started with the Zig build system for those who have not grokked it yet.

In the video I show how to create a package that exposes a Zig module and then
how to import that module in another Zig project. After June I will add more
videos to the series in order to cover more of the build system.

Here's the video: https://youtu.be/jy7w_7JZYyw

# [FreeBSD and NetBSD Cross-Compilation Support]($section.id('2025-05-20'))
Author: Alex RÃ¸nne Petersen

Pull requests [#23835](https://github.com/ziglang/zig/pull/23835) and
[#23913](https://github.com/ziglang/zig/pull/23913) have now been merged. This
means that, using `zig cc` or `zig build`, you can now build binaries targeting
FreeBSD 14.0.0+ and NetBSD 10.1+ from any machine, just as you've been able to
for Linux, macOS, and Windows for a long time now.

This builds on the [strategy](https://github.com/ziglang/libc-abi-tools) we were
already using for glibc and will soon be using for other targets as well. For
any given FreeBSD/NetBSD release, we build libc and related libraries for every
supported target, and then extract public symbol information from the resulting
ELF files. We then combine all that information into a very compact `abilists`
file that gets shipped with Zig. Finally, when the user asks to link libc while
cross-compiling, we load the `abilists` file and build a stub library for each
constituent libc library (`libc.so`, `libm.so`, etc), making sure that it
accurately reflects the symbols provided by libc for the target architecture and
OS version, and has the expected [soname](https://en.wikipedia.org/wiki/Soname).
This is all quite similar to how the
[llvm-ifs tool](https://llvm.org/docs/CommandGuide/llvm-ifs.html) works.

We currently import [crt0](https://en.wikipedia.org/wiki/Crt0) code from the
latest known FreeBSD/NetBSD release and manually apply any patches needed to
make it work with any OS version that we support cross-compilation to. This is
necessary because the OS sometimes changes the crt0 ABI. We'd like to eventually
[reimplement the crt0 code in Zig](https://github.com/ziglang/zig/issues/23875).

We also ship FreeBSD/NetBSD system and libc headers with the Zig compiler.
Unlike the stub libraries we produce, however, we always import headers from the
latest version of the OS. This is because it would be far too space-inefficient
to ship separate headers for every OS version, and we realistically don't have
the time to audit the headers on every import and add appropriate version guards
to all new declarations. The good news, though, is that we do accept patches to
add version guards when necessary; we've already had many contributions of this
sort in our imported glibc headers.

Please take this for a spin and report any bugs you find!

We would like to also add support for
[OpenBSD libc](https://github.com/ziglang/zig/issues/2878) and
[Dragonfly BSD libc](https://github.com/ziglang/zig/issues/23880), but because
these BSDs cannot be conveniently cross-compiled from Linux, we need motivated
users of them to chip in. Besides those, we are also looking into
[SerenityOS](https://github.com/ziglang/zig/issues/23879),
[Android](https://github.com/ziglang/zig/issues/23906), and
[Fuchsia](https://github.com/ziglang/zig/issues/23877) libc support.

# [Website updated to Zine 0.10.0]($section.id('2025-04-09'))
Author: Loris Cro

The official Zig website now builds using standalone Zine. A lot of code got
rewritten so if you see regressions on the website, please open an issue.
Regressions only please, thanks!

Normally a Zine update would not be worthy of a devlog entry, but the recent
update to it was pretty big as Zine went from being a funky Zig build script to
a standalone executable. If you were interested in Zine before but never got
the time to try it out, this milestone is a great moment to
[give it a shot](https://zine-ssg.io). Run `zine init` to get a sample website
that also implements a devlog for you out of the box.

P.S. I've also added dates to each entry on the page, people were asking for this for a while :^)

# [Release Tag Status Update]($section.id('2025-03-03'))

The 0.14.0 release is coming shortly. We didn't get the release notes done yet,
and I'm calling it a day.

Tomorrow morning I'll make the tag, kick off the CI, and then work to finish
the release notes while it builds.

I know there were a lot of things that sadly didn't make the cut. Let's try to
get them into 0.14.1 or 0.15.0. Meanwhile, there are a ton of major and minor
enhancements that have already landed, and will debut tomorrow.

# [Improved UBSan Error Messages]($section.id('2025-02-24'))

Author: David Rubin

Lately, I've been extensively working with C interop, and one thing that's been
sorely missing is clear error messages from UBSan. When compiling C with
`zig cc`, Zig provides better defaults, including implicitly enabling `-fsanitize=undefined`.
This has been great for catching subtle bugs and makes working with
C more bearable. However, due to the lack of a UBSan runtime, all undefined
behavior was previously caught with a `trap` instruction.

For example, consider this example C program:
```c
#include <stdio.h>

int foo(int x, int y) {
    return x + y;
}

int main() {
    int result = foo(0x7fffffff, 0x7fffffff);
    printf("%d\n", result);
}
```
Running this with `zig cc` used to result in an unhelpful error:
```
$ zig run test.c -lc
fish: Job 1, 'zig run empty.c -lc' terminated by signal SIGILL (Illegal instruction)
```

Not exactly informative! To understand what went wrong, you'd have to run the
executable in a debugger. Even then, tracking down the root cause could be
daunting. Many newcomers ran into this `Illegal instruction` error without
realizing that UBSan was enabled by default, leading to confusion. This issue
was common enough to warrant a dedicated
[Wiki page](https://github.com/ziglang/zig/wiki/zig-cc-compatibility-with-clang#ubsan-and-sigill-illegal-instruction).

With the new [UBSan runtime merged](https://github.com/ziglang/zig/pull/22488),
the experience has completely changed. Now instead of an obscure `SIGILL`, you
get a much more helpful error message:
```
$ zig run test.c -lc
thread 208135 panic: signed integer overflow: 2147483647 + 2147483647 cannot be represented in type 'int'
/home/david/Code/zig/build/test.c:4:14: 0x1013e41 in foo (test.c)
    return x + y;
             ^
/home/david/Code/zig/build/test.c:8:18: 0x1013e63 in main (test.c)
    int result = foo(0x7fffffff, 0x7fffffff);
                 ^
../sysdeps/nptl/libc_start_call_main.h:58:16: 0x7fca4c42e1c9 in __libc_start_call_main (../sysdeps/x86/libc-start.c)
../csu/libc-start.c:360:3: 0x7fca4c42e28a in __libc_start_main_impl (../sysdeps/x86/libc-start.c)
???:?:?: 0x1013de4 in ??? (???)
???:?:?: 0x0 in ??? (???)
fish: Job 1, 'zig run test.c -lc' terminated by signal SIGABRT (Abort)
```

Now, not only do we see *what* went wrong (signed integer overflow), but we also
see *where* it happened -- two critical pieces of information that were previously
missing.

## Remaining Limitations

While the new runtime vastly improves debugging, there are still two features
that LLVM's UBSan runtime provides which ours doesn't support yet:

1. In C++, UBSan can detect when an object's vptr indicates the wrong dynamic
type or when its lifetime hasn't started. Supporting this would require replicating
the Itanium C++ ABI, which isn't worth the extreme complexity.
2. Currently, the runtime doesn't show the exact locations of attributes like
`assume_aligned` and `__nonnull`. This should be relatively straightforward to
add, and contributions are welcome!

If you've ever been frustrated by cryptic `SIGILL` errors while trying out Zig,
this update should make debugging undefined behavior a lot easier!

# [No-Libc Zig Now Outperforms Glibc Zig]($section.id('2025-02-07'))

Author: Andrew Kelley

Alright, I know I'm supposed to be focused on issue triage and merging PRs for
the upcoming release this month, but in my defense, I do some of my best work
while procrastinating.

Jokes aside, this week we had CI failures due to Zig's debug allocator creating
too many memory mappings. This was interfering with Jacob's work on the x86
backend, so I spent the time to
[rework the debug allocator](https://github.com/ziglang/zig/pull/20511#issuecomment-2638356298).

Since this was a chance to eliminate the dependency on a compile-time known
page size, I based my work on contributor archbirdplus's patch to add
runtime-known page size support to the Zig standard library. With this change
landed, it means Zig finally works on Asahi Linux. My fault for originally
making page size compile-time known. Sorry about that!

Along with detecting page size at runtime, the new implementation no longer
memsets each page to 0xaa bytes then back to 0x00 bytes, no longer searches
when freeing, and no longer depends on a treap data structure. Instead, the
allocation metadata is stored inline, on the page, using a pre-cached lookup
table that is computed at compile-time:

```zig
/// This is executed only at compile-time to prepopulate a lookup table.
fn calculateSlotCount(size_class_index: usize) SlotIndex {
    const size_class = @as(usize, 1) << @as(Log2USize, @intCast(size_class_index));
    var lower: usize = 1 << minimum_slots_per_bucket_log2;
    var upper: usize = (page_size - bucketSize(lower)) / size_class;
    while (upper > lower) {
        const proposed: usize = lower + (upper - lower) / 2;
        if (proposed == lower) return lower;
        const slots_end = proposed * size_class;
        const header_begin = mem.alignForward(usize, slots_end, @alignOf(BucketHeader));
        const end = header_begin + bucketSize(proposed);
        if (end > page_size) {
            upper = proposed - 1;
        } else {
            lower = proposed;
        }
    }
    const slots_end = lower * size_class;
    const header_begin = mem.alignForward(usize, slots_end, @alignOf(BucketHeader));
    const end = header_begin + bucketSize(lower);
    assert(end <= page_size);
    return lower;
}
```

It's pretty nice because you can tweak some global constants and then get
optimal slot sizes. That assert at the end means if the constraints could not
be satisfied you get a compile error. Meanwhile in C land, equivalent code has
to resort to handcrafted lookup tables. Just look at the top of malloc.c from
musl:

```c
const uint16_t size_classes[] = {
	1, 2, 3, 4, 5, 6, 7, 8,
	9, 10, 12, 15,
	18, 20, 25, 31,
	36, 42, 50, 63,
	72, 84, 102, 127,
	146, 170, 204, 255,
	292, 340, 409, 511,
	584, 682, 818, 1023,
	1169, 1364, 1637, 2047,
	2340, 2730, 3276, 4095,
	4680, 5460, 6552, 8191,
};
```

Not nearly as nice to experiment with different size classes. The water's warm,
Rich, come on in! ðŸ˜›

Anyway, as a result of reworking this allocator, not only does it work with
runtime-known page size, and avoid creating too many memory mappings, it also
performs significantly better than before. The motivating test case for these
changes was this degenerate ast-check task, with a debug compiler:

```
Benchmark 1 (3 runs): master/bin/zig ast-check ../lib/compiler_rt/udivmodti4_test.zig
  measurement          mean Â± Ïƒ            min â€¦ max           outliers         delta
  wall_time          22.8s  Â±  184ms    22.6s  â€¦ 22.9s           0 ( 0%)        0%
  peak_rss           58.6MB Â± 77.5KB    58.5MB â€¦ 58.6MB          0 ( 0%)        0%
  cpu_cycles         38.1G  Â± 84.7M     38.0G  â€¦ 38.2G           0 ( 0%)        0%
  instructions       27.7G  Â± 16.6K     27.7G  â€¦ 27.7G           0 ( 0%)        0%
  cache_references   1.08G  Â± 4.40M     1.07G  â€¦ 1.08G           0 ( 0%)        0%
  cache_misses       7.54M  Â± 1.39M     6.51M  â€¦ 9.12M           0 ( 0%)        0%
  branch_misses       165M  Â±  454K      165M  â€¦  166M           0 ( 0%)        0%
Benchmark 2 (3 runs): branch/bin/zig ast-check ../lib/compiler_rt/udivmodti4_test.zig
  measurement          mean Â± Ïƒ            min â€¦ max           outliers         delta
  wall_time          20.5s  Â± 95.8ms    20.4s  â€¦ 20.6s           0 ( 0%)        âš¡- 10.1% Â±  1.5%
  peak_rss           54.9MB Â±  303KB    54.6MB â€¦ 55.1MB          0 ( 0%)        âš¡-  6.2% Â±  0.9%
  cpu_cycles         34.8G  Â± 85.2M     34.7G  â€¦ 34.9G           0 ( 0%)        âš¡-  8.6% Â±  0.5%
  instructions       25.2G  Â± 2.21M     25.2G  â€¦ 25.2G           0 ( 0%)        âš¡-  8.8% Â±  0.0%
  cache_references   1.02G  Â±  195M      902M  â€¦ 1.24G           0 ( 0%)          -  5.8% Â± 29.0%
  cache_misses       4.57M  Â±  934K     3.93M  â€¦ 5.64M           0 ( 0%)        âš¡- 39.4% Â± 35.6%
  branch_misses       142M  Â±  183K      142M  â€¦  142M           0 ( 0%)        âš¡- 14.1% Â±  0.5%
```

I didn't stop there, however. Even though I had release tasks to get back to,
this left me *itching* to make a fast allocator - one that was designed for
multi-threaded applications built in ReleaseFast mode.

It's a tricky problem. A fast allocator needs to avoid contention by storing
thread-local state, however, it does not directly learn when a thread exits, so
one thread must periodically attempt to reclaim another thread's resources.
There is also the producer-consumer pattern - one thread only allocates while
one thread only frees. A naive implementation would never reclaim this memory.

Inspiration struck, and
[200 lines of code later](https://github.com/ziglang/zig/blob/42dbd35d3e16247ee68d7e3ace0da3778a1f5d37/lib/std/heap/SmpAllocator.zig)
I had a working implementation... after Jacob helped me find a couple logic
bugs.

I created
[Where in the World Did Carmen's Memory Go?](https://github.com/andrewrk/CarmensPlayground)
and used it to test a couple specific usage patterns. Idea here is to over time
collect a robust test suite, do fuzzing, benchmarking, etc., to make it easier
to try out new Allocator ideas in Zig.

After getting good scores on those contrived tests, I turned to the real world
use cases of the Zig compiler itself. Since it can be built with and without
libc, it's a great way to test the performance delta between the two.

Here's that same degenerate case above, but with a release build of the compiler -
glibc zig vs no libc zig:

```
Benchmark 1 (32 runs): glibc/bin/zig ast-check ../lib/compiler_rt/udivmodti4_test.zig
  measurement          mean Â± Ïƒ            min â€¦ max           outliers         delta
  wall_time           156ms Â± 6.58ms     151ms â€¦  173ms          4 (13%)        0%
  peak_rss           45.0MB Â± 20.9KB    45.0MB â€¦ 45.1MB          1 ( 3%)        0%
  cpu_cycles          766M  Â± 10.2M      754M  â€¦  796M           0 ( 0%)        0%
  instructions       3.19G  Â± 12.7      3.19G  â€¦ 3.19G           0 ( 0%)        0%
  cache_references   4.12M  Â±  498K     3.88M  â€¦ 6.13M           3 ( 9%)        0%
  cache_misses        128K  Â± 2.42K      125K  â€¦  134K           0 ( 0%)        0%
  branch_misses      1.14M  Â±  215K      925K  â€¦ 1.43M           0 ( 0%)        0%
Benchmark 2 (34 runs): SmpAllocator/bin/zig ast-check ../lib/compiler_rt/udivmodti4_test.zig
  measurement          mean Â± Ïƒ            min â€¦ max           outliers         delta
  wall_time           149ms Â± 1.87ms     146ms â€¦  156ms          1 ( 3%)        âš¡-  4.9% Â±  1.5%
  peak_rss           39.6MB Â±  141KB    38.8MB â€¦ 39.6MB          2 ( 6%)        âš¡- 12.1% Â±  0.1%
  cpu_cycles          750M  Â± 3.77M      744M  â€¦  756M           0 ( 0%)        âš¡-  2.1% Â±  0.5%
  instructions       3.05G  Â± 11.5      3.05G  â€¦ 3.05G           0 ( 0%)        âš¡-  4.5% Â±  0.0%
  cache_references   2.94M  Â± 99.2K     2.88M  â€¦ 3.36M           4 (12%)        âš¡- 28.7% Â±  4.2%
  cache_misses       48.2K  Â± 1.07K     45.6K  â€¦ 52.1K           2 ( 6%)        âš¡- 62.4% Â±  0.7%
  branch_misses       890K  Â± 28.8K      862K  â€¦ 1.02M           2 ( 6%)        âš¡- 21.8% Â±  6.5%
```

Outperforming glibc!

And finally here's the entire compiler building itself:

```
Benchmark 1 (3 runs): glibc/bin/zig build -Dno-lib -p trash
  measurement          mean Â± Ïƒ            min â€¦ max           outliers         delta
  wall_time          12.2s  Â± 99.4ms    12.1s  â€¦ 12.3s           0 ( 0%)        0%
  peak_rss            975MB Â± 21.7MB     951MB â€¦  993MB          0 ( 0%)        0%
  cpu_cycles         88.7G  Â± 68.3M     88.7G  â€¦ 88.8G           0 ( 0%)        0%
  instructions        188G  Â± 1.40M      188G  â€¦  188G           0 ( 0%)        0%
  cache_references   5.88G  Â± 33.2M     5.84G  â€¦ 5.90G           0 ( 0%)        0%
  cache_misses        383M  Â± 2.26M      381M  â€¦  385M           0 ( 0%)        0%
  branch_misses       368M  Â± 1.77M      366M  â€¦  369M           0 ( 0%)        0%
Benchmark 2 (3 runs): SmpAllocator/fast/bin/zig build -Dno-lib -p trash
  measurement          mean Â± Ïƒ            min â€¦ max           outliers         delta
  wall_time          12.2s  Â± 49.0ms    12.2s  â€¦ 12.3s           0 ( 0%)          +  0.0% Â±  1.5%
  peak_rss            953MB Â± 3.47MB     950MB â€¦  957MB          0 ( 0%)          -  2.2% Â±  3.6%
  cpu_cycles         88.4G  Â±  165M     88.2G  â€¦ 88.6G           0 ( 0%)          -  0.4% Â±  0.3%
  instructions        181G  Â± 6.31M      181G  â€¦  181G           0 ( 0%)        âš¡-  3.9% Â±  0.0%
  cache_references   5.48G  Â± 17.5M     5.46G  â€¦ 5.50G           0 ( 0%)        âš¡-  6.9% Â±  1.0%
  cache_misses        386M  Â± 1.85M      384M  â€¦  388M           0 ( 0%)          +  0.6% Â±  1.2%
  branch_misses       377M  Â±  899K      377M  â€¦  378M           0 ( 0%)        ðŸ’©+  2.6% Â±  0.9%
```

I feel that this is a key moment in the Zig project's trajectory.
[This last piece of the puzzle](https://github.com/ziglang/zig/pull/22808)
marks the point at which the language and standard library has become *strictly
better* to use than C and libc.

While other languages build on top of libc, Zig instead has conquered it!

# [LLDB Fork for Zig]($section.id('2025-01-24'))

Author: Alex RÃ¸nne Petersen

One of the major things [Jacob](https://github.com/jacobly0) has been working on is good debugging support for Zig. This
includes an [LLDB fork](https://github.com/jacobly0/llvm-project/tree/lldb-zig) with enhancements for the Zig language,
and is primarily intended for use with Zig's self-hosted backends. With the self-hosted x86_64 backend becoming much
more usable in the upcoming 0.14.0 release, I decided to type up a
[wiki page](https://github.com/ziglang/zig/wiki/LLDB-for-Zig) with instructions for building and using the fork.

If you're already trying out Zig's self-hosted backend in your workflow, please take the LLDB fork for a spin and see
how it works for you.
