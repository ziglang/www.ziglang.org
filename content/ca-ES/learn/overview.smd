---
.title = "Visió general",
.author = "",
.date = @date("2024-08-07:00:00:00"),
.layout = "page.shtml",
.custom = {
	"mobile_menu_title": "Visió general",
},
---
# Característiques destacades
## [Llenguatge petit i senzill]($heading.id('small-simple-language'))

Concentreu-vos a depurar la vostra aplicació en lloc de depurar els vostres coneixements del llenguatge de programació.

La sintaxi completa de Zig està especificada en un [fitxer de gramàtica PEG de 580 línies](https://ziglang.org/documentation/master/#Grammar).

No hi ha **flux de control ocult**, ni assignacions de memòria ocultes, ni preprocessador ni macros. Si el codi Zig no sembla que estigui saltant per cridar una funció, és que no ho fa. Això vol dir que podeu estar segurs que el codi següent només crida `foo()` i després `bar()`, i això està garantit sense necessitat de conèixer cap tipus:

```zig
var a = b + c.d;
foo();
bar();
```

Exemples de flux de control ocult:

- D té funcions `@property`, que són mètodes als quals es crida aparentment accedint a un camp; per tant, en l'exemple anterior, `c.d` podria cridar una funció.
- C++, D i Rust tenen sobrecàrrega d'operadors, així que l'operador `+` podria cridar una funció.
- C++, D i Go tenen excepcions throw/catch, de manera que `foo()` podria llençar una excepció i evitar que es cridi `bar()`.

Zig afavoreix el manteniment i la llegibilitat del codi fent que tot el flux de control es gestioni exclusivament amb paraules clau del llenguatge i crides a funcions.

## [Rendiment i seguretat: trieu-ne dos]($heading.id('performance-and-safety-choose-two'))

Zig disposa de quatre [modes de compilació](https://ziglang.org/documentation/master/#Build-Mode), i es poden combinar fins a [granularitat de bloc](https://ziglang.org/documentation/master/#setRuntimeSafety).

| Paràmetre | [Debug](https://ziglang.org/documentation/master/#Debug) | [ReleaseSafe](https://ziglang.org/documentation/master/#ReleaseSafe) | [ReleaseFast](https://ziglang.org/documentation/master/#ReleaseFast) | [ReleaseSmall](https://ziglang.org/documentation/master/#ReleaseSmall) |
|-----------|-------|-------------|-------------|--------------|
Optimitzacions - milloren la velocitat, dificulten la depuració, allarguen el temps de compilació | | On | On | On |
Comprovacions de seguretat en temps d'execució - perjudiquen la velocitat, augmenten la mida, fallen en lloc de provocar comportament indefinit | On | On | | |

Així és com es veu el [desbordament d'enters](https://ziglang.org/documentation/master/#Integer-Overflow) en temps de compilació, sigui quin sigui el mode:

[]($code.language('=html').buildAsset('features/1-integer-overflow.zig'))

Així és com es veu en temps d'execució, en compilacions amb comprovacions de seguretat:

[]($code.language('=html').buildAsset('features/2-integer-overflow-runtime.zig'))


Aquestes [traces de pila funcionen a tots els objectius](#stack-traces-on-all-targets), incloent-hi entorns [freestanding](https://andrewkelley.me/post/zig-stack-traces-kernel-panic-bare-bones-os.html).

Amb Zig podeu compilar en un mode amb seguretat activada, i desactivar-la selectivament als colls d'ampolla de rendiment. Per exemple, l'exemple anterior es podria modificar així:

[]($code.language('=html').buildAsset('features/3-undefined-behavior.zig'))

Zig utilitza el [comportament il·legal](https://ziglang.org/documentation/master/#Illegal-Behavior) com una eina precisa tant per prevenir errors com per millorar el rendiment.

Parlant de rendiment, Zig és més ràpid que C.

- Tot el codi Zig viu en una sola unitat de compilació, optimitzat conjuntament.
- Comportament il·legal escollit amb cura. Per exemple, en Zig tant els enters amb signe com els sense signe tenen comportament il·legal quan hi ha un desbordament, a diferència de C on només els enters amb signe el tenen. Això [facilita optimitzacions que no estan disponibles a C](https://godbolt.org/z/vhjv9oM1W).
- Zig exposa directament un [tipus vectorial SIMD](https://ziglang.org/documentation/master/#Vectors), cosa que facilita escriure codi vectoritzat portàtil.
- La biblioteca estàndard proporciona estructures de dades essencials com taules hash i llistes dinàmiques; en C sovint és temptador usar llistes enllaçades per simplicitat.
- Les funcions avançades de CPU s'activen per defecte, llevat que s'estigui [compilant en creuat](#cross-compiling-is-a-first-class-use-case).

Tingueu en compte que Zig no és un llenguatge completament segur. Si voleu seguir l'evolució de la seguretat de Zig, podeu subscriure-us a aquestes incidències:

- [enumerar totes les classes de comportament indefinit, fins i tot les que no es poden comprovar amb seguretat](https://github.com/ziglang/zig/issues/1966)
- [fer que els modes Debug i ReleaseSafe siguin completament segurs](https://github.com/ziglang/zig/issues/2301)

## Zig competeix amb C en lloc de dependre'n

La biblioteca estàndard de Zig s'integra amb libc, però no en depèn. Aquí teniu un Hello World:

[]($code.language('=html').buildAsset('features/4-hello.zig'))

Quan es compila amb `-O ReleaseSmall`, eliminant els símbols de depuració i en mode d'un sol fil, se'n genera un executable estàtic de 9.8 KiB per a l'objectiu x86_64-linux:
```
$ zig build-exe hello.zig -O ReleaseSmall -fstrip -fsingle-threaded
$ wc -c hello
9944 hello
$ ldd hello
  not a dynamic executable
```

En Windows, la compilació és encara més petita, només 4096 bytes:
```
$ zig build-exe hello.zig -O ReleaseSmall -fstrip -fsingle-threaded -target x86_64-windows
$ wc -c hello.exe
4096 hello.exe
$ file hello.exe
hello.exe: PE32+ executable (console) x86-64, for MS Windows
```

## Declaracions de nivell superior independents de l'ordre

Les declaracions de nivell superior, com ara les variables globals, són independents de l'ordre i s'analitzen de manera mandrosa. Els valors d'inicialització de les variables globals s'[avaluen en temps de compilació](#compile-time-reflection-and-compile-time-code-execution).

[]($code.language('=html').buildAsset('features/5-global-variables.zig'))

## Tipus opcional en lloc de punters nuls

En altres llenguatges de programació, les referències nul·les són la font de moltes excepcions en temps d'execució, i fins i tot són acusades de ser [el pitjor error de la informàtica](https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/).

Els punters Zig sense adorns no poden ser nuls:

[]($code.language('=html').buildAsset('features/6-null-to-ptr.zig'))

Tanmateix, qualsevol tipus es pot convertir en un [tipus opcional](https://ziglang.org/documentation/master/#Optionals) prefixant-lo amb `?`:

[]($code.language('=html').buildAsset('features/7-optional-syntax.zig'))

Per desempaquetar un valor opcional, es pot usar `orelse` per proporcionar un valor per defecte:

[]($code.language('=html').buildAsset('features/8-optional-orelse.zig'))

Una altra opció és usar `if`:

[]($code.language('=html').buildAsset('features/9-optional-if.zig'))

La mateixa sintaxi funciona amb [while](https://ziglang.org/documentation/master/#while):

[]($code.language('=html').buildAsset('features/10-optional-while.zig'))

## Gestió manual de la memòria

Una biblioteca escrita en Zig es pot utilitzar a qualsevol lloc:

- [Aplicacions d'escriptori](https://github.com/TM35-Metronome/)
- Servidors de baixa latència
- [Nuclis de sistemes operatius](https://github.com/AndreaOrru/zen)
- [Dispositius encastats](https://github.com/skyfex/zig-nrf-demo/)
- Programari en temps real, per exemple actuacions en directe, avions, marcapassos
- [En navegadors web o altres connectors amb WebAssembly](https://shritesh.github.io/zigfmt-web/)
- Des d'altres llenguatges, utilitzant l'ABI de C

Per aconseguir-ho, els programadors de Zig han de gestionar la memòria ells mateixos i han de tractar els errors d'assignació.

Això també és cert per a la biblioteca estàndard de Zig. Qualsevol funció que hagi d'assignar memòria accepta un paràmetre d'assignador. Com a resultat, la biblioteca estàndard de Zig es pot utilitzar fins i tot en l'objectiu freestanding.

A més de [Una nova mirada a la gestió d'errors](#a-fresh-take-on-error-handling), Zig proporciona [defer](https://ziglang.org/documentation/master/#defer) i [errdefer](https://ziglang.org/documentation/master/#errdefer) per fer que la gestió de recursos (no només la memòria) sigui senzilla i fàcil de verificar.

Per a un exemple de `defer`, vegeu [Integració amb biblioteques de C sense FFI/bindings](#integration-with-c-libraries-without-ffibindings). Aquí teniu un exemple d'ús d'`errdefer`:
[]($code.language('=html').buildAsset('features/11-errdefer.zig'))


## [Una nova mirada a la gestió d'errors]($heading.id('a-fresh-take-on-error-handling'))

Els errors són valors, i no es poden ignorar:

[]($code.language('=html').buildAsset('features/12-errors-as-values.zig'))

Els errors es poden gestionar amb [catch](https://ziglang.org/documentation/master/#catch):

[]($code.language('=html').buildAsset('features/13-errors-catch.zig'))

La paraula clau [try](https://ziglang.org/documentation/master/#try) és una drecera de `catch |err| return err`:

[]($code.language('=html').buildAsset('features/14-errors-try.zig'))

Tingueu en compte que és una [traça de retorn d'errors](https://ziglang.org/documentation/master/#Error-Return-Traces), no una [traça de pila](#stack-traces-on-all-targets). El codi no ha pagat el cost de desenrotllar la pila per obtenir aquesta traça.

La paraula clau [switch](https://ziglang.org/documentation/master/#switch) aplicada a un error garanteix que s'han gestionat tots els errors possibles:

[]($code.language('=html').buildAsset('features/15-errors-switch.zig'))

La paraula clau [unreachable](https://ziglang.org/documentation/master/#unreachable) s'utilitza per afirmar que no es produiran errors:

[]($code.language('=html').buildAsset('features/16-unreachable.zig'))

Això invoca [comportament indefinit](#performance-and-safety-choose-two) en els modes de compilació sense seguretat, així que assegureu-vos d'utilitzar-la només quan l'èxit estigui garantit.

### [Traces de pila a tots els objectius]($heading.id("stack-traces-on-all-targets"))

Les traces de pila i les [traces de retorn d'errors](https://ziglang.org/documentation/master/#Error-Return-Traces) mostrades en aquesta pàgina funcionen a tots els objectius de Suport de Nivell 1 i alguns de Nivell 2. [Fins i tot en freestanding](https://andrewkelley.me/post/zig-stack-traces-kernel-panic-bare-bones-os.html)!

A més, la biblioteca estàndard pot capturar una traça de pila en qualsevol punt i abocar-la a la sortida d'errors més tard:

[]($code.language('=html').buildAsset('features/17-stack-traces.zig'))

L'assignador DebugAllocator de la biblioteca estàndard utilitza aquesta tècnica per informar de fuites i alliberaments dobles.

## Estructures de dades genèriques i funcions

Els tipus són valors que s'han de conèixer en temps de compilació:

[]($code.language('=html').buildAsset('features/18-types.zig'))

Una estructura de dades genèrica és simplement una funció que retorna un `type`:

[]($code.language('=html').buildAsset('features/19-generics.zig'))

## [Reflexió i execució de codi en temps de compilació]($heading.id('compile-time-reflection-and-compile-time-code-execution'))

La funció [@typeInfo](https://ziglang.org/documentation/master/#typeInfo) proporciona reflexió:

[]($code.language('=html').buildAsset('features/20-reflection.zig'))

La biblioteca estàndard de Zig utilitza aquesta tècnica per implementar la impressió formatada. Tot i ser un [llenguatge petit i senzill](#small-simple-language), la impressió formatada de Zig està implementada íntegrament en Zig. Mentrestant, en C, els errors de compilació de printf estan codificats al compilador. De manera similar, a Rust la macro d'impressió formatada està codificada al compilador.

Zig també pot avaluar funcions i blocs de codi en temps de compilació. En alguns contextos, com la inicialització de variables globals, l'expressió s'avalua implícitament en temps de compilació. En cas contrari, es pot avaluar explícitament codi en temps de compilació amb la paraula clau [comptime](https://ziglang.org/documentation/master/#comptime). Això pot ser especialment potent combinat amb asserts:

[]($code.language('=html').buildAsset('features/21-comptime.zig'))

## [Integració amb biblioteques de C sense FFI/bindings]($heading.id('integration-with-c-libraries-without-ffibindings'))

[@cImport](https://ziglang.org/documentation/master/#cImport) importa directament tipus, variables, funcions i macros simples per utilitzar-los a Zig. Fins i tot tradueix funcions inline de C a Zig.

Aquí teniu un exemple d'emissió d'una ona sinusoidal amb [libsoundio](http://libsound.io/):

<u>sine.zig</u>
[]($code.language('=html').buildAsset('features/22-sine-wave.zig'))

```
$ zig build-exe sine.zig -lsoundio -lc
$ ./sine
Output device: Built-in Audio Analog Stereo
^C
```

[Aquest codi Zig és significativament més senzill que l'equivalent en C](https://gist.github.com/andrewrk/d285c8f912169329e5e28c3d0a63c1d8), a més de tenir més proteccions de seguretat, i tot això s'aconsegueix important directament l'encapçalament de C, sense bindings d'API.

*Zig és millor usant biblioteques de C que el mateix C.*

### [Zig també és un compilador de C]($heading.id('zig-is-also-a-c-compiler'))

Aquí teniu un exemple de Zig compilant codi C:

<u>hello.c</u>
```c
#include <stdio.h>

int main(int argc, char **argv) {
    printf("Hello world\n");
    return 0;
}
```

```
$ zig build-exe hello.c -lc
$ ./hello
Hello world
```

Podeu usar `--verbose-cc` per veure quina ordre del compilador C s'ha executat:
```
$ zig build-exe hello.c -lc --verbose-cc
zig cc -MD -MV -MF .zig-cache/tmp/42zL6fBH8fSo-hello.o.d -nostdinc -fno-spell-checking -isystem /home/andy/dev/zig/build/lib/zig/include -isystem /home/andy/dev/zig/build/lib/zig/libc/include/x86_64-linux-gnu -isystem /home/andy/dev/zig/build/lib/zig/libc/include/generic-glibc -isystem /home/andy/dev/zig/build/lib/zig/libc/include/x86_64-linux-any -isystem /home/andy/dev/zig/build/lib/zig/libc/include/any-linux-any -march=native -g -fstack-protector-strong --param ssp-buffer-size=4 -fno-omit-frame-pointer -o .zig-cache/tmp/42zL6fBH8fSo-hello.o -c hello.c -fPIC
```

Fixeu-vos que si executeu l'ordre un altre cop, no hi ha cap sortida i acaba instantàniament:
```
$ time zig build-exe hello.c -lc --verbose-cc

real	0m0.027s
user	0m0.018s
sys	0m0.009s
```

Això és gràcies a la [Memòria cau d'artefactes de compilació](https://ziglang.org/download/0.4.0/release-notes.html#Build-Artifact-Caching). Zig analitza automàticament el fitxer .d amb un sistema de memòria cau robust per evitar repetir feina.

No només Zig pot compilar codi C, sinó que hi ha una molt bona raó per fer servir Zig com a compilador de C: [Zig inclou libc](#zig-ships-with-libc).

### Exportar funcions, variables i tipus perquè el codi C hi depengui

Un dels casos d'ús principals de Zig és exportar una biblioteca amb l'ABI de C perquè altres llenguatges hi puguin cridar. La paraula clau `export` davant de funcions, variables i tipus fa que formin part de l'API de la biblioteca:

<u>mathtest.zig</u>
[]($code.language('=html').buildAsset('features/23-math-test.zig'))

Per fer una biblioteca estàtica:
```
$ zig build-lib mathtest.zig
```

Per fer una biblioteca compartida:
```
$ zig build-lib mathtest.zig -dynamic
```

Aquí teniu un exemple amb el [Sistema de compilació de Zig](#zig-build-system):

<u>test.c</u>
```c
#include "mathtest.h"
#include <stdio.h>

int main(int argc, char **argv) {
    int32_t result = add(42, 1337);
    printf("%d\n", result);
    return 0;
}
```

<u>build.zig</u>
[]($code.language('=html').buildAsset('features/24-build.zig'))

```
$ zig build test
1379
```

## [La compilació creuada és un cas d'ús de primera classe]($heading.id('cross-compiling-is-a-first-class-use-case'))

Zig pot compilar per a qualsevol objectiu de la Taula de Suport (vegeu les notes de l'última versió) amb Suport de Nivell 3 o superior. No cal instal·lar cap "toolchain de compilació creuada" ni res per l'estil. Aquí hi ha un Hello World nadiu:

[]($code.language('=html').buildAsset('features/4-hello.zig'))

Ara per compilar-lo per a x86_64-windows, x86_64-macos i aarch64-linux:
```
$ zig build-exe hello.zig -target x86_64-windows
$ file hello.exe
hello.exe: PE32+ executable (console) x86-64, for MS Windows
$ zig build-exe hello.zig -target x86_64-macos
$ file hello
hello: Mach-O 64-bit x86_64 executable, flags:<NOUNDEFS|DYLDLINK|TWOLEVEL|PIE>
$ zig build-exe hello.zig -target aarch64-linux
$ file hello
hello: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, with debug_info, not stripped
```

Això funciona des de qualsevol objectiu de Nivell 3+ cap a qualsevol altre objectiu de Nivell 3+.

### [Zig inclou libc]($heading.id('zig-ships-with-libc'))

Podeu veure els objectius libc disponibles amb `zig targets`:
```
...
.libc = .{
  "arc-linux-gnu",
  "arm-freebsd-eabihf",
  "arm-linux-gnueabi",
  "arm-linux-gnueabihf",
  "arm-linux-musleabi",
  "arm-linux-musleabihf",
  "arm-netbsd-eabi",
  "arm-netbsd-eabihf",
  "armeb-linux-gnueabi",
  "armeb-linux-gnueabihf",
  "armeb-linux-musleabi",
  "armeb-linux-musleabihf",
  "armeb-netbsd-eabi",
  "armeb-netbsd-eabihf",
  "thumb-linux-musleabi",
  "thumb-linux-musleabihf",
  "thumb-windows-gnu",
  "thumbeb-linux-musleabi",
  "thumbeb-linux-musleabihf",
  "aarch64-freebsd-none",
  "aarch64-linux-gnu",
  "aarch64-linux-musl",
  "aarch64-macos-none",
  "aarch64-netbsd-none",
  "aarch64-windows-gnu",
  "aarch64_be-linux-gnu",
  "aarch64_be-linux-musl",
  "aarch64_be-netbsd-none",
  "csky-linux-gnueabi",
  "csky-linux-gnueabihf",
  "hexagon-linux-musl",
  "loongarch64-linux-gnu",
  "loongarch64-linux-gnusf",
  "loongarch64-linux-musl",
  "loongarch64-linux-muslsf",
  "m68k-linux-gnu",
  "m68k-linux-musl",
  "m68k-netbsd-none",
  "mips-linux-gnueabi",
  "mips-linux-gnueabihf",
  "mips-linux-musleabi",
  "mips-linux-musleabihf",
  "mips-netbsd-eabi",
  "mips-netbsd-eabihf",
  "mipsel-linux-gnueabi",
  "mipsel-linux-gnueabihf",
  "mipsel-linux-musleabi",
  "mipsel-linux-musleabihf",
  "mipsel-netbsd-eabi",
  "mipsel-netbsd-eabihf",
  "mips64-linux-gnuabi64",
  "mips64-linux-gnuabin32",
  "mips64-linux-muslabi64",
  "mips64-linux-muslabin32",
  "mips64el-linux-gnuabi64",
  "mips64el-linux-gnuabin32",
  "mips64el-linux-muslabi64",
  "mips64el-linux-muslabin32",
  "powerpc-freebsd-eabihf",
  "powerpc-linux-gnueabi",
  "powerpc-linux-gnueabihf",
  "powerpc-linux-musleabi",
  "powerpc-linux-musleabihf",
  "powerpc-netbsd-eabi",
  "powerpc-netbsd-eabihf",
  "powerpc64-freebsd-none",
  "powerpc64-linux-gnu",
  "powerpc64-linux-musl",
  "powerpc64le-freebsd-none",
  "powerpc64le-linux-gnu",
  "powerpc64le-linux-musl",
  "riscv32-linux-gnu",
  "riscv32-linux-musl",
  "riscv64-freebsd-none",
  "riscv64-linux-gnu",
  "riscv64-linux-musl",
  "s390x-linux-gnu",
  "s390x-linux-musl",
  "sparc-linux-gnu",
  "sparc-netbsd-none",
  "sparc64-linux-gnu",
  "sparc64-netbsd-none",
  "wasm32-wasi-musl",
  "x86-freebsd-none",
  "x86-linux-gnu",
  "x86-linux-musl",
  "x86-netbsd-none",
  "x86-windows-gnu",
  "x86_64-freebsd-none",
  "x86_64-linux-gnu",
  "x86_64-linux-gnux32",
  "x86_64-linux-musl",
  "x86_64-linux-muslx32",
  "x86_64-macos-none",
  "x86_64-netbsd-none",
  "x86_64-windows-gnu",
},
...
 ```

Això vol dir que `-lc` per a aquests objectius *no depèn de cap fitxer del sistema*!

Tornem a mirar l'[exemple de C hello world](#zig-is-also-a-c-compiler):
```
$ zig build-exe hello.c -lc
$ ./hello
Hello world
$ ldd ./hello
	linux-vdso.so.1 (0x00007ffd03dc9000)
	libc.so.6 => /lib/libc.so.6 (0x00007fc4b62be000)
	libm.so.6 => /lib/libm.so.6 (0x00007fc4b5f29000)
	libpthread.so.0 => /lib/libpthread.so.0 (0x00007fc4b5d0a000)
	libdl.so.2 => /lib/libdl.so.2 (0x00007fc4b5b06000)
	librt.so.1 => /lib/librt.so.1 (0x00007fc4b58fe000)
	/lib/ld-linux-x86-64.so.2 => /lib64/ld-linux-x86-64.so.2 (0x00007fc4b6672000)
```

[glibc](https://www.gnu.org/software/libc/) no admet compilació estàtica, però [musl](https://www.musl-libc.org/) sí:
```
$ zig build-exe hello.c -lc -target x86_64-linux-musl
$ ./hello
Hello world
$ ldd hello
  not a dynamic executable
```

En aquest exemple, Zig va compilar musl libc des del codi font i després hi va enllaçar. La compilació de musl libc per a x86_64-linux queda disponible gràcies al [sistema de memòria cau](https://ziglang.org/download/0.4.0/release-notes.html#Build-Artifact-Caching), de manera que sempre que torni a caldre aquest libc estarà disponible instantàniament.

Això vol dir que aquesta funcionalitat és disponible en qualsevol plataforma. Els usuaris de Windows i macOS poden compilar codi Zig i C, i enllaçar amb libc, per a qualsevol dels objectius de la llista anterior. De manera similar, es pot compilar en creuat per a altres arquitectures:
```
$ zig build-exe hello.c -lc -target aarch64-linux-gnu
$ file hello
hello: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 2.0.0, with debug_info, not stripped
```

En alguns aspectes, Zig és un millor compilador de C que els compiladors de C!

Aquesta funcionalitat va més enllà d'empaquetar un conjunt d'eines de compilació creuada juntament amb Zig. Per exemple, la mida total dels fitxers d'encapçalaments libc que Zig inclou és de 22 MiB sense comprimir. Mentrestant, els encapçalaments de musl libc + encapçalaments de Linux per a x86_64 ocupen 8 MiB, i els de glibc 3.1 MiB (glibc no inclou els headers de Linux), i tot i això Zig inclou actualment 40 libc. Amb un empaquetat naïf això serien 444 MiB. Tanmateix, gràcies a l'[eina process_headers](https://github.com/ziglang/zig/blob/0.4.0/libc/process_headers.zig), i a una mica de [treball manual](https://github.com/ziglang/zig/wiki/Updating-libc), els tarballs binaris de Zig continuen sent d'uns 30 MiB en total, malgrat donar suport a libc per a tots aquests objectius, així com compiler-rt, libunwind i libcxx, i malgrat ser un compilador de C compatible amb clang. Per comparar, el paquet binari de clang 8.0.0 per a Windows des d'llvm.org ocupa 132 MiB.

Només s'han provat a fons els objectius de Suport de Nivell 1. Està previst [afegir més libc](https://github.com/ziglang/zig/issues/514) (incloent-hi per a Windows) i [afegir cobertura de proves per compilar contra tots els libc](https://github.com/ziglang/zig/issues/2058).

Està [previst tenir un gestor de paquets de Zig](https://github.com/ziglang/zig/issues/943), però encara no està fet. Una de les coses que serà possible és crear un paquet per a biblioteques de C. Això farà que el [Sistema de compilació de Zig](#zig-build-system) sigui atractiu tant per als programadors de Zig com per als de C.

## [Sistema de compilació de Zig]($heading.id('zig-build-system'))

Zig ve amb un sistema de compilació, de manera que no necessiteu make, cmake ni res per l'estil.
```
$ zig init
info: created build.zig
info: created build.zig.zon
info: created src/main.zig
info: created src/root.zig
info: see `zig build --help` for a menu of options
```

<u>src/main.zig</u>
[]($code.language('=html').buildAsset('features/25-all-bases.zig'))


<u>build.zig</u>
[]($code.language('=html').buildAsset('features/26-build.zig'))


Fem un cop d'ull al menú `--help`.
```
$ zig build --help
Usage: zig build [steps] [options]

Steps:
  install (default)            Copy build artifacts to prefix path
  uninstall                    Remove build artifacts from prefix path
  run                          Run the app
  test                         Run unit tests

General Options:
  -p, --prefix [path]          Where to install files (default: zig-out)
  --prefix-lib-dir [path]      Where to install libraries
  --prefix-exe-dir [path]      Where to install executables
  --prefix-include-dir [path]  Where to install C header files

  --release[=mode]             Request release mode, optionally specifying a
                               preferred optimization mode: fast, safe, small

  -fdarling,  -fno-darling     Integration with system-installed Darling to
                               execute macOS programs on Linux hosts
                               (default: no)
  -fqemu,     -fno-qemu        Integration with system-installed QEMU to execute
                               foreign-architecture programs on Linux hosts
                               (default: no)
  --glibc-runtimes [path]      Enhances QEMU integration by providing glibc built
                               for multiple foreign architectures, allowing
                               execution of non-native programs that link with glibc.
  -frosetta,  -fno-rosetta     Rely on Rosetta to execute x86_64 programs on
                               ARM64 macOS hosts. (default: no)
  -fwasmtime, -fno-wasmtime    Integration with system-installed wasmtime to
                               execute WASI binaries. (default: no)
  -fwine,     -fno-wine        Integration with system-installed Wine to execute
                               Windows programs on Linux hosts. (default: no)

  -h, --help                   Print this help and exit
  -l, --list-steps             Print available steps
  --verbose                    Print commands before executing them
  --color [auto|off|on]        Enable or disable colored error messages
  --prominent-compile-errors   Buffer compile errors and display at end
  --summary [mode]             Control the printing of the build summary
    all                        Print the build summary in its entirety
    new                        Omit cached steps
    failures                   (Default) Only print failed steps
    none                       Do not print the build summary
  -j<N>                        Limit concurrent jobs (default is to use all CPU cores)
  --maxrss <bytes>             Limit memory usage (default is to use available memory)
  --skip-oom-steps             Instead of failing, skip steps that would exceed --maxrss
  --fetch                      Exit after fetching dependency tree
  --watch                      Continuously rebuild when source files are modified
  --fuzz                       Continuously search for unit test failures
  --debounce <ms>              Delay before rebuilding after changed file detected
     -fincremental             Enable incremental compilation
  -fno-incremental             Disable incremental compilation

Project-Specific Options:
  -Dtarget=[string]            The CPU architecture, OS, and ABI to build for
  -Dcpu=[string]               Target CPU features to add or subtract
  -Dofmt=[string]              Target object format
  -Ddynamic-linker=[string]    Path to interpreter on the target system
  -Doptimize=[enum]            Prioritize performance, safety, or binary size
                                 Supported Values:
                                   Debug
                                   ReleaseSafe
                                   ReleaseFast
                                   ReleaseSmall

System Integration Options:
  --search-prefix [path]       Add a path to look for binaries, libraries, headers
  --sysroot [path]             Set the system root directory (usually /)
  --libc [file]                Provide a file which specifies libc paths

  --system [pkgdir]            Disable package fetching; enable all integrations
  -fsys=[name]                 Enable a system integration
  -fno-sys=[name]              Disable a system integration

  Available System Integrations:                Enabled:
  (none)                                        -

Advanced Options:
  -freference-trace[=num]      How many lines of reference trace should be shown per compile error
  -fno-reference-trace         Disable reference trace
  -fallow-so-scripts           Allows .so files to be GNU ld scripts
  -fno-allow-so-scripts        (default) .so files must be ELF files
  --build-file [file]          Override path to build.zig
  --cache-dir [path]           Override path to local Zig cache directory
  --global-cache-dir [path]    Override path to global Zig cache directory
  --zig-lib-dir [arg]          Override path to Zig lib directory
  --build-runner [file]        Override path to build runner
  --seed [integer]             For shuffling dependency traversal order (default: random)
  --debug-log [scope]          Enable debugging the compiler
  --debug-pkg-config           Fail if unknown pkg-config flags encountered
  --debug-rt                   Debug compiler runtime libraries
  --verbose-link               Enable compiler debug output for linking
  --verbose-air                Enable compiler debug output for Zig AIR
  --verbose-llvm-ir[=file]     Enable compiler debug output for LLVM IR
  --verbose-llvm-bc=[file]     Enable compiler debug output for LLVM BC
  --verbose-cimport            Enable compiler debug output for C imports
  --verbose-cc                 Enable compiler debug output for C compilation
  --verbose-llvm-cpu-features  Enable compiler debug output for LLVM CPU features
```

Podeu veure que un dels passos disponibles és `run`.
```
$ zig build run
All your codebase are belong to us.
Run `zig build test` to run the tests.
```

Aquests són alguns scripts de compilació d'exemple:

- [Script de compilació del joc de Tetris amb OpenGL](https://github.com/andrewrk/tetris/blob/master/build.zig)
- [Script de compilació del joc d'arcade bare metal per a Raspberry Pi 3](https://github.com/andrewrk/clashos/blob/master/build.zig)
- [Script de compilació del compilador Zig auto-hostatjat](https://github.com/ziglang/zig/blob/master/build.zig)

## Ampli ventall d'objectius compatibles

Zig utilitza un sistema de "nivells de suport" per comunicar el nivell de suport de les diferents plataformes.

[Taula de suport a Zig 0.15](https://ziglang.org/download/0.15.1/release-notes.html#Target-Support)

## Respectuós amb els mantenidors de paquets

Tot i que Zig és autoallotjat, compilar-lo des del codi font només depèn d'una cadena d'eines C/C++ i LLVM, utilitzant passos de compilació estàndard de CMake gràcies a un [procés d'arrencada basat en WebAssembly](https://ziglang.org/news/goodbye-cpp/).

Per a les distribucions que volen evitar binaris privatius, hi ha un conjunt de passos ben documentat per [reproduir Zig sense binaris](https://jakstys.lt/2024/zig-reproduced-without-binaries/).

En el futur, esperem inspirar una tercera part a implementar un intèrpret de Zig escrit en C que redueixi això a O(1) passos.

Com assenyala Maya Rashish,
[portar Zig a altres plataformes és divertit i ràpid](http://coypu.sdf.org/porting-zig.html).

Els [modes de compilació](https://ziglang.org/documentation/master/#Build-Mode) que no són de depuració són reproduïbles/deterministes.

Hi ha una [versió JSON de la pàgina de descàrrega](https://ziglang.org/download/index.json).
