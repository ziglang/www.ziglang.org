<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Learn on Zig Programming Language</title><link>//ziglang.github.io/www.ziglang.org/learn/</link><description>Recent content in Learn on Zig Programming Language</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="//ziglang.github.io/www.ziglang.org/learn/index.xml" rel="self" type="application/rss+xml"/><item><title>Code Examples</title><link>//ziglang.github.io/www.ziglang.org/learn/samples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/samples/</guid><description>Memory leak detection Using std.GeneralPurposeAllocator you can easily track double frees and memory leaks.
leak.zig
const std = @import(&amp;quot;std&amp;quot;); pub fn main() !void { var gpalloc = std.heap.GeneralPurposeAllocator(.{}){}; defer std.debug.assert(!gpalloc.deinit()); const alloc = &amp;amp;gpalloc.allocator; const u32_ptr = try alloc.create(u32); // oops I forgot to free! }$ zig build-exe leak.zig $ ./leak error(std): Memory leak detected: /Users/kristoff/Documents/www.ziglang.org/doctest-aea158bb/leak.zig:9:37: 0x10e77096f in main (leak) const u32_ptr = try alloc.create(u32); ^ /Users/kristoff/zig/build/lib/zig/std/start.zig:334:37: 0x10e772152 in std.start.main (leak) const result = root.</description></item><item><title>Getting started Guide</title><link>//ziglang.github.io/www.ziglang.org/learn/getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/getting-started/</guid><description/></item><item><title>In-depth Overview</title><link>//ziglang.github.io/www.ziglang.org/learn/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/overview/</guid><description>Feature Highlights Small, simple language Focus on debugging your application rather than debugging your programming language knowledge.
Zig&amp;rsquo;s entire syntax is specified with a 500-line PEG grammar file.
There is no hidden control flow, no hidden memory allocations, no preprocessor, and no macros. If Zig code doesn&amp;rsquo;t look like it&amp;rsquo;s jumping away to call a function, then it isn&amp;rsquo;t. This means you can be sure that the following code calls only foo() and then bar(), and this is guaranteed without needing to know the types of anything:</description></item><item><title>Tools</title><link>//ziglang.github.io/www.ziglang.org/learn/tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/tools/</guid><description>Language Servers Language servers are editor-agnostic tools for obtaining syntax highlighting, autocompletion, and many other features. Consider using a Language server over a syntax-highlighting extension for a richer development experience.
zigtools/zls Text Editors Editor-specific tools, mostly syntax highlighters.
VS Code ziglang/vscode-zig Sublime Text ziglang/sublime-zig-language Vim ziglang/zig.vim Emacs ziglang/zig-mode Kate ziglang/kde-syntax-highlighting Documentation and Testing kristoff-it/zig-doctest</description></item><item><title>Why Zig When There is Already C++, D, and Rust?</title><link>//ziglang.github.io/www.ziglang.org/learn/why_zig_rust_d_cpp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/why_zig_rust_d_cpp/</guid><description>No hidden control flow If Zig code doesn&amp;rsquo;t look like it&amp;rsquo;s jumping away to call a function, then it isn&amp;rsquo;t. This means you can be sure that the following code calls only foo() and then bar(), and this is guaranteed without needing to know the types of anything:
var a = b + c.d; foo(); bar(); D has @property functions, which are methods that you call with what looks like field access, so in the above example, c.</description></item></channel></rss>